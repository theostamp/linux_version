"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(dashboard)/kiosk-widgets/page",{

/***/ "(app-pages-browser)/./app/(dashboard)/kiosk-widgets/page.tsx":
/*!************************************************!*\
  !*** ./app/(dashboard)/kiosk-widgets/page.tsx ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ KioskWidgetsPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_contexts_BuildingContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/contexts/BuildingContext */ \"(app-pages-browser)/./components/contexts/BuildingContext.tsx\");\n/* harmony import */ var _components_ui_card__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/ui/card */ \"(app-pages-browser)/./components/ui/card.tsx\");\n/* harmony import */ var _components_ui_button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/ui/button */ \"(app-pages-browser)/./components/ui/button.tsx\");\n/* harmony import */ var _components_ui_input__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/components/ui/input */ \"(app-pages-browser)/./components/ui/input.tsx\");\n/* harmony import */ var _components_ui_label__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/components/ui/label */ \"(app-pages-browser)/./components/ui/label.tsx\");\n/* harmony import */ var _components_ui_switch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/components/ui/switch */ \"(app-pages-browser)/./components/ui/switch.tsx\");\n/* harmony import */ var _components_ui_badge__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/components/ui/badge */ \"(app-pages-browser)/./components/ui/badge.tsx\");\n/* harmony import */ var _components_ui_separator__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/components/ui/separator */ \"(app-pages-browser)/./components/ui/separator.tsx\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/house.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/chart-column.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/shield.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/bell.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/vote.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/euro.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/wrench.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/file-text.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/clock.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/qr-code.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/thermometer.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/cloud.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/users.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/message-square.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/megaphone.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/external-link.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/trending-up.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/refresh-cw.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/building.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/grid-3x3.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/settings.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/eye-off.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/eye.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/rotate-ccw.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/save.js\");\n/* harmony import */ var _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! __barrel_optimize__?names=BarChart3,Bell,Building,Clock,Cloud,Euro,ExternalLink,Eye,EyeOff,FileText,Grid3X3,Home,Megaphone,MessageSquare,Monitor,QrCode,RefreshCw,RotateCcw,Save,Settings,Shield,Thermometer,TrendingUp,Users,Vote,Wrench!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/monitor.js\");\n/* harmony import */ var _hooks_useKioskWidgets__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/hooks/useKioskWidgets */ \"(app-pages-browser)/./hooks/useKioskWidgets.ts\");\n/* harmony import */ var sonner__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! sonner */ \"(app-pages-browser)/./node_modules/sonner/dist/index.mjs\");\n/* harmony import */ var _components_KioskCanvasEditor__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @/components/KioskCanvasEditor */ \"(app-pages-browser)/./components/KioskCanvasEditor.tsx\");\n/* harmony import */ var _hello_pangea_dnd__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! @hello-pangea/dnd */ \"(app-pages-browser)/./node_modules/@hello-pangea/dnd/dist/dnd.esm.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Widget icons mapping\nconst WIDGET_ICONS = {\n    dashboard_overview: _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_13__[\"default\"],\n    building_statistics: _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_14__[\"default\"],\n    emergency_contacts: _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_15__[\"default\"],\n    announcements: _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_16__[\"default\"],\n    votes: _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_17__[\"default\"],\n    financial_overview: _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_18__[\"default\"],\n    maintenance_overview: _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_19__[\"default\"],\n    projects_overview: _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_20__[\"default\"],\n    current_time: _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_21__[\"default\"],\n    qr_code_connection: _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_22__[\"default\"],\n    weather_widget_sidebar: _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_23__[\"default\"],\n    weather_widget_topbar: _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_24__[\"default\"],\n    internal_manager_info: _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_25__[\"default\"],\n    community_message: _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_26__[\"default\"],\n    advertising_banners_sidebar: _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_27__[\"default\"],\n    advertising_banners_topbar: _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_28__[\"default\"],\n    news_ticker: _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_29__[\"default\"]\n};\n// Category colors\nconst CATEGORY_COLORS = {\n    main_slides: 'bg-blue-100 text-blue-800 border-blue-200',\n    sidebar_widgets: 'bg-green-100 text-green-800 border-green-200',\n    top_bar_widgets: 'bg-purple-100 text-purple-800 border-purple-200',\n    special_widgets: 'bg-orange-100 text-orange-800 border-orange-200'\n};\n// Category labels\nconst CATEGORY_LABELS = {\n    main_slides: 'Κύρια Slides',\n    sidebar_widgets: 'Sidebar Widgets',\n    top_bar_widgets: 'Top Bar Widgets',\n    special_widgets: 'Ειδικά Widgets'\n};\nfunction KioskWidgetsPage() {\n    _s();\n    const { selectedBuilding } = (0,_components_contexts_BuildingContext__WEBPACK_IMPORTED_MODULE_2__.useBuilding)();\n    const { config, isLoading, error, toggleWidget, updateWidgetOrder, updateGlobalSettings, resetToDefault, getEnabledWidgets } = (0,_hooks_useKioskWidgets__WEBPACK_IMPORTED_MODULE_10__.useKioskWidgets)(selectedBuilding === null || selectedBuilding === void 0 ? void 0 : selectedBuilding.id);\n    const [isSaving, setIsSaving] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [previewMode, setPreviewMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [useCanvasEditor, setUseCanvasEditor] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false); // Default to Classic View\n    // Group widgets by category\n    const widgetsByCategory = config.widgets.reduce((acc, widget)=>{\n        if (!acc[widget.category]) {\n            acc[widget.category] = [];\n        }\n        acc[widget.category].push(widget);\n        return acc;\n    }, {});\n    // Sort widgets within each category by order\n    Object.keys(widgetsByCategory).forEach((category)=>{\n        widgetsByCategory[category].sort((a, b)=>a.order - b.order);\n    });\n    const handleToggleWidget = async (widgetId, enabled)=>{\n        const success = await toggleWidget(widgetId, enabled);\n        if (success) {\n            sonner__WEBPACK_IMPORTED_MODULE_11__.toast.success(enabled ? 'Widget ενεργοποιήθηκε' : 'Widget απενεργοποιήθηκε');\n        } else {\n            sonner__WEBPACK_IMPORTED_MODULE_11__.toast.error('Αποτυχία ενημέρωσης widget');\n        }\n    };\n    // Drag and Drop handler for Classic View\n    const handleDragEnd = async (result)=>{\n        const { destination, source, draggableId } = result;\n        if (!destination) return;\n        if (destination.droppableId === source.droppableId && destination.index === source.index) {\n            return;\n        }\n        const category = source.droppableId;\n        const widgets = [\n            ...widgetsByCategory[category]\n        ];\n        // Reorder widgets\n        const [reorderedWidget] = widgets.splice(source.index, 1);\n        widgets.splice(destination.index, 0, reorderedWidget);\n        // Update order for all widgets in the category\n        const updates = widgets.map((widget, index)=>updateWidgetOrder(widget.id, index));\n        try {\n            await Promise.all(updates);\n            sonner__WEBPACK_IMPORTED_MODULE_11__.toast.success('Σειρά widgets ενημερώθηκε');\n        } catch (error) {\n            sonner__WEBPACK_IMPORTED_MODULE_11__.toast.error('Αποτυχία ενημέρωσης σειράς');\n        }\n    };\n    const handleMoveUp = async (widgetId, category)=>{\n        const widgets = [\n            ...widgetsByCategory[category]\n        ];\n        const currentIndex = widgets.findIndex((w)=>w.id === widgetId);\n        if (currentIndex > 0) {\n            const newIndex = currentIndex - 1;\n            [widgets[currentIndex], widgets[newIndex]] = [\n                widgets[newIndex],\n                widgets[currentIndex]\n            ];\n            // Update order for all widgets in the category\n            const updates = widgets.map((widget, index)=>updateWidgetOrder(widget.id, index));\n            try {\n                await Promise.all(updates);\n                sonner__WEBPACK_IMPORTED_MODULE_11__.toast.success('Σειρά widgets ενημερώθηκε');\n            } catch (error) {\n                sonner__WEBPACK_IMPORTED_MODULE_11__.toast.error('Αποτυχία ενημέρωσης σειράς');\n            }\n        }\n    };\n    const handleMoveDown = async (widgetId, category)=>{\n        const widgets = [\n            ...widgetsByCategory[category]\n        ];\n        const currentIndex = widgets.findIndex((w)=>w.id === widgetId);\n        if (currentIndex < widgets.length - 1) {\n            const newIndex = currentIndex + 1;\n            [widgets[currentIndex], widgets[newIndex]] = [\n                widgets[newIndex],\n                widgets[currentIndex]\n            ];\n            // Update order for all widgets in the category\n            const updates = widgets.map((widget, index)=>updateWidgetOrder(widget.id, index));\n            try {\n                await Promise.all(updates);\n                sonner__WEBPACK_IMPORTED_MODULE_11__.toast.success('Σειρά widgets ενημερώθηκε');\n            } catch (error) {\n                sonner__WEBPACK_IMPORTED_MODULE_11__.toast.error('Αποτυχία ενημέρωσης σειράς');\n            }\n        }\n    };\n    const handleGlobalSettingsChange = async (field, value)=>{\n        const success = await updateGlobalSettings({\n            [field]: value\n        });\n        if (success) {\n            sonner__WEBPACK_IMPORTED_MODULE_11__.toast.success('Ρυθμίσεις ενημερώθηκαν');\n        } else {\n            sonner__WEBPACK_IMPORTED_MODULE_11__.toast.error('Αποτυχία ενημέρωσης ρυθμίσεων');\n        }\n    };\n    const handleResetToDefault = async ()=>{\n        if (confirm('Είστε σίγουροι ότι θέλετε να επαναφέρετε όλες τις ρυθμίσεις στα προεπιλεγμένα;')) {\n            const success = await resetToDefault();\n            if (success) {\n                sonner__WEBPACK_IMPORTED_MODULE_11__.toast.success('Ρυθμίσεις επαναφέρθηκαν στα προεπιλεγμένα');\n            } else {\n                sonner__WEBPACK_IMPORTED_MODULE_11__.toast.error('Αποτυχία επαναφοράς ρυθμίσεων');\n            }\n        }\n    };\n    const handleSaveAll = async ()=>{\n        setIsSaving(true);\n        try {\n            // This will trigger a save through the hook\n            sonner__WEBPACK_IMPORTED_MODULE_11__.toast.success('Όλες οι ρυθμίσεις αποθηκεύτηκαν');\n        } catch (error) {\n            sonner__WEBPACK_IMPORTED_MODULE_11__.toast.error('Αποτυχία αποθήκευσης');\n        } finally{\n            setIsSaving(false);\n        }\n    };\n    if (isLoading) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"flex items-center justify-center h-64\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600\"\n                }, void 0, false, {\n                    fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                    lineNumber: 248,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    className: \"ml-2\",\n                    children: \"Φόρτωση ρυθμίσεων widgets...\"\n                }, void 0, false, {\n                    fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                    lineNumber: 249,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n            lineNumber: 247,\n            columnNumber: 7\n        }, this);\n    }\n    if (error) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"bg-red-50 border border-red-200 rounded-lg p-4\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    className: \"text-red-800\",\n                    children: error\n                }, void 0, false, {\n                    fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                    lineNumber: 257,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_4__.Button, {\n                    onClick: ()=>window.location.reload(),\n                    variant: \"outline\",\n                    className: \"mt-2\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_30__[\"default\"], {\n                            className: \"w-4 h-4 mr-2\"\n                        }, void 0, false, {\n                            fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                            lineNumber: 263,\n                            columnNumber: 11\n                        }, this),\n                        \"Επανάληψη\"\n                    ]\n                }, void 0, true, {\n                    fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                    lineNumber: 258,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n            lineNumber: 256,\n            columnNumber: 7\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"space-y-6\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex items-center justify-between\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                className: \"text-2xl font-bold text-gray-900\",\n                                children: \"Διαχείριση Kiosk Widgets\"\n                            }, void 0, false, {\n                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                lineNumber: 275,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-gray-600 mt-1\",\n                                children: \"Ρυθμίστε ποια widgets θα εμφανίζονται στο kiosk και σε ποια σειρά\"\n                            }, void 0, false, {\n                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                lineNumber: 276,\n                                columnNumber: 11\n                            }, this),\n                            selectedBuilding && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_badge__WEBPACK_IMPORTED_MODULE_8__.Badge, {\n                                variant: \"outline\",\n                                className: \"mt-2\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_31__[\"default\"], {\n                                        className: \"w-3 h-3 mr-1\"\n                                    }, void 0, false, {\n                                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                        lineNumber: 281,\n                                        columnNumber: 15\n                                    }, this),\n                                    selectedBuilding.name\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                lineNumber: 280,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                        lineNumber: 274,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex items-center space-x-2\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_4__.Button, {\n                                variant: useCanvasEditor ? \"default\" : \"outline\",\n                                onClick: ()=>setUseCanvasEditor(true),\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_32__[\"default\"], {\n                                        className: \"w-4 h-4 mr-2\"\n                                    }, void 0, false, {\n                                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                        lineNumber: 291,\n                                        columnNumber: 13\n                                    }, this),\n                                    \"Canvas Editor\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                lineNumber: 287,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_4__.Button, {\n                                variant: !useCanvasEditor ? \"default\" : \"outline\",\n                                onClick: ()=>setUseCanvasEditor(false),\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_33__[\"default\"], {\n                                        className: \"w-4 h-4 mr-2\"\n                                    }, void 0, false, {\n                                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                        lineNumber: 298,\n                                        columnNumber: 13\n                                    }, this),\n                                    \"Classic View\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                lineNumber: 294,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_separator__WEBPACK_IMPORTED_MODULE_9__.Separator, {\n                                orientation: \"vertical\",\n                                className: \"h-8\"\n                            }, void 0, false, {\n                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                lineNumber: 301,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_4__.Button, {\n                                variant: \"outline\",\n                                onClick: ()=>setPreviewMode(!previewMode),\n                                children: [\n                                    previewMode ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_34__[\"default\"], {\n                                        className: \"w-4 h-4 mr-2\"\n                                    }, void 0, false, {\n                                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                        lineNumber: 306,\n                                        columnNumber: 28\n                                    }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_35__[\"default\"], {\n                                        className: \"w-4 h-4 mr-2\"\n                                    }, void 0, false, {\n                                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                        lineNumber: 306,\n                                        columnNumber: 66\n                                    }, this),\n                                    previewMode ? 'Απόκρυψη Preview' : 'Preview'\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                lineNumber: 302,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_4__.Button, {\n                                variant: \"outline\",\n                                onClick: handleResetToDefault,\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_36__[\"default\"], {\n                                        className: \"w-4 h-4 mr-2\"\n                                    }, void 0, false, {\n                                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                        lineNumber: 313,\n                                        columnNumber: 13\n                                    }, this),\n                                    \"Επαναφορά\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                lineNumber: 309,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_4__.Button, {\n                                onClick: handleSaveAll,\n                                disabled: isSaving,\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_37__[\"default\"], {\n                                        className: \"w-4 h-4 mr-2\"\n                                    }, void 0, false, {\n                                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                        lineNumber: 320,\n                                        columnNumber: 13\n                                    }, this),\n                                    isSaving ? 'Αποθήκευση...' : 'Αποθήκευση'\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                lineNumber: 316,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                        lineNumber: 286,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                lineNumber: 273,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.Card, {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardHeader, {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardTitle, {\n                                className: \"flex items-center\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_33__[\"default\"], {\n                                        className: \"w-5 h-5 mr-2\"\n                                    }, void 0, false, {\n                                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                        lineNumber: 330,\n                                        columnNumber: 13\n                                    }, this),\n                                    \"Γενικές Ρυθμίσεις\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                lineNumber: 329,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardDescription, {\n                                children: \"Ρυθμίσεις που επηρεάζουν τη συνολική λειτουργία του kiosk\"\n                            }, void 0, false, {\n                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                lineNumber: 333,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                        lineNumber: 328,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardContent, {\n                        className: \"space-y-4\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"grid grid-cols-1 md:grid-cols-3 gap-4\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"space-y-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_label__WEBPACK_IMPORTED_MODULE_6__.Label, {\n                                            htmlFor: \"slideDuration\",\n                                            children: \"Διάρκεια Slide (δευτερόλεπτα)\"\n                                        }, void 0, false, {\n                                            fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                            lineNumber: 340,\n                                            columnNumber: 15\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_input__WEBPACK_IMPORTED_MODULE_5__.Input, {\n                                            id: \"slideDuration\",\n                                            type: \"number\",\n                                            min: \"5\",\n                                            max: \"60\",\n                                            value: config.settings.slideDuration,\n                                            onChange: (e)=>handleGlobalSettingsChange('slideDuration', parseInt(e.target.value))\n                                        }, void 0, false, {\n                                            fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                            lineNumber: 341,\n                                            columnNumber: 15\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                    lineNumber: 339,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"space-y-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_label__WEBPACK_IMPORTED_MODULE_6__.Label, {\n                                            htmlFor: \"refreshInterval\",\n                                            children: \"Διάστημα Ανανέωσης (δευτερόλεπτα)\"\n                                        }, void 0, false, {\n                                            fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                            lineNumber: 351,\n                                            columnNumber: 15\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_input__WEBPACK_IMPORTED_MODULE_5__.Input, {\n                                            id: \"refreshInterval\",\n                                            type: \"number\",\n                                            min: \"10\",\n                                            max: \"300\",\n                                            value: config.settings.refreshInterval,\n                                            onChange: (e)=>handleGlobalSettingsChange('refreshInterval', parseInt(e.target.value))\n                                        }, void 0, false, {\n                                            fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                            lineNumber: 352,\n                                            columnNumber: 15\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                    lineNumber: 350,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex items-center space-x-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_switch__WEBPACK_IMPORTED_MODULE_7__.Switch, {\n                                            id: \"autoRefresh\",\n                                            checked: config.settings.autoRefresh,\n                                            onCheckedChange: (checked)=>handleGlobalSettingsChange('autoRefresh', checked)\n                                        }, void 0, false, {\n                                            fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                            lineNumber: 362,\n                                            columnNumber: 15\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_label__WEBPACK_IMPORTED_MODULE_6__.Label, {\n                                            htmlFor: \"autoRefresh\",\n                                            children: \"Αυτόματη Ανανέωση\"\n                                        }, void 0, false, {\n                                            fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                            lineNumber: 367,\n                                            columnNumber: 15\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                    lineNumber: 361,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                            lineNumber: 338,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                        lineNumber: 337,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                lineNumber: 327,\n                columnNumber: 7\n            }, this),\n            !useCanvasEditor && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_hello_pangea_dnd__WEBPACK_IMPORTED_MODULE_38__.DragDropContext, {\n                onDragEnd: handleDragEnd,\n                children: Object.entries(widgetsByCategory).map((param)=>{\n                    let [category, widgets] = param;\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.Card, {\n                        className: \"mb-6\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardHeader, {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardTitle, {\n                                        className: \"flex items-center\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_39__[\"default\"], {\n                                                className: \"w-5 h-5 mr-2\"\n                                            }, void 0, false, {\n                                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                lineNumber: 380,\n                                                columnNumber: 19\n                                            }, this),\n                                            CATEGORY_LABELS[category],\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_badge__WEBPACK_IMPORTED_MODULE_8__.Badge, {\n                                                variant: \"outline\",\n                                                className: \"ml-2 \".concat(CATEGORY_COLORS[category]),\n                                                children: [\n                                                    widgets.filter((w)=>w.enabled).length,\n                                                    \" / \",\n                                                    widgets.length\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                lineNumber: 382,\n                                                columnNumber: 19\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                        lineNumber: 379,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardDescription, {\n                                        children: [\n                                            category === 'main_slides' && 'Κύρια περιεχόμενα που εμφανίζονται ως slides',\n                                            category === 'sidebar_widgets' && 'Widgets που εμφανίζονται στην πλευρική μπάρα',\n                                            category === 'top_bar_widgets' && 'Widgets που εμφανίζονται στην επάνω μπάρα',\n                                            category === 'special_widgets' && 'Ειδικά widgets (π.χ. news ticker)'\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                        lineNumber: 389,\n                                        columnNumber: 17\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                lineNumber: 378,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardContent, {\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_hello_pangea_dnd__WEBPACK_IMPORTED_MODULE_38__.Droppable, {\n                                    droppableId: category,\n                                    children: (provided, snapshot)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            ref: provided.innerRef,\n                                            ...provided.droppableProps,\n                                            className: \"space-y-2 min-h-[100px] p-2 rounded-lg transition-colors \".concat(snapshot.isDraggingOver ? 'bg-blue-50 border-2 border-dashed border-blue-300' : 'bg-gray-50'),\n                                            children: [\n                                                widgets.map((widget, index)=>{\n                                                    const IconComponent = WIDGET_ICONS[widget.id] || _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_33__[\"default\"];\n                                                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_hello_pangea_dnd__WEBPACK_IMPORTED_MODULE_38__.Draggable, {\n                                                        draggableId: widget.id,\n                                                        index: index,\n                                                        children: (provided, snapshot)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                ref: provided.innerRef,\n                                                                ...provided.draggableProps,\n                                                                className: \"flex items-center space-x-3 p-3 bg-white border rounded-lg transition-all \".concat(snapshot.isDragging ? 'shadow-lg border-blue-400 bg-blue-50' : 'hover:shadow-md hover:border-gray-300'),\n                                                                children: [\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                        ...provided.dragHandleProps,\n                                                                        className: \"flex flex-col space-y-1 cursor-grab active:cursor-grabbing\",\n                                                                        children: [\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                                className: \"w-4 h-1 bg-gray-300 rounded\"\n                                                                            }, void 0, false, {\n                                                                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                                                lineNumber: 425,\n                                                                                columnNumber: 35\n                                                                            }, this),\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                                className: \"w-4 h-1 bg-gray-300 rounded\"\n                                                                            }, void 0, false, {\n                                                                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                                                lineNumber: 426,\n                                                                                columnNumber: 35\n                                                                            }, this),\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                                className: \"w-4 h-1 bg-gray-300 rounded\"\n                                                                            }, void 0, false, {\n                                                                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                                                lineNumber: 427,\n                                                                                columnNumber: 35\n                                                                            }, this)\n                                                                        ]\n                                                                    }, void 0, true, {\n                                                                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                                        lineNumber: 421,\n                                                                        columnNumber: 33\n                                                                    }, this),\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                        className: \"flex-shrink-0\",\n                                                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(IconComponent, {\n                                                                            className: \"w-5 h-5 text-gray-600\"\n                                                                        }, void 0, false, {\n                                                                            fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                                            lineNumber: 432,\n                                                                            columnNumber: 35\n                                                                        }, this)\n                                                                    }, void 0, false, {\n                                                                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                                        lineNumber: 431,\n                                                                        columnNumber: 33\n                                                                    }, this),\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                        className: \"flex-1 min-w-0\",\n                                                                        children: [\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                                className: \"flex items-center space-x-2\",\n                                                                                children: [\n                                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                                                                        className: \"font-medium text-gray-900 truncate\",\n                                                                                        children: widget.name\n                                                                                    }, void 0, false, {\n                                                                                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                                                        lineNumber: 438,\n                                                                                        columnNumber: 37\n                                                                                    }, this),\n                                                                                    widget.enabled && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_badge__WEBPACK_IMPORTED_MODULE_8__.Badge, {\n                                                                                        variant: \"secondary\",\n                                                                                        className: \"text-xs\",\n                                                                                        children: \"Ενεργό\"\n                                                                                    }, void 0, false, {\n                                                                                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                                                        lineNumber: 442,\n                                                                                        columnNumber: 39\n                                                                                    }, this)\n                                                                                ]\n                                                                            }, void 0, true, {\n                                                                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                                                lineNumber: 437,\n                                                                                columnNumber: 35\n                                                                            }, this),\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                                                className: \"text-sm text-gray-600 truncate\",\n                                                                                children: widget.description\n                                                                            }, void 0, false, {\n                                                                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                                                lineNumber: 447,\n                                                                                columnNumber: 35\n                                                                            }, this)\n                                                                        ]\n                                                                    }, void 0, true, {\n                                                                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                                        lineNumber: 436,\n                                                                        columnNumber: 33\n                                                                    }, this),\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                        className: \"flex-shrink-0\",\n                                                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_switch__WEBPACK_IMPORTED_MODULE_7__.Switch, {\n                                                                            checked: widget.enabled,\n                                                                            onCheckedChange: (checked)=>handleToggleWidget(widget.id, checked)\n                                                                        }, void 0, false, {\n                                                                            fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                                            lineNumber: 454,\n                                                                            columnNumber: 35\n                                                                        }, this)\n                                                                    }, void 0, false, {\n                                                                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                                        lineNumber: 453,\n                                                                        columnNumber: 33\n                                                                    }, this)\n                                                                ]\n                                                            }, void 0, true, {\n                                                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                                lineNumber: 411,\n                                                                columnNumber: 31\n                                                            }, this)\n                                                    }, widget.id, false, {\n                                                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                        lineNumber: 409,\n                                                        columnNumber: 27\n                                                    }, this);\n                                                }),\n                                                provided.placeholder\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                            lineNumber: 399,\n                                            columnNumber: 21\n                                        }, this)\n                                }, void 0, false, {\n                                    fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                    lineNumber: 397,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                lineNumber: 396,\n                                columnNumber: 15\n                            }, this)\n                        ]\n                    }, category, true, {\n                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                        lineNumber: 377,\n                        columnNumber: 13\n                    }, this);\n                })\n            }, void 0, false, {\n                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                lineNumber: 375,\n                columnNumber: 9\n            }, this),\n            useCanvasEditor ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_KioskCanvasEditor__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\n                buildingId: selectedBuilding === null || selectedBuilding === void 0 ? void 0 : selectedBuilding.id\n            }, void 0, false, {\n                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                lineNumber: 478,\n                columnNumber: 9\n            }, this) : null,\n            previewMode && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.Card, {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardHeader, {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardTitle, {\n                                className: \"flex items-center\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_35__[\"default\"], {\n                                        className: \"w-5 h-5 mr-2\"\n                                    }, void 0, false, {\n                                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                        lineNumber: 486,\n                                        columnNumber: 15\n                                    }, this),\n                                    \"Preview - Ενεργά Widgets\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                lineNumber: 485,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardDescription, {\n                                children: \"Προεπισκόπηση των widgets που θα εμφανίζονται στο kiosk\"\n                            }, void 0, false, {\n                                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                lineNumber: 489,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                        lineNumber: 484,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardContent, {\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\",\n                            children: Object.entries(widgetsByCategory).map((param)=>{\n                                let [category, widgets] = param;\n                                const enabledWidgets = widgets.filter((w)=>w.enabled);\n                                if (enabledWidgets.length === 0) return null;\n                                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"space-y-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                                            className: \"font-medium text-sm text-gray-700\",\n                                            children: CATEGORY_LABELS[category]\n                                        }, void 0, false, {\n                                            fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                            lineNumber: 501,\n                                            columnNumber: 21\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"space-y-1\",\n                                            children: enabledWidgets.map((widget)=>{\n                                                const IconComponent = WIDGET_ICONS[widget.id] || _barrel_optimize_names_BarChart3_Bell_Building_Clock_Cloud_Euro_ExternalLink_Eye_EyeOff_FileText_Grid3X3_Home_Megaphone_MessageSquare_Monitor_QrCode_RefreshCw_RotateCcw_Save_Settings_Shield_Thermometer_TrendingUp_Users_Vote_Wrench_lucide_react__WEBPACK_IMPORTED_MODULE_33__[\"default\"];\n                                                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \"flex items-center space-x-2 text-sm\",\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(IconComponent, {\n                                                            className: \"w-4 h-4 text-gray-500\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                            lineNumber: 509,\n                                                            columnNumber: 29\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                            className: \"text-gray-700\",\n                                                            children: widget.name\n                                                        }, void 0, false, {\n                                                            fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                            lineNumber: 510,\n                                                            columnNumber: 29\n                                                        }, this)\n                                                    ]\n                                                }, widget.id, true, {\n                                                    fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                                    lineNumber: 508,\n                                                    columnNumber: 27\n                                                }, this);\n                                            })\n                                        }, void 0, false, {\n                                            fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                            lineNumber: 504,\n                                            columnNumber: 21\n                                        }, this)\n                                    ]\n                                }, category, true, {\n                                    fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                                    lineNumber: 500,\n                                    columnNumber: 19\n                                }, this);\n                            })\n                        }, void 0, false, {\n                            fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                            lineNumber: 494,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                        lineNumber: 493,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n                lineNumber: 483,\n                columnNumber: 9\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/app/(dashboard)/kiosk-widgets/page.tsx\",\n        lineNumber: 271,\n        columnNumber: 5\n    }, this);\n}\n_s(KioskWidgetsPage, \"lqMzwTAqbLaTcVrglP0QGQbOEd8=\", false, function() {\n    return [\n        _components_contexts_BuildingContext__WEBPACK_IMPORTED_MODULE_2__.useBuilding,\n        _hooks_useKioskWidgets__WEBPACK_IMPORTED_MODULE_10__.useKioskWidgets\n    ];\n});\n_c = KioskWidgetsPage;\nvar _c;\n$RefreshReg$(_c, \"KioskWidgetsPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC8oZGFzaGJvYXJkKS9raW9zay13aWRnZXRzL3BhZ2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRWlDO0FBQ21DO0FBQzZCO0FBQ2pEO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDUTtBQXlDaEM7QUFDb0M7QUFFM0I7QUFDZ0M7QUFDdUI7QUFFdEYsdUJBQXVCO0FBQ3ZCLE1BQU02QyxlQUFvQztJQUN4Q0Msb0JBQW9CWCw0UkFBSUE7SUFDeEJZLHFCQUFxQmIsNFJBQVNBO0lBQzlCYyxvQkFBb0JsQiw0UkFBTUE7SUFDMUJtQixlQUFlekIsNFJBQUlBO0lBQ25CMEIsT0FBT3pCLDRSQUFJQTtJQUNYMEIsb0JBQW9CekIsNFJBQUlBO0lBQ3hCMEIsc0JBQXNCekIsNFJBQU1BO0lBQzVCMEIsbUJBQW1CekIsNFJBQVFBO0lBQzNCMEIsY0FBY25DLDRSQUFLQTtJQUNuQm9DLG9CQUFvQnZCLDRSQUFNQTtJQUMxQndCLHdCQUF3QnZCLDRSQUFXQTtJQUNuQ3dCLHVCQUF1QnJDLDRSQUFLQTtJQUM1QnNDLHVCQUF1QnJDLDRSQUFLQTtJQUM1QnNDLG1CQUFtQnJDLDRSQUFhQTtJQUNoQ3NDLDZCQUE2QnJDLDRSQUFTQTtJQUN0Q3NDLDRCQUE0QnpCLDRSQUFZQTtJQUN4QzBCLGFBQWEvQiw0UkFBVUE7QUFDekI7QUFFQSxrQkFBa0I7QUFDbEIsTUFBTWdDLGtCQUFrRDtJQUN0REMsYUFBYTtJQUNiQyxpQkFBaUI7SUFDakJDLGlCQUFpQjtJQUNqQkMsaUJBQWlCO0FBQ25CO0FBRUEsa0JBQWtCO0FBQ2xCLE1BQU1DLGtCQUFrRDtJQUN0REosYUFBYTtJQUNiQyxpQkFBaUI7SUFDakJDLGlCQUFpQjtJQUNqQkMsaUJBQWlCO0FBQ25CO0FBRWUsU0FBU0U7O0lBQ3RCLE1BQU0sRUFBRUMsZ0JBQWdCLEVBQUUsR0FBR3JFLGlGQUFXQTtJQUN4QyxNQUFN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QVU7Ozs7OztzRUFDekIsOERBQUNDOzREQUFLRCxXQUFVO3NFQUFpQnpDLE9BQU9rRCxJQUFJOzs7Ozs7O21EQUZwQ2xELE9BQU9YLEVBQUU7Ozs7OzRDQUt2Qjs7Ozs7OzttQ0FiTVk7Ozs7OzRCQWlCZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPZDtHQTVhd0J0Qjs7UUFDT3BFLDZFQUFXQTtRQVVwQ3NDLG9FQUFlQTs7O0tBWEc4QiIsInNvdXJjZXMiOlsiL2FwcC9hcHAvKGRhc2hib2FyZCkva2lvc2std2lkZ2V0cy9wYWdlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlQnVpbGRpbmcgfSBmcm9tICdAL2NvbXBvbmVudHMvY29udGV4dHMvQnVpbGRpbmdDb250ZXh0JztcbmltcG9ydCB7IENhcmQsIENhcmRDb250ZW50LCBDYXJkRGVzY3JpcHRpb24sIENhcmRIZWFkZXIsIENhcmRUaXRsZSB9IGZyb20gJ0AvY29tcG9uZW50cy91aS9jYXJkJztcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gJ0AvY29tcG9uZW50cy91aS9idXR0b24nO1xuaW1wb3J0IHsgSW5wdXQgfSBmcm9tICdAL2NvbXBvbmVudHMvdWkvaW5wdXQnO1xuaW1wb3J0IHsgTGFiZWwgfSBmcm9tICdAL2NvbXBvbmVudHMvdWkvbGFiZWwnO1xuaW1wb3J0IHsgU3dpdGNoIH0gZnJvbSAnQC9jb21wb25lbnRzL3VpL3N3aXRjaCc7XG5pbXBvcnQgeyBCYWRnZSB9IGZyb20gJ0AvY29tcG9uZW50cy91aS9iYWRnZSc7XG5pbXBvcnQgeyBTZXBhcmF0b3IgfSBmcm9tICdAL2NvbXBvbmVudHMvdWkvc2VwYXJhdG9yJztcbmltcG9ydCB7IFxuICBNb25pdG9yLCBcbiAgU2V0dGluZ3MsIFxuICBTYXZlLCBcbiAgUm90YXRlQ2N3LCBcbiAgRXllLCBcbiAgRXllT2ZmLCBcbiAgQ2xvY2ssXG4gIFNtYXJ0cGhvbmUsXG4gIENsb3VkLFxuICBVc2VycyxcbiAgTWVzc2FnZVNxdWFyZSxcbiAgTWVnYXBob25lLFxuICBCZWxsLFxuICBWb3RlLFxuICBFdXJvLFxuICBXcmVuY2gsXG4gIEZpbGVUZXh0LFxuICBCdWlsZGluZyxcbiAgU2hpZWxkLFxuICBUcmVuZGluZ1VwLFxuICBRckNvZGUsXG4gIFRoZXJtb21ldGVyLFxuICBDYWxlbmRhcixcbiAgUGhvbmUsXG4gIEdsb2JlLFxuICBCYXJDaGFydDMsXG4gIEhvbWUsXG4gIEFsZXJ0VHJpYW5nbGUsXG4gIFBhY2thZ2UsXG4gIENhcixcbiAgRG9vck9wZW4sXG4gIFVzZXJDaGVjayxcbiAgRHJvcGxldHMsXG4gIEZsYW1lLFxuICBIZWFydCxcbiAgRXh0ZXJuYWxMaW5rLFxuICBJbWFnZSBhcyBJbWFnZUljb24sXG4gIFJlZnJlc2hDdyxcbiAgR3JpZDNYM1xufSBmcm9tICdsdWNpZGUtcmVhY3QnO1xuaW1wb3J0IHsgdXNlS2lvc2tXaWRnZXRzIH0gZnJvbSAnQC9ob29rcy91c2VLaW9za1dpZGdldHMnO1xuaW1wb3J0IHsgS2lvc2tXaWRnZXQsIFdpZGdldENhdGVnb3J5IH0gZnJvbSAnQC90eXBlcy9raW9zay13aWRnZXRzJztcbmltcG9ydCB7IHRvYXN0IH0gZnJvbSAnc29ubmVyJztcbmltcG9ydCBLaW9za0NhbnZhc0VkaXRvciBmcm9tICdAL2NvbXBvbmVudHMvS2lvc2tDYW52YXNFZGl0b3InO1xuaW1wb3J0IHsgRHJhZ0Ryb3BDb250ZXh0LCBEcm9wcGFibGUsIERyYWdnYWJsZSwgRHJvcFJlc3VsdCB9IGZyb20gJ0BoZWxsby1wYW5nZWEvZG5kJztcblxuLy8gV2lkZ2V0IGljb25zIG1hcHBpbmdcbmNvbnN0IFdJREdFVF9JQ09OUzogUmVjb3JkPHN0cmluZywgYW55PiA9IHtcbiAgZGFzaGJvYXJkX292ZXJ2aWV3OiBIb21lLFxuICBidWlsZGluZ19zdGF0aXN0aWNzOiBCYXJDaGFydDMsXG4gIGVtZXJnZW5jeV9jb250YWN0czogU2hpZWxkLFxuICBhbm5vdW5jZW1lbnRzOiBCZWxsLFxuICB2b3RlczogVm90ZSxcbiAgZmluYW5jaWFsX292ZXJ2aWV3OiBFdXJvLFxuICBtYWludGVuYW5jZV9vdmVydmlldzogV3JlbmNoLFxuICBwcm9qZWN0c19vdmVydmlldzogRmlsZVRleHQsXG4gIGN1cnJlbnRfdGltZTogQ2xvY2ssXG4gIHFyX2NvZGVfY29ubmVjdGlvbjogUXJDb2RlLFxuICB3ZWF0aGVyX3dpZGdldF9zaWRlYmFyOiBUaGVybW9tZXRlcixcbiAgd2VhdGhlcl93aWRnZXRfdG9wYmFyOiBDbG91ZCxcbiAgaW50ZXJuYWxfbWFuYWdlcl9pbmZvOiBVc2VycyxcbiAgY29tbXVuaXR5X21lc3NhZ2U6IE1lc3NhZ2VTcXVhcmUsXG4gIGFkdmVydGlzaW5nX2Jhbm5lcnNfc2lkZWJhcjogTWVnYXBob25lLFxuICBhZHZlcnRpc2luZ19iYW5uZXJzX3RvcGJhcjogRXh0ZXJuYWxMaW5rLFxuICBuZXdzX3RpY2tlcjogVHJlbmRpbmdVcCxcbn07XG5cbi8vIENhdGVnb3J5IGNvbG9yc1xuY29uc3QgQ0FURUdPUllfQ09MT1JTOiBSZWNvcmQ8V2lkZ2V0Q2F0ZWdvcnksIHN0cmluZz4gPSB7XG4gIG1haW5fc2xpZGVzOiAnYmctYmx1ZS0xMDAgdGV4dC1ibHVlLTgwMCBib3JkZXItYmx1ZS0yMDAnLFxuICBzaWRlYmFyX3dpZGdldHM6ICdiZy1ncmVlbi0xMDAgdGV4dC1ncmVlbi04MDAgYm9yZGVyLWdyZWVuLTIwMCcsXG4gIHRvcF9iYXJfd2lkZ2V0czogJ2JnLXB1cnBsZS0xMDAgdGV4dC1wdXJwbGUtODAwIGJvcmRlci1wdXJwbGUtMjAwJyxcbiAgc3BlY2lhbF93aWRnZXRzOiAnYmctb3JhbmdlLTEwMCB0ZXh0LW9yYW5nZS04MDAgYm9yZGVyLW9yYW5nZS0yMDAnLFxufTtcblxuLy8gQ2F0ZWdvcnkgbGFiZWxzXG5jb25zdCBDQVRFR09SWV9MQUJFTFM6IFJlY29yZDxXaWRnZXRDYXRlZ29yeSwgc3RyaW5nPiA9IHtcbiAgbWFpbl9zbGlkZXM6ICfOms+Nz4HOuc6xIFNsaWRlcycsXG4gIHNpZGViYXJfd2lkZ2V0czogJ1NpZGViYXIgV2lkZ2V0cycsXG4gIHRvcF9iYXJfd2lkZ2V0czogJ1RvcCBCYXIgV2lkZ2V0cycsXG4gIHNwZWNpYWxfd2lkZ2V0czogJ86VzrnOtM65zrrOrCBXaWRnZXRzJyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEtpb3NrV2lkZ2V0c1BhZ2UoKSB7XG4gIGNvbnN0IHsgc2VsZWN0ZWRCdWlsZGluZyB9ID0gdXNlQnVpbGRpbmcoKTtcbiAgY29uc3Qge1xuICAgIGNvbmZpZyxcbiAgICBpc0xvYWRpbmcsXG4gICAgZXJyb3IsXG4gICAgdG9nZ2xlV2lkZ2V0LFxuICAgIHVwZGF0ZVdpZGdldE9yZGVyLFxuICAgIHVwZGF0ZUdsb2JhbFNldHRpbmdzLFxuICAgIHJlc2V0VG9EZWZhdWx0LFxuICAgIGdldEVuYWJsZWRXaWRnZXRzLFxuICB9ID0gdXNlS2lvc2tXaWRnZXRzKHNlbGVjdGVkQnVpbGRpbmc/LmlkKTtcblxuICBjb25zdCBbaXNTYXZpbmcsIHNldElzU2F2aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3ByZXZpZXdNb2RlLCBzZXRQcmV2aWV3TW9kZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFt1c2VDYW52YXNFZGl0b3IsIHNldFVzZUNhbnZhc0VkaXRvcl0gPSB1c2VTdGF0ZShmYWxzZSk7IC8vIERlZmF1bHQgdG8gQ2xhc3NpYyBWaWV3XG5cbiAgLy8gR3JvdXAgd2lkZ2V0cyBieSBjYXRlZ29yeVxuICBjb25zdCB3aWRnZXRzQnlDYXRlZ29yeSA9IGNvbmZpZy53aWRnZXRzLnJlZHVjZSgoYWNjLCB3aWRnZXQpID0+IHtcbiAgICBpZiAoIWFjY1t3aWRnZXQuY2F0ZWdvcnldKSB7XG4gICAgICBhY2Nbd2lkZ2V0LmNhdGVnb3J5XSA9IFtdO1xuICAgIH1cbiAgICBhY2Nbd2lkZ2V0LmNhdGVnb3J5XS5wdXNoKHdpZGdldCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30gYXMgUmVjb3JkPFdpZGdldENhdGVnb3J5LCBLaW9za1dpZGdldFtdPik7XG5cbiAgLy8gU29ydCB3aWRnZXRzIHdpdGhpbiBlYWNoIGNhdGVnb3J5IGJ5IG9yZGVyXG4gIE9iamVjdC5rZXlzKHdpZGdldHNCeUNhdGVnb3J5KS5mb3JFYWNoKGNhdGVnb3J5ID0+IHtcbiAgICB3aWRnZXRzQnlDYXRlZ29yeVtjYXRlZ29yeSBhcyBXaWRnZXRDYXRlZ29yeV0uc29ydCgoYSwgYikgPT4gYS5vcmRlciAtIGIub3JkZXIpO1xuICB9KTtcblxuICBjb25zdCBoYW5kbGVUb2dnbGVXaWRnZXQgPSBhc3luYyAod2lkZ2V0SWQ6IHN0cmluZywgZW5hYmxlZDogYm9vbGVhbikgPT4ge1xuICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCB0b2dnbGVXaWRnZXQod2lkZ2V0SWQsIGVuYWJsZWQpO1xuICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICB0b2FzdC5zdWNjZXNzKGVuYWJsZWQgPyAnV2lkZ2V0IM61zr3Otc+BzrPOv8+Azr/Ouc6uzrjOt866zrUnIDogJ1dpZGdldCDOsc+AzrXOvc61z4HOs86/z4DOv865zq7OuM63zrrOtScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b2FzdC5lcnJvcignzpHPgM6/z4TPhc+Hzq/OsSDOtc69zrfOvM6tz4HPic+DzrfPgiB3aWRnZXQnKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRHJhZyBhbmQgRHJvcCBoYW5kbGVyIGZvciBDbGFzc2ljIFZpZXdcbiAgY29uc3QgaGFuZGxlRHJhZ0VuZCA9IGFzeW5jIChyZXN1bHQ6IERyb3BSZXN1bHQpID0+IHtcbiAgICBjb25zdCB7IGRlc3RpbmF0aW9uLCBzb3VyY2UsIGRyYWdnYWJsZUlkIH0gPSByZXN1bHQ7XG5cbiAgICBpZiAoIWRlc3RpbmF0aW9uKSByZXR1cm47XG5cbiAgICBpZiAoXG4gICAgICBkZXN0aW5hdGlvbi5kcm9wcGFibGVJZCA9PT0gc291cmNlLmRyb3BwYWJsZUlkICYmXG4gICAgICBkZXN0aW5hdGlvbi5pbmRleCA9PT0gc291cmNlLmluZGV4XG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2F0ZWdvcnkgPSBzb3VyY2UuZHJvcHBhYmxlSWQgYXMgV2lkZ2V0Q2F0ZWdvcnk7XG4gICAgY29uc3Qgd2lkZ2V0cyA9IFsuLi53aWRnZXRzQnlDYXRlZ29yeVtjYXRlZ29yeV1dO1xuICAgIFxuICAgIC8vIFJlb3JkZXIgd2lkZ2V0c1xuICAgIGNvbnN0IFtyZW9yZGVyZWRXaWRnZXRdID0gd2lkZ2V0cy5zcGxpY2Uoc291cmNlLmluZGV4LCAxKTtcbiAgICB3aWRnZXRzLnNwbGljZShkZXN0aW5hdGlvbi5pbmRleCwgMCwgcmVvcmRlcmVkV2lkZ2V0KTtcblxuICAgIC8vIFVwZGF0ZSBvcmRlciBmb3IgYWxsIHdpZGdldHMgaW4gdGhlIGNhdGVnb3J5XG4gICAgY29uc3QgdXBkYXRlcyA9IHdpZGdldHMubWFwKCh3aWRnZXQsIGluZGV4KSA9PiBcbiAgICAgIHVwZGF0ZVdpZGdldE9yZGVyKHdpZGdldC5pZCwgaW5kZXgpXG4gICAgKTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbCh1cGRhdGVzKTtcbiAgICAgIHRvYXN0LnN1Y2Nlc3MoJ86jzrXOuc+Bzqwgd2lkZ2V0cyDOtc69zrfOvM61z4HPjs64zrfOus61Jyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRvYXN0LmVycm9yKCfOkc+Azr/PhM+Fz4fOr86xIM61zr3Ot868zq3Pgc+Jz4POt8+CIM+DzrXOuc+BzqzPgicpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVNb3ZlVXAgPSBhc3luYyAod2lkZ2V0SWQ6IHN0cmluZywgY2F0ZWdvcnk6IFdpZGdldENhdGVnb3J5KSA9PiB7XG4gICAgY29uc3Qgd2lkZ2V0cyA9IFsuLi53aWRnZXRzQnlDYXRlZ29yeVtjYXRlZ29yeV1dO1xuICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHdpZGdldHMuZmluZEluZGV4KHcgPT4gdy5pZCA9PT0gd2lkZ2V0SWQpO1xuICAgIFxuICAgIGlmIChjdXJyZW50SW5kZXggPiAwKSB7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG4gICAgICBbd2lkZ2V0c1tjdXJyZW50SW5kZXhdLCB3aWRnZXRzW25ld0luZGV4XV0gPSBbd2lkZ2V0c1tuZXdJbmRleF0sIHdpZGdldHNbY3VycmVudEluZGV4XV07XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBvcmRlciBmb3IgYWxsIHdpZGdldHMgaW4gdGhlIGNhdGVnb3J5XG4gICAgICBjb25zdCB1cGRhdGVzID0gd2lkZ2V0cy5tYXAoKHdpZGdldCwgaW5kZXgpID0+IFxuICAgICAgICB1cGRhdGVXaWRnZXRPcmRlcih3aWRnZXQuaWQsIGluZGV4KVxuICAgICAgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodXBkYXRlcyk7XG4gICAgICAgIHRvYXN0LnN1Y2Nlc3MoJ86jzrXOuc+Bzqwgd2lkZ2V0cyDOtc69zrfOvM61z4HPjs64zrfOus61Jyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0b2FzdC5lcnJvcignzpHPgM6/z4TPhc+Hzq/OsSDOtc69zrfOvM6tz4HPic+DzrfPgiDPg861zrnPgc6sz4InKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlTW92ZURvd24gPSBhc3luYyAod2lkZ2V0SWQ6IHN0cmluZywgY2F0ZWdvcnk6IFdpZGdldENhdGVnb3J5KSA9PiB7XG4gICAgY29uc3Qgd2lkZ2V0cyA9IFsuLi53aWRnZXRzQnlDYXRlZ29yeVtjYXRlZ29yeV1dO1xuICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHdpZGdldHMuZmluZEluZGV4KHcgPT4gdy5pZCA9PT0gd2lkZ2V0SWQpO1xuICAgIFxuICAgIGlmIChjdXJyZW50SW5kZXggPCB3aWRnZXRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gY3VycmVudEluZGV4ICsgMTtcbiAgICAgIFt3aWRnZXRzW2N1cnJlbnRJbmRleF0sIHdpZGdldHNbbmV3SW5kZXhdXSA9IFt3aWRnZXRzW25ld0luZGV4XSwgd2lkZ2V0c1tjdXJyZW50SW5kZXhdXTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIG9yZGVyIGZvciBhbGwgd2lkZ2V0cyBpbiB0aGUgY2F0ZWdvcnlcbiAgICAgIGNvbnN0IHVwZGF0ZXMgPSB3aWRnZXRzLm1hcCgod2lkZ2V0LCBpbmRleCkgPT4gXG4gICAgICAgIHVwZGF0ZVdpZGdldE9yZGVyKHdpZGdldC5pZCwgaW5kZXgpXG4gICAgICApO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh1cGRhdGVzKTtcbiAgICAgICAgdG9hc3Quc3VjY2VzcygnzqPOtc65z4HOrCB3aWRnZXRzIM61zr3Ot868zrXPgc+OzrjOt866zrUnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRvYXN0LmVycm9yKCfOkc+Azr/PhM+Fz4fOr86xIM61zr3Ot868zq3Pgc+Jz4POt8+CIM+DzrXOuc+BzqzPgicpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVHbG9iYWxTZXR0aW5nc0NoYW5nZSA9IGFzeW5jIChmaWVsZDogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiB7XG4gICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHVwZGF0ZUdsb2JhbFNldHRpbmdzKHsgW2ZpZWxkXTogdmFsdWUgfSk7XG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIHRvYXN0LnN1Y2Nlc3MoJ86hz4XOuM68zq/Pg861zrnPgiDOtc69zrfOvM61z4HPjs64zrfOus6xzr0nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9hc3QuZXJyb3IoJ86Rz4DOv8+Ez4XPh86vzrEgzrXOvc63zrzOrc+Bz4nPg863z4Igz4HPhc64zrzOr8+DzrXPic69Jyk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVJlc2V0VG9EZWZhdWx0ID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChjb25maXJtKCfOlc6vz4PPhM61IM+Dzq/Os86/z4XPgc6/zrkgz4zPhM65IM64zq3Ou861z4TOtSDOvc6xIM61z4DOsc69zrHPhs6tz4HOtc+EzrUgz4zOu861z4Igz4TOuc+CIM+Bz4XOuM68zq/Pg861zrnPgiDPg8+EzrEgz4DPgc6/zrXPgM65zrvOtc6zzrzOrc69zrE7JykpIHtcbiAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCByZXNldFRvRGVmYXVsdCgpO1xuICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgdG9hc3Quc3VjY2VzcygnzqHPhc64zrzOr8+DzrXOuc+CIM61z4DOsc69zrHPhs6tz4HOuM63zrrOsc69IM+Dz4TOsSDPgM+Bzr/Otc+AzrnOu861zrPOvM6tzr3OsScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9hc3QuZXJyb3IoJ86Rz4DOv8+Ez4XPh86vzrEgzrXPgM6xzr3Osc+Gzr/Pgc6sz4Igz4HPhc64zrzOr8+DzrXPic69Jyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVNhdmVBbGwgPSBhc3luYyAoKSA9PiB7XG4gICAgc2V0SXNTYXZpbmcodHJ1ZSk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgc2F2ZSB0aHJvdWdoIHRoZSBob29rXG4gICAgICB0b2FzdC5zdWNjZXNzKCfOjM67zrXPgiDOv865IM+Bz4XOuM68zq/Pg861zrnPgiDOsc+Azr/OuM63zrrOtc+Nz4TOt866zrHOvScpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0b2FzdC5lcnJvcignzpHPgM6/z4TPhc+Hzq/OsSDOsc+Azr/OuM6uzrrOtc+Fz4POt8+CJyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzU2F2aW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKGlzTG9hZGluZykge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGgtNjRcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhbmltYXRlLXNwaW4gcm91bmRlZC1mdWxsIGgtOCB3LTggYm9yZGVyLWItMiBib3JkZXItYmx1ZS02MDBcIj48L2Rpdj5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibWwtMlwiPs6mz4zPgc+Ez4nPg863IM+Bz4XOuM68zq/Pg861z4nOvSB3aWRnZXRzLi4uPC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLXJlZC01MCBib3JkZXIgYm9yZGVyLXJlZC0yMDAgcm91bmRlZC1sZyBwLTRcIj5cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1yZWQtODAwXCI+e2Vycm9yfTwvcD5cbiAgICAgICAgPEJ1dHRvbiBcbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCl9IFxuICAgICAgICAgIHZhcmlhbnQ9XCJvdXRsaW5lXCIgXG4gICAgICAgICAgY2xhc3NOYW1lPVwibXQtMlwiXG4gICAgICAgID5cbiAgICAgICAgICA8UmVmcmVzaEN3IGNsYXNzTmFtZT1cInctNCBoLTQgbXItMlwiIC8+XG4gICAgICAgICAgzpXPgM6xzr3OrM67zrfPiM63XG4gICAgICAgIDwvQnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTZcIj5cbiAgICAgIHsvKiBIZWFkZXIgKi99XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlblwiPlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LTJ4bCBmb250LWJvbGQgdGV4dC1ncmF5LTkwMFwiPs6UzrnOsc+HzrXOr8+BzrnPg863IEtpb3NrIFdpZGdldHM8L2gxPlxuICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtZ3JheS02MDAgbXQtMVwiPlxuICAgICAgICAgICAgzqHPhc64zrzOr8+Dz4TOtSDPgM6/zrnOsSB3aWRnZXRzIM64zrEgzrXOvM+GzrHOvc6vzrbOv869z4TOsc65IM+Dz4TOvyBraW9zayDOus6xzrkgz4POtSDPgM6/zrnOsSDPg861zrnPgc6sXG4gICAgICAgICAgPC9wPlxuICAgICAgICAgIHtzZWxlY3RlZEJ1aWxkaW5nICYmIChcbiAgICAgICAgICAgIDxCYWRnZSB2YXJpYW50PVwib3V0bGluZVwiIGNsYXNzTmFtZT1cIm10LTJcIj5cbiAgICAgICAgICAgICAgPEJ1aWxkaW5nIGNsYXNzTmFtZT1cInctMyBoLTMgbXItMVwiIC8+XG4gICAgICAgICAgICAgIHtzZWxlY3RlZEJ1aWxkaW5nLm5hbWV9XG4gICAgICAgICAgICA8L0JhZGdlPlxuICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtMlwiPlxuICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgIHZhcmlhbnQ9e3VzZUNhbnZhc0VkaXRvciA/IFwiZGVmYXVsdFwiIDogXCJvdXRsaW5lXCJ9XG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRVc2VDYW52YXNFZGl0b3IodHJ1ZSl9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPEdyaWQzWDMgY2xhc3NOYW1lPVwidy00IGgtNCBtci0yXCIgLz5cbiAgICAgICAgICAgIENhbnZhcyBFZGl0b3JcbiAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICB2YXJpYW50PXshdXNlQ2FudmFzRWRpdG9yID8gXCJkZWZhdWx0XCIgOiBcIm91dGxpbmVcIn1cbiAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFVzZUNhbnZhc0VkaXRvcihmYWxzZSl9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPFNldHRpbmdzIGNsYXNzTmFtZT1cInctNCBoLTQgbXItMlwiIC8+XG4gICAgICAgICAgICBDbGFzc2ljIFZpZXdcbiAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICA8U2VwYXJhdG9yIG9yaWVudGF0aW9uPVwidmVydGljYWxcIiBjbGFzc05hbWU9XCJoLThcIiAvPlxuICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgIHZhcmlhbnQ9XCJvdXRsaW5lXCJcbiAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFByZXZpZXdNb2RlKCFwcmV2aWV3TW9kZSl9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge3ByZXZpZXdNb2RlID8gPEV5ZU9mZiBjbGFzc05hbWU9XCJ3LTQgaC00IG1yLTJcIiAvPiA6IDxFeWUgY2xhc3NOYW1lPVwidy00IGgtNCBtci0yXCIgLz59XG4gICAgICAgICAgICB7cHJldmlld01vZGUgPyAnzpHPgM+MzrrPgc+Fz4jOtyBQcmV2aWV3JyA6ICdQcmV2aWV3J31cbiAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICB2YXJpYW50PVwib3V0bGluZVwiXG4gICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVSZXNldFRvRGVmYXVsdH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8Um90YXRlQ2N3IGNsYXNzTmFtZT1cInctNCBoLTQgbXItMlwiIC8+XG4gICAgICAgICAgICDOlc+AzrHOvc6xz4bOv8+BzqxcbiAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVTYXZlQWxsfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e2lzU2F2aW5nfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxTYXZlIGNsYXNzTmFtZT1cInctNCBoLTQgbXItMlwiIC8+XG4gICAgICAgICAgICB7aXNTYXZpbmcgPyAnzpHPgM6/zrjOrs66zrXPhc+DzrcuLi4nIDogJ86Rz4DOv864zq7Ous61z4XPg863J31cbiAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgey8qIEdsb2JhbCBTZXR0aW5ncyAqL31cbiAgICAgIDxDYXJkPlxuICAgICAgICA8Q2FyZEhlYWRlcj5cbiAgICAgICAgICA8Q2FyZFRpdGxlIGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICA8U2V0dGluZ3MgY2xhc3NOYW1lPVwidy01IGgtNSBtci0yXCIgLz5cbiAgICAgICAgICAgIM6TzrXOvc65zrrOrc+CIM6hz4XOuM68zq/Pg861zrnPglxuICAgICAgICAgIDwvQ2FyZFRpdGxlPlxuICAgICAgICAgIDxDYXJkRGVzY3JpcHRpb24+XG4gICAgICAgICAgICDOoc+FzrjOvM6vz4POtc65z4Igz4DOv8+FIM61z4DOt8+BzrXOrM62zr/Phc69IM+Ezrcgz4PPhc69zr/Ou865zrrOriDOu861zrnPhM6/z4XPgc6zzq/OsSDPhM6/z4Uga2lvc2tcbiAgICAgICAgICA8L0NhcmREZXNjcmlwdGlvbj5cbiAgICAgICAgPC9DYXJkSGVhZGVyPlxuICAgICAgICA8Q2FyZENvbnRlbnQgY2xhc3NOYW1lPVwic3BhY2UteS00XCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkIGdyaWQtY29scy0xIG1kOmdyaWQtY29scy0zIGdhcC00XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwYWNlLXktMlwiPlxuICAgICAgICAgICAgICA8TGFiZWwgaHRtbEZvcj1cInNsaWRlRHVyYXRpb25cIj7OlM65zqzPgc66zrXOuc6xIFNsaWRlICjOtM61z4XPhM61z4HPjM67zrXPgM+EzrEpPC9MYWJlbD5cbiAgICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgaWQ9XCJzbGlkZUR1cmF0aW9uXCJcbiAgICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICBtaW49XCI1XCJcbiAgICAgICAgICAgICAgICBtYXg9XCI2MFwiXG4gICAgICAgICAgICAgICAgdmFsdWU9e2NvbmZpZy5zZXR0aW5ncy5zbGlkZUR1cmF0aW9ufVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gaGFuZGxlR2xvYmFsU2V0dGluZ3NDaGFuZ2UoJ3NsaWRlRHVyYXRpb24nLCBwYXJzZUludChlLnRhcmdldC52YWx1ZSkpfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwYWNlLXktMlwiPlxuICAgICAgICAgICAgICA8TGFiZWwgaHRtbEZvcj1cInJlZnJlc2hJbnRlcnZhbFwiPs6UzrnOrM+Dz4TOt868zrEgzpHOvc6xzr3Orc+Jz4POt8+CICjOtM61z4XPhM61z4HPjM67zrXPgM+EzrEpPC9MYWJlbD5cbiAgICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgaWQ9XCJyZWZyZXNoSW50ZXJ2YWxcIlxuICAgICAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgICAgICAgICAgIG1pbj1cIjEwXCJcbiAgICAgICAgICAgICAgICBtYXg9XCIzMDBcIlxuICAgICAgICAgICAgICAgIHZhbHVlPXtjb25maWcuc2V0dGluZ3MucmVmcmVzaEludGVydmFsfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gaGFuZGxlR2xvYmFsU2V0dGluZ3NDaGFuZ2UoJ3JlZnJlc2hJbnRlcnZhbCcsIHBhcnNlSW50KGUudGFyZ2V0LnZhbHVlKSl9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC0yXCI+XG4gICAgICAgICAgICAgIDxTd2l0Y2hcbiAgICAgICAgICAgICAgICBpZD1cImF1dG9SZWZyZXNoXCJcbiAgICAgICAgICAgICAgICBjaGVja2VkPXtjb25maWcuc2V0dGluZ3MuYXV0b1JlZnJlc2h9XG4gICAgICAgICAgICAgICAgb25DaGVja2VkQ2hhbmdlPXsoY2hlY2tlZCkgPT4gaGFuZGxlR2xvYmFsU2V0dGluZ3NDaGFuZ2UoJ2F1dG9SZWZyZXNoJywgY2hlY2tlZCl9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDxMYWJlbCBodG1sRm9yPVwiYXV0b1JlZnJlc2hcIj7Okc+Fz4TPjM68zrHPhM63IM6Rzr3Osc69zq3Pic+Dzrc8L0xhYmVsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvQ2FyZENvbnRlbnQ+XG4gICAgICA8L0NhcmQ+XG5cbiAgICAgIHsvKiBXaWRnZXRzIGJ5IENhdGVnb3J5IC0gQ2xhc3NpYyBWaWV3IHdpdGggRHJhZyAmIERyb3AgKi99XG4gICAgICB7IXVzZUNhbnZhc0VkaXRvciAmJiAoXG4gICAgICAgIDxEcmFnRHJvcENvbnRleHQgb25EcmFnRW5kPXtoYW5kbGVEcmFnRW5kfT5cbiAgICAgICAgICB7T2JqZWN0LmVudHJpZXMod2lkZ2V0c0J5Q2F0ZWdvcnkpLm1hcCgoW2NhdGVnb3J5LCB3aWRnZXRzXSkgPT4gKFxuICAgICAgICAgICAgPENhcmQga2V5PXtjYXRlZ29yeX0gY2xhc3NOYW1lPVwibWItNlwiPlxuICAgICAgICAgICAgICA8Q2FyZEhlYWRlcj5cbiAgICAgICAgICAgICAgICA8Q2FyZFRpdGxlIGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICA8TW9uaXRvciBjbGFzc05hbWU9XCJ3LTUgaC01IG1yLTJcIiAvPlxuICAgICAgICAgICAgICAgICAge0NBVEVHT1JZX0xBQkVMU1tjYXRlZ29yeSBhcyBXaWRnZXRDYXRlZ29yeV19XG4gICAgICAgICAgICAgICAgICA8QmFkZ2UgXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJvdXRsaW5lXCIgXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YG1sLTIgJHtDQVRFR09SWV9DT0xPUlNbY2F0ZWdvcnkgYXMgV2lkZ2V0Q2F0ZWdvcnldfWB9XG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHt3aWRnZXRzLmZpbHRlcih3ID0+IHcuZW5hYmxlZCkubGVuZ3RofSAvIHt3aWRnZXRzLmxlbmd0aH1cbiAgICAgICAgICAgICAgICAgIDwvQmFkZ2U+XG4gICAgICAgICAgICAgICAgPC9DYXJkVGl0bGU+XG4gICAgICAgICAgICAgICAgPENhcmREZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgIHtjYXRlZ29yeSA9PT0gJ21haW5fc2xpZGVzJyAmJiAnzprPjc+BzrnOsSDPgM61z4HOuc61z4fPjM68zrXOvc6xIM+Azr/PhSDOtc68z4bOsc69zq/Ots6/zr3PhM6xzrkgz4nPgiBzbGlkZXMnfVxuICAgICAgICAgICAgICAgICAge2NhdGVnb3J5ID09PSAnc2lkZWJhcl93aWRnZXRzJyAmJiAnV2lkZ2V0cyDPgM6/z4UgzrXOvM+GzrHOvc6vzrbOv869z4TOsc65IM+Dz4TOt869IM+AzrvOtc+Fz4HOuc66zq4gzrzPgM6sz4HOsSd9XG4gICAgICAgICAgICAgICAgICB7Y2F0ZWdvcnkgPT09ICd0b3BfYmFyX3dpZGdldHMnICYmICdXaWRnZXRzIM+Azr/PhSDOtc68z4bOsc69zq/Ots6/zr3PhM6xzrkgz4PPhM63zr0gzrXPgM6szr3PiSDOvM+AzqzPgc6xJ31cbiAgICAgICAgICAgICAgICAgIHtjYXRlZ29yeSA9PT0gJ3NwZWNpYWxfd2lkZ2V0cycgJiYgJ86VzrnOtM65zrrOrCB3aWRnZXRzICjPgC7Phy4gbmV3cyB0aWNrZXIpJ31cbiAgICAgICAgICAgICAgICA8L0NhcmREZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgPC9DYXJkSGVhZGVyPlxuICAgICAgICAgICAgICA8Q2FyZENvbnRlbnQ+XG4gICAgICAgICAgICAgICAgPERyb3BwYWJsZSBkcm9wcGFibGVJZD17Y2F0ZWdvcnl9PlxuICAgICAgICAgICAgICAgICAgeyhwcm92aWRlZCwgc25hcHNob3QpID0+IChcbiAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgIHJlZj17cHJvdmlkZWQuaW5uZXJSZWZ9XG4gICAgICAgICAgICAgICAgICAgICAgey4uLnByb3ZpZGVkLmRyb3BwYWJsZVByb3BzfVxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YHNwYWNlLXktMiBtaW4taC1bMTAwcHhdIHAtMiByb3VuZGVkLWxnIHRyYW5zaXRpb24tY29sb3JzICR7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwc2hvdC5pc0RyYWdnaW5nT3ZlciA/ICdiZy1ibHVlLTUwIGJvcmRlci0yIGJvcmRlci1kYXNoZWQgYm9yZGVyLWJsdWUtMzAwJyA6ICdiZy1ncmF5LTUwJ1xuICAgICAgICAgICAgICAgICAgICAgIH1gfVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAge3dpZGdldHMubWFwKCh3aWRnZXQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBJY29uQ29tcG9uZW50ID0gV0lER0VUX0lDT05TW3dpZGdldC5pZF0gfHwgU2V0dGluZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICA8RHJhZ2dhYmxlIGtleT17d2lkZ2V0LmlkfSBkcmFnZ2FibGVJZD17d2lkZ2V0LmlkfSBpbmRleD17aW5kZXh9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsocHJvdmlkZWQsIHNuYXBzaG90KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZj17cHJvdmlkZWQuaW5uZXJSZWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsuLi5wcm92aWRlZC5kcmFnZ2FibGVQcm9wc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC0zIHAtMyBiZy13aGl0ZSBib3JkZXIgcm91bmRlZC1sZyB0cmFuc2l0aW9uLWFsbCAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBzaG90LmlzRHJhZ2dpbmcgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdzaGFkb3ctbGcgYm9yZGVyLWJsdWUtNDAwIGJnLWJsdWUtNTAnIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnaG92ZXI6c2hhZG93LW1kIGhvdmVyOmJvcmRlci1ncmF5LTMwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfWB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvKiBEcmFnIEhhbmRsZSAqL31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Li4ucHJvdmlkZWQuZHJhZ0hhbmRsZVByb3BzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgc3BhY2UteS0xIGN1cnNvci1ncmFiIGFjdGl2ZTpjdXJzb3ItZ3JhYmJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LTQgaC0xIGJnLWdyYXktMzAwIHJvdW5kZWRcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctNCBoLTEgYmctZ3JheS0zMDAgcm91bmRlZFwiPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy00IGgtMSBiZy1ncmF5LTMwMCByb3VuZGVkXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgey8qIFdpZGdldCBJY29uICovfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgtc2hyaW5rLTBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SWNvbkNvbXBvbmVudCBjbGFzc05hbWU9XCJ3LTUgaC01IHRleHQtZ3JheS02MDBcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvKiBXaWRnZXQgSW5mbyAqL31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4LTEgbWluLXctMFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC0yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwiZm9udC1tZWRpdW0gdGV4dC1ncmF5LTkwMCB0cnVuY2F0ZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7d2lkZ2V0Lm5hbWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2gzPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3dpZGdldC5lbmFibGVkICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJhZGdlIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIiBjbGFzc05hbWU9XCJ0ZXh0LXhzXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgzpXOvc61z4HOs8+MXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvQmFkZ2U+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmF5LTYwMCB0cnVuY2F0ZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3dpZGdldC5kZXNjcmlwdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgey8qIFRvZ2dsZSBTd2l0Y2ggKi99XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleC1zaHJpbmstMFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3dpZGdldC5lbmFibGVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGVja2VkQ2hhbmdlPXsoY2hlY2tlZCkgPT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZVRvZ2dsZVdpZGdldCh3aWRnZXQuaWQsIGNoZWNrZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L0RyYWdnYWJsZT5cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgICAgICAge3Byb3ZpZGVkLnBsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgPC9Ecm9wcGFibGU+XG4gICAgICAgICAgICAgIDwvQ2FyZENvbnRlbnQ+XG4gICAgICAgICAgICA8L0NhcmQ+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvRHJhZ0Ryb3BDb250ZXh0PlxuICAgICAgKX1cblxuICAgICAgey8qIENhbnZhcyBFZGl0b3Igb3IgQ2xhc3NpYyBWaWV3ICovfVxuICAgICAge3VzZUNhbnZhc0VkaXRvciA/IChcbiAgICAgICAgPEtpb3NrQ2FudmFzRWRpdG9yIGJ1aWxkaW5nSWQ9e3NlbGVjdGVkQnVpbGRpbmc/LmlkfSAvPlxuICAgICAgKSA6IG51bGx9XG5cbiAgICAgIHsvKiBQcmV2aWV3IFNlY3Rpb24gKi99XG4gICAgICB7cHJldmlld01vZGUgJiYgKFxuICAgICAgICA8Q2FyZD5cbiAgICAgICAgICA8Q2FyZEhlYWRlcj5cbiAgICAgICAgICAgIDxDYXJkVGl0bGUgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgPEV5ZSBjbGFzc05hbWU9XCJ3LTUgaC01IG1yLTJcIiAvPlxuICAgICAgICAgICAgICBQcmV2aWV3IC0gzpXOvc61z4HOs86sIFdpZGdldHNcbiAgICAgICAgICAgIDwvQ2FyZFRpdGxlPlxuICAgICAgICAgICAgPENhcmREZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgzqDPgc6/zrXPgM65z4POus+Mz4DOt8+Dzrcgz4TPic69IHdpZGdldHMgz4DOv8+FIM64zrEgzrXOvM+GzrHOvc6vzrbOv869z4TOsc65IM+Dz4TOvyBraW9za1xuICAgICAgICAgICAgPC9DYXJkRGVzY3JpcHRpb24+XG4gICAgICAgICAgPC9DYXJkSGVhZGVyPlxuICAgICAgICAgIDxDYXJkQ29udGVudD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMSBtZDpncmlkLWNvbHMtMiBsZzpncmlkLWNvbHMtMyBnYXAtNFwiPlxuICAgICAgICAgICAgICB7T2JqZWN0LmVudHJpZXMod2lkZ2V0c0J5Q2F0ZWdvcnkpLm1hcCgoW2NhdGVnb3J5LCB3aWRnZXRzXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuYWJsZWRXaWRnZXRzID0gd2lkZ2V0cy5maWx0ZXIodyA9PiB3LmVuYWJsZWQpO1xuICAgICAgICAgICAgICAgIGlmIChlbmFibGVkV2lkZ2V0cy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICA8ZGl2IGtleT17Y2F0ZWdvcnl9IGNsYXNzTmFtZT1cInNwYWNlLXktMlwiPlxuICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3NOYW1lPVwiZm9udC1tZWRpdW0gdGV4dC1zbSB0ZXh0LWdyYXktNzAwXCI+XG4gICAgICAgICAgICAgICAgICAgICAge0NBVEVHT1JZX0xBQkVMU1tjYXRlZ29yeSBhcyBXaWRnZXRDYXRlZ29yeV19XG4gICAgICAgICAgICAgICAgICAgIDwvaDQ+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0xXCI+XG4gICAgICAgICAgICAgICAgICAgICAge2VuYWJsZWRXaWRnZXRzLm1hcCgod2lkZ2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBJY29uQ29tcG9uZW50ID0gV0lER0VUX0lDT05TW3dpZGdldC5pZF0gfHwgU2V0dGluZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17d2lkZ2V0LmlkfSBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBzcGFjZS14LTIgdGV4dC1zbVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxJY29uQ29tcG9uZW50IGNsYXNzTmFtZT1cInctNCBoLTQgdGV4dC1ncmF5LTUwMFwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1ncmF5LTcwMFwiPnt3aWRnZXQubmFtZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvQ2FyZENvbnRlbnQ+XG4gICAgICAgIDwvQ2FyZD5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gICk7XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VCdWlsZGluZyIsIkNhcmQiLCJDYXJkQ29udGVudCIsIkNhcmREZXNjcmlwdGlvbiIsIkNhcmRIZWFkZXIiLCJDYXJkVGl0bGUiLCJCdXR0b24iLCJJbnB1dCIsIkxhYmVsIiwiU3dpdGNoIiwiQmFkZ2UiLCJTZXBhcmF0b3IiLCJNb25pdG9yIiwiU2V0dGluZ3MiLCJTYXZlIiwiUm90YXRlQ2N3IiwiRXllIiwiRXllT2ZmIiwiQ2xvY2siLCJDbG91ZCIsIlVzZXJzIiwiTWVzc2FnZVNxdWFyZSIsIk1lZ2FwaG9uZSIsIkJlbGwiLCJWb3RlIiwiRXVybyIsIldyZW5jaCIsIkZpbGVUZXh0IiwiQnVpbGRpbmciLCJTaGllbGQiLCJUcmVuZGluZ1VwIiwiUXJDb2RlIiwiVGhlcm1vbWV0ZXIiLCJCYXJDaGFydDMiLCJIb21lIiwiRXh0ZXJuYWxMaW5rIiwiUmVmcmVzaEN3IiwiR3JpZDNYMyIsInVzZUtpb3NrV2lkZ2V0cyIsInRvYXN0IiwiS2lvc2tDYW52YXNFZGl0b3IiLCJEcmFnRHJvcENvbnRleHQiLCJEcm9wcGFibGUiLCJEcmFnZ2FibGUiLCJXSURHRVRfSUNPTlMiLCJkYXNoYm9hcmRfb3ZlcnZpZXciLCJidWlsZGluZ19zdGF0aXN0aWNzIiwiZW1lcmdlbmN5X2NvbnRhY3RzIiwiYW5ub3VuY2VtZW50cyIsInZvdGVzIiwiZmluYW5jaWFsX292ZXJ2aWV3IiwibWFpbnRlbmFuY2Vfb3ZlcnZpZXciLCJwcm9qZWN0c19vdmVydmlldyIsImN1cnJlbnRfdGltZSIsInFyX2NvZGVfY29ubmVjdGlvbiIsIndlYXRoZXJfd2lkZ2V0X3NpZGViYXIiLCJ3ZWF0aGVyX3dpZGdldF90b3BiYXIiLCJpbnRlcm5hbF9tYW5hZ2VyX2luZm8iLCJjb21tdW5pdHlfbWVzc2FnZSIsImFkdmVydGlzaW5nX2Jhbm5lcnNfc2lkZWJhciIsImFkdmVydGlzaW5nX2Jhbm5lcnNfdG9wYmFyIiwibmV3c190aWNrZXIiLCJDQVRFR09SWV9DT0xPUlMiLCJtYWluX3NsaWRlcyIsInNpZGViYXJfd2lkZ2V0cyIsInRvcF9iYXJfd2lkZ2V0cyIsInNwZWNpYWxfd2lkZ2V0cyIsIkNBVEVHT1JZX0xBQkVMUyIsIktpb3NrV2lkZ2V0c1BhZ2UiLCJzZWxlY3RlZEJ1aWxkaW5nIiwiY29uZmlnIiwiaXNMb2FkaW5nIiwiZXJyb3IiLCJ0b2dnbGVXaWRnZXQiLCJ1cGRhdGVXaWRnZXRPcmRlciIsInVwZGF0ZUdsb2JhbFNldHRpbmdzIiwicmVzZXRUb0RlZmF1bHQiLCJnZXRFbmFibGVkV2lkZ2V0cyIsImlkIiwiaXNTYXZpbmciLCJzZXRJc1NhdmluZyIsInByZXZpZXdNb2RlIiwic2V0UHJldmlld01vZGUiLCJ1c2VDYW52YXNFZGl0b3IiLCJzZXRVc2VDYW52YXNFZGl0b3IiLCJ3aWRnZXRzQnlDYXRlZ29yeSIsIndpZGdldHMiLCJyZWR1Y2UiLCJhY2MiLCJ3aWRnZXQiLCJjYXRlZ29yeSIsInB1c2giLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsInNvcnQiLCJhIiwiYiIsIm9yZGVyIiwiaGFuZGxlVG9nZ2xlV2lkZ2V0Iiwid2lkZ2V0SWQiLCJlbmFibGVkIiwic3VjY2VzcyIsImhhbmRsZURyYWdFbmQiLCJyZXN1bHQiLCJkZXN0aW5hdGlvbiIsInNvdXJjZSIsImRyYWdnYWJsZUlkIiwiZHJvcHBhYmxlSWQiLCJpbmRleCIsInJlb3JkZXJlZFdpZGdldCIsInNwbGljZSIsInVwZGF0ZXMiLCJtYXAiLCJQcm9taXNlIiwiYWxsIiwiaGFuZGxlTW92ZVVwIiwiY3VycmVudEluZGV4IiwiZmluZEluZGV4IiwidyIsIm5ld0luZGV4IiwiaGFuZGxlTW92ZURvd24iLCJsZW5ndGgiLCJoYW5kbGVHbG9iYWxTZXR0aW5nc0NoYW5nZSIsImZpZWxkIiwidmFsdWUiLCJoYW5kbGVSZXNldFRvRGVmYXVsdCIsImNvbmZpcm0iLCJoYW5kbGVTYXZlQWxsIiwiZGl2IiwiY2xhc3NOYW1lIiwic3BhbiIsInAiLCJvbkNsaWNrIiwid2luZG93IiwibG9jYXRpb24iLCJyZWxvYWQiLCJ2YXJpYW50IiwiaDEiLCJuYW1lIiwib3JpZW50YXRpb24iLCJkaXNhYmxlZCIsImh0bWxGb3IiLCJ0eXBlIiwibWluIiwibWF4Iiwic2V0dGluZ3MiLCJzbGlkZUR1cmF0aW9uIiwib25DaGFuZ2UiLCJlIiwicGFyc2VJbnQiLCJ0YXJnZXQiLCJyZWZyZXNoSW50ZXJ2YWwiLCJjaGVja2VkIiwiYXV0b1JlZnJlc2giLCJvbkNoZWNrZWRDaGFuZ2UiLCJvbkRyYWdFbmQiLCJlbnRyaWVzIiwiZmlsdGVyIiwicHJvdmlkZWQiLCJzbmFwc2hvdCIsInJlZiIsImlubmVyUmVmIiwiZHJvcHBhYmxlUHJvcHMiLCJpc0RyYWdnaW5nT3ZlciIsIkljb25Db21wb25lbnQiLCJkcmFnZ2FibGVQcm9wcyIsImlzRHJhZ2dpbmciLCJkcmFnSGFuZGxlUHJvcHMiLCJoMyIsImRlc2NyaXB0aW9uIiwicGxhY2Vob2xkZXIiLCJidWlsZGluZ0lkIiwiZW5hYmxlZFdpZGdldHMiLCJoNCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/(dashboard)/kiosk-widgets/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _extends)\n/* harmony export */ });\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyIvYXBwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICByZXR1cm4gX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAobikge1xuICAgIGZvciAodmFyIGUgPSAxOyBlIDwgYXJndW1lbnRzLmxlbmd0aDsgZSsrKSB7XG4gICAgICB2YXIgdCA9IGFyZ3VtZW50c1tlXTtcbiAgICAgIGZvciAodmFyIHIgaW4gdCkgKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIHIpICYmIChuW3JdID0gdFtyXSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9LCBfZXh0ZW5kcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuZXhwb3J0IHsgX2V4dGVuZHMgYXMgZGVmYXVsdCB9OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@hello-pangea/dnd/dist/dnd.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@hello-pangea/dnd/dist/dnd.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DragDropContext: () => (/* binding */ DragDropContext),\n/* harmony export */   Draggable: () => (/* binding */ PublicDraggable),\n/* harmony export */   Droppable: () => (/* binding */ ConnectedDroppable),\n/* harmony export */   useKeyboardSensor: () => (/* binding */ useKeyboardSensor),\n/* harmony export */   useMouseSensor: () => (/* binding */ useMouseSensor),\n/* harmony export */   useTouchSensor: () => (/* binding */ useTouchSensor)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! redux */ \"(app-pages-browser)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-redux */ \"(app-pages-browser)/./node_modules/react-redux/dist/react-redux.mjs\");\n/* harmony import */ var css_box_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! css-box-model */ \"(app-pages-browser)/./node_modules/css-box-model/dist/css-box-model.esm.js\");\n/* harmony import */ var raf_schd__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! raf-schd */ \"(app-pages-browser)/./node_modules/raf-schd/dist/raf-schd.esm.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n\n\n\n\n\n\n\n\nconst isProduction$1 = \"development\" === 'production';\nconst spacesAndTabs = /[ \\t]{2,}/g;\nconst lineStartWithSpaces = /^[ \\t]*/gm;\nconst clean$2 = value => value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();\nconst getDevMessage = message => clean$2(`\n  %c@hello-pangea/dnd\n\n  %c${clean$2(message)}\n\n  %c👷‍ This is a development only message. It will be removed in production builds.\n`);\nconst getFormattedMessage = message => [getDevMessage(message), 'color: #00C584; font-size: 1.2em; font-weight: bold;', 'line-height: 1.5', 'color: #723874;'];\nconst isDisabledFlag = '__@hello-pangea/dnd-disable-dev-warnings';\nfunction log(type, message) {\n  if (isProduction$1) {\n    return;\n  }\n  if (typeof window !== 'undefined' && window[isDisabledFlag]) {\n    return;\n  }\n  console[type](...getFormattedMessage(message));\n}\nconst warning = log.bind(null, 'warn');\nconst error = log.bind(null, 'error');\n\nfunction noop$2() {}\n\nfunction getOptions(shared, fromBinding) {\n  return {\n    ...shared,\n    ...fromBinding\n  };\n}\nfunction bindEvents(el, bindings, sharedOptions) {\n  const unbindings = bindings.map(binding => {\n    const options = getOptions(sharedOptions, binding.options);\n    el.addEventListener(binding.eventName, binding.fn, options);\n    return function unbind() {\n      el.removeEventListener(binding.eventName, binding.fn, options);\n    };\n  });\n  return function unbindAll() {\n    unbindings.forEach(unbind => {\n      unbind();\n    });\n  };\n}\n\nconst isProduction = \"development\" === 'production';\nconst prefix$1 = 'Invariant failed';\nclass RbdInvariant extends Error {}\nRbdInvariant.prototype.toString = function toString() {\n  return this.message;\n};\nfunction invariant(condition, message) {\n  if (isProduction) {\n    throw new RbdInvariant(prefix$1);\n  } else {\n    throw new RbdInvariant(`${prefix$1}: ${message || ''}`);\n  }\n}\n\nclass ErrorBoundary extends (react__WEBPACK_IMPORTED_MODULE_0___default().Component) {\n  constructor(...args) {\n    super(...args);\n    this.callbacks = null;\n    this.unbind = noop$2;\n    this.onWindowError = event => {\n      const callbacks = this.getCallbacks();\n      if (callbacks.isDragging()) {\n        callbacks.tryAbort();\n         true ? warning(`\n        An error was caught by our window 'error' event listener while a drag was occurring.\n        The active drag has been aborted.\n      `) : 0;\n      }\n      const err = event.error;\n      if (err instanceof RbdInvariant) {\n        event.preventDefault();\n        if (true) {\n          error(err.message);\n        }\n      }\n    };\n    this.getCallbacks = () => {\n      if (!this.callbacks) {\n        throw new Error('Unable to find AppCallbacks in <ErrorBoundary/>');\n      }\n      return this.callbacks;\n    };\n    this.setCallbacks = callbacks => {\n      this.callbacks = callbacks;\n    };\n  }\n  componentDidMount() {\n    this.unbind = bindEvents(window, [{\n      eventName: 'error',\n      fn: this.onWindowError\n    }]);\n  }\n  componentDidCatch(err) {\n    if (err instanceof RbdInvariant) {\n      if (true) {\n        error(err.message);\n      }\n      this.setState({});\n      return;\n    }\n    throw err;\n  }\n  componentWillUnmount() {\n    this.unbind();\n  }\n  render() {\n    return this.props.children(this.setCallbacks);\n  }\n}\n\nconst dragHandleUsageInstructions = `\n  Press space bar to start a drag.\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\n  Some screen readers may require you to be in focus mode or to use your pass through key\n`;\nconst position = index => index + 1;\nconst onDragStart = start => `\n  You have lifted an item in position ${position(start.source.index)}\n`;\nconst withLocation = (source, destination) => {\n  const isInHomeList = source.droppableId === destination.droppableId;\n  const startPosition = position(source.index);\n  const endPosition = position(destination.index);\n  if (isInHomeList) {\n    return `\n      You have moved the item from position ${startPosition}\n      to position ${endPosition}\n    `;\n  }\n  return `\n    You have moved the item from position ${startPosition}\n    in list ${source.droppableId}\n    to list ${destination.droppableId}\n    in position ${endPosition}\n  `;\n};\nconst withCombine = (id, source, combine) => {\n  const inHomeList = source.droppableId === combine.droppableId;\n  if (inHomeList) {\n    return `\n      The item ${id}\n      has been combined with ${combine.draggableId}`;\n  }\n  return `\n      The item ${id}\n      in list ${source.droppableId}\n      has been combined with ${combine.draggableId}\n      in list ${combine.droppableId}\n    `;\n};\nconst onDragUpdate = update => {\n  const location = update.destination;\n  if (location) {\n    return withLocation(update.source, location);\n  }\n  const combine = update.combine;\n  if (combine) {\n    return withCombine(update.draggableId, update.source, combine);\n  }\n  return 'You are over an area that cannot be dropped on';\n};\nconst returnedToStart = source => `\n  The item has returned to its starting position\n  of ${position(source.index)}\n`;\nconst onDragEnd = result => {\n  if (result.reason === 'CANCEL') {\n    return `\n      Movement cancelled.\n      ${returnedToStart(result.source)}\n    `;\n  }\n  const location = result.destination;\n  const combine = result.combine;\n  if (location) {\n    return `\n      You have dropped the item.\n      ${withLocation(result.source, location)}\n    `;\n  }\n  if (combine) {\n    return `\n      You have dropped the item.\n      ${withCombine(result.draggableId, result.source, combine)}\n    `;\n  }\n  return `\n    The item has been dropped while not over a drop area.\n    ${returnedToStart(result.source)}\n  `;\n};\nconst preset = {\n  dragHandleUsageInstructions,\n  onDragStart,\n  onDragUpdate,\n  onDragEnd\n};\n\nfunction isEqual$2(first, second) {\n  if (first === second) {\n    return true;\n  }\n  if (Number.isNaN(first) && Number.isNaN(second)) {\n    return true;\n  }\n  return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n  if (newInputs.length !== lastInputs.length) {\n    return false;\n  }\n  for (let i = 0; i < newInputs.length; i++) {\n    if (!isEqual$2(newInputs[i], lastInputs[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction useMemo(getResult, inputs) {\n  const initial = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => ({\n    inputs,\n    result: getResult()\n  }))[0];\n  const isFirstRun = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n  const committed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initial);\n  const useCache = isFirstRun.current || Boolean(inputs && committed.current.inputs && areInputsEqual(inputs, committed.current.inputs));\n  const cache = useCache ? committed.current : {\n    inputs,\n    result: getResult()\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    isFirstRun.current = false;\n    committed.current = cache;\n  }, [cache]);\n  return cache.result;\n}\nfunction useCallback(callback, inputs) {\n  return useMemo(() => callback, inputs);\n}\n\nconst origin = {\n  x: 0,\n  y: 0\n};\nconst add = (point1, point2) => ({\n  x: point1.x + point2.x,\n  y: point1.y + point2.y\n});\nconst subtract = (point1, point2) => ({\n  x: point1.x - point2.x,\n  y: point1.y - point2.y\n});\nconst isEqual$1 = (point1, point2) => point1.x === point2.x && point1.y === point2.y;\nconst negate = point => ({\n  x: point.x !== 0 ? -point.x : 0,\n  y: point.y !== 0 ? -point.y : 0\n});\nconst patch = (line, value, otherValue = 0) => {\n  if (line === 'x') {\n    return {\n      x: value,\n      y: otherValue\n    };\n  }\n  return {\n    x: otherValue,\n    y: value\n  };\n};\nconst distance = (point1, point2) => Math.sqrt((point2.x - point1.x) ** 2 + (point2.y - point1.y) ** 2);\nconst closest$1 = (target, points) => Math.min(...points.map(point => distance(target, point)));\nconst apply = fn => point => ({\n  x: fn(point.x),\n  y: fn(point.y)\n});\n\nvar executeClip = (frame, subject) => {\n  const result = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)({\n    top: Math.max(subject.top, frame.top),\n    right: Math.min(subject.right, frame.right),\n    bottom: Math.min(subject.bottom, frame.bottom),\n    left: Math.max(subject.left, frame.left)\n  });\n  if (result.width <= 0 || result.height <= 0) {\n    return null;\n  }\n  return result;\n};\n\nconst offsetByPosition = (spacing, point) => ({\n  top: spacing.top + point.y,\n  left: spacing.left + point.x,\n  bottom: spacing.bottom + point.y,\n  right: spacing.right + point.x\n});\nconst getCorners = spacing => [{\n  x: spacing.left,\n  y: spacing.top\n}, {\n  x: spacing.right,\n  y: spacing.top\n}, {\n  x: spacing.left,\n  y: spacing.bottom\n}, {\n  x: spacing.right,\n  y: spacing.bottom\n}];\nconst noSpacing = {\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0\n};\n\nconst scroll$1 = (target, frame) => {\n  if (!frame) {\n    return target;\n  }\n  return offsetByPosition(target, frame.scroll.diff.displacement);\n};\nconst increase = (target, axis, withPlaceholder) => {\n  if (withPlaceholder && withPlaceholder.increasedBy) {\n    return {\n      ...target,\n      [axis.end]: target[axis.end] + withPlaceholder.increasedBy[axis.line]\n    };\n  }\n  return target;\n};\nconst clip = (target, frame) => {\n  if (frame && frame.shouldClipSubject) {\n    return executeClip(frame.pageMarginBox, target);\n  }\n  return (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)(target);\n};\nvar getSubject = ({\n  page,\n  withPlaceholder,\n  axis,\n  frame\n}) => {\n  const scrolled = scroll$1(page.marginBox, frame);\n  const increased = increase(scrolled, axis, withPlaceholder);\n  const clipped = clip(increased, frame);\n  return {\n    page,\n    withPlaceholder,\n    active: clipped\n  };\n};\n\nvar scrollDroppable = (droppable, newScroll) => {\n  !droppable.frame ?  true ? invariant() : 0 : void 0;\n  const scrollable = droppable.frame;\n  const scrollDiff = subtract(newScroll, scrollable.scroll.initial);\n  const scrollDisplacement = negate(scrollDiff);\n  const frame = {\n    ...scrollable,\n    scroll: {\n      initial: scrollable.scroll.initial,\n      current: newScroll,\n      diff: {\n        value: scrollDiff,\n        displacement: scrollDisplacement\n      },\n      max: scrollable.scroll.max\n    }\n  };\n  const subject = getSubject({\n    page: droppable.subject.page,\n    withPlaceholder: droppable.subject.withPlaceholder,\n    axis: droppable.axis,\n    frame\n  });\n  const result = {\n    ...droppable,\n    frame,\n    subject\n  };\n  return result;\n};\n\nfunction memoizeOne(resultFn, isEqual = areInputsEqual) {\n  let cache = null;\n  function memoized(...newArgs) {\n    if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {\n      return cache.lastResult;\n    }\n    const lastResult = resultFn.apply(this, newArgs);\n    cache = {\n      lastResult,\n      lastArgs: newArgs,\n      lastThis: this\n    };\n    return lastResult;\n  }\n  memoized.clear = function clear() {\n    cache = null;\n  };\n  return memoized;\n}\n\nconst toDroppableMap = memoizeOne(droppables => droppables.reduce((previous, current) => {\n  previous[current.descriptor.id] = current;\n  return previous;\n}, {}));\nconst toDraggableMap = memoizeOne(draggables => draggables.reduce((previous, current) => {\n  previous[current.descriptor.id] = current;\n  return previous;\n}, {}));\nconst toDroppableList = memoizeOne(droppables => Object.values(droppables));\nconst toDraggableList = memoizeOne(draggables => Object.values(draggables));\n\nvar getDraggablesInsideDroppable = memoizeOne((droppableId, draggables) => {\n  const result = toDraggableList(draggables).filter(draggable => droppableId === draggable.descriptor.droppableId).sort((a, b) => a.descriptor.index - b.descriptor.index);\n  return result;\n});\n\nfunction tryGetDestination(impact) {\n  if (impact.at && impact.at.type === 'REORDER') {\n    return impact.at.destination;\n  }\n  return null;\n}\nfunction tryGetCombine(impact) {\n  if (impact.at && impact.at.type === 'COMBINE') {\n    return impact.at.combine;\n  }\n  return null;\n}\n\nvar removeDraggableFromList = memoizeOne((remove, list) => list.filter(item => item.descriptor.id !== remove.descriptor.id));\n\nvar moveToNextCombine = ({\n  isMovingForward,\n  draggable,\n  destination,\n  insideDestination,\n  previousImpact\n}) => {\n  if (!destination.isCombineEnabled) {\n    return null;\n  }\n  const location = tryGetDestination(previousImpact);\n  if (!location) {\n    return null;\n  }\n  function getImpact(target) {\n    const at = {\n      type: 'COMBINE',\n      combine: {\n        draggableId: target,\n        droppableId: destination.descriptor.id\n      }\n    };\n    return {\n      ...previousImpact,\n      at\n    };\n  }\n  const all = previousImpact.displaced.all;\n  const closestId = all.length ? all[0] : null;\n  if (isMovingForward) {\n    return closestId ? getImpact(closestId) : null;\n  }\n  const withoutDraggable = removeDraggableFromList(draggable, insideDestination);\n  if (!closestId) {\n    if (!withoutDraggable.length) {\n      return null;\n    }\n    const last = withoutDraggable[withoutDraggable.length - 1];\n    return getImpact(last.descriptor.id);\n  }\n  const indexOfClosest = withoutDraggable.findIndex(d => d.descriptor.id === closestId);\n  !(indexOfClosest !== -1) ?  true ? invariant(false, 'Could not find displaced item in set') : 0 : void 0;\n  const proposedIndex = indexOfClosest - 1;\n  if (proposedIndex < 0) {\n    return null;\n  }\n  const before = withoutDraggable[proposedIndex];\n  return getImpact(before.descriptor.id);\n};\n\nvar isHomeOf = (draggable, destination) => draggable.descriptor.droppableId === destination.descriptor.id;\n\nconst noDisplacedBy = {\n  point: origin,\n  value: 0\n};\nconst emptyGroups = {\n  invisible: {},\n  visible: {},\n  all: []\n};\nconst noImpact = {\n  displaced: emptyGroups,\n  displacedBy: noDisplacedBy,\n  at: null\n};\n\nvar isWithin = (lowerBound, upperBound) => value => lowerBound <= value && value <= upperBound;\n\nvar isPartiallyVisibleThroughFrame = frame => {\n  const isWithinVertical = isWithin(frame.top, frame.bottom);\n  const isWithinHorizontal = isWithin(frame.left, frame.right);\n  return subject => {\n    const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n    if (isContained) {\n      return true;\n    }\n    const isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);\n    const isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);\n    const isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;\n    if (isPartiallyContained) {\n      return true;\n    }\n    const isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;\n    const isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;\n    const isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;\n    if (isTargetBiggerThanFrame) {\n      return true;\n    }\n    const isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;\n    return isTargetBiggerOnOneAxis;\n  };\n};\n\nvar isTotallyVisibleThroughFrame = frame => {\n  const isWithinVertical = isWithin(frame.top, frame.bottom);\n  const isWithinHorizontal = isWithin(frame.left, frame.right);\n  return subject => {\n    const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n    return isContained;\n  };\n};\n\nconst vertical = {\n  direction: 'vertical',\n  line: 'y',\n  crossAxisLine: 'x',\n  start: 'top',\n  end: 'bottom',\n  size: 'height',\n  crossAxisStart: 'left',\n  crossAxisEnd: 'right',\n  crossAxisSize: 'width'\n};\nconst horizontal = {\n  direction: 'horizontal',\n  line: 'x',\n  crossAxisLine: 'y',\n  start: 'left',\n  end: 'right',\n  size: 'width',\n  crossAxisStart: 'top',\n  crossAxisEnd: 'bottom',\n  crossAxisSize: 'height'\n};\n\nvar isTotallyVisibleThroughFrameOnAxis = axis => frame => {\n  const isWithinVertical = isWithin(frame.top, frame.bottom);\n  const isWithinHorizontal = isWithin(frame.left, frame.right);\n  return subject => {\n    if (axis === vertical) {\n      return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);\n    }\n    return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n  };\n};\n\nconst getDroppableDisplaced = (target, destination) => {\n  const displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;\n  return offsetByPosition(target, displacement);\n};\nconst isVisibleInDroppable = (target, destination, isVisibleThroughFrameFn) => {\n  if (!destination.subject.active) {\n    return false;\n  }\n  return isVisibleThroughFrameFn(destination.subject.active)(target);\n};\nconst isVisibleInViewport = (target, viewport, isVisibleThroughFrameFn) => isVisibleThroughFrameFn(viewport)(target);\nconst isVisible$1 = ({\n  target: toBeDisplaced,\n  destination,\n  viewport,\n  withDroppableDisplacement,\n  isVisibleThroughFrameFn\n}) => {\n  const displacedTarget = withDroppableDisplacement ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;\n  return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);\n};\nconst isPartiallyVisible = args => isVisible$1({\n  ...args,\n  isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame\n});\nconst isTotallyVisible = args => isVisible$1({\n  ...args,\n  isVisibleThroughFrameFn: isTotallyVisibleThroughFrame\n});\nconst isTotallyVisibleOnAxis = args => isVisible$1({\n  ...args,\n  isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)\n});\n\nconst getShouldAnimate = (id, last, forceShouldAnimate) => {\n  if (typeof forceShouldAnimate === 'boolean') {\n    return forceShouldAnimate;\n  }\n  if (!last) {\n    return true;\n  }\n  const {\n    invisible,\n    visible\n  } = last;\n  if (invisible[id]) {\n    return false;\n  }\n  const previous = visible[id];\n  return previous ? previous.shouldAnimate : true;\n};\nfunction getTarget(draggable, displacedBy) {\n  const marginBox = draggable.page.marginBox;\n  const expandBy = {\n    top: displacedBy.point.y,\n    right: 0,\n    bottom: 0,\n    left: displacedBy.point.x\n  };\n  return (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)((0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.expand)(marginBox, expandBy));\n}\nfunction getDisplacementGroups({\n  afterDragging,\n  destination,\n  displacedBy,\n  viewport,\n  forceShouldAnimate,\n  last\n}) {\n  return afterDragging.reduce(function process(groups, draggable) {\n    const target = getTarget(draggable, displacedBy);\n    const id = draggable.descriptor.id;\n    groups.all.push(id);\n    const isVisible = isPartiallyVisible({\n      target,\n      destination,\n      viewport,\n      withDroppableDisplacement: true\n    });\n    if (!isVisible) {\n      groups.invisible[draggable.descriptor.id] = true;\n      return groups;\n    }\n    const shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);\n    const displacement = {\n      draggableId: id,\n      shouldAnimate\n    };\n    groups.visible[id] = displacement;\n    return groups;\n  }, {\n    all: [],\n    visible: {},\n    invisible: {}\n  });\n}\n\nfunction getIndexOfLastItem(draggables, options) {\n  if (!draggables.length) {\n    return 0;\n  }\n  const indexOfLastItem = draggables[draggables.length - 1].descriptor.index;\n  return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;\n}\nfunction goAtEnd({\n  insideDestination,\n  inHomeList,\n  displacedBy,\n  destination\n}) {\n  const newIndex = getIndexOfLastItem(insideDestination, {\n    inHomeList\n  });\n  return {\n    displaced: emptyGroups,\n    displacedBy,\n    at: {\n      type: 'REORDER',\n      destination: {\n        droppableId: destination.descriptor.id,\n        index: newIndex\n      }\n    }\n  };\n}\nfunction calculateReorderImpact({\n  draggable,\n  insideDestination,\n  destination,\n  viewport,\n  displacedBy,\n  last,\n  index,\n  forceShouldAnimate\n}) {\n  const inHomeList = isHomeOf(draggable, destination);\n  if (index == null) {\n    return goAtEnd({\n      insideDestination,\n      inHomeList,\n      displacedBy,\n      destination\n    });\n  }\n  const match = insideDestination.find(item => item.descriptor.index === index);\n  if (!match) {\n    return goAtEnd({\n      insideDestination,\n      inHomeList,\n      displacedBy,\n      destination\n    });\n  }\n  const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n  const sliceFrom = insideDestination.indexOf(match);\n  const impacted = withoutDragging.slice(sliceFrom);\n  const displaced = getDisplacementGroups({\n    afterDragging: impacted,\n    destination,\n    displacedBy,\n    last,\n    viewport: viewport.frame,\n    forceShouldAnimate\n  });\n  return {\n    displaced,\n    displacedBy,\n    at: {\n      type: 'REORDER',\n      destination: {\n        droppableId: destination.descriptor.id,\n        index\n      }\n    }\n  };\n}\n\nfunction didStartAfterCritical(draggableId, afterCritical) {\n  return Boolean(afterCritical.effected[draggableId]);\n}\n\nvar fromCombine = ({\n  isMovingForward,\n  destination,\n  draggables,\n  combine,\n  afterCritical\n}) => {\n  if (!destination.isCombineEnabled) {\n    return null;\n  }\n  const combineId = combine.draggableId;\n  const combineWith = draggables[combineId];\n  const combineWithIndex = combineWith.descriptor.index;\n  const didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);\n  if (didCombineWithStartAfterCritical) {\n    if (isMovingForward) {\n      return combineWithIndex;\n    }\n    return combineWithIndex - 1;\n  }\n  if (isMovingForward) {\n    return combineWithIndex + 1;\n  }\n  return combineWithIndex;\n};\n\nvar fromReorder = ({\n  isMovingForward,\n  isInHomeList,\n  insideDestination,\n  location\n}) => {\n  if (!insideDestination.length) {\n    return null;\n  }\n  const currentIndex = location.index;\n  const proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;\n  const firstIndex = insideDestination[0].descriptor.index;\n  const lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;\n  const upperBound = isInHomeList ? lastIndex : lastIndex + 1;\n  if (proposedIndex < firstIndex) {\n    return null;\n  }\n  if (proposedIndex > upperBound) {\n    return null;\n  }\n  return proposedIndex;\n};\n\nvar moveToNextIndex = ({\n  isMovingForward,\n  isInHomeList,\n  draggable,\n  draggables,\n  destination,\n  insideDestination,\n  previousImpact,\n  viewport,\n  afterCritical\n}) => {\n  const wasAt = previousImpact.at;\n  !wasAt ?  true ? invariant(false, 'Cannot move in direction without previous impact location') : 0 : void 0;\n  if (wasAt.type === 'REORDER') {\n    const newIndex = fromReorder({\n      isMovingForward,\n      isInHomeList,\n      location: wasAt.destination,\n      insideDestination\n    });\n    if (newIndex == null) {\n      return null;\n    }\n    return calculateReorderImpact({\n      draggable,\n      insideDestination,\n      destination,\n      viewport,\n      last: previousImpact.displaced,\n      displacedBy: previousImpact.displacedBy,\n      index: newIndex\n    });\n  }\n  const newIndex = fromCombine({\n    isMovingForward,\n    destination,\n    displaced: previousImpact.displaced,\n    draggables,\n    combine: wasAt.combine,\n    afterCritical\n  });\n  if (newIndex == null) {\n    return null;\n  }\n  return calculateReorderImpact({\n    draggable,\n    insideDestination,\n    destination,\n    viewport,\n    last: previousImpact.displaced,\n    displacedBy: previousImpact.displacedBy,\n    index: newIndex\n  });\n};\n\nvar getCombinedItemDisplacement = ({\n  displaced,\n  afterCritical,\n  combineWith,\n  displacedBy\n}) => {\n  const isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);\n  if (didStartAfterCritical(combineWith, afterCritical)) {\n    return isDisplaced ? origin : negate(displacedBy.point);\n  }\n  return isDisplaced ? displacedBy.point : origin;\n};\n\nvar whenCombining = ({\n  afterCritical,\n  impact,\n  draggables\n}) => {\n  const combine = tryGetCombine(impact);\n  !combine ?  true ? invariant() : 0 : void 0;\n  const combineWith = combine.draggableId;\n  const center = draggables[combineWith].page.borderBox.center;\n  const displaceBy = getCombinedItemDisplacement({\n    displaced: impact.displaced,\n    afterCritical,\n    combineWith,\n    displacedBy: impact.displacedBy\n  });\n  return add(center, displaceBy);\n};\n\nconst distanceFromStartToBorderBoxCenter = (axis, box) => box.margin[axis.start] + box.borderBox[axis.size] / 2;\nconst distanceFromEndToBorderBoxCenter = (axis, box) => box.margin[axis.end] + box.borderBox[axis.size] / 2;\nconst getCrossAxisBorderBoxCenter = (axis, target, isMoving) => target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;\nconst goAfter = ({\n  axis,\n  moveRelativeTo,\n  isMoving\n}) => patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\nconst goBefore = ({\n  axis,\n  moveRelativeTo,\n  isMoving\n}) => patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\nconst goIntoStart = ({\n  axis,\n  moveInto,\n  isMoving\n}) => patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));\n\nvar whenReordering = ({\n  impact,\n  draggable,\n  draggables,\n  droppable,\n  afterCritical\n}) => {\n  const insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n  const draggablePage = draggable.page;\n  const axis = droppable.axis;\n  if (!insideDestination.length) {\n    return goIntoStart({\n      axis,\n      moveInto: droppable.page,\n      isMoving: draggablePage\n    });\n  }\n  const {\n    displaced,\n    displacedBy\n  } = impact;\n  const closestAfter = displaced.all[0];\n  if (closestAfter) {\n    const closest = draggables[closestAfter];\n    if (didStartAfterCritical(closestAfter, afterCritical)) {\n      return goBefore({\n        axis,\n        moveRelativeTo: closest.page,\n        isMoving: draggablePage\n      });\n    }\n    const withDisplacement = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.offset)(closest.page, displacedBy.point);\n    return goBefore({\n      axis,\n      moveRelativeTo: withDisplacement,\n      isMoving: draggablePage\n    });\n  }\n  const last = insideDestination[insideDestination.length - 1];\n  if (last.descriptor.id === draggable.descriptor.id) {\n    return draggablePage.borderBox.center;\n  }\n  if (didStartAfterCritical(last.descriptor.id, afterCritical)) {\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.offset)(last.page, negate(afterCritical.displacedBy.point));\n    return goAfter({\n      axis,\n      moveRelativeTo: page,\n      isMoving: draggablePage\n    });\n  }\n  return goAfter({\n    axis,\n    moveRelativeTo: last.page,\n    isMoving: draggablePage\n  });\n};\n\nvar withDroppableDisplacement = (droppable, point) => {\n  const frame = droppable.frame;\n  if (!frame) {\n    return point;\n  }\n  return add(point, frame.scroll.diff.displacement);\n};\n\nconst getResultWithoutDroppableDisplacement = ({\n  impact,\n  draggable,\n  droppable,\n  draggables,\n  afterCritical\n}) => {\n  const original = draggable.page.borderBox.center;\n  const at = impact.at;\n  if (!droppable) {\n    return original;\n  }\n  if (!at) {\n    return original;\n  }\n  if (at.type === 'REORDER') {\n    return whenReordering({\n      impact,\n      draggable,\n      draggables,\n      droppable,\n      afterCritical\n    });\n  }\n  return whenCombining({\n    impact,\n    draggables,\n    afterCritical\n  });\n};\nvar getPageBorderBoxCenterFromImpact = args => {\n  const withoutDisplacement = getResultWithoutDroppableDisplacement(args);\n  const droppable = args.droppable;\n  const withDisplacement = droppable ? withDroppableDisplacement(droppable, withoutDisplacement) : withoutDisplacement;\n  return withDisplacement;\n};\n\nvar scrollViewport = (viewport, newScroll) => {\n  const diff = subtract(newScroll, viewport.scroll.initial);\n  const displacement = negate(diff);\n  const frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)({\n    top: newScroll.y,\n    bottom: newScroll.y + viewport.frame.height,\n    left: newScroll.x,\n    right: newScroll.x + viewport.frame.width\n  });\n  const updated = {\n    frame,\n    scroll: {\n      initial: viewport.scroll.initial,\n      max: viewport.scroll.max,\n      current: newScroll,\n      diff: {\n        value: diff,\n        displacement\n      }\n    }\n  };\n  return updated;\n};\n\nfunction getDraggables$1(ids, draggables) {\n  return ids.map(id => draggables[id]);\n}\nfunction tryGetVisible(id, groups) {\n  for (let i = 0; i < groups.length; i++) {\n    const displacement = groups[i].visible[id];\n    if (displacement) {\n      return displacement;\n    }\n  }\n  return null;\n}\nvar speculativelyIncrease = ({\n  impact,\n  viewport,\n  destination,\n  draggables,\n  maxScrollChange\n}) => {\n  const scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));\n  const scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;\n  const last = impact.displaced;\n  const withViewportScroll = getDisplacementGroups({\n    afterDragging: getDraggables$1(last.all, draggables),\n    destination,\n    displacedBy: impact.displacedBy,\n    viewport: scrolledViewport.frame,\n    last,\n    forceShouldAnimate: false\n  });\n  const withDroppableScroll = getDisplacementGroups({\n    afterDragging: getDraggables$1(last.all, draggables),\n    destination: scrolledDroppable,\n    displacedBy: impact.displacedBy,\n    viewport: viewport.frame,\n    last,\n    forceShouldAnimate: false\n  });\n  const invisible = {};\n  const visible = {};\n  const groups = [last, withViewportScroll, withDroppableScroll];\n  last.all.forEach(id => {\n    const displacement = tryGetVisible(id, groups);\n    if (displacement) {\n      visible[id] = displacement;\n      return;\n    }\n    invisible[id] = true;\n  });\n  const newImpact = {\n    ...impact,\n    displaced: {\n      all: last.all,\n      invisible,\n      visible\n    }\n  };\n  return newImpact;\n};\n\nvar withViewportDisplacement = (viewport, point) => add(viewport.scroll.diff.displacement, point);\n\nvar getClientFromPageBorderBoxCenter = ({\n  pageBorderBoxCenter,\n  draggable,\n  viewport\n}) => {\n  const withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);\n  const offset = subtract(withoutPageScrollChange, draggable.page.borderBox.center);\n  return add(draggable.client.borderBox.center, offset);\n};\n\nvar isTotallyVisibleInNewLocation = ({\n  draggable,\n  destination,\n  newPageBorderBoxCenter,\n  viewport,\n  withDroppableDisplacement,\n  onlyOnMainAxis = false\n}) => {\n  const changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);\n  const shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);\n  const args = {\n    target: shifted,\n    destination,\n    withDroppableDisplacement,\n    viewport\n  };\n  return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);\n};\n\nvar moveToNextPlace = ({\n  isMovingForward,\n  draggable,\n  destination,\n  draggables,\n  previousImpact,\n  viewport,\n  previousPageBorderBoxCenter,\n  previousClientSelection,\n  afterCritical\n}) => {\n  if (!destination.isEnabled) {\n    return null;\n  }\n  const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n  const isInHomeList = isHomeOf(draggable, destination);\n  const impact = moveToNextCombine({\n    isMovingForward,\n    draggable,\n    destination,\n    insideDestination,\n    previousImpact\n  }) || moveToNextIndex({\n    isMovingForward,\n    isInHomeList,\n    draggable,\n    draggables,\n    destination,\n    insideDestination,\n    previousImpact,\n    viewport,\n    afterCritical\n  });\n  if (!impact) {\n    return null;\n  }\n  const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n    impact,\n    draggable,\n    droppable: destination,\n    draggables,\n    afterCritical\n  });\n  const isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n    draggable,\n    destination,\n    newPageBorderBoxCenter: pageBorderBoxCenter,\n    viewport: viewport.frame,\n    withDroppableDisplacement: false,\n    onlyOnMainAxis: true\n  });\n  if (isVisibleInNewLocation) {\n    const clientSelection = getClientFromPageBorderBoxCenter({\n      pageBorderBoxCenter,\n      draggable,\n      viewport\n    });\n    return {\n      clientSelection,\n      impact,\n      scrollJumpRequest: null\n    };\n  }\n  const distance = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);\n  const cautious = speculativelyIncrease({\n    impact,\n    viewport,\n    destination,\n    draggables,\n    maxScrollChange: distance\n  });\n  return {\n    clientSelection: previousClientSelection,\n    impact: cautious,\n    scrollJumpRequest: distance\n  };\n};\n\nconst getKnownActive = droppable => {\n  const rect = droppable.subject.active;\n  !rect ?  true ? invariant(false, 'Cannot get clipped area from droppable') : 0 : void 0;\n  return rect;\n};\nvar getBestCrossAxisDroppable = ({\n  isMovingForward,\n  pageBorderBoxCenter,\n  source,\n  droppables,\n  viewport\n}) => {\n  const active = source.subject.active;\n  if (!active) {\n    return null;\n  }\n  const axis = source.axis;\n  const isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);\n  const candidates = toDroppableList(droppables).filter(droppable => droppable !== source).filter(droppable => droppable.isEnabled).filter(droppable => Boolean(droppable.subject.active)).filter(droppable => isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable))).filter(droppable => {\n    const activeOfTarget = getKnownActive(droppable);\n    if (isMovingForward) {\n      return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];\n    }\n    return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];\n  }).filter(droppable => {\n    const activeOfTarget = getKnownActive(droppable);\n    const isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);\n    return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);\n  }).sort((a, b) => {\n    const first = getKnownActive(a)[axis.crossAxisStart];\n    const second = getKnownActive(b)[axis.crossAxisStart];\n    if (isMovingForward) {\n      return first - second;\n    }\n    return second - first;\n  }).filter((droppable, index, array) => getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart]);\n  if (!candidates.length) {\n    return null;\n  }\n  if (candidates.length === 1) {\n    return candidates[0];\n  }\n  const contains = candidates.filter(droppable => {\n    const isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);\n    return isWithinDroppable(pageBorderBoxCenter[axis.line]);\n  });\n  if (contains.length === 1) {\n    return contains[0];\n  }\n  if (contains.length > 1) {\n    return contains.sort((a, b) => getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start])[0];\n  }\n  return candidates.sort((a, b) => {\n    const first = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(a)));\n    const second = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(b)));\n    if (first !== second) {\n      return first - second;\n    }\n    return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n  })[0];\n};\n\nconst getCurrentPageBorderBoxCenter = (draggable, afterCritical) => {\n  const original = draggable.page.borderBox.center;\n  return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;\n};\nconst getCurrentPageBorderBox = (draggable, afterCritical) => {\n  const original = draggable.page.borderBox;\n  return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;\n};\n\nvar getClosestDraggable = ({\n  pageBorderBoxCenter,\n  viewport,\n  destination,\n  insideDestination,\n  afterCritical\n}) => {\n  const sorted = insideDestination.filter(draggable => isTotallyVisible({\n    target: getCurrentPageBorderBox(draggable, afterCritical),\n    destination,\n    viewport: viewport.frame,\n    withDroppableDisplacement: true\n  })).sort((a, b) => {\n    const distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));\n    const distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));\n    if (distanceToA < distanceToB) {\n      return -1;\n    }\n    if (distanceToB < distanceToA) {\n      return 1;\n    }\n    return a.descriptor.index - b.descriptor.index;\n  });\n  return sorted[0] || null;\n};\n\nvar getDisplacedBy = memoizeOne(function getDisplacedBy(axis, displaceBy) {\n  const displacement = displaceBy[axis.line];\n  return {\n    value: displacement,\n    point: patch(axis.line, displacement)\n  };\n});\n\nconst getRequiredGrowthForPlaceholder = (droppable, placeholderSize, draggables) => {\n  const axis = droppable.axis;\n  if (droppable.descriptor.mode === 'virtual') {\n    return patch(axis.line, placeholderSize[axis.line]);\n  }\n  const availableSpace = droppable.subject.page.contentBox[axis.size];\n  const insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n  const spaceUsed = insideDroppable.reduce((sum, dimension) => sum + dimension.client.marginBox[axis.size], 0);\n  const requiredSpace = spaceUsed + placeholderSize[axis.line];\n  const needsToGrowBy = requiredSpace - availableSpace;\n  if (needsToGrowBy <= 0) {\n    return null;\n  }\n  return patch(axis.line, needsToGrowBy);\n};\nconst withMaxScroll = (frame, max) => ({\n  ...frame,\n  scroll: {\n    ...frame.scroll,\n    max\n  }\n});\nconst addPlaceholder = (droppable, draggable, draggables) => {\n  const frame = droppable.frame;\n  !!isHomeOf(draggable, droppable) ?  true ? invariant(false, 'Should not add placeholder space to home list') : 0 : void 0;\n  !!droppable.subject.withPlaceholder ?  true ? invariant(false, 'Cannot add placeholder size to a subject when it already has one') : 0 : void 0;\n  const placeholderSize = getDisplacedBy(droppable.axis, draggable.displaceBy).point;\n  const requiredGrowth = getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables);\n  const added = {\n    placeholderSize,\n    increasedBy: requiredGrowth,\n    oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null\n  };\n  if (!frame) {\n    const subject = getSubject({\n      page: droppable.subject.page,\n      withPlaceholder: added,\n      axis: droppable.axis,\n      frame: droppable.frame\n    });\n    return {\n      ...droppable,\n      subject\n    };\n  }\n  const maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;\n  const newFrame = withMaxScroll(frame, maxScroll);\n  const subject = getSubject({\n    page: droppable.subject.page,\n    withPlaceholder: added,\n    axis: droppable.axis,\n    frame: newFrame\n  });\n  return {\n    ...droppable,\n    subject,\n    frame: newFrame\n  };\n};\nconst removePlaceholder = droppable => {\n  const added = droppable.subject.withPlaceholder;\n  !added ?  true ? invariant(false, 'Cannot remove placeholder form subject when there was none') : 0 : void 0;\n  const frame = droppable.frame;\n  if (!frame) {\n    const subject = getSubject({\n      page: droppable.subject.page,\n      axis: droppable.axis,\n      frame: null,\n      withPlaceholder: null\n    });\n    return {\n      ...droppable,\n      subject\n    };\n  }\n  const oldMaxScroll = added.oldFrameMaxScroll;\n  !oldMaxScroll ?  true ? invariant(false, 'Expected droppable with frame to have old max frame scroll when removing placeholder') : 0 : void 0;\n  const newFrame = withMaxScroll(frame, oldMaxScroll);\n  const subject = getSubject({\n    page: droppable.subject.page,\n    axis: droppable.axis,\n    frame: newFrame,\n    withPlaceholder: null\n  });\n  return {\n    ...droppable,\n    subject,\n    frame: newFrame\n  };\n};\n\nvar moveToNewDroppable = ({\n  previousPageBorderBoxCenter,\n  moveRelativeTo,\n  insideDestination,\n  draggable,\n  draggables,\n  destination,\n  viewport,\n  afterCritical\n}) => {\n  if (!moveRelativeTo) {\n    if (insideDestination.length) {\n      return null;\n    }\n    const proposed = {\n      displaced: emptyGroups,\n      displacedBy: noDisplacedBy,\n      at: {\n        type: 'REORDER',\n        destination: {\n          droppableId: destination.descriptor.id,\n          index: 0\n        }\n      }\n    };\n    const proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n      impact: proposed,\n      draggable,\n      droppable: destination,\n      draggables,\n      afterCritical\n    });\n    const withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);\n    const isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n      draggable,\n      destination: withPlaceholder,\n      newPageBorderBoxCenter: proposedPageBorderBoxCenter,\n      viewport: viewport.frame,\n      withDroppableDisplacement: false,\n      onlyOnMainAxis: true\n    });\n    return isVisibleInNewLocation ? proposed : null;\n  }\n  const isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);\n  const proposedIndex = (() => {\n    const relativeTo = moveRelativeTo.descriptor.index;\n    if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {\n      return relativeTo;\n    }\n    if (isGoingBeforeTarget) {\n      return relativeTo;\n    }\n    return relativeTo + 1;\n  })();\n  const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n  return calculateReorderImpact({\n    draggable,\n    insideDestination,\n    destination,\n    viewport,\n    displacedBy,\n    last: emptyGroups,\n    index: proposedIndex\n  });\n};\n\nvar moveCrossAxis = ({\n  isMovingForward,\n  previousPageBorderBoxCenter,\n  draggable,\n  isOver,\n  draggables,\n  droppables,\n  viewport,\n  afterCritical\n}) => {\n  const destination = getBestCrossAxisDroppable({\n    isMovingForward,\n    pageBorderBoxCenter: previousPageBorderBoxCenter,\n    source: isOver,\n    droppables,\n    viewport\n  });\n  if (!destination) {\n    return null;\n  }\n  const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n  const moveRelativeTo = getClosestDraggable({\n    pageBorderBoxCenter: previousPageBorderBoxCenter,\n    viewport,\n    destination,\n    insideDestination,\n    afterCritical\n  });\n  const impact = moveToNewDroppable({\n    previousPageBorderBoxCenter,\n    destination,\n    draggable,\n    draggables,\n    moveRelativeTo,\n    insideDestination,\n    viewport,\n    afterCritical\n  });\n  if (!impact) {\n    return null;\n  }\n  const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n    impact,\n    draggable,\n    droppable: destination,\n    draggables,\n    afterCritical\n  });\n  const clientSelection = getClientFromPageBorderBoxCenter({\n    pageBorderBoxCenter,\n    draggable,\n    viewport\n  });\n  return {\n    clientSelection,\n    impact,\n    scrollJumpRequest: null\n  };\n};\n\nvar whatIsDraggedOver = impact => {\n  const at = impact.at;\n  if (!at) {\n    return null;\n  }\n  if (at.type === 'REORDER') {\n    return at.destination.droppableId;\n  }\n  return at.combine.droppableId;\n};\n\nconst getDroppableOver$1 = (impact, droppables) => {\n  const id = whatIsDraggedOver(impact);\n  return id ? droppables[id] : null;\n};\nvar moveInDirection = ({\n  state,\n  type\n}) => {\n  const isActuallyOver = getDroppableOver$1(state.impact, state.dimensions.droppables);\n  const isMainAxisMovementAllowed = Boolean(isActuallyOver);\n  const home = state.dimensions.droppables[state.critical.droppable.id];\n  const isOver = isActuallyOver || home;\n  const direction = isOver.axis.direction;\n  const isMovingOnMainAxis = direction === 'vertical' && (type === 'MOVE_UP' || type === 'MOVE_DOWN') || direction === 'horizontal' && (type === 'MOVE_LEFT' || type === 'MOVE_RIGHT');\n  if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {\n    return null;\n  }\n  const isMovingForward = type === 'MOVE_DOWN' || type === 'MOVE_RIGHT';\n  const draggable = state.dimensions.draggables[state.critical.draggable.id];\n  const previousPageBorderBoxCenter = state.current.page.borderBoxCenter;\n  const {\n    draggables,\n    droppables\n  } = state.dimensions;\n  return isMovingOnMainAxis ? moveToNextPlace({\n    isMovingForward,\n    previousPageBorderBoxCenter,\n    draggable,\n    destination: isOver,\n    draggables,\n    viewport: state.viewport,\n    previousClientSelection: state.current.client.selection,\n    previousImpact: state.impact,\n    afterCritical: state.afterCritical\n  }) : moveCrossAxis({\n    isMovingForward,\n    previousPageBorderBoxCenter,\n    draggable,\n    isOver,\n    draggables,\n    droppables,\n    viewport: state.viewport,\n    afterCritical: state.afterCritical\n  });\n};\n\nfunction isMovementAllowed(state) {\n  return state.phase === 'DRAGGING' || state.phase === 'COLLECTING';\n}\n\nfunction isPositionInFrame(frame) {\n  const isWithinVertical = isWithin(frame.top, frame.bottom);\n  const isWithinHorizontal = isWithin(frame.left, frame.right);\n  return function run(point) {\n    return isWithinVertical(point.y) && isWithinHorizontal(point.x);\n  };\n}\n\nfunction getHasOverlap(first, second) {\n  return first.left < second.right && first.right > second.left && first.top < second.bottom && first.bottom > second.top;\n}\nfunction getFurthestAway({\n  pageBorderBox,\n  draggable,\n  candidates\n}) {\n  const startCenter = draggable.page.borderBox.center;\n  const sorted = candidates.map(candidate => {\n    const axis = candidate.axis;\n    const target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);\n    return {\n      id: candidate.descriptor.id,\n      distance: distance(startCenter, target)\n    };\n  }).sort((a, b) => b.distance - a.distance);\n  return sorted[0] ? sorted[0].id : null;\n}\nfunction getDroppableOver({\n  pageBorderBox,\n  draggable,\n  droppables\n}) {\n  const candidates = toDroppableList(droppables).filter(item => {\n    if (!item.isEnabled) {\n      return false;\n    }\n    const active = item.subject.active;\n    if (!active) {\n      return false;\n    }\n    if (!getHasOverlap(pageBorderBox, active)) {\n      return false;\n    }\n    if (isPositionInFrame(active)(pageBorderBox.center)) {\n      return true;\n    }\n    const axis = item.axis;\n    const childCenter = active.center[axis.crossAxisLine];\n    const crossAxisStart = pageBorderBox[axis.crossAxisStart];\n    const crossAxisEnd = pageBorderBox[axis.crossAxisEnd];\n    const isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);\n    const isStartContained = isContained(crossAxisStart);\n    const isEndContained = isContained(crossAxisEnd);\n    if (!isStartContained && !isEndContained) {\n      return true;\n    }\n    if (isStartContained) {\n      return crossAxisStart < childCenter;\n    }\n    return crossAxisEnd > childCenter;\n  });\n  if (!candidates.length) {\n    return null;\n  }\n  if (candidates.length === 1) {\n    return candidates[0].descriptor.id;\n  }\n  return getFurthestAway({\n    pageBorderBox,\n    draggable,\n    candidates\n  });\n}\n\nconst offsetRectByPosition = (rect, point) => (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)(offsetByPosition(rect, point));\n\nvar withDroppableScroll = (droppable, area) => {\n  const frame = droppable.frame;\n  if (!frame) {\n    return area;\n  }\n  return offsetRectByPosition(area, frame.scroll.diff.value);\n};\n\nfunction getIsDisplaced({\n  displaced,\n  id\n}) {\n  return Boolean(displaced.visible[id] || displaced.invisible[id]);\n}\n\nfunction atIndex({\n  draggable,\n  closest,\n  inHomeList\n}) {\n  if (!closest) {\n    return null;\n  }\n  if (!inHomeList) {\n    return closest.descriptor.index;\n  }\n  if (closest.descriptor.index > draggable.descriptor.index) {\n    return closest.descriptor.index - 1;\n  }\n  return closest.descriptor.index;\n}\nvar getReorderImpact = ({\n  pageBorderBoxWithDroppableScroll: targetRect,\n  draggable,\n  destination,\n  insideDestination,\n  last,\n  viewport,\n  afterCritical\n}) => {\n  const axis = destination.axis;\n  const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n  const displacement = displacedBy.value;\n  const targetStart = targetRect[axis.start];\n  const targetEnd = targetRect[axis.end];\n  const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n  const closest = withoutDragging.find(child => {\n    const id = child.descriptor.id;\n    const childCenter = child.page.borderBox.center[axis.line];\n    const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n    const isDisplaced = getIsDisplaced({\n      displaced: last,\n      id\n    });\n    if (didStartAfterCritical$1) {\n      if (isDisplaced) {\n        return targetEnd <= childCenter;\n      }\n      return targetStart < childCenter - displacement;\n    }\n    if (isDisplaced) {\n      return targetEnd <= childCenter + displacement;\n    }\n    return targetStart < childCenter;\n  }) || null;\n  const newIndex = atIndex({\n    draggable,\n    closest,\n    inHomeList: isHomeOf(draggable, destination)\n  });\n  return calculateReorderImpact({\n    draggable,\n    insideDestination,\n    destination,\n    viewport,\n    last,\n    displacedBy,\n    index: newIndex\n  });\n};\n\nconst combineThresholdDivisor = 4;\nvar getCombineImpact = ({\n  draggable,\n  pageBorderBoxWithDroppableScroll: targetRect,\n  previousImpact,\n  destination,\n  insideDestination,\n  afterCritical\n}) => {\n  if (!destination.isCombineEnabled) {\n    return null;\n  }\n  const axis = destination.axis;\n  const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n  const displacement = displacedBy.value;\n  const targetStart = targetRect[axis.start];\n  const targetEnd = targetRect[axis.end];\n  const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n  const combineWith = withoutDragging.find(child => {\n    const id = child.descriptor.id;\n    const childRect = child.page.borderBox;\n    const childSize = childRect[axis.size];\n    const threshold = childSize / combineThresholdDivisor;\n    const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n    const isDisplaced = getIsDisplaced({\n      displaced: previousImpact.displaced,\n      id\n    });\n    if (didStartAfterCritical$1) {\n      if (isDisplaced) {\n        return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;\n      }\n      return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;\n    }\n    if (isDisplaced) {\n      return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;\n    }\n    return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;\n  });\n  if (!combineWith) {\n    return null;\n  }\n  const impact = {\n    displacedBy,\n    displaced: previousImpact.displaced,\n    at: {\n      type: 'COMBINE',\n      combine: {\n        draggableId: combineWith.descriptor.id,\n        droppableId: destination.descriptor.id\n      }\n    }\n  };\n  return impact;\n};\n\nvar getDragImpact = ({\n  pageOffset,\n  draggable,\n  draggables,\n  droppables,\n  previousImpact,\n  viewport,\n  afterCritical\n}) => {\n  const pageBorderBox = offsetRectByPosition(draggable.page.borderBox, pageOffset);\n  const destinationId = getDroppableOver({\n    pageBorderBox,\n    draggable,\n    droppables\n  });\n  if (!destinationId) {\n    return noImpact;\n  }\n  const destination = droppables[destinationId];\n  const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n  const pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);\n  return getCombineImpact({\n    pageBorderBoxWithDroppableScroll,\n    draggable,\n    previousImpact,\n    destination,\n    insideDestination,\n    afterCritical\n  }) || getReorderImpact({\n    pageBorderBoxWithDroppableScroll,\n    draggable,\n    destination,\n    insideDestination,\n    last: previousImpact.displaced,\n    viewport,\n    afterCritical\n  });\n};\n\nvar patchDroppableMap = (droppables, updated) => ({\n  ...droppables,\n  [updated.descriptor.id]: updated\n});\n\nconst clearUnusedPlaceholder = ({\n  previousImpact,\n  impact,\n  droppables\n}) => {\n  const last = whatIsDraggedOver(previousImpact);\n  const now = whatIsDraggedOver(impact);\n  if (!last) {\n    return droppables;\n  }\n  if (last === now) {\n    return droppables;\n  }\n  const lastDroppable = droppables[last];\n  if (!lastDroppable.subject.withPlaceholder) {\n    return droppables;\n  }\n  const updated = removePlaceholder(lastDroppable);\n  return patchDroppableMap(droppables, updated);\n};\nvar recomputePlaceholders = ({\n  draggable,\n  draggables,\n  droppables,\n  previousImpact,\n  impact\n}) => {\n  const cleaned = clearUnusedPlaceholder({\n    previousImpact,\n    impact,\n    droppables\n  });\n  const isOver = whatIsDraggedOver(impact);\n  if (!isOver) {\n    return cleaned;\n  }\n  const droppable = droppables[isOver];\n  if (isHomeOf(draggable, droppable)) {\n    return cleaned;\n  }\n  if (droppable.subject.withPlaceholder) {\n    return cleaned;\n  }\n  const patched = addPlaceholder(droppable, draggable, draggables);\n  return patchDroppableMap(cleaned, patched);\n};\n\nvar update = ({\n  state,\n  clientSelection: forcedClientSelection,\n  dimensions: forcedDimensions,\n  viewport: forcedViewport,\n  impact: forcedImpact,\n  scrollJumpRequest\n}) => {\n  const viewport = forcedViewport || state.viewport;\n  const dimensions = forcedDimensions || state.dimensions;\n  const clientSelection = forcedClientSelection || state.current.client.selection;\n  const offset = subtract(clientSelection, state.initial.client.selection);\n  const client = {\n    offset,\n    selection: clientSelection,\n    borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)\n  };\n  const page = {\n    selection: add(client.selection, viewport.scroll.current),\n    borderBoxCenter: add(client.borderBoxCenter, viewport.scroll.current),\n    offset: add(client.offset, viewport.scroll.diff.value)\n  };\n  const current = {\n    client,\n    page\n  };\n  if (state.phase === 'COLLECTING') {\n    return {\n      ...state,\n      dimensions,\n      viewport,\n      current\n    };\n  }\n  const draggable = dimensions.draggables[state.critical.draggable.id];\n  const newImpact = forcedImpact || getDragImpact({\n    pageOffset: page.offset,\n    draggable,\n    draggables: dimensions.draggables,\n    droppables: dimensions.droppables,\n    previousImpact: state.impact,\n    viewport,\n    afterCritical: state.afterCritical\n  });\n  const withUpdatedPlaceholders = recomputePlaceholders({\n    draggable,\n    impact: newImpact,\n    previousImpact: state.impact,\n    draggables: dimensions.draggables,\n    droppables: dimensions.droppables\n  });\n  const result = {\n    ...state,\n    current,\n    dimensions: {\n      draggables: dimensions.draggables,\n      droppables: withUpdatedPlaceholders\n    },\n    impact: newImpact,\n    viewport,\n    scrollJumpRequest: scrollJumpRequest || null,\n    forceShouldAnimate: scrollJumpRequest ? false : null\n  };\n  return result;\n};\n\nfunction getDraggables(ids, draggables) {\n  return ids.map(id => draggables[id]);\n}\nvar recompute = ({\n  impact,\n  viewport,\n  draggables,\n  destination,\n  forceShouldAnimate\n}) => {\n  const last = impact.displaced;\n  const afterDragging = getDraggables(last.all, draggables);\n  const displaced = getDisplacementGroups({\n    afterDragging,\n    destination,\n    displacedBy: impact.displacedBy,\n    viewport: viewport.frame,\n    forceShouldAnimate,\n    last\n  });\n  return {\n    ...impact,\n    displaced\n  };\n};\n\nvar getClientBorderBoxCenter = ({\n  impact,\n  draggable,\n  droppable,\n  draggables,\n  viewport,\n  afterCritical\n}) => {\n  const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n    impact,\n    draggable,\n    draggables,\n    droppable,\n    afterCritical\n  });\n  return getClientFromPageBorderBoxCenter({\n    pageBorderBoxCenter,\n    draggable,\n    viewport\n  });\n};\n\nvar refreshSnap = ({\n  state,\n  dimensions: forcedDimensions,\n  viewport: forcedViewport\n}) => {\n  !(state.movementMode === 'SNAP') ?  true ? invariant() : 0 : void 0;\n  const needsVisibilityCheck = state.impact;\n  const viewport = forcedViewport || state.viewport;\n  const dimensions = forcedDimensions || state.dimensions;\n  const {\n    draggables,\n    droppables\n  } = dimensions;\n  const draggable = draggables[state.critical.draggable.id];\n  const isOver = whatIsDraggedOver(needsVisibilityCheck);\n  !isOver ?  true ? invariant(false, 'Must be over a destination in SNAP movement mode') : 0 : void 0;\n  const destination = droppables[isOver];\n  const impact = recompute({\n    impact: needsVisibilityCheck,\n    viewport,\n    destination,\n    draggables\n  });\n  const clientSelection = getClientBorderBoxCenter({\n    impact,\n    draggable,\n    droppable: destination,\n    draggables,\n    viewport,\n    afterCritical: state.afterCritical\n  });\n  return update({\n    impact,\n    clientSelection,\n    state,\n    dimensions,\n    viewport\n  });\n};\n\nvar getHomeLocation = descriptor => ({\n  index: descriptor.index,\n  droppableId: descriptor.droppableId\n});\n\nvar getLiftEffect = ({\n  draggable,\n  home,\n  draggables,\n  viewport\n}) => {\n  const displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);\n  const insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);\n  const rawIndex = insideHome.indexOf(draggable);\n  !(rawIndex !== -1) ?  true ? invariant(false, 'Expected draggable to be inside home list') : 0 : void 0;\n  const afterDragging = insideHome.slice(rawIndex + 1);\n  const effected = afterDragging.reduce((previous, item) => {\n    previous[item.descriptor.id] = true;\n    return previous;\n  }, {});\n  const afterCritical = {\n    inVirtualList: home.descriptor.mode === 'virtual',\n    displacedBy,\n    effected\n  };\n  const displaced = getDisplacementGroups({\n    afterDragging,\n    destination: home,\n    displacedBy,\n    last: null,\n    viewport: viewport.frame,\n    forceShouldAnimate: false\n  });\n  const impact = {\n    displaced,\n    displacedBy,\n    at: {\n      type: 'REORDER',\n      destination: getHomeLocation(draggable.descriptor)\n    }\n  };\n  return {\n    impact,\n    afterCritical\n  };\n};\n\nvar patchDimensionMap = (dimensions, updated) => ({\n  draggables: dimensions.draggables,\n  droppables: patchDroppableMap(dimensions.droppables, updated)\n});\n\nconst start = key => {\n  if (true) {\n    {\n      return;\n    }\n  }\n};\nconst finish = key => {\n  if (true) {\n    {\n      return;\n    }\n  }\n};\n\nvar offsetDraggable = ({\n  draggable,\n  offset: offset$1,\n  initialWindowScroll\n}) => {\n  const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.offset)(draggable.client, offset$1);\n  const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(client, initialWindowScroll);\n  const moved = {\n    ...draggable,\n    placeholder: {\n      ...draggable.placeholder,\n      client\n    },\n    client,\n    page\n  };\n  return moved;\n};\n\nvar getFrame = droppable => {\n  const frame = droppable.frame;\n  !frame ?  true ? invariant(false, 'Expected Droppable to have a frame') : 0 : void 0;\n  return frame;\n};\n\nvar adjustAdditionsForScrollChanges = ({\n  additions,\n  updatedDroppables,\n  viewport\n}) => {\n  const windowScrollChange = viewport.scroll.diff.value;\n  return additions.map(draggable => {\n    const droppableId = draggable.descriptor.droppableId;\n    const modified = updatedDroppables[droppableId];\n    const frame = getFrame(modified);\n    const droppableScrollChange = frame.scroll.diff.value;\n    const totalChange = add(windowScrollChange, droppableScrollChange);\n    const moved = offsetDraggable({\n      draggable,\n      offset: totalChange,\n      initialWindowScroll: viewport.scroll.initial\n    });\n    return moved;\n  });\n};\n\nvar publishWhileDraggingInVirtual = ({\n  state,\n  published\n}) => {\n  start();\n  const withScrollChange = published.modified.map(update => {\n    const existing = state.dimensions.droppables[update.droppableId];\n    const scrolled = scrollDroppable(existing, update.scroll);\n    return scrolled;\n  });\n  const droppables = {\n    ...state.dimensions.droppables,\n    ...toDroppableMap(withScrollChange)\n  };\n  const updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({\n    additions: published.additions,\n    updatedDroppables: droppables,\n    viewport: state.viewport\n  }));\n  const draggables = {\n    ...state.dimensions.draggables,\n    ...updatedAdditions\n  };\n  published.removals.forEach(id => {\n    delete draggables[id];\n  });\n  const dimensions = {\n    droppables,\n    draggables\n  };\n  const wasOverId = whatIsDraggedOver(state.impact);\n  const wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;\n  const draggable = dimensions.draggables[state.critical.draggable.id];\n  const home = dimensions.droppables[state.critical.droppable.id];\n  const {\n    impact: onLiftImpact,\n    afterCritical\n  } = getLiftEffect({\n    draggable,\n    home,\n    draggables,\n    viewport: state.viewport\n  });\n  const previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;\n  const impact = getDragImpact({\n    pageOffset: state.current.page.offset,\n    draggable: dimensions.draggables[state.critical.draggable.id],\n    draggables: dimensions.draggables,\n    droppables: dimensions.droppables,\n    previousImpact,\n    viewport: state.viewport,\n    afterCritical\n  });\n  finish();\n  const draggingState = {\n    ...state,\n    phase: 'DRAGGING',\n    impact,\n    onLiftImpact,\n    dimensions,\n    afterCritical,\n    forceShouldAnimate: false\n  };\n  if (state.phase === 'COLLECTING') {\n    return draggingState;\n  }\n  const dropPending = {\n    ...draggingState,\n    phase: 'DROP_PENDING',\n    reason: state.reason,\n    isWaiting: false\n  };\n  return dropPending;\n};\n\nconst isSnapping = state => state.movementMode === 'SNAP';\nconst postDroppableChange = (state, updated, isEnabledChanging) => {\n  const dimensions = patchDimensionMap(state.dimensions, updated);\n  if (!isSnapping(state) || isEnabledChanging) {\n    return update({\n      state,\n      dimensions\n    });\n  }\n  return refreshSnap({\n    state,\n    dimensions\n  });\n};\nfunction removeScrollJumpRequest(state) {\n  if (state.isDragging && state.movementMode === 'SNAP') {\n    return {\n      ...state,\n      scrollJumpRequest: null\n    };\n  }\n  return state;\n}\nconst idle$2 = {\n  phase: 'IDLE',\n  completed: null,\n  shouldFlush: false\n};\nvar reducer = (state = idle$2, action) => {\n  if (action.type === 'FLUSH') {\n    return {\n      ...idle$2,\n      shouldFlush: true\n    };\n  }\n  if (action.type === 'INITIAL_PUBLISH') {\n    !(state.phase === 'IDLE') ?  true ? invariant(false, 'INITIAL_PUBLISH must come after a IDLE phase') : 0 : void 0;\n    const {\n      critical,\n      clientSelection,\n      viewport,\n      dimensions,\n      movementMode\n    } = action.payload;\n    const draggable = dimensions.draggables[critical.draggable.id];\n    const home = dimensions.droppables[critical.droppable.id];\n    const client = {\n      selection: clientSelection,\n      borderBoxCenter: draggable.client.borderBox.center,\n      offset: origin\n    };\n    const initial = {\n      client,\n      page: {\n        selection: add(client.selection, viewport.scroll.initial),\n        borderBoxCenter: add(client.selection, viewport.scroll.initial),\n        offset: add(client.selection, viewport.scroll.diff.value)\n      }\n    };\n    const isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(item => !item.isFixedOnPage);\n    const {\n      impact,\n      afterCritical\n    } = getLiftEffect({\n      draggable,\n      home,\n      draggables: dimensions.draggables,\n      viewport\n    });\n    const result = {\n      phase: 'DRAGGING',\n      isDragging: true,\n      critical,\n      movementMode,\n      dimensions,\n      initial,\n      current: initial,\n      isWindowScrollAllowed,\n      impact,\n      afterCritical,\n      onLiftImpact: impact,\n      viewport,\n      scrollJumpRequest: null,\n      forceShouldAnimate: null\n    };\n    return result;\n  }\n  if (action.type === 'COLLECTION_STARTING') {\n    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {\n      return state;\n    }\n    !(state.phase === 'DRAGGING') ?  true ? invariant(false, `Collection cannot start from phase ${state.phase}`) : 0 : void 0;\n    const result = {\n      ...state,\n      phase: 'COLLECTING'\n    };\n    return result;\n  }\n  if (action.type === 'PUBLISH_WHILE_DRAGGING') {\n    !(state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') ?  true ? invariant(false, `Unexpected ${action.type} received in phase ${state.phase}`) : 0 : void 0;\n    return publishWhileDraggingInVirtual({\n      state,\n      published: action.payload\n    });\n  }\n  if (action.type === 'MOVE') {\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n    !isMovementAllowed(state) ?  true ? invariant(false, `${action.type} not permitted in phase ${state.phase}`) : 0 : void 0;\n    const {\n      client: clientSelection\n    } = action.payload;\n    if (isEqual$1(clientSelection, state.current.client.selection)) {\n      return state;\n    }\n    return update({\n      state,\n      clientSelection,\n      impact: isSnapping(state) ? state.impact : null\n    });\n  }\n  if (action.type === 'UPDATE_DROPPABLE_SCROLL') {\n    if (state.phase === 'DROP_PENDING') {\n      return removeScrollJumpRequest(state);\n    }\n    if (state.phase === 'COLLECTING') {\n      return removeScrollJumpRequest(state);\n    }\n    !isMovementAllowed(state) ?  true ? invariant(false, `${action.type} not permitted in phase ${state.phase}`) : 0 : void 0;\n    const {\n      id,\n      newScroll\n    } = action.payload;\n    const target = state.dimensions.droppables[id];\n    if (!target) {\n      return state;\n    }\n    const scrolled = scrollDroppable(target, newScroll);\n    return postDroppableChange(state, scrolled, false);\n  }\n  if (action.type === 'UPDATE_DROPPABLE_IS_ENABLED') {\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n    !isMovementAllowed(state) ?  true ? invariant(false, `Attempting to move in an unsupported phase ${state.phase}`) : 0 : void 0;\n    const {\n      id,\n      isEnabled\n    } = action.payload;\n    const target = state.dimensions.droppables[id];\n    !target ?  true ? invariant(false, `Cannot find Droppable[id: ${id}] to toggle its enabled state`) : 0 : void 0;\n    !(target.isEnabled !== isEnabled) ?  true ? invariant(false, `Trying to set droppable isEnabled to ${String(isEnabled)}\n      but it is already ${String(target.isEnabled)}`) : 0 : void 0;\n    const updated = {\n      ...target,\n      isEnabled\n    };\n    return postDroppableChange(state, updated, true);\n  }\n  if (action.type === 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED') {\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n    !isMovementAllowed(state) ?  true ? invariant(false, `Attempting to move in an unsupported phase ${state.phase}`) : 0 : void 0;\n    const {\n      id,\n      isCombineEnabled\n    } = action.payload;\n    const target = state.dimensions.droppables[id];\n    !target ?  true ? invariant(false, `Cannot find Droppable[id: ${id}] to toggle its isCombineEnabled state`) : 0 : void 0;\n    !(target.isCombineEnabled !== isCombineEnabled) ?  true ? invariant(false, `Trying to set droppable isCombineEnabled to ${String(isCombineEnabled)}\n      but it is already ${String(target.isCombineEnabled)}`) : 0 : void 0;\n    const updated = {\n      ...target,\n      isCombineEnabled\n    };\n    return postDroppableChange(state, updated, true);\n  }\n  if (action.type === 'MOVE_BY_WINDOW_SCROLL') {\n    if (state.phase === 'DROP_PENDING' || state.phase === 'DROP_ANIMATING') {\n      return state;\n    }\n    !isMovementAllowed(state) ?  true ? invariant(false, `Cannot move by window in phase ${state.phase}`) : 0 : void 0;\n    !state.isWindowScrollAllowed ?  true ? invariant(false, 'Window scrolling is currently not supported for fixed lists') : 0 : void 0;\n    const newScroll = action.payload.newScroll;\n    if (isEqual$1(state.viewport.scroll.current, newScroll)) {\n      return removeScrollJumpRequest(state);\n    }\n    const viewport = scrollViewport(state.viewport, newScroll);\n    if (isSnapping(state)) {\n      return refreshSnap({\n        state,\n        viewport\n      });\n    }\n    return update({\n      state,\n      viewport\n    });\n  }\n  if (action.type === 'UPDATE_VIEWPORT_MAX_SCROLL') {\n    if (!isMovementAllowed(state)) {\n      return state;\n    }\n    const maxScroll = action.payload.maxScroll;\n    if (isEqual$1(maxScroll, state.viewport.scroll.max)) {\n      return state;\n    }\n    const withMaxScroll = {\n      ...state.viewport,\n      scroll: {\n        ...state.viewport.scroll,\n        max: maxScroll\n      }\n    };\n    return {\n      ...state,\n      viewport: withMaxScroll\n    };\n  }\n  if (action.type === 'MOVE_UP' || action.type === 'MOVE_DOWN' || action.type === 'MOVE_LEFT' || action.type === 'MOVE_RIGHT') {\n    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {\n      return state;\n    }\n    !(state.phase === 'DRAGGING') ?  true ? invariant(false, `${action.type} received while not in DRAGGING phase`) : 0 : void 0;\n    const result = moveInDirection({\n      state,\n      type: action.type\n    });\n    if (!result) {\n      return state;\n    }\n    return update({\n      state,\n      impact: result.impact,\n      clientSelection: result.clientSelection,\n      scrollJumpRequest: result.scrollJumpRequest\n    });\n  }\n  if (action.type === 'DROP_PENDING') {\n    const reason = action.payload.reason;\n    !(state.phase === 'COLLECTING') ?  true ? invariant(false, 'Can only move into the DROP_PENDING phase from the COLLECTING phase') : 0 : void 0;\n    const newState = {\n      ...state,\n      phase: 'DROP_PENDING',\n      isWaiting: true,\n      reason\n    };\n    return newState;\n  }\n  if (action.type === 'DROP_ANIMATE') {\n    const {\n      completed,\n      dropDuration,\n      newHomeClientOffset\n    } = action.payload;\n    !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ?  true ? invariant(false, `Cannot animate drop from phase ${state.phase}`) : 0 : void 0;\n    const result = {\n      phase: 'DROP_ANIMATING',\n      completed,\n      dropDuration,\n      newHomeClientOffset,\n      dimensions: state.dimensions\n    };\n    return result;\n  }\n  if (action.type === 'DROP_COMPLETE') {\n    const {\n      completed\n    } = action.payload;\n    return {\n      phase: 'IDLE',\n      completed,\n      shouldFlush: false\n    };\n  }\n  return state;\n};\n\nfunction guard(action, predicate) {\n  return action instanceof Object && 'type' in action && action.type === predicate;\n}\nconst beforeInitialCapture = args => ({\n  type: 'BEFORE_INITIAL_CAPTURE',\n  payload: args\n});\nconst lift$1 = args => ({\n  type: 'LIFT',\n  payload: args\n});\nconst initialPublish = args => ({\n  type: 'INITIAL_PUBLISH',\n  payload: args\n});\nconst publishWhileDragging = args => ({\n  type: 'PUBLISH_WHILE_DRAGGING',\n  payload: args\n});\nconst collectionStarting = () => ({\n  type: 'COLLECTION_STARTING',\n  payload: null\n});\nconst updateDroppableScroll = args => ({\n  type: 'UPDATE_DROPPABLE_SCROLL',\n  payload: args\n});\nconst updateDroppableIsEnabled = args => ({\n  type: 'UPDATE_DROPPABLE_IS_ENABLED',\n  payload: args\n});\nconst updateDroppableIsCombineEnabled = args => ({\n  type: 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED',\n  payload: args\n});\nconst move = args => ({\n  type: 'MOVE',\n  payload: args\n});\nconst moveByWindowScroll = args => ({\n  type: 'MOVE_BY_WINDOW_SCROLL',\n  payload: args\n});\nconst updateViewportMaxScroll = args => ({\n  type: 'UPDATE_VIEWPORT_MAX_SCROLL',\n  payload: args\n});\nconst moveUp = () => ({\n  type: 'MOVE_UP',\n  payload: null\n});\nconst moveDown = () => ({\n  type: 'MOVE_DOWN',\n  payload: null\n});\nconst moveRight = () => ({\n  type: 'MOVE_RIGHT',\n  payload: null\n});\nconst moveLeft = () => ({\n  type: 'MOVE_LEFT',\n  payload: null\n});\nconst flush = () => ({\n  type: 'FLUSH',\n  payload: null\n});\nconst animateDrop = args => ({\n  type: 'DROP_ANIMATE',\n  payload: args\n});\nconst completeDrop = args => ({\n  type: 'DROP_COMPLETE',\n  payload: args\n});\nconst drop = args => ({\n  type: 'DROP',\n  payload: args\n});\nconst dropPending = args => ({\n  type: 'DROP_PENDING',\n  payload: args\n});\nconst dropAnimationFinished = () => ({\n  type: 'DROP_ANIMATION_FINISHED',\n  payload: null\n});\n\nfunction checkIndexes(insideDestination) {\n  if (insideDestination.length <= 1) {\n    return;\n  }\n  const indexes = insideDestination.map(d => d.descriptor.index);\n  const errors = {};\n  for (let i = 1; i < indexes.length; i++) {\n    const current = indexes[i];\n    const previous = indexes[i - 1];\n    if (current !== previous + 1) {\n      errors[current] = true;\n    }\n  }\n  if (!Object.keys(errors).length) {\n    return;\n  }\n  const formatted = indexes.map(index => {\n    const hasError = Boolean(errors[index]);\n    return hasError ? `[🔥${index}]` : `${index}`;\n  }).join(', ');\n   true ? warning(`\n    Detected non-consecutive <Draggable /> indexes.\n\n    (This can cause unexpected bugs)\n\n    ${formatted}\n  `) : 0;\n}\nfunction validateDimensions(critical, dimensions) {\n  if (true) {\n    const insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);\n    checkIndexes(insideDestination);\n  }\n}\n\nvar lift = marshal => ({\n  getState,\n  dispatch\n}) => next => action => {\n  if (!guard(action, 'LIFT')) {\n    next(action);\n    return;\n  }\n  const {\n    id,\n    clientSelection,\n    movementMode\n  } = action.payload;\n  const initial = getState();\n  if (initial.phase === 'DROP_ANIMATING') {\n    dispatch(completeDrop({\n      completed: initial.completed\n    }));\n  }\n  !(getState().phase === 'IDLE') ?  true ? invariant(false, 'Unexpected phase to start a drag') : 0 : void 0;\n  dispatch(flush());\n  dispatch(beforeInitialCapture({\n    draggableId: id,\n    movementMode\n  }));\n  const scrollOptions = {\n    shouldPublishImmediately: movementMode === 'SNAP'\n  };\n  const request = {\n    draggableId: id,\n    scrollOptions\n  };\n  const {\n    critical,\n    dimensions,\n    viewport\n  } = marshal.startPublishing(request);\n  validateDimensions(critical, dimensions);\n  dispatch(initialPublish({\n    critical,\n    dimensions,\n    clientSelection,\n    movementMode,\n    viewport\n  }));\n};\n\nvar style = marshal => () => next => action => {\n  if (guard(action, 'INITIAL_PUBLISH')) {\n    marshal.dragging();\n  }\n  if (guard(action, 'DROP_ANIMATE')) {\n    marshal.dropping(action.payload.completed.result.reason);\n  }\n  if (guard(action, 'FLUSH') || guard(action, 'DROP_COMPLETE')) {\n    marshal.resting();\n  }\n  next(action);\n};\n\nconst curves = {\n  outOfTheWay: 'cubic-bezier(0.2, 0, 0, 1)',\n  drop: 'cubic-bezier(.2,1,.1,1)'\n};\nconst combine = {\n  opacity: {\n    drop: 0,\n    combining: 0.7\n  },\n  scale: {\n    drop: 0.75\n  }\n};\nconst timings = {\n  outOfTheWay: 0.2,\n  minDropTime: 0.33,\n  maxDropTime: 0.55\n};\nconst outOfTheWayTiming = `${timings.outOfTheWay}s ${curves.outOfTheWay}`;\nconst transitions = {\n  fluid: `opacity ${outOfTheWayTiming}`,\n  snap: `transform ${outOfTheWayTiming}, opacity ${outOfTheWayTiming}`,\n  drop: duration => {\n    const timing = `${duration}s ${curves.drop}`;\n    return `transform ${timing}, opacity ${timing}`;\n  },\n  outOfTheWay: `transform ${outOfTheWayTiming}`,\n  placeholder: `height ${outOfTheWayTiming}, width ${outOfTheWayTiming}, margin ${outOfTheWayTiming}`\n};\nconst moveTo = offset => isEqual$1(offset, origin) ? undefined : `translate(${offset.x}px, ${offset.y}px)`;\nconst transforms = {\n  moveTo,\n  drop: (offset, isCombining) => {\n    const translate = moveTo(offset);\n    if (!translate) {\n      return undefined;\n    }\n    if (!isCombining) {\n      return translate;\n    }\n    return `${translate} scale(${combine.scale.drop})`;\n  }\n};\n\nconst {\n  minDropTime,\n  maxDropTime\n} = timings;\nconst dropTimeRange = maxDropTime - minDropTime;\nconst maxDropTimeAtDistance = 1500;\nconst cancelDropModifier = 0.6;\nvar getDropDuration = ({\n  current,\n  destination,\n  reason\n}) => {\n  const distance$1 = distance(current, destination);\n  if (distance$1 <= 0) {\n    return minDropTime;\n  }\n  if (distance$1 >= maxDropTimeAtDistance) {\n    return maxDropTime;\n  }\n  const percentage = distance$1 / maxDropTimeAtDistance;\n  const duration = minDropTime + dropTimeRange * percentage;\n  const withDuration = reason === 'CANCEL' ? duration * cancelDropModifier : duration;\n  return Number(withDuration.toFixed(2));\n};\n\nvar getNewHomeClientOffset = ({\n  impact,\n  draggable,\n  dimensions,\n  viewport,\n  afterCritical\n}) => {\n  const {\n    draggables,\n    droppables\n  } = dimensions;\n  const droppableId = whatIsDraggedOver(impact);\n  const destination = droppableId ? droppables[droppableId] : null;\n  const home = droppables[draggable.descriptor.droppableId];\n  const newClientCenter = getClientBorderBoxCenter({\n    impact,\n    draggable,\n    draggables,\n    afterCritical,\n    droppable: destination || home,\n    viewport\n  });\n  const offset = subtract(newClientCenter, draggable.client.borderBox.center);\n  return offset;\n};\n\nvar getDropImpact = ({\n  draggables,\n  reason,\n  lastImpact,\n  home,\n  viewport,\n  onLiftImpact\n}) => {\n  if (!lastImpact.at || reason !== 'DROP') {\n    const recomputedHomeImpact = recompute({\n      draggables,\n      impact: onLiftImpact,\n      destination: home,\n      viewport,\n      forceShouldAnimate: true\n    });\n    return {\n      impact: recomputedHomeImpact,\n      didDropInsideDroppable: false\n    };\n  }\n  if (lastImpact.at.type === 'REORDER') {\n    return {\n      impact: lastImpact,\n      didDropInsideDroppable: true\n    };\n  }\n  const withoutMovement = {\n    ...lastImpact,\n    displaced: emptyGroups\n  };\n  return {\n    impact: withoutMovement,\n    didDropInsideDroppable: true\n  };\n};\n\nconst dropMiddleware = ({\n  getState,\n  dispatch\n}) => next => action => {\n  if (!guard(action, 'DROP')) {\n    next(action);\n    return;\n  }\n  const state = getState();\n  const reason = action.payload.reason;\n  if (state.phase === 'COLLECTING') {\n    dispatch(dropPending({\n      reason\n    }));\n    return;\n  }\n  if (state.phase === 'IDLE') {\n    return;\n  }\n  const isWaitingForDrop = state.phase === 'DROP_PENDING' && state.isWaiting;\n  !!isWaitingForDrop ?  true ? invariant(false, 'A DROP action occurred while DROP_PENDING and still waiting') : 0 : void 0;\n  !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ?  true ? invariant(false, `Cannot drop in phase: ${state.phase}`) : 0 : void 0;\n  const critical = state.critical;\n  const dimensions = state.dimensions;\n  const draggable = dimensions.draggables[state.critical.draggable.id];\n  const {\n    impact,\n    didDropInsideDroppable\n  } = getDropImpact({\n    reason,\n    lastImpact: state.impact,\n    afterCritical: state.afterCritical,\n    onLiftImpact: state.onLiftImpact,\n    home: state.dimensions.droppables[state.critical.droppable.id],\n    viewport: state.viewport,\n    draggables: state.dimensions.draggables\n  });\n  const destination = didDropInsideDroppable ? tryGetDestination(impact) : null;\n  const combine = didDropInsideDroppable ? tryGetCombine(impact) : null;\n  const source = {\n    index: critical.draggable.index,\n    droppableId: critical.droppable.id\n  };\n  const result = {\n    draggableId: draggable.descriptor.id,\n    type: draggable.descriptor.type,\n    source,\n    reason,\n    mode: state.movementMode,\n    destination,\n    combine\n  };\n  const newHomeClientOffset = getNewHomeClientOffset({\n    impact,\n    draggable,\n    dimensions,\n    viewport: state.viewport,\n    afterCritical: state.afterCritical\n  });\n  const completed = {\n    critical: state.critical,\n    afterCritical: state.afterCritical,\n    result,\n    impact\n  };\n  const isAnimationRequired = !isEqual$1(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);\n  if (!isAnimationRequired) {\n    dispatch(completeDrop({\n      completed\n    }));\n    return;\n  }\n  const dropDuration = getDropDuration({\n    current: state.current.client.offset,\n    destination: newHomeClientOffset,\n    reason\n  });\n  const args = {\n    newHomeClientOffset,\n    dropDuration,\n    completed\n  };\n  dispatch(animateDrop(args));\n};\n\nvar getWindowScroll = () => ({\n  x: window.pageXOffset,\n  y: window.pageYOffset\n});\n\nfunction getWindowScrollBinding(update) {\n  return {\n    eventName: 'scroll',\n    options: {\n      passive: true,\n      capture: false\n    },\n    fn: event => {\n      if (event.target !== window && event.target !== window.document) {\n        return;\n      }\n      update();\n    }\n  };\n}\nfunction getScrollListener({\n  onWindowScroll\n}) {\n  function updateScroll() {\n    onWindowScroll(getWindowScroll());\n  }\n  const scheduled = (0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(updateScroll);\n  const binding = getWindowScrollBinding(scheduled);\n  let unbind = noop$2;\n  function isActive() {\n    return unbind !== noop$2;\n  }\n  function start() {\n    !!isActive() ?  true ? invariant(false, 'Cannot start scroll listener when already active') : 0 : void 0;\n    unbind = bindEvents(window, [binding]);\n  }\n  function stop() {\n    !isActive() ?  true ? invariant(false, 'Cannot stop scroll listener when not active') : 0 : void 0;\n    scheduled.cancel();\n    unbind();\n    unbind = noop$2;\n  }\n  return {\n    start,\n    stop,\n    isActive\n  };\n}\n\nconst shouldStop$1 = action => guard(action, 'DROP_COMPLETE') || guard(action, 'DROP_ANIMATE') || guard(action, 'FLUSH');\nconst scrollListener = store => {\n  const listener = getScrollListener({\n    onWindowScroll: newScroll => {\n      store.dispatch(moveByWindowScroll({\n        newScroll\n      }));\n    }\n  });\n  return next => action => {\n    if (!listener.isActive() && guard(action, 'INITIAL_PUBLISH')) {\n      listener.start();\n    }\n    if (listener.isActive() && shouldStop$1(action)) {\n      listener.stop();\n    }\n    next(action);\n  };\n};\n\nvar getExpiringAnnounce = announce => {\n  let wasCalled = false;\n  let isExpired = false;\n  const timeoutId = setTimeout(() => {\n    isExpired = true;\n  });\n  const result = message => {\n    if (wasCalled) {\n       true ? warning('Announcement already made. Not making a second announcement') : 0;\n      return;\n    }\n    if (isExpired) {\n       true ? warning(`\n        Announcements cannot be made asynchronously.\n        Default message has already been announced.\n      `) : 0;\n      return;\n    }\n    wasCalled = true;\n    announce(message);\n    clearTimeout(timeoutId);\n  };\n  result.wasCalled = () => wasCalled;\n  return result;\n};\n\nvar getAsyncMarshal = () => {\n  const entries = [];\n  const execute = timerId => {\n    const index = entries.findIndex(item => item.timerId === timerId);\n    !(index !== -1) ?  true ? invariant(false, 'Could not find timer') : 0 : void 0;\n    const [entry] = entries.splice(index, 1);\n    entry.callback();\n  };\n  const add = fn => {\n    const timerId = setTimeout(() => execute(timerId));\n    const entry = {\n      timerId,\n      callback: fn\n    };\n    entries.push(entry);\n  };\n  const flush = () => {\n    if (!entries.length) {\n      return;\n    }\n    const shallow = [...entries];\n    entries.length = 0;\n    shallow.forEach(entry => {\n      clearTimeout(entry.timerId);\n      entry.callback();\n    });\n  };\n  return {\n    add,\n    flush\n  };\n};\n\nconst areLocationsEqual = (first, second) => {\n  if (first == null && second == null) {\n    return true;\n  }\n  if (first == null || second == null) {\n    return false;\n  }\n  return first.droppableId === second.droppableId && first.index === second.index;\n};\nconst isCombineEqual = (first, second) => {\n  if (first == null && second == null) {\n    return true;\n  }\n  if (first == null || second == null) {\n    return false;\n  }\n  return first.draggableId === second.draggableId && first.droppableId === second.droppableId;\n};\nconst isCriticalEqual = (first, second) => {\n  if (first === second) {\n    return true;\n  }\n  const isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;\n  const isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;\n  return isDraggableEqual && isDroppableEqual;\n};\n\nconst withTimings = (key, fn) => {\n  start();\n  fn();\n  finish();\n};\nconst getDragStart = (critical, mode) => ({\n  draggableId: critical.draggable.id,\n  type: critical.droppable.type,\n  source: {\n    droppableId: critical.droppable.id,\n    index: critical.draggable.index\n  },\n  mode\n});\nfunction execute(responder, data, announce, getDefaultMessage) {\n  if (!responder) {\n    announce(getDefaultMessage(data));\n    return;\n  }\n  const willExpire = getExpiringAnnounce(announce);\n  const provided = {\n    announce: willExpire\n  };\n  responder(data, provided);\n  if (!willExpire.wasCalled()) {\n    announce(getDefaultMessage(data));\n  }\n}\nvar getPublisher = (getResponders, announce) => {\n  const asyncMarshal = getAsyncMarshal();\n  let dragging = null;\n  const beforeCapture = (draggableId, mode) => {\n    !!dragging ?  true ? invariant(false, 'Cannot fire onBeforeCapture as a drag start has already been published') : 0 : void 0;\n    withTimings('onBeforeCapture', () => {\n      const fn = getResponders().onBeforeCapture;\n      if (fn) {\n        const before = {\n          draggableId,\n          mode\n        };\n        fn(before);\n      }\n    });\n  };\n  const beforeStart = (critical, mode) => {\n    !!dragging ?  true ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : 0 : void 0;\n    withTimings('onBeforeDragStart', () => {\n      const fn = getResponders().onBeforeDragStart;\n      if (fn) {\n        fn(getDragStart(critical, mode));\n      }\n    });\n  };\n  const start = (critical, mode) => {\n    !!dragging ?  true ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : 0 : void 0;\n    const data = getDragStart(critical, mode);\n    dragging = {\n      mode,\n      lastCritical: critical,\n      lastLocation: data.source,\n      lastCombine: null\n    };\n    asyncMarshal.add(() => {\n      withTimings('onDragStart', () => execute(getResponders().onDragStart, data, announce, preset.onDragStart));\n    });\n  };\n  const update = (critical, impact) => {\n    const location = tryGetDestination(impact);\n    const combine = tryGetCombine(impact);\n    !dragging ?  true ? invariant(false, 'Cannot fire onDragMove when onDragStart has not been called') : 0 : void 0;\n    const hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);\n    if (hasCriticalChanged) {\n      dragging.lastCritical = critical;\n    }\n    const hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);\n    if (hasLocationChanged) {\n      dragging.lastLocation = location;\n    }\n    const hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine);\n    if (hasGroupingChanged) {\n      dragging.lastCombine = combine;\n    }\n    if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {\n      return;\n    }\n    const data = {\n      ...getDragStart(critical, dragging.mode),\n      combine,\n      destination: location\n    };\n    asyncMarshal.add(() => {\n      withTimings('onDragUpdate', () => execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate));\n    });\n  };\n  const flush = () => {\n    !dragging ?  true ? invariant(false, 'Can only flush responders while dragging') : 0 : void 0;\n    asyncMarshal.flush();\n  };\n  const drop = result => {\n    !dragging ?  true ? invariant(false, 'Cannot fire onDragEnd when there is no matching onDragStart') : 0 : void 0;\n    dragging = null;\n    withTimings('onDragEnd', () => execute(getResponders().onDragEnd, result, announce, preset.onDragEnd));\n  };\n  const abort = () => {\n    if (!dragging) {\n      return;\n    }\n    const result = {\n      ...getDragStart(dragging.lastCritical, dragging.mode),\n      combine: null,\n      destination: null,\n      reason: 'CANCEL'\n    };\n    drop(result);\n  };\n  return {\n    beforeCapture,\n    beforeStart,\n    start,\n    update,\n    flush,\n    drop,\n    abort\n  };\n};\n\nvar responders = (getResponders, announce) => {\n  const publisher = getPublisher(getResponders, announce);\n  return store => next => action => {\n    if (guard(action, 'BEFORE_INITIAL_CAPTURE')) {\n      publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);\n      return;\n    }\n    if (guard(action, 'INITIAL_PUBLISH')) {\n      const critical = action.payload.critical;\n      publisher.beforeStart(critical, action.payload.movementMode);\n      next(action);\n      publisher.start(critical, action.payload.movementMode);\n      return;\n    }\n    if (guard(action, 'DROP_COMPLETE')) {\n      const result = action.payload.completed.result;\n      publisher.flush();\n      next(action);\n      publisher.drop(result);\n      return;\n    }\n    next(action);\n    if (guard(action, 'FLUSH')) {\n      publisher.abort();\n      return;\n    }\n    const state = store.getState();\n    if (state.phase === 'DRAGGING') {\n      publisher.update(state.critical, state.impact);\n    }\n  };\n};\n\nconst dropAnimationFinishMiddleware = store => next => action => {\n  if (!guard(action, 'DROP_ANIMATION_FINISHED')) {\n    next(action);\n    return;\n  }\n  const state = store.getState();\n  !(state.phase === 'DROP_ANIMATING') ?  true ? invariant(false, 'Cannot finish a drop animating when no drop is occurring') : 0 : void 0;\n  store.dispatch(completeDrop({\n    completed: state.completed\n  }));\n};\n\nconst dropAnimationFlushOnScrollMiddleware = store => {\n  let unbind = null;\n  let frameId = null;\n  function clear() {\n    if (frameId) {\n      cancelAnimationFrame(frameId);\n      frameId = null;\n    }\n    if (unbind) {\n      unbind();\n      unbind = null;\n    }\n  }\n  return next => action => {\n    if (guard(action, 'FLUSH') || guard(action, 'DROP_COMPLETE') || guard(action, 'DROP_ANIMATION_FINISHED')) {\n      clear();\n    }\n    next(action);\n    if (!guard(action, 'DROP_ANIMATE')) {\n      return;\n    }\n    const binding = {\n      eventName: 'scroll',\n      options: {\n        capture: true,\n        passive: false,\n        once: true\n      },\n      fn: function flushDropAnimation() {\n        const state = store.getState();\n        if (state.phase === 'DROP_ANIMATING') {\n          store.dispatch(dropAnimationFinished());\n        }\n      }\n    };\n    frameId = requestAnimationFrame(() => {\n      frameId = null;\n      unbind = bindEvents(window, [binding]);\n    });\n  };\n};\n\nvar dimensionMarshalStopper = marshal => () => next => action => {\n  if (guard(action, 'DROP_COMPLETE') || guard(action, 'FLUSH') || guard(action, 'DROP_ANIMATE')) {\n    marshal.stopPublishing();\n  }\n  next(action);\n};\n\nvar focus = marshal => {\n  let isWatching = false;\n  return () => next => action => {\n    if (guard(action, 'INITIAL_PUBLISH')) {\n      isWatching = true;\n      marshal.tryRecordFocus(action.payload.critical.draggable.id);\n      next(action);\n      marshal.tryRestoreFocusRecorded();\n      return;\n    }\n    next(action);\n    if (!isWatching) {\n      return;\n    }\n    if (guard(action, 'FLUSH')) {\n      isWatching = false;\n      marshal.tryRestoreFocusRecorded();\n      return;\n    }\n    if (guard(action, 'DROP_COMPLETE')) {\n      isWatching = false;\n      const result = action.payload.completed.result;\n      if (result.combine) {\n        marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);\n      }\n      marshal.tryRestoreFocusRecorded();\n    }\n  };\n};\n\nconst shouldStop = action => guard(action, 'DROP_COMPLETE') || guard(action, 'DROP_ANIMATE') || guard(action, 'FLUSH');\nvar autoScroll = autoScroller => store => next => action => {\n  if (shouldStop(action)) {\n    autoScroller.stop();\n    next(action);\n    return;\n  }\n  if (guard(action, 'INITIAL_PUBLISH')) {\n    next(action);\n    const state = store.getState();\n    !(state.phase === 'DRAGGING') ?  true ? invariant(false, 'Expected phase to be DRAGGING after INITIAL_PUBLISH') : 0 : void 0;\n    autoScroller.start(state);\n    return;\n  }\n  next(action);\n  autoScroller.scroll(store.getState());\n};\n\nconst pendingDrop = store => next => action => {\n  next(action);\n  if (!guard(action, 'PUBLISH_WHILE_DRAGGING')) {\n    return;\n  }\n  const postActionState = store.getState();\n  if (postActionState.phase !== 'DROP_PENDING') {\n    return;\n  }\n  if (postActionState.isWaiting) {\n    return;\n  }\n  store.dispatch(drop({\n    reason: postActionState.reason\n  }));\n};\n\nconst composeEnhancers =  true && typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({\n  name: '@hello-pangea/dnd'\n}) : redux__WEBPACK_IMPORTED_MODULE_5__.compose;\nvar createStore = ({\n  dimensionMarshal,\n  focusMarshal,\n  styleMarshal,\n  getResponders,\n  announce,\n  autoScroller\n}) => (0,redux__WEBPACK_IMPORTED_MODULE_5__.createStore)(reducer, composeEnhancers((0,redux__WEBPACK_IMPORTED_MODULE_5__.applyMiddleware)(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift(dimensionMarshal), dropMiddleware, dropAnimationFinishMiddleware, dropAnimationFlushOnScrollMiddleware, pendingDrop, autoScroll(autoScroller), scrollListener, focus(focusMarshal), responders(getResponders, announce))));\n\nconst clean$1 = () => ({\n  additions: {},\n  removals: {},\n  modified: {}\n});\nfunction createPublisher({\n  registry,\n  callbacks\n}) {\n  let staging = clean$1();\n  let frameId = null;\n  const collect = () => {\n    if (frameId) {\n      return;\n    }\n    callbacks.collectionStarting();\n    frameId = requestAnimationFrame(() => {\n      frameId = null;\n      start();\n      const {\n        additions,\n        removals,\n        modified\n      } = staging;\n      const added = Object.keys(additions).map(id => registry.draggable.getById(id).getDimension(origin)).sort((a, b) => a.descriptor.index - b.descriptor.index);\n      const updated = Object.keys(modified).map(id => {\n        const entry = registry.droppable.getById(id);\n        const scroll = entry.callbacks.getScrollWhileDragging();\n        return {\n          droppableId: id,\n          scroll\n        };\n      });\n      const result = {\n        additions: added,\n        removals: Object.keys(removals),\n        modified: updated\n      };\n      staging = clean$1();\n      finish();\n      callbacks.publish(result);\n    });\n  };\n  const add = entry => {\n    const id = entry.descriptor.id;\n    staging.additions[id] = entry;\n    staging.modified[entry.descriptor.droppableId] = true;\n    if (staging.removals[id]) {\n      delete staging.removals[id];\n    }\n    collect();\n  };\n  const remove = entry => {\n    const descriptor = entry.descriptor;\n    staging.removals[descriptor.id] = true;\n    staging.modified[descriptor.droppableId] = true;\n    if (staging.additions[descriptor.id]) {\n      delete staging.additions[descriptor.id];\n    }\n    collect();\n  };\n  const stop = () => {\n    if (!frameId) {\n      return;\n    }\n    cancelAnimationFrame(frameId);\n    frameId = null;\n    staging = clean$1();\n  };\n  return {\n    add,\n    remove,\n    stop\n  };\n}\n\nvar getMaxScroll = ({\n  scrollHeight,\n  scrollWidth,\n  height,\n  width\n}) => {\n  const maxScroll = subtract({\n    x: scrollWidth,\n    y: scrollHeight\n  }, {\n    x: width,\n    y: height\n  });\n  const adjustedMaxScroll = {\n    x: Math.max(0, maxScroll.x),\n    y: Math.max(0, maxScroll.y)\n  };\n  return adjustedMaxScroll;\n};\n\nvar getDocumentElement = () => {\n  const doc = document.documentElement;\n  !doc ?  true ? invariant(false, 'Cannot find document.documentElement') : 0 : void 0;\n  return doc;\n};\n\nvar getMaxWindowScroll = () => {\n  const doc = getDocumentElement();\n  const maxScroll = getMaxScroll({\n    scrollHeight: doc.scrollHeight,\n    scrollWidth: doc.scrollWidth,\n    width: doc.clientWidth,\n    height: doc.clientHeight\n  });\n  return maxScroll;\n};\n\nvar getViewport = () => {\n  const scroll = getWindowScroll();\n  const maxScroll = getMaxWindowScroll();\n  const top = scroll.y;\n  const left = scroll.x;\n  const doc = getDocumentElement();\n  const width = doc.clientWidth;\n  const height = doc.clientHeight;\n  const right = left + width;\n  const bottom = top + height;\n  const frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)({\n    top,\n    left,\n    right,\n    bottom\n  });\n  const viewport = {\n    frame,\n    scroll: {\n      initial: scroll,\n      current: scroll,\n      max: maxScroll,\n      diff: {\n        value: origin,\n        displacement: origin\n      }\n    }\n  };\n  return viewport;\n};\n\nvar getInitialPublish = ({\n  critical,\n  scrollOptions,\n  registry\n}) => {\n  start();\n  const viewport = getViewport();\n  const windowScroll = viewport.scroll.current;\n  const home = critical.droppable;\n  const droppables = registry.droppable.getAllByType(home.type).map(entry => entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions));\n  const draggables = registry.draggable.getAllByType(critical.draggable.type).map(entry => entry.getDimension(windowScroll));\n  const dimensions = {\n    draggables: toDraggableMap(draggables),\n    droppables: toDroppableMap(droppables)\n  };\n  finish();\n  const result = {\n    dimensions,\n    critical,\n    viewport\n  };\n  return result;\n};\n\nfunction shouldPublishUpdate(registry, dragging, entry) {\n  if (entry.descriptor.id === dragging.id) {\n    return false;\n  }\n  if (entry.descriptor.type !== dragging.type) {\n    return false;\n  }\n  const home = registry.droppable.getById(entry.descriptor.droppableId);\n  if (home.descriptor.mode !== 'virtual') {\n     true ? warning(`\n      You are attempting to add or remove a Draggable [id: ${entry.descriptor.id}]\n      while a drag is occurring. This is only supported for virtual lists.\n\n      See https://github.com/hello-pangea/dnd/blob/main/docs/patterns/virtual-lists.md\n    `) : 0;\n    return false;\n  }\n  return true;\n}\nvar createDimensionMarshal = (registry, callbacks) => {\n  let collection = null;\n  const publisher = createPublisher({\n    callbacks: {\n      publish: callbacks.publishWhileDragging,\n      collectionStarting: callbacks.collectionStarting\n    },\n    registry\n  });\n  const updateDroppableIsEnabled = (id, isEnabled) => {\n    !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update is enabled flag of Droppable ${id} as it is not registered`) : 0 : void 0;\n    if (!collection) {\n      return;\n    }\n    callbacks.updateDroppableIsEnabled({\n      id,\n      isEnabled\n    });\n  };\n  const updateDroppableIsCombineEnabled = (id, isCombineEnabled) => {\n    if (!collection) {\n      return;\n    }\n    !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update isCombineEnabled flag of Droppable ${id} as it is not registered`) : 0 : void 0;\n    callbacks.updateDroppableIsCombineEnabled({\n      id,\n      isCombineEnabled\n    });\n  };\n  const updateDroppableScroll = (id, newScroll) => {\n    if (!collection) {\n      return;\n    }\n    !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update the scroll on Droppable ${id} as it is not registered`) : 0 : void 0;\n    callbacks.updateDroppableScroll({\n      id,\n      newScroll\n    });\n  };\n  const scrollDroppable = (id, change) => {\n    if (!collection) {\n      return;\n    }\n    registry.droppable.getById(id).callbacks.scroll(change);\n  };\n  const stopPublishing = () => {\n    if (!collection) {\n      return;\n    }\n    publisher.stop();\n    const home = collection.critical.droppable;\n    registry.droppable.getAllByType(home.type).forEach(entry => entry.callbacks.dragStopped());\n    collection.unsubscribe();\n    collection = null;\n  };\n  const subscriber = event => {\n    !collection ?  true ? invariant(false, 'Should only be subscribed when a collection is occurring') : 0 : void 0;\n    const dragging = collection.critical.draggable;\n    if (event.type === 'ADDITION') {\n      if (shouldPublishUpdate(registry, dragging, event.value)) {\n        publisher.add(event.value);\n      }\n    }\n    if (event.type === 'REMOVAL') {\n      if (shouldPublishUpdate(registry, dragging, event.value)) {\n        publisher.remove(event.value);\n      }\n    }\n  };\n  const startPublishing = request => {\n    !!collection ?  true ? invariant(false, 'Cannot start capturing critical dimensions as there is already a collection') : 0 : void 0;\n    const entry = registry.draggable.getById(request.draggableId);\n    const home = registry.droppable.getById(entry.descriptor.droppableId);\n    const critical = {\n      draggable: entry.descriptor,\n      droppable: home.descriptor\n    };\n    const unsubscribe = registry.subscribe(subscriber);\n    collection = {\n      critical,\n      unsubscribe\n    };\n    return getInitialPublish({\n      critical,\n      registry,\n      scrollOptions: request.scrollOptions\n    });\n  };\n  const marshal = {\n    updateDroppableIsEnabled,\n    updateDroppableIsCombineEnabled,\n    scrollDroppable,\n    updateDroppableScroll,\n    startPublishing,\n    stopPublishing\n  };\n  return marshal;\n};\n\nvar canStartDrag = (state, id) => {\n  if (state.phase === 'IDLE') {\n    return true;\n  }\n  if (state.phase !== 'DROP_ANIMATING') {\n    return false;\n  }\n  if (state.completed.result.draggableId === id) {\n    return false;\n  }\n  return state.completed.result.reason === 'DROP';\n};\n\nvar scrollWindow = change => {\n  window.scrollBy(change.x, change.y);\n};\n\nconst getScrollableDroppables = memoizeOne(droppables => toDroppableList(droppables).filter(droppable => {\n  if (!droppable.isEnabled) {\n    return false;\n  }\n  if (!droppable.frame) {\n    return false;\n  }\n  return true;\n}));\nconst getScrollableDroppableOver = (target, droppables) => {\n  const maybe = getScrollableDroppables(droppables).find(droppable => {\n    !droppable.frame ?  true ? invariant(false, 'Invalid result') : 0 : void 0;\n    return isPositionInFrame(droppable.frame.pageMarginBox)(target);\n  }) || null;\n  return maybe;\n};\nvar getBestScrollableDroppable = ({\n  center,\n  destination,\n  droppables\n}) => {\n  if (destination) {\n    const dimension = droppables[destination];\n    if (!dimension.frame) {\n      return null;\n    }\n    return dimension;\n  }\n  const dimension = getScrollableDroppableOver(center, droppables);\n  return dimension;\n};\n\nconst defaultAutoScrollerOptions = {\n  startFromPercentage: 0.25,\n  maxScrollAtPercentage: 0.05,\n  maxPixelScroll: 28,\n  ease: percentage => percentage ** 2,\n  durationDampening: {\n    stopDampeningAt: 1200,\n    accelerateAt: 360\n  },\n  disabled: false\n};\n\nvar getDistanceThresholds = (container, axis, getAutoScrollerOptions = () => defaultAutoScrollerOptions) => {\n  const autoScrollerOptions = getAutoScrollerOptions();\n  const startScrollingFrom = container[axis.size] * autoScrollerOptions.startFromPercentage;\n  const maxScrollValueAt = container[axis.size] * autoScrollerOptions.maxScrollAtPercentage;\n  const thresholds = {\n    startScrollingFrom,\n    maxScrollValueAt\n  };\n  return thresholds;\n};\n\nvar getPercentage = ({\n  startOfRange,\n  endOfRange,\n  current\n}) => {\n  const range = endOfRange - startOfRange;\n  if (range === 0) {\n     true ? warning(`\n      Detected distance range of 0 in the fluid auto scroller\n      This is unexpected and would cause a divide by 0 issue.\n      Not allowing an auto scroll\n    `) : 0;\n    return 0;\n  }\n  const currentInRange = current - startOfRange;\n  const percentage = currentInRange / range;\n  return percentage;\n};\n\nvar minScroll = 1;\n\nvar getValueFromDistance = (distanceToEdge, thresholds, getAutoScrollerOptions = () => defaultAutoScrollerOptions) => {\n  const autoScrollerOptions = getAutoScrollerOptions();\n  if (distanceToEdge > thresholds.startScrollingFrom) {\n    return 0;\n  }\n  if (distanceToEdge <= thresholds.maxScrollValueAt) {\n    return autoScrollerOptions.maxPixelScroll;\n  }\n  if (distanceToEdge === thresholds.startScrollingFrom) {\n    return minScroll;\n  }\n  const percentageFromMaxScrollValueAt = getPercentage({\n    startOfRange: thresholds.maxScrollValueAt,\n    endOfRange: thresholds.startScrollingFrom,\n    current: distanceToEdge\n  });\n  const percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;\n  const scroll = autoScrollerOptions.maxPixelScroll * autoScrollerOptions.ease(percentageFromStartScrollingFrom);\n  return Math.ceil(scroll);\n};\n\nvar dampenValueByTime = (proposedScroll, dragStartTime, getAutoScrollerOptions) => {\n  const autoScrollerOptions = getAutoScrollerOptions();\n  const accelerateAt = autoScrollerOptions.durationDampening.accelerateAt;\n  const stopAt = autoScrollerOptions.durationDampening.stopDampeningAt;\n  const startOfRange = dragStartTime;\n  const endOfRange = stopAt;\n  const now = Date.now();\n  const runTime = now - startOfRange;\n  if (runTime >= stopAt) {\n    return proposedScroll;\n  }\n  if (runTime < accelerateAt) {\n    return minScroll;\n  }\n  const betweenAccelerateAtAndStopAtPercentage = getPercentage({\n    startOfRange: accelerateAt,\n    endOfRange,\n    current: runTime\n  });\n  const scroll = proposedScroll * autoScrollerOptions.ease(betweenAccelerateAtAndStopAtPercentage);\n  return Math.ceil(scroll);\n};\n\nvar getValue = ({\n  distanceToEdge,\n  thresholds,\n  dragStartTime,\n  shouldUseTimeDampening,\n  getAutoScrollerOptions\n}) => {\n  const scroll = getValueFromDistance(distanceToEdge, thresholds, getAutoScrollerOptions);\n  if (scroll === 0) {\n    return 0;\n  }\n  if (!shouldUseTimeDampening) {\n    return scroll;\n  }\n  return Math.max(dampenValueByTime(scroll, dragStartTime, getAutoScrollerOptions), minScroll);\n};\n\nvar getScrollOnAxis = ({\n  container,\n  distanceToEdges,\n  dragStartTime,\n  axis,\n  shouldUseTimeDampening,\n  getAutoScrollerOptions\n}) => {\n  const thresholds = getDistanceThresholds(container, axis, getAutoScrollerOptions);\n  const isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];\n  if (isCloserToEnd) {\n    return getValue({\n      distanceToEdge: distanceToEdges[axis.end],\n      thresholds,\n      dragStartTime,\n      shouldUseTimeDampening,\n      getAutoScrollerOptions\n    });\n  }\n  return -1 * getValue({\n    distanceToEdge: distanceToEdges[axis.start],\n    thresholds,\n    dragStartTime,\n    shouldUseTimeDampening,\n    getAutoScrollerOptions\n  });\n};\n\nvar adjustForSizeLimits = ({\n  container,\n  subject,\n  proposedScroll\n}) => {\n  const isTooBigVertically = subject.height > container.height;\n  const isTooBigHorizontally = subject.width > container.width;\n  if (!isTooBigHorizontally && !isTooBigVertically) {\n    return proposedScroll;\n  }\n  if (isTooBigHorizontally && isTooBigVertically) {\n    return null;\n  }\n  return {\n    x: isTooBigHorizontally ? 0 : proposedScroll.x,\n    y: isTooBigVertically ? 0 : proposedScroll.y\n  };\n};\n\nconst clean = apply(value => value === 0 ? 0 : value);\nvar getScroll$1 = ({\n  dragStartTime,\n  container,\n  subject,\n  center,\n  shouldUseTimeDampening,\n  getAutoScrollerOptions\n}) => {\n  const distanceToEdges = {\n    top: center.y - container.top,\n    right: container.right - center.x,\n    bottom: container.bottom - center.y,\n    left: center.x - container.left\n  };\n  const y = getScrollOnAxis({\n    container,\n    distanceToEdges,\n    dragStartTime,\n    axis: vertical,\n    shouldUseTimeDampening,\n    getAutoScrollerOptions\n  });\n  const x = getScrollOnAxis({\n    container,\n    distanceToEdges,\n    dragStartTime,\n    axis: horizontal,\n    shouldUseTimeDampening,\n    getAutoScrollerOptions\n  });\n  const required = clean({\n    x,\n    y\n  });\n  if (isEqual$1(required, origin)) {\n    return null;\n  }\n  const limited = adjustForSizeLimits({\n    container,\n    subject,\n    proposedScroll: required\n  });\n  if (!limited) {\n    return null;\n  }\n  return isEqual$1(limited, origin) ? null : limited;\n};\n\nconst smallestSigned = apply(value => {\n  if (value === 0) {\n    return 0;\n  }\n  return value > 0 ? 1 : -1;\n});\nconst getOverlap = (() => {\n  const getRemainder = (target, max) => {\n    if (target < 0) {\n      return target;\n    }\n    if (target > max) {\n      return target - max;\n    }\n    return 0;\n  };\n  return ({\n    current,\n    max,\n    change\n  }) => {\n    const targetScroll = add(current, change);\n    const overlap = {\n      x: getRemainder(targetScroll.x, max.x),\n      y: getRemainder(targetScroll.y, max.y)\n    };\n    if (isEqual$1(overlap, origin)) {\n      return null;\n    }\n    return overlap;\n  };\n})();\nconst canPartiallyScroll = ({\n  max: rawMax,\n  current,\n  change\n}) => {\n  const max = {\n    x: Math.max(current.x, rawMax.x),\n    y: Math.max(current.y, rawMax.y)\n  };\n  const smallestChange = smallestSigned(change);\n  const overlap = getOverlap({\n    max,\n    current,\n    change: smallestChange\n  });\n  if (!overlap) {\n    return true;\n  }\n  if (smallestChange.x !== 0 && overlap.x === 0) {\n    return true;\n  }\n  if (smallestChange.y !== 0 && overlap.y === 0) {\n    return true;\n  }\n  return false;\n};\nconst canScrollWindow = (viewport, change) => canPartiallyScroll({\n  current: viewport.scroll.current,\n  max: viewport.scroll.max,\n  change\n});\nconst getWindowOverlap = (viewport, change) => {\n  if (!canScrollWindow(viewport, change)) {\n    return null;\n  }\n  const max = viewport.scroll.max;\n  const current = viewport.scroll.current;\n  return getOverlap({\n    current,\n    max,\n    change\n  });\n};\nconst canScrollDroppable = (droppable, change) => {\n  const frame = droppable.frame;\n  if (!frame) {\n    return false;\n  }\n  return canPartiallyScroll({\n    current: frame.scroll.current,\n    max: frame.scroll.max,\n    change\n  });\n};\nconst getDroppableOverlap = (droppable, change) => {\n  const frame = droppable.frame;\n  if (!frame) {\n    return null;\n  }\n  if (!canScrollDroppable(droppable, change)) {\n    return null;\n  }\n  return getOverlap({\n    current: frame.scroll.current,\n    max: frame.scroll.max,\n    change\n  });\n};\n\nvar getWindowScrollChange = ({\n  viewport,\n  subject,\n  center,\n  dragStartTime,\n  shouldUseTimeDampening,\n  getAutoScrollerOptions\n}) => {\n  const scroll = getScroll$1({\n    dragStartTime,\n    container: viewport.frame,\n    subject,\n    center,\n    shouldUseTimeDampening,\n    getAutoScrollerOptions\n  });\n  return scroll && canScrollWindow(viewport, scroll) ? scroll : null;\n};\n\nvar getDroppableScrollChange = ({\n  droppable,\n  subject,\n  center,\n  dragStartTime,\n  shouldUseTimeDampening,\n  getAutoScrollerOptions\n}) => {\n  const frame = droppable.frame;\n  if (!frame) {\n    return null;\n  }\n  const scroll = getScroll$1({\n    dragStartTime,\n    container: frame.pageMarginBox,\n    subject,\n    center,\n    shouldUseTimeDampening,\n    getAutoScrollerOptions\n  });\n  return scroll && canScrollDroppable(droppable, scroll) ? scroll : null;\n};\n\nvar scroll = ({\n  state,\n  dragStartTime,\n  shouldUseTimeDampening,\n  scrollWindow,\n  scrollDroppable,\n  getAutoScrollerOptions\n}) => {\n  const center = state.current.page.borderBoxCenter;\n  const draggable = state.dimensions.draggables[state.critical.draggable.id];\n  const subject = draggable.page.marginBox;\n  if (state.isWindowScrollAllowed) {\n    const viewport = state.viewport;\n    const change = getWindowScrollChange({\n      dragStartTime,\n      viewport,\n      subject,\n      center,\n      shouldUseTimeDampening,\n      getAutoScrollerOptions\n    });\n    if (change) {\n      scrollWindow(change);\n      return;\n    }\n  }\n  const droppable = getBestScrollableDroppable({\n    center,\n    destination: whatIsDraggedOver(state.impact),\n    droppables: state.dimensions.droppables\n  });\n  if (!droppable) {\n    return;\n  }\n  const change = getDroppableScrollChange({\n    dragStartTime,\n    droppable,\n    subject,\n    center,\n    shouldUseTimeDampening,\n    getAutoScrollerOptions\n  });\n  if (change) {\n    scrollDroppable(droppable.descriptor.id, change);\n  }\n};\n\nvar createFluidScroller = ({\n  scrollWindow,\n  scrollDroppable,\n  getAutoScrollerOptions = () => defaultAutoScrollerOptions\n}) => {\n  const scheduleWindowScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(scrollWindow);\n  const scheduleDroppableScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(scrollDroppable);\n  let dragging = null;\n  const tryScroll = state => {\n    !dragging ?  true ? invariant(false, 'Cannot fluid scroll if not dragging') : 0 : void 0;\n    const {\n      shouldUseTimeDampening,\n      dragStartTime\n    } = dragging;\n    scroll({\n      state,\n      scrollWindow: scheduleWindowScroll,\n      scrollDroppable: scheduleDroppableScroll,\n      dragStartTime,\n      shouldUseTimeDampening,\n      getAutoScrollerOptions\n    });\n  };\n  const start$1 = state => {\n    start();\n    !!dragging ?  true ? invariant(false, 'Cannot start auto scrolling when already started') : 0 : void 0;\n    const dragStartTime = Date.now();\n    let wasScrollNeeded = false;\n    const fakeScrollCallback = () => {\n      wasScrollNeeded = true;\n    };\n    scroll({\n      state,\n      dragStartTime: 0,\n      shouldUseTimeDampening: false,\n      scrollWindow: fakeScrollCallback,\n      scrollDroppable: fakeScrollCallback,\n      getAutoScrollerOptions\n    });\n    dragging = {\n      dragStartTime,\n      shouldUseTimeDampening: wasScrollNeeded\n    };\n    finish();\n    if (wasScrollNeeded) {\n      tryScroll(state);\n    }\n  };\n  const stop = () => {\n    if (!dragging) {\n      return;\n    }\n    scheduleWindowScroll.cancel();\n    scheduleDroppableScroll.cancel();\n    dragging = null;\n  };\n  return {\n    start: start$1,\n    stop,\n    scroll: tryScroll\n  };\n};\n\nvar createJumpScroller = ({\n  move,\n  scrollDroppable,\n  scrollWindow\n}) => {\n  const moveByOffset = (state, offset) => {\n    const client = add(state.current.client.selection, offset);\n    move({\n      client\n    });\n  };\n  const scrollDroppableAsMuchAsItCan = (droppable, change) => {\n    if (!canScrollDroppable(droppable, change)) {\n      return change;\n    }\n    const overlap = getDroppableOverlap(droppable, change);\n    if (!overlap) {\n      scrollDroppable(droppable.descriptor.id, change);\n      return null;\n    }\n    const whatTheDroppableCanScroll = subtract(change, overlap);\n    scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);\n    const remainder = subtract(change, whatTheDroppableCanScroll);\n    return remainder;\n  };\n  const scrollWindowAsMuchAsItCan = (isWindowScrollAllowed, viewport, change) => {\n    if (!isWindowScrollAllowed) {\n      return change;\n    }\n    if (!canScrollWindow(viewport, change)) {\n      return change;\n    }\n    const overlap = getWindowOverlap(viewport, change);\n    if (!overlap) {\n      scrollWindow(change);\n      return null;\n    }\n    const whatTheWindowCanScroll = subtract(change, overlap);\n    scrollWindow(whatTheWindowCanScroll);\n    const remainder = subtract(change, whatTheWindowCanScroll);\n    return remainder;\n  };\n  const jumpScroller = state => {\n    const request = state.scrollJumpRequest;\n    if (!request) {\n      return;\n    }\n    const destination = whatIsDraggedOver(state.impact);\n    !destination ?  true ? invariant(false, 'Cannot perform a jump scroll when there is no destination') : 0 : void 0;\n    const droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);\n    if (!droppableRemainder) {\n      return;\n    }\n    const viewport = state.viewport;\n    const windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);\n    if (!windowRemainder) {\n      return;\n    }\n    moveByOffset(state, windowRemainder);\n  };\n  return jumpScroller;\n};\n\nvar createAutoScroller = ({\n  scrollDroppable,\n  scrollWindow,\n  move,\n  getAutoScrollerOptions\n}) => {\n  const fluidScroller = createFluidScroller({\n    scrollWindow,\n    scrollDroppable,\n    getAutoScrollerOptions\n  });\n  const jumpScroll = createJumpScroller({\n    move,\n    scrollWindow,\n    scrollDroppable\n  });\n  const scroll = state => {\n    const autoScrollerOptions = getAutoScrollerOptions();\n    if (autoScrollerOptions.disabled || state.phase !== 'DRAGGING') {\n      return;\n    }\n    if (state.movementMode === 'FLUID') {\n      fluidScroller.scroll(state);\n      return;\n    }\n    if (!state.scrollJumpRequest) {\n      return;\n    }\n    jumpScroll(state);\n  };\n  const scroller = {\n    scroll,\n    start: fluidScroller.start,\n    stop: fluidScroller.stop\n  };\n  return scroller;\n};\n\nconst prefix = 'data-rfd';\nconst dragHandle = (() => {\n  const base = `${prefix}-drag-handle`;\n  return {\n    base,\n    draggableId: `${base}-draggable-id`,\n    contextId: `${base}-context-id`\n  };\n})();\nconst draggable = (() => {\n  const base = `${prefix}-draggable`;\n  return {\n    base,\n    contextId: `${base}-context-id`,\n    id: `${base}-id`\n  };\n})();\nconst droppable = (() => {\n  const base = `${prefix}-droppable`;\n  return {\n    base,\n    contextId: `${base}-context-id`,\n    id: `${base}-id`\n  };\n})();\nconst scrollContainer = {\n  contextId: `${prefix}-scroll-container-context-id`\n};\n\nconst makeGetSelector = context => attribute => `[${attribute}=\"${context}\"]`;\nconst getStyles = (rules, property) => rules.map(rule => {\n  const value = rule.styles[property];\n  if (!value) {\n    return '';\n  }\n  return `${rule.selector} { ${value} }`;\n}).join(' ');\nconst noPointerEvents = 'pointer-events: none;';\nvar getStyles$1 = contextId => {\n  const getSelector = makeGetSelector(contextId);\n  const dragHandle$1 = (() => {\n    const grabCursor = `\n      cursor: -webkit-grab;\n      cursor: grab;\n    `;\n    return {\n      selector: getSelector(dragHandle.contextId),\n      styles: {\n        always: `\n          -webkit-touch-callout: none;\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n          touch-action: manipulation;\n        `,\n        resting: grabCursor,\n        dragging: noPointerEvents,\n        dropAnimating: grabCursor\n      }\n    };\n  })();\n  const draggable$1 = (() => {\n    const transition = `\n      transition: ${transitions.outOfTheWay};\n    `;\n    return {\n      selector: getSelector(draggable.contextId),\n      styles: {\n        dragging: transition,\n        dropAnimating: transition,\n        userCancel: transition\n      }\n    };\n  })();\n  const droppable$1 = {\n    selector: getSelector(droppable.contextId),\n    styles: {\n      always: `overflow-anchor: none;`\n    }\n  };\n  const body = {\n    selector: 'body',\n    styles: {\n      dragging: `\n        cursor: grabbing;\n        cursor: -webkit-grabbing;\n        user-select: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        overflow-anchor: none;\n      `\n    }\n  };\n  const rules = [draggable$1, dragHandle$1, droppable$1, body];\n  return {\n    always: getStyles(rules, 'always'),\n    resting: getStyles(rules, 'resting'),\n    dragging: getStyles(rules, 'dragging'),\n    dropAnimating: getStyles(rules, 'dropAnimating'),\n    userCancel: getStyles(rules, 'userCancel')\n  };\n};\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\nconst getHead = () => {\n  const head = document.querySelector('head');\n  !head ?  true ? invariant(false, 'Cannot find the head to append a style to') : 0 : void 0;\n  return head;\n};\nconst createStyleEl = nonce => {\n  const el = document.createElement('style');\n  if (nonce) {\n    el.setAttribute('nonce', nonce);\n  }\n  el.type = 'text/css';\n  return el;\n};\nfunction useStyleMarshal(contextId, nonce) {\n  const styles = useMemo(() => getStyles$1(contextId), [contextId]);\n  const alwaysRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const dynamicRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const setDynamicStyle = useCallback(memoizeOne(proposed => {\n    const el = dynamicRef.current;\n    !el ?  true ? invariant(false, 'Cannot set dynamic style element if it is not set') : 0 : void 0;\n    el.textContent = proposed;\n  }), []);\n  const setAlwaysStyle = useCallback(proposed => {\n    const el = alwaysRef.current;\n    !el ?  true ? invariant(false, 'Cannot set dynamic style element if it is not set') : 0 : void 0;\n    el.textContent = proposed;\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    !(!alwaysRef.current && !dynamicRef.current) ?  true ? invariant(false, 'style elements already mounted') : 0 : void 0;\n    const always = createStyleEl(nonce);\n    const dynamic = createStyleEl(nonce);\n    alwaysRef.current = always;\n    dynamicRef.current = dynamic;\n    always.setAttribute(`${prefix}-always`, contextId);\n    dynamic.setAttribute(`${prefix}-dynamic`, contextId);\n    getHead().appendChild(always);\n    getHead().appendChild(dynamic);\n    setAlwaysStyle(styles.always);\n    setDynamicStyle(styles.resting);\n    return () => {\n      const remove = ref => {\n        const current = ref.current;\n        !current ?  true ? invariant(false, 'Cannot unmount ref as it is not set') : 0 : void 0;\n        getHead().removeChild(current);\n        ref.current = null;\n      };\n      remove(alwaysRef);\n      remove(dynamicRef);\n    };\n  }, [nonce, setAlwaysStyle, setDynamicStyle, styles.always, styles.resting, contextId]);\n  const dragging = useCallback(() => setDynamicStyle(styles.dragging), [setDynamicStyle, styles.dragging]);\n  const dropping = useCallback(reason => {\n    if (reason === 'DROP') {\n      setDynamicStyle(styles.dropAnimating);\n      return;\n    }\n    setDynamicStyle(styles.userCancel);\n  }, [setDynamicStyle, styles.dropAnimating, styles.userCancel]);\n  const resting = useCallback(() => {\n    if (!dynamicRef.current) {\n      return;\n    }\n    setDynamicStyle(styles.resting);\n  }, [setDynamicStyle, styles.resting]);\n  const marshal = useMemo(() => ({\n    dragging,\n    dropping,\n    resting\n  }), [dragging, dropping, resting]);\n  return marshal;\n}\n\nfunction querySelectorAll(parentNode, selector) {\n  return Array.from(parentNode.querySelectorAll(selector));\n}\n\nvar getWindowFromEl = el => {\n  if (el && el.ownerDocument && el.ownerDocument.defaultView) {\n    return el.ownerDocument.defaultView;\n  }\n  return window;\n};\n\nfunction isHtmlElement(el) {\n  return el instanceof getWindowFromEl(el).HTMLElement;\n}\n\nfunction findDragHandle(contextId, draggableId) {\n  const selector = `[${dragHandle.contextId}=\"${contextId}\"]`;\n  const possible = querySelectorAll(document, selector);\n  if (!possible.length) {\n     true ? warning(`Unable to find any drag handles in the context \"${contextId}\"`) : 0;\n    return null;\n  }\n  const handle = possible.find(el => {\n    return el.getAttribute(dragHandle.draggableId) === draggableId;\n  });\n  if (!handle) {\n     true ? warning(`Unable to find drag handle with id \"${draggableId}\" as no handle with a matching id was found`) : 0;\n    return null;\n  }\n  if (!isHtmlElement(handle)) {\n     true ? warning('drag handle needs to be a HTMLElement') : 0;\n    return null;\n  }\n  return handle;\n}\n\nfunction useFocusMarshal(contextId) {\n  const entriesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n  const recordRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const restoreFocusFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  const register = useCallback(function register(id, focus) {\n    const entry = {\n      id,\n      focus\n    };\n    entriesRef.current[id] = entry;\n    return function unregister() {\n      const entries = entriesRef.current;\n      const current = entries[id];\n      if (current !== entry) {\n        delete entries[id];\n      }\n    };\n  }, []);\n  const tryGiveFocus = useCallback(function tryGiveFocus(tryGiveFocusTo) {\n    const handle = findDragHandle(contextId, tryGiveFocusTo);\n    if (handle && handle !== document.activeElement) {\n      handle.focus();\n    }\n  }, [contextId]);\n  const tryShiftRecord = useCallback(function tryShiftRecord(previous, redirectTo) {\n    if (recordRef.current === previous) {\n      recordRef.current = redirectTo;\n    }\n  }, []);\n  const tryRestoreFocusRecorded = useCallback(function tryRestoreFocusRecorded() {\n    if (restoreFocusFrameRef.current) {\n      return;\n    }\n    if (!isMountedRef.current) {\n      return;\n    }\n    restoreFocusFrameRef.current = requestAnimationFrame(() => {\n      restoreFocusFrameRef.current = null;\n      const record = recordRef.current;\n      if (record) {\n        tryGiveFocus(record);\n      }\n    });\n  }, [tryGiveFocus]);\n  const tryRecordFocus = useCallback(function tryRecordFocus(id) {\n    recordRef.current = null;\n    const focused = document.activeElement;\n    if (!focused) {\n      return;\n    }\n    if (focused.getAttribute(dragHandle.draggableId) !== id) {\n      return;\n    }\n    recordRef.current = id;\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    isMountedRef.current = true;\n    return function clearFrameOnUnmount() {\n      isMountedRef.current = false;\n      const frameId = restoreFocusFrameRef.current;\n      if (frameId) {\n        cancelAnimationFrame(frameId);\n      }\n    };\n  }, []);\n  const marshal = useMemo(() => ({\n    register,\n    tryRecordFocus,\n    tryRestoreFocusRecorded,\n    tryShiftRecord\n  }), [register, tryRecordFocus, tryRestoreFocusRecorded, tryShiftRecord]);\n  return marshal;\n}\n\nfunction createRegistry() {\n  const entries = {\n    draggables: {},\n    droppables: {}\n  };\n  const subscribers = [];\n  function subscribe(cb) {\n    subscribers.push(cb);\n    return function unsubscribe() {\n      const index = subscribers.indexOf(cb);\n      if (index === -1) {\n        return;\n      }\n      subscribers.splice(index, 1);\n    };\n  }\n  function notify(event) {\n    if (subscribers.length) {\n      subscribers.forEach(cb => cb(event));\n    }\n  }\n  function findDraggableById(id) {\n    return entries.draggables[id] || null;\n  }\n  function getDraggableById(id) {\n    const entry = findDraggableById(id);\n    !entry ?  true ? invariant(false, `Cannot find draggable entry with id [${id}]`) : 0 : void 0;\n    return entry;\n  }\n  const draggableAPI = {\n    register: entry => {\n      entries.draggables[entry.descriptor.id] = entry;\n      notify({\n        type: 'ADDITION',\n        value: entry\n      });\n    },\n    update: (entry, last) => {\n      const current = entries.draggables[last.descriptor.id];\n      if (!current) {\n        return;\n      }\n      if (current.uniqueId !== entry.uniqueId) {\n        return;\n      }\n      delete entries.draggables[last.descriptor.id];\n      entries.draggables[entry.descriptor.id] = entry;\n    },\n    unregister: entry => {\n      const draggableId = entry.descriptor.id;\n      const current = findDraggableById(draggableId);\n      if (!current) {\n        return;\n      }\n      if (entry.uniqueId !== current.uniqueId) {\n        return;\n      }\n      delete entries.draggables[draggableId];\n      if (entries.droppables[entry.descriptor.droppableId]) {\n        notify({\n          type: 'REMOVAL',\n          value: entry\n        });\n      }\n    },\n    getById: getDraggableById,\n    findById: findDraggableById,\n    exists: id => Boolean(findDraggableById(id)),\n    getAllByType: type => Object.values(entries.draggables).filter(entry => entry.descriptor.type === type)\n  };\n  function findDroppableById(id) {\n    return entries.droppables[id] || null;\n  }\n  function getDroppableById(id) {\n    const entry = findDroppableById(id);\n    !entry ?  true ? invariant(false, `Cannot find droppable entry with id [${id}]`) : 0 : void 0;\n    return entry;\n  }\n  const droppableAPI = {\n    register: entry => {\n      entries.droppables[entry.descriptor.id] = entry;\n    },\n    unregister: entry => {\n      const current = findDroppableById(entry.descriptor.id);\n      if (!current) {\n        return;\n      }\n      if (entry.uniqueId !== current.uniqueId) {\n        return;\n      }\n      delete entries.droppables[entry.descriptor.id];\n    },\n    getById: getDroppableById,\n    findById: findDroppableById,\n    exists: id => Boolean(findDroppableById(id)),\n    getAllByType: type => Object.values(entries.droppables).filter(entry => entry.descriptor.type === type)\n  };\n  function clean() {\n    entries.draggables = {};\n    entries.droppables = {};\n    subscribers.length = 0;\n  }\n  return {\n    draggable: draggableAPI,\n    droppable: droppableAPI,\n    subscribe,\n    clean\n  };\n}\n\nfunction useRegistry() {\n  const registry = useMemo(createRegistry, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return function unmount() {\n      registry.clean();\n    };\n  }, [registry]);\n  return registry;\n}\n\nvar StoreContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\n\nvar getBodyElement = () => {\n  const body = document.body;\n  !body ?  true ? invariant(false, 'Cannot find document.body') : 0 : void 0;\n  return body;\n};\n\nconst visuallyHidden = {\n  position: 'absolute',\n  width: '1px',\n  height: '1px',\n  margin: '-1px',\n  border: '0',\n  padding: '0',\n  overflow: 'hidden',\n  clip: 'rect(0 0 0 0)',\n  'clip-path': 'inset(100%)'\n};\n\nconst getId = contextId => `rfd-announcement-${contextId}`;\nfunction useAnnouncer(contextId) {\n  const id = useMemo(() => getId(contextId), [contextId]);\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function setup() {\n    const el = document.createElement('div');\n    ref.current = el;\n    el.id = id;\n    el.setAttribute('aria-live', 'assertive');\n    el.setAttribute('aria-atomic', 'true');\n    (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(el.style, visuallyHidden);\n    getBodyElement().appendChild(el);\n    return function cleanup() {\n      setTimeout(function remove() {\n        const body = getBodyElement();\n        if (body.contains(el)) {\n          body.removeChild(el);\n        }\n        if (el === ref.current) {\n          ref.current = null;\n        }\n      });\n    };\n  }, [id]);\n  const announce = useCallback(message => {\n    const el = ref.current;\n    if (el) {\n      el.textContent = message;\n      return;\n    }\n     true ? warning(`\n      A screen reader message was trying to be announced but it was unable to do so.\n      This can occur if you unmount your <DragDropContext /> in your onDragEnd.\n      Consider calling provided.announce() before the unmount so that the instruction will\n      not be lost for users relying on a screen reader.\n\n      Message not passed to screen reader:\n\n      \"${message}\"\n    `) : 0;\n  }, []);\n  return announce;\n}\n\nconst defaults = {\n  separator: '::'\n};\nfunction useUniqueId(prefix, options = defaults) {\n  const id = react__WEBPACK_IMPORTED_MODULE_0___default().useId();\n  return useMemo(() => `${prefix}${options.separator}${id}`, [options.separator, prefix, id]);\n}\n\nfunction getElementId({\n  contextId,\n  uniqueId\n}) {\n  return `rfd-hidden-text-${contextId}-${uniqueId}`;\n}\nfunction useHiddenTextElement({\n  contextId,\n  text\n}) {\n  const uniqueId = useUniqueId('hidden-text', {\n    separator: '-'\n  });\n  const id = useMemo(() => getElementId({\n    contextId,\n    uniqueId\n  }), [uniqueId, contextId]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function mount() {\n    const el = document.createElement('div');\n    el.id = id;\n    el.textContent = text;\n    el.style.display = 'none';\n    getBodyElement().appendChild(el);\n    return function unmount() {\n      const body = getBodyElement();\n      if (body.contains(el)) {\n        body.removeChild(el);\n      }\n    };\n  }, [id, text]);\n  return id;\n}\n\nvar AppContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\n\nvar peerDependencies = {\n\treact: \"^18.0.0 || ^19.0.0\"};\n\nconst semver = /(\\d+)\\.(\\d+)\\.(\\d+)/;\nconst getVersion = value => {\n  const result = semver.exec(value);\n  !(result != null) ?  true ? invariant(false, `Unable to parse React version ${value}`) : 0 : void 0;\n  const major = Number(result[1]);\n  const minor = Number(result[2]);\n  const patch = Number(result[3]);\n  return {\n    major,\n    minor,\n    patch,\n    raw: value\n  };\n};\nconst isSatisfied = (expected, actual) => {\n  if (actual.major > expected.major) {\n    return true;\n  }\n  if (actual.major < expected.major) {\n    return false;\n  }\n  if (actual.minor > expected.minor) {\n    return true;\n  }\n  if (actual.minor < expected.minor) {\n    return false;\n  }\n  return actual.patch >= expected.patch;\n};\nvar checkReactVersion = (peerDepValue, actualValue) => {\n  const peerDep = getVersion(peerDepValue);\n  const actual = getVersion(actualValue);\n  if (isSatisfied(peerDep, actual)) {\n    return;\n  }\n   true ? warning(`\n    React version: [${actual.raw}]\n    does not satisfy expected peer dependency version: [${peerDep.raw}]\n\n    This can result in run time bugs, and even fatal crashes\n  `) : 0;\n};\n\nconst suffix = `\n  We expect a html5 doctype: <!doctype html>\n  This is to ensure consistent browser layout and measurement\n\n  More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/doctype.md\n`;\nvar checkDoctype = doc => {\n  const doctype = doc.doctype;\n  if (!doctype) {\n     true ? warning(`\n      No <!doctype html> found.\n\n      ${suffix}\n    `) : 0;\n    return;\n  }\n  if (doctype.name.toLowerCase() !== 'html') {\n     true ? warning(`\n      Unexpected <!doctype> found: (${doctype.name})\n\n      ${suffix}\n    `) : 0;\n  }\n  if (doctype.publicId !== '') {\n     true ? warning(`\n      Unexpected <!doctype> publicId found: (${doctype.publicId})\n      A html5 doctype does not have a publicId\n\n      ${suffix}\n    `) : 0;\n  }\n};\n\nfunction useDev(useHook) {\n  if (true) {\n    useHook();\n  }\n}\n\nfunction useDevSetupWarning(fn, inputs) {\n  useDev(() => {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      try {\n        fn();\n      } catch (e) {\n        error(`\n          A setup problem was encountered.\n\n          > ${e.message}\n        `);\n      }\n    }, inputs);\n  });\n}\n\nfunction useStartupValidation() {\n  useDevSetupWarning(() => {\n    checkReactVersion(peerDependencies.react, (react__WEBPACK_IMPORTED_MODULE_0___default().version));\n    checkDoctype(document);\n  }, []);\n}\n\nfunction usePrevious(current) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(current);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    ref.current = current;\n  });\n  return ref;\n}\n\nfunction create() {\n  let lock = null;\n  function isClaimed() {\n    return Boolean(lock);\n  }\n  function isActive(value) {\n    return value === lock;\n  }\n  function claim(abandon) {\n    !!lock ?  true ? invariant(false, 'Cannot claim lock as it is already claimed') : 0 : void 0;\n    const newLock = {\n      abandon\n    };\n    lock = newLock;\n    return newLock;\n  }\n  function release() {\n    !lock ?  true ? invariant(false, 'Cannot release lock when there is no lock') : 0 : void 0;\n    lock = null;\n  }\n  function tryAbandon() {\n    if (lock) {\n      lock.abandon();\n      release();\n    }\n  }\n  return {\n    isClaimed,\n    isActive,\n    claim,\n    release,\n    tryAbandon\n  };\n}\n\nfunction isDragging(state) {\n  if (state.phase === 'IDLE' || state.phase === 'DROP_ANIMATING') {\n    return false;\n  }\n  return state.isDragging;\n}\n\nconst tab = 9;\nconst enter = 13;\nconst escape = 27;\nconst space = 32;\nconst pageUp = 33;\nconst pageDown = 34;\nconst end = 35;\nconst home = 36;\nconst arrowLeft = 37;\nconst arrowUp = 38;\nconst arrowRight = 39;\nconst arrowDown = 40;\n\nconst preventedKeys = {\n  [enter]: true,\n  [tab]: true\n};\nvar preventStandardKeyEvents = event => {\n  if (preventedKeys[event.keyCode]) {\n    event.preventDefault();\n  }\n};\n\nconst supportedEventName = (() => {\n  const base = 'visibilitychange';\n  if (typeof document === 'undefined') {\n    return base;\n  }\n  const candidates = [base, `ms${base}`, `webkit${base}`, `moz${base}`, `o${base}`];\n  const supported = candidates.find(eventName => `on${eventName}` in document);\n  return supported || base;\n})();\n\nconst primaryButton = 0;\nconst sloppyClickThreshold = 5;\nfunction isSloppyClickThresholdExceeded(original, current) {\n  return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;\n}\nconst idle$1 = {\n  type: 'IDLE'\n};\nfunction getCaptureBindings({\n  cancel,\n  completed,\n  getPhase,\n  setPhase\n}) {\n  return [{\n    eventName: 'mousemove',\n    fn: event => {\n      const {\n        button,\n        clientX,\n        clientY\n      } = event;\n      if (button !== primaryButton) {\n        return;\n      }\n      const point = {\n        x: clientX,\n        y: clientY\n      };\n      const phase = getPhase();\n      if (phase.type === 'DRAGGING') {\n        event.preventDefault();\n        phase.actions.move(point);\n        return;\n      }\n      !(phase.type === 'PENDING') ?  true ? invariant(false, 'Cannot be IDLE') : 0 : void 0;\n      const pending = phase.point;\n      if (!isSloppyClickThresholdExceeded(pending, point)) {\n        return;\n      }\n      event.preventDefault();\n      const actions = phase.actions.fluidLift(point);\n      setPhase({\n        type: 'DRAGGING',\n        actions\n      });\n    }\n  }, {\n    eventName: 'mouseup',\n    fn: event => {\n      const phase = getPhase();\n      if (phase.type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n      event.preventDefault();\n      phase.actions.drop({\n        shouldBlockNextClick: true\n      });\n      completed();\n    }\n  }, {\n    eventName: 'mousedown',\n    fn: event => {\n      if (getPhase().type === 'DRAGGING') {\n        event.preventDefault();\n      }\n      cancel();\n    }\n  }, {\n    eventName: 'keydown',\n    fn: event => {\n      const phase = getPhase();\n      if (phase.type === 'PENDING') {\n        cancel();\n        return;\n      }\n      if (event.keyCode === escape) {\n        event.preventDefault();\n        cancel();\n        return;\n      }\n      preventStandardKeyEvents(event);\n    }\n  }, {\n    eventName: 'resize',\n    fn: cancel\n  }, {\n    eventName: 'scroll',\n    options: {\n      passive: true,\n      capture: false\n    },\n    fn: () => {\n      if (getPhase().type === 'PENDING') {\n        cancel();\n      }\n    }\n  }, {\n    eventName: 'webkitmouseforcedown',\n    fn: event => {\n      const phase = getPhase();\n      !(phase.type !== 'IDLE') ?  true ? invariant(false, 'Unexpected phase') : 0 : void 0;\n      if (phase.actions.shouldRespectForcePress()) {\n        cancel();\n        return;\n      }\n      event.preventDefault();\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\nfunction useMouseSensor(api) {\n  const phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle$1);\n  const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$2);\n  const startCaptureBinding = useMemo(() => ({\n    eventName: 'mousedown',\n    fn: function onMouseDown(event) {\n      if (event.defaultPrevented) {\n        return;\n      }\n      if (event.button !== primaryButton) {\n        return;\n      }\n      if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {\n        return;\n      }\n      const draggableId = api.findClosestDraggableId(event);\n      if (!draggableId) {\n        return;\n      }\n      const actions = api.tryGetLock(draggableId, stop, {\n        sourceEvent: event\n      });\n      if (!actions) {\n        return;\n      }\n      event.preventDefault();\n      const point = {\n        x: event.clientX,\n        y: event.clientY\n      };\n      unbindEventsRef.current();\n      startPendingDrag(actions, point);\n    }\n  }), [api]);\n  const preventForcePressBinding = useMemo(() => ({\n    eventName: 'webkitmouseforcewillbegin',\n    fn: event => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      const id = api.findClosestDraggableId(event);\n      if (!id) {\n        return;\n      }\n      const options = api.findOptionsForDraggable(id);\n      if (!options) {\n        return;\n      }\n      if (options.shouldRespectForcePress) {\n        return;\n      }\n      if (!api.canGetLock(id)) {\n        return;\n      }\n      event.preventDefault();\n    }\n  }), [api]);\n  const listenForCapture = useCallback(function listenForCapture() {\n    const options = {\n      passive: false,\n      capture: true\n    };\n    unbindEventsRef.current = bindEvents(window, [preventForcePressBinding, startCaptureBinding], options);\n  }, [preventForcePressBinding, startCaptureBinding]);\n  const stop = useCallback(() => {\n    const current = phaseRef.current;\n    if (current.type === 'IDLE') {\n      return;\n    }\n    phaseRef.current = idle$1;\n    unbindEventsRef.current();\n    listenForCapture();\n  }, [listenForCapture]);\n  const cancel = useCallback(() => {\n    const phase = phaseRef.current;\n    stop();\n    if (phase.type === 'DRAGGING') {\n      phase.actions.cancel({\n        shouldBlockNextClick: true\n      });\n    }\n    if (phase.type === 'PENDING') {\n      phase.actions.abort();\n    }\n  }, [stop]);\n  const bindCapturingEvents = useCallback(function bindCapturingEvents() {\n    const options = {\n      capture: true,\n      passive: false\n    };\n    const bindings = getCaptureBindings({\n      cancel,\n      completed: stop,\n      getPhase: () => phaseRef.current,\n      setPhase: phase => {\n        phaseRef.current = phase;\n      }\n    });\n    unbindEventsRef.current = bindEvents(window, bindings, options);\n  }, [cancel, stop]);\n  const startPendingDrag = useCallback(function startPendingDrag(actions, point) {\n    !(phaseRef.current.type === 'IDLE') ?  true ? invariant(false, 'Expected to move from IDLE to PENDING drag') : 0 : void 0;\n    phaseRef.current = {\n      type: 'PENDING',\n      point,\n      actions\n    };\n    bindCapturingEvents();\n  }, [bindCapturingEvents]);\n  useIsomorphicLayoutEffect(function mount() {\n    listenForCapture();\n    return function unmount() {\n      unbindEventsRef.current();\n    };\n  }, [listenForCapture]);\n}\n\nfunction noop$1() {}\nconst scrollJumpKeys = {\n  [pageDown]: true,\n  [pageUp]: true,\n  [home]: true,\n  [end]: true\n};\nfunction getDraggingBindings(actions, stop) {\n  function cancel() {\n    stop();\n    actions.cancel();\n  }\n  function drop() {\n    stop();\n    actions.drop();\n  }\n  return [{\n    eventName: 'keydown',\n    fn: event => {\n      if (event.keyCode === escape) {\n        event.preventDefault();\n        cancel();\n        return;\n      }\n      if (event.keyCode === space) {\n        event.preventDefault();\n        drop();\n        return;\n      }\n      if (event.keyCode === arrowDown) {\n        event.preventDefault();\n        actions.moveDown();\n        return;\n      }\n      if (event.keyCode === arrowUp) {\n        event.preventDefault();\n        actions.moveUp();\n        return;\n      }\n      if (event.keyCode === arrowRight) {\n        event.preventDefault();\n        actions.moveRight();\n        return;\n      }\n      if (event.keyCode === arrowLeft) {\n        event.preventDefault();\n        actions.moveLeft();\n        return;\n      }\n      if (scrollJumpKeys[event.keyCode]) {\n        event.preventDefault();\n        return;\n      }\n      preventStandardKeyEvents(event);\n    }\n  }, {\n    eventName: 'mousedown',\n    fn: cancel\n  }, {\n    eventName: 'mouseup',\n    fn: cancel\n  }, {\n    eventName: 'click',\n    fn: cancel\n  }, {\n    eventName: 'touchstart',\n    fn: cancel\n  }, {\n    eventName: 'resize',\n    fn: cancel\n  }, {\n    eventName: 'wheel',\n    fn: cancel,\n    options: {\n      passive: true\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\nfunction useKeyboardSensor(api) {\n  const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$1);\n  const startCaptureBinding = useMemo(() => ({\n    eventName: 'keydown',\n    fn: function onKeyDown(event) {\n      if (event.defaultPrevented) {\n        return;\n      }\n      if (event.keyCode !== space) {\n        return;\n      }\n      const draggableId = api.findClosestDraggableId(event);\n      if (!draggableId) {\n        return;\n      }\n      const preDrag = api.tryGetLock(draggableId, stop, {\n        sourceEvent: event\n      });\n      if (!preDrag) {\n        return;\n      }\n      event.preventDefault();\n      let isCapturing = true;\n      const actions = preDrag.snapLift();\n      unbindEventsRef.current();\n      function stop() {\n        !isCapturing ?  true ? invariant(false, 'Cannot stop capturing a keyboard drag when not capturing') : 0 : void 0;\n        isCapturing = false;\n        unbindEventsRef.current();\n        listenForCapture();\n      }\n      unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {\n        capture: true,\n        passive: false\n      });\n    }\n  }), [api]);\n  const listenForCapture = useCallback(function tryStartCapture() {\n    const options = {\n      passive: false,\n      capture: true\n    };\n    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);\n  }, [startCaptureBinding]);\n  useIsomorphicLayoutEffect(function mount() {\n    listenForCapture();\n    return function unmount() {\n      unbindEventsRef.current();\n    };\n  }, [listenForCapture]);\n}\n\nconst idle = {\n  type: 'IDLE'\n};\nconst timeForLongPress = 120;\nconst forcePressThreshold = 0.15;\nfunction getWindowBindings({\n  cancel,\n  getPhase\n}) {\n  return [{\n    eventName: 'orientationchange',\n    fn: cancel\n  }, {\n    eventName: 'resize',\n    fn: cancel\n  }, {\n    eventName: 'contextmenu',\n    fn: event => {\n      event.preventDefault();\n    }\n  }, {\n    eventName: 'keydown',\n    fn: event => {\n      if (getPhase().type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n      if (event.keyCode === escape) {\n        event.preventDefault();\n      }\n      cancel();\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\nfunction getHandleBindings({\n  cancel,\n  completed,\n  getPhase\n}) {\n  return [{\n    eventName: 'touchmove',\n    options: {\n      capture: false\n    },\n    fn: event => {\n      const phase = getPhase();\n      if (phase.type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n      phase.hasMoved = true;\n      const {\n        clientX,\n        clientY\n      } = event.touches[0];\n      const point = {\n        x: clientX,\n        y: clientY\n      };\n      event.preventDefault();\n      phase.actions.move(point);\n    }\n  }, {\n    eventName: 'touchend',\n    fn: event => {\n      const phase = getPhase();\n      if (phase.type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n      event.preventDefault();\n      phase.actions.drop({\n        shouldBlockNextClick: true\n      });\n      completed();\n    }\n  }, {\n    eventName: 'touchcancel',\n    fn: event => {\n      if (getPhase().type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n      event.preventDefault();\n      cancel();\n    }\n  }, {\n    eventName: 'touchforcechange',\n    fn: event => {\n      const phase = getPhase();\n      !(phase.type !== 'IDLE') ?  true ? invariant() : 0 : void 0;\n      const touch = event.touches[0];\n      if (!touch) {\n        return;\n      }\n      const isForcePress = touch.force >= forcePressThreshold;\n      if (!isForcePress) {\n        return;\n      }\n      const shouldRespect = phase.actions.shouldRespectForcePress();\n      if (phase.type === 'PENDING') {\n        if (shouldRespect) {\n          cancel();\n        }\n        return;\n      }\n      if (shouldRespect) {\n        if (phase.hasMoved) {\n          event.preventDefault();\n          return;\n        }\n        cancel();\n        return;\n      }\n      event.preventDefault();\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\nfunction useTouchSensor(api) {\n  const phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle);\n  const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$2);\n  const getPhase = useCallback(function getPhase() {\n    return phaseRef.current;\n  }, []);\n  const setPhase = useCallback(function setPhase(phase) {\n    phaseRef.current = phase;\n  }, []);\n  const startCaptureBinding = useMemo(() => ({\n    eventName: 'touchstart',\n    fn: function onTouchStart(event) {\n      if (event.defaultPrevented) {\n        return;\n      }\n      const draggableId = api.findClosestDraggableId(event);\n      if (!draggableId) {\n        return;\n      }\n      const actions = api.tryGetLock(draggableId, stop, {\n        sourceEvent: event\n      });\n      if (!actions) {\n        return;\n      }\n      const touch = event.touches[0];\n      const {\n        clientX,\n        clientY\n      } = touch;\n      const point = {\n        x: clientX,\n        y: clientY\n      };\n      unbindEventsRef.current();\n      startPendingDrag(actions, point);\n    }\n  }), [api]);\n  const listenForCapture = useCallback(function listenForCapture() {\n    const options = {\n      capture: true,\n      passive: false\n    };\n    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);\n  }, [startCaptureBinding]);\n  const stop = useCallback(() => {\n    const current = phaseRef.current;\n    if (current.type === 'IDLE') {\n      return;\n    }\n    if (current.type === 'PENDING') {\n      clearTimeout(current.longPressTimerId);\n    }\n    setPhase(idle);\n    unbindEventsRef.current();\n    listenForCapture();\n  }, [listenForCapture, setPhase]);\n  const cancel = useCallback(() => {\n    const phase = phaseRef.current;\n    stop();\n    if (phase.type === 'DRAGGING') {\n      phase.actions.cancel({\n        shouldBlockNextClick: true\n      });\n    }\n    if (phase.type === 'PENDING') {\n      phase.actions.abort();\n    }\n  }, [stop]);\n  const bindCapturingEvents = useCallback(function bindCapturingEvents() {\n    const options = {\n      capture: true,\n      passive: false\n    };\n    const args = {\n      cancel,\n      completed: stop,\n      getPhase\n    };\n    const unbindTarget = bindEvents(window, getHandleBindings(args), options);\n    const unbindWindow = bindEvents(window, getWindowBindings(args), options);\n    unbindEventsRef.current = function unbindAll() {\n      unbindTarget();\n      unbindWindow();\n    };\n  }, [cancel, getPhase, stop]);\n  const startDragging = useCallback(function startDragging() {\n    const phase = getPhase();\n    !(phase.type === 'PENDING') ?  true ? invariant(false, `Cannot start dragging from phase ${phase.type}`) : 0 : void 0;\n    const actions = phase.actions.fluidLift(phase.point);\n    setPhase({\n      type: 'DRAGGING',\n      actions,\n      hasMoved: false\n    });\n  }, [getPhase, setPhase]);\n  const startPendingDrag = useCallback(function startPendingDrag(actions, point) {\n    !(getPhase().type === 'IDLE') ?  true ? invariant(false, 'Expected to move from IDLE to PENDING drag') : 0 : void 0;\n    const longPressTimerId = setTimeout(startDragging, timeForLongPress);\n    setPhase({\n      type: 'PENDING',\n      point,\n      actions,\n      longPressTimerId\n    });\n    bindCapturingEvents();\n  }, [bindCapturingEvents, getPhase, setPhase, startDragging]);\n  useIsomorphicLayoutEffect(function mount() {\n    listenForCapture();\n    return function unmount() {\n      unbindEventsRef.current();\n      const phase = getPhase();\n      if (phase.type === 'PENDING') {\n        clearTimeout(phase.longPressTimerId);\n        setPhase(idle);\n      }\n    };\n  }, [getPhase, listenForCapture, setPhase]);\n  useIsomorphicLayoutEffect(function webkitHack() {\n    const unbind = bindEvents(window, [{\n      eventName: 'touchmove',\n      fn: () => {},\n      options: {\n        capture: false,\n        passive: false\n      }\n    }]);\n    return unbind;\n  }, []);\n}\n\nfunction useValidateSensorHooks(sensorHooks) {\n  useDev(() => {\n    const previousRef = usePrevious(sensorHooks);\n    useDevSetupWarning(() => {\n      !(previousRef.current.length === sensorHooks.length) ?  true ? invariant(false, 'Cannot change the amount of sensor hooks after mounting') : 0 : void 0;\n    });\n  });\n}\n\nconst interactiveTagNames = ['input', 'button', 'textarea', 'select', 'option', 'optgroup', 'video', 'audio'];\nfunction isAnInteractiveElement(parent, current) {\n  if (current == null) {\n    return false;\n  }\n  const hasAnInteractiveTag = interactiveTagNames.includes(current.tagName.toLowerCase());\n  if (hasAnInteractiveTag) {\n    return true;\n  }\n  const attribute = current.getAttribute('contenteditable');\n  if (attribute === 'true' || attribute === '') {\n    return true;\n  }\n  if (current === parent) {\n    return false;\n  }\n  return isAnInteractiveElement(parent, current.parentElement);\n}\nfunction isEventInInteractiveElement(draggable, event) {\n  const target = event.target;\n  if (!isHtmlElement(target)) {\n    return false;\n  }\n  return isAnInteractiveElement(draggable, target);\n}\n\nvar getBorderBoxCenterPosition = el => (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)(el.getBoundingClientRect()).center;\n\nfunction isElement(el) {\n  return el instanceof getWindowFromEl(el).Element;\n}\n\nconst supportedMatchesName = (() => {\n  const base = 'matches';\n  if (typeof document === 'undefined') {\n    return base;\n  }\n  const candidates = [base, 'msMatchesSelector', 'webkitMatchesSelector'];\n  const value = candidates.find(name => name in Element.prototype);\n  return value || base;\n})();\nfunction closestPonyfill(el, selector) {\n  if (el == null) {\n    return null;\n  }\n  if (el[supportedMatchesName](selector)) {\n    return el;\n  }\n  return closestPonyfill(el.parentElement, selector);\n}\nfunction closest(el, selector) {\n  if (el.closest) {\n    return el.closest(selector);\n  }\n  return closestPonyfill(el, selector);\n}\n\nfunction getSelector(contextId) {\n  return `[${dragHandle.contextId}=\"${contextId}\"]`;\n}\nfunction findClosestDragHandleFromEvent(contextId, event) {\n  const target = event.target;\n  if (!isElement(target)) {\n     true ? warning('event.target must be a Element') : 0;\n    return null;\n  }\n  const selector = getSelector(contextId);\n  const handle = closest(target, selector);\n  if (!handle) {\n    return null;\n  }\n  if (!isHtmlElement(handle)) {\n     true ? warning('drag handle must be a HTMLElement') : 0;\n    return null;\n  }\n  return handle;\n}\nfunction tryGetClosestDraggableIdFromEvent(contextId, event) {\n  const handle = findClosestDragHandleFromEvent(contextId, event);\n  if (!handle) {\n    return null;\n  }\n  return handle.getAttribute(dragHandle.draggableId);\n}\n\nfunction findDraggable(contextId, draggableId) {\n  const selector = `[${draggable.contextId}=\"${contextId}\"]`;\n  const possible = querySelectorAll(document, selector);\n  const draggable$1 = possible.find(el => {\n    return el.getAttribute(draggable.id) === draggableId;\n  });\n  if (!draggable$1) {\n    return null;\n  }\n  if (!isHtmlElement(draggable$1)) {\n     true ? warning('Draggable element is not a HTMLElement') : 0;\n    return null;\n  }\n  return draggable$1;\n}\n\nfunction preventDefault(event) {\n  event.preventDefault();\n}\nfunction isActive({\n  expected,\n  phase,\n  isLockActive,\n  shouldWarn\n}) {\n  if (!isLockActive()) {\n    if (shouldWarn) {\n       true ? warning(`\n        Cannot perform action.\n        The sensor no longer has an action lock.\n\n        Tips:\n\n        - Throw away your action handlers when forceStop() is called\n        - Check actions.isActive() if you really need to\n      `) : 0;\n    }\n    return false;\n  }\n  if (expected !== phase) {\n    if (shouldWarn) {\n       true ? warning(`\n        Cannot perform action.\n        The actions you used belong to an outdated phase\n\n        Current phase: ${expected}\n        You called an action from outdated phase: ${phase}\n\n        Tips:\n\n        - Do not use preDragActions actions after calling preDragActions.lift()\n      `) : 0;\n    }\n    return false;\n  }\n  return true;\n}\nfunction canStart({\n  lockAPI,\n  store,\n  registry,\n  draggableId\n}) {\n  if (lockAPI.isClaimed()) {\n    return false;\n  }\n  const entry = registry.draggable.findById(draggableId);\n  if (!entry) {\n     true ? warning(`Unable to find draggable with id: ${draggableId}`) : 0;\n    return false;\n  }\n  if (!entry.options.isEnabled) {\n    return false;\n  }\n  if (!canStartDrag(store.getState(), draggableId)) {\n    return false;\n  }\n  return true;\n}\nfunction tryStart({\n  lockAPI,\n  contextId,\n  store,\n  registry,\n  draggableId,\n  forceSensorStop,\n  sourceEvent\n}) {\n  const shouldStart = canStart({\n    lockAPI,\n    store,\n    registry,\n    draggableId\n  });\n  if (!shouldStart) {\n    return null;\n  }\n  const entry = registry.draggable.getById(draggableId);\n  const el = findDraggable(contextId, entry.descriptor.id);\n  if (!el) {\n     true ? warning(`Unable to find draggable element with id: ${draggableId}`) : 0;\n    return null;\n  }\n  if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {\n    return null;\n  }\n  const lock = lockAPI.claim(forceSensorStop || noop$2);\n  let phase = 'PRE_DRAG';\n  function getShouldRespectForcePress() {\n    return entry.options.shouldRespectForcePress;\n  }\n  function isLockActive() {\n    return lockAPI.isActive(lock);\n  }\n  function tryDispatch(expected, getAction) {\n    if (isActive({\n      expected,\n      phase,\n      isLockActive,\n      shouldWarn: true\n    })) {\n      store.dispatch(getAction());\n    }\n  }\n  const tryDispatchWhenDragging = tryDispatch.bind(null, 'DRAGGING');\n  function lift(args) {\n    function completed() {\n      lockAPI.release();\n      phase = 'COMPLETED';\n    }\n    if (phase !== 'PRE_DRAG') {\n      completed();\n       true ? invariant(false, `Cannot lift in phase ${phase}`) : 0 ;\n    }\n    store.dispatch(lift$1(args.liftActionArgs));\n    phase = 'DRAGGING';\n    function finish(reason, options = {\n      shouldBlockNextClick: false\n    }) {\n      args.cleanup();\n      if (options.shouldBlockNextClick) {\n        const unbind = bindEvents(window, [{\n          eventName: 'click',\n          fn: preventDefault,\n          options: {\n            once: true,\n            passive: false,\n            capture: true\n          }\n        }]);\n        setTimeout(unbind);\n      }\n      completed();\n      store.dispatch(drop({\n        reason\n      }));\n    }\n    return {\n      isActive: () => isActive({\n        expected: 'DRAGGING',\n        phase,\n        isLockActive,\n        shouldWarn: false\n      }),\n      shouldRespectForcePress: getShouldRespectForcePress,\n      drop: options => finish('DROP', options),\n      cancel: options => finish('CANCEL', options),\n      ...args.actions\n    };\n  }\n  function fluidLift(clientSelection) {\n    const move$1 = (0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(client => {\n      tryDispatchWhenDragging(() => move({\n        client\n      }));\n    });\n    const api = lift({\n      liftActionArgs: {\n        id: draggableId,\n        clientSelection,\n        movementMode: 'FLUID'\n      },\n      cleanup: () => move$1.cancel(),\n      actions: {\n        move: move$1\n      }\n    });\n    return {\n      ...api,\n      move: move$1\n    };\n  }\n  function snapLift() {\n    const actions = {\n      moveUp: () => tryDispatchWhenDragging(moveUp),\n      moveRight: () => tryDispatchWhenDragging(moveRight),\n      moveDown: () => tryDispatchWhenDragging(moveDown),\n      moveLeft: () => tryDispatchWhenDragging(moveLeft)\n    };\n    return lift({\n      liftActionArgs: {\n        id: draggableId,\n        clientSelection: getBorderBoxCenterPosition(el),\n        movementMode: 'SNAP'\n      },\n      cleanup: noop$2,\n      actions\n    });\n  }\n  function abortPreDrag() {\n    const shouldRelease = isActive({\n      expected: 'PRE_DRAG',\n      phase,\n      isLockActive,\n      shouldWarn: true\n    });\n    if (shouldRelease) {\n      lockAPI.release();\n    }\n  }\n  const preDrag = {\n    isActive: () => isActive({\n      expected: 'PRE_DRAG',\n      phase,\n      isLockActive,\n      shouldWarn: false\n    }),\n    shouldRespectForcePress: getShouldRespectForcePress,\n    fluidLift,\n    snapLift,\n    abort: abortPreDrag\n  };\n  return preDrag;\n}\nconst defaultSensors = [useMouseSensor, useKeyboardSensor, useTouchSensor];\nfunction useSensorMarshal({\n  contextId,\n  store,\n  registry,\n  customSensors,\n  enableDefaultSensors\n}) {\n  const useSensors = [...(enableDefaultSensors ? defaultSensors : []), ...(customSensors || [])];\n  const lockAPI = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => create())[0];\n  const tryAbandonLock = useCallback(function tryAbandonLock(previous, current) {\n    if (isDragging(previous) && !isDragging(current)) {\n      lockAPI.tryAbandon();\n    }\n  }, [lockAPI]);\n  useIsomorphicLayoutEffect(function listenToStore() {\n    let previous = store.getState();\n    const unsubscribe = store.subscribe(() => {\n      const current = store.getState();\n      tryAbandonLock(previous, current);\n      previous = current;\n    });\n    return unsubscribe;\n  }, [lockAPI, store, tryAbandonLock]);\n  useIsomorphicLayoutEffect(() => {\n    return lockAPI.tryAbandon;\n  }, [lockAPI.tryAbandon]);\n  const canGetLock = useCallback(draggableId => {\n    return canStart({\n      lockAPI,\n      registry,\n      store,\n      draggableId\n    });\n  }, [lockAPI, registry, store]);\n  const tryGetLock = useCallback((draggableId, forceStop, options) => tryStart({\n    lockAPI,\n    registry,\n    contextId,\n    store,\n    draggableId,\n    forceSensorStop: forceStop || null,\n    sourceEvent: options && options.sourceEvent ? options.sourceEvent : null\n  }), [contextId, lockAPI, registry, store]);\n  const findClosestDraggableId = useCallback(event => tryGetClosestDraggableIdFromEvent(contextId, event), [contextId]);\n  const findOptionsForDraggable = useCallback(id => {\n    const entry = registry.draggable.findById(id);\n    return entry ? entry.options : null;\n  }, [registry.draggable]);\n  const tryReleaseLock = useCallback(function tryReleaseLock() {\n    if (!lockAPI.isClaimed()) {\n      return;\n    }\n    lockAPI.tryAbandon();\n    if (store.getState().phase !== 'IDLE') {\n      store.dispatch(flush());\n    }\n  }, [lockAPI, store]);\n  const isLockClaimed = useCallback(() => lockAPI.isClaimed(), [lockAPI]);\n  const api = useMemo(() => ({\n    canGetLock,\n    tryGetLock,\n    findClosestDraggableId,\n    findOptionsForDraggable,\n    tryReleaseLock,\n    isLockClaimed\n  }), [canGetLock, tryGetLock, findClosestDraggableId, findOptionsForDraggable, tryReleaseLock, isLockClaimed]);\n  useValidateSensorHooks(useSensors);\n  for (let i = 0; i < useSensors.length; i++) {\n    useSensors[i](api);\n  }\n}\n\nconst createResponders = props => ({\n  onBeforeCapture: t => {\n    const onBeforeCapureCallback = () => {\n      if (props.onBeforeCapture) {\n        props.onBeforeCapture(t);\n      }\n    };\n    (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(onBeforeCapureCallback);\n  },\n  onBeforeDragStart: props.onBeforeDragStart,\n  onDragStart: props.onDragStart,\n  onDragEnd: props.onDragEnd,\n  onDragUpdate: props.onDragUpdate\n});\nconst createAutoScrollerOptions = props => ({\n  ...defaultAutoScrollerOptions,\n  ...props.autoScrollerOptions,\n  durationDampening: {\n    ...defaultAutoScrollerOptions.durationDampening,\n    ...props.autoScrollerOptions\n  }\n});\nfunction getStore(lazyRef) {\n  !lazyRef.current ?  true ? invariant(false, 'Could not find store from lazy ref') : 0 : void 0;\n  return lazyRef.current;\n}\nfunction App(props) {\n  const {\n    contextId,\n    setCallbacks,\n    sensors,\n    nonce,\n    dragHandleUsageInstructions\n  } = props;\n  const lazyStoreRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  useStartupValidation();\n  const lastPropsRef = usePrevious(props);\n  const getResponders = useCallback(() => {\n    return createResponders(lastPropsRef.current);\n  }, [lastPropsRef]);\n  const getAutoScrollerOptions = useCallback(() => {\n    return createAutoScrollerOptions(lastPropsRef.current);\n  }, [lastPropsRef]);\n  const announce = useAnnouncer(contextId);\n  const dragHandleUsageInstructionsId = useHiddenTextElement({\n    contextId,\n    text: dragHandleUsageInstructions\n  });\n  const styleMarshal = useStyleMarshal(contextId, nonce);\n  const lazyDispatch = useCallback(action => {\n    getStore(lazyStoreRef).dispatch(action);\n  }, []);\n  const marshalCallbacks = useMemo(() => (0,redux__WEBPACK_IMPORTED_MODULE_5__.bindActionCreators)({\n    publishWhileDragging,\n    updateDroppableScroll,\n    updateDroppableIsEnabled,\n    updateDroppableIsCombineEnabled,\n    collectionStarting\n  }, lazyDispatch), [lazyDispatch]);\n  const registry = useRegistry();\n  const dimensionMarshal = useMemo(() => {\n    return createDimensionMarshal(registry, marshalCallbacks);\n  }, [registry, marshalCallbacks]);\n  const autoScroller = useMemo(() => createAutoScroller({\n    scrollWindow,\n    scrollDroppable: dimensionMarshal.scrollDroppable,\n    getAutoScrollerOptions,\n    ...(0,redux__WEBPACK_IMPORTED_MODULE_5__.bindActionCreators)({\n      move\n    }, lazyDispatch)\n  }), [dimensionMarshal.scrollDroppable, lazyDispatch, getAutoScrollerOptions]);\n  const focusMarshal = useFocusMarshal(contextId);\n  const store = useMemo(() => createStore({\n    announce,\n    autoScroller,\n    dimensionMarshal,\n    focusMarshal,\n    getResponders,\n    styleMarshal\n  }), [announce, autoScroller, dimensionMarshal, focusMarshal, getResponders, styleMarshal]);\n  if (true) {\n    if (lazyStoreRef.current && lazyStoreRef.current !== store) {\n       true ? warning('unexpected store change') : 0;\n    }\n  }\n  lazyStoreRef.current = store;\n  const tryResetStore = useCallback(() => {\n    const current = getStore(lazyStoreRef);\n    const state = current.getState();\n    if (state.phase !== 'IDLE') {\n      current.dispatch(flush());\n    }\n  }, []);\n  const isDragging = useCallback(() => {\n    const state = getStore(lazyStoreRef).getState();\n    if (state.phase === 'DROP_ANIMATING') {\n      return true;\n    }\n    if (state.phase === 'IDLE') {\n      return false;\n    }\n    return state.isDragging;\n  }, []);\n  const appCallbacks = useMemo(() => ({\n    isDragging,\n    tryAbort: tryResetStore\n  }), [isDragging, tryResetStore]);\n  setCallbacks(appCallbacks);\n  const getCanLift = useCallback(id => canStartDrag(getStore(lazyStoreRef).getState(), id), []);\n  const getIsMovementAllowed = useCallback(() => isMovementAllowed(getStore(lazyStoreRef).getState()), []);\n  const appContext = useMemo(() => ({\n    marshal: dimensionMarshal,\n    focus: focusMarshal,\n    contextId,\n    canLift: getCanLift,\n    isMovementAllowed: getIsMovementAllowed,\n    dragHandleUsageInstructionsId,\n    registry\n  }), [contextId, dimensionMarshal, dragHandleUsageInstructionsId, focusMarshal, getCanLift, getIsMovementAllowed, registry]);\n  useSensorMarshal({\n    contextId,\n    store,\n    registry,\n    customSensors: sensors || null,\n    enableDefaultSensors: props.enableDefaultSensors !== false\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return tryResetStore;\n  }, [tryResetStore]);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AppContext.Provider, {\n    value: appContext\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_redux__WEBPACK_IMPORTED_MODULE_6__.Provider, {\n    context: StoreContext,\n    store: store\n  }, props.children));\n}\n\nfunction useUniqueContextId() {\n  return react__WEBPACK_IMPORTED_MODULE_0___default().useId();\n}\n\nfunction DragDropContext(props) {\n  const contextId = useUniqueContextId();\n  const dragHandleUsageInstructions = props.dragHandleUsageInstructions || preset.dragHandleUsageInstructions;\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ErrorBoundary, null, setCallbacks => react__WEBPACK_IMPORTED_MODULE_0___default().createElement(App, {\n    nonce: props.nonce,\n    contextId: contextId,\n    setCallbacks: setCallbacks,\n    dragHandleUsageInstructions: dragHandleUsageInstructions,\n    enableDefaultSensors: props.enableDefaultSensors,\n    sensors: props.sensors,\n    onBeforeCapture: props.onBeforeCapture,\n    onBeforeDragStart: props.onBeforeDragStart,\n    onDragStart: props.onDragStart,\n    onDragUpdate: props.onDragUpdate,\n    onDragEnd: props.onDragEnd,\n    autoScrollerOptions: props.autoScrollerOptions\n  }, props.children));\n}\n\nconst zIndexOptions = {\n  dragging: 5000,\n  dropAnimating: 4500\n};\nconst getDraggingTransition = (shouldAnimateDragMovement, dropping) => {\n  if (dropping) {\n    return transitions.drop(dropping.duration);\n  }\n  if (shouldAnimateDragMovement) {\n    return transitions.snap;\n  }\n  return transitions.fluid;\n};\nconst getDraggingOpacity = (isCombining, isDropAnimating) => {\n  if (!isCombining) {\n    return undefined;\n  }\n  return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;\n};\nconst getShouldDraggingAnimate = dragging => {\n  if (dragging.forceShouldAnimate != null) {\n    return dragging.forceShouldAnimate;\n  }\n  return dragging.mode === 'SNAP';\n};\nfunction getDraggingStyle(dragging) {\n  const dimension = dragging.dimension;\n  const box = dimension.client;\n  const {\n    offset,\n    combineWith,\n    dropping\n  } = dragging;\n  const isCombining = Boolean(combineWith);\n  const shouldAnimate = getShouldDraggingAnimate(dragging);\n  const isDropAnimating = Boolean(dropping);\n  const transform = isDropAnimating ? transforms.drop(offset, isCombining) : transforms.moveTo(offset);\n  const style = {\n    position: 'fixed',\n    top: box.marginBox.top,\n    left: box.marginBox.left,\n    boxSizing: 'border-box',\n    width: box.borderBox.width,\n    height: box.borderBox.height,\n    transition: getDraggingTransition(shouldAnimate, dropping),\n    transform,\n    opacity: getDraggingOpacity(isCombining, isDropAnimating),\n    zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,\n    pointerEvents: 'none'\n  };\n  return style;\n}\nfunction getSecondaryStyle(secondary) {\n  return {\n    transform: transforms.moveTo(secondary.offset),\n    transition: secondary.shouldAnimateDisplacement ? undefined : 'none'\n  };\n}\nfunction getStyle$1(mapped) {\n  return mapped.type === 'DRAGGING' ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);\n}\n\nfunction getDimension$1(descriptor, el, windowScroll = origin) {\n  const computedStyles = window.getComputedStyle(el);\n  const borderBox = el.getBoundingClientRect();\n  const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.calculateBox)(borderBox, computedStyles);\n  const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(client, windowScroll);\n  const placeholder = {\n    client,\n    tagName: el.tagName.toLowerCase(),\n    display: computedStyles.display\n  };\n  const displaceBy = {\n    x: client.marginBox.width,\n    y: client.marginBox.height\n  };\n  const dimension = {\n    descriptor,\n    placeholder,\n    displaceBy,\n    client,\n    page\n  };\n  return dimension;\n}\n\nfunction useDraggablePublisher(args) {\n  const uniqueId = useUniqueId('draggable');\n  const {\n    descriptor,\n    registry,\n    getDraggableRef,\n    canDragInteractiveElements,\n    shouldRespectForcePress,\n    isEnabled\n  } = args;\n  const options = useMemo(() => ({\n    canDragInteractiveElements,\n    shouldRespectForcePress,\n    isEnabled\n  }), [canDragInteractiveElements, isEnabled, shouldRespectForcePress]);\n  const getDimension = useCallback(windowScroll => {\n    const el = getDraggableRef();\n    !el ?  true ? invariant(false, 'Cannot get dimension when no ref is set') : 0 : void 0;\n    return getDimension$1(descriptor, el, windowScroll);\n  }, [descriptor, getDraggableRef]);\n  const entry = useMemo(() => ({\n    uniqueId,\n    descriptor,\n    options,\n    getDimension\n  }), [descriptor, getDimension, options, uniqueId]);\n  const publishedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(entry);\n  const isFirstPublishRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n  useIsomorphicLayoutEffect(() => {\n    registry.draggable.register(publishedRef.current);\n    return () => registry.draggable.unregister(publishedRef.current);\n  }, [registry.draggable]);\n  useIsomorphicLayoutEffect(() => {\n    if (isFirstPublishRef.current) {\n      isFirstPublishRef.current = false;\n      return;\n    }\n    const last = publishedRef.current;\n    publishedRef.current = entry;\n    registry.draggable.update(entry, last);\n  }, [entry, registry.draggable]);\n}\n\nvar DroppableContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\n\nfunction checkIsValidInnerRef(el) {\n  !(el && isHtmlElement(el)) ?  true ? invariant(false, `\n    provided.innerRef has not been provided with a HTMLElement.\n\n    You can find a guide on using the innerRef callback functions at:\n    https://github.com/hello-pangea/dnd/blob/main/docs/guides/using-inner-ref.md\n  `) : 0 : void 0;\n}\n\nfunction useValidation$1(props, contextId, getRef) {\n  useDevSetupWarning(() => {\n    function prefix(id) {\n      return `Draggable[id: ${id}]: `;\n    }\n    const id = props.draggableId;\n    !id ?  true ? invariant(false, 'Draggable requires a draggableId') : 0 : void 0;\n    !(typeof id === 'string') ?  true ? invariant(false, `Draggable requires a [string] draggableId.\n      Provided: [type: ${typeof id}] (value: ${id})`) : 0 : void 0;\n    !Number.isInteger(props.index) ?  true ? invariant(false, `${prefix(id)} requires an integer index prop`) : 0 : void 0;\n    if (props.mapped.type === 'DRAGGING') {\n      return;\n    }\n    checkIsValidInnerRef(getRef());\n    if (props.isEnabled) {\n      !findDragHandle(contextId, id) ?  true ? invariant(false, `${prefix(id)} Unable to find drag handle`) : 0 : void 0;\n    }\n  });\n}\nfunction useClonePropValidation(isClone) {\n  useDev(() => {\n    const initialRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(isClone);\n    useDevSetupWarning(() => {\n      !(isClone === initialRef.current) ?  true ? invariant(false, 'Draggable isClone prop value changed during component life') : 0 : void 0;\n    }, [isClone]);\n  });\n}\n\nfunction useRequiredContext(Context) {\n  const result = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n  !result ?  true ? invariant(false, 'Could not find required context') : 0 : void 0;\n  return result;\n}\n\nfunction preventHtml5Dnd(event) {\n  event.preventDefault();\n}\nconst Draggable = props => {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const setRef = useCallback((el = null) => {\n    ref.current = el;\n  }, []);\n  const getRef = useCallback(() => ref.current, []);\n  const {\n    contextId,\n    dragHandleUsageInstructionsId,\n    registry\n  } = useRequiredContext(AppContext);\n  const {\n    type,\n    droppableId\n  } = useRequiredContext(DroppableContext);\n  const descriptor = useMemo(() => ({\n    id: props.draggableId,\n    index: props.index,\n    type,\n    droppableId\n  }), [props.draggableId, props.index, type, droppableId]);\n  const {\n    children,\n    draggableId,\n    isEnabled,\n    shouldRespectForcePress,\n    canDragInteractiveElements,\n    isClone,\n    mapped,\n    dropAnimationFinished: dropAnimationFinishedAction\n  } = props;\n  useValidation$1(props, contextId, getRef);\n  useClonePropValidation(isClone);\n  if (!isClone) {\n    const forPublisher = useMemo(() => ({\n      descriptor,\n      registry,\n      getDraggableRef: getRef,\n      canDragInteractiveElements,\n      shouldRespectForcePress,\n      isEnabled\n    }), [descriptor, registry, getRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled]);\n    useDraggablePublisher(forPublisher);\n  }\n  const dragHandleProps = useMemo(() => isEnabled ? {\n    tabIndex: 0,\n    role: 'button',\n    'aria-describedby': dragHandleUsageInstructionsId,\n    'data-rfd-drag-handle-draggable-id': draggableId,\n    'data-rfd-drag-handle-context-id': contextId,\n    draggable: false,\n    onDragStart: preventHtml5Dnd\n  } : null, [contextId, dragHandleUsageInstructionsId, draggableId, isEnabled]);\n  const onMoveEnd = useCallback(event => {\n    if (mapped.type !== 'DRAGGING') {\n      return;\n    }\n    if (!mapped.dropping) {\n      return;\n    }\n    if (event.propertyName !== 'transform') {\n      return;\n    }\n    (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(dropAnimationFinishedAction);\n  }, [dropAnimationFinishedAction, mapped]);\n  const provided = useMemo(() => {\n    const style = getStyle$1(mapped);\n    const onTransitionEnd = mapped.type === 'DRAGGING' && mapped.dropping ? onMoveEnd : undefined;\n    const result = {\n      innerRef: setRef,\n      draggableProps: {\n        'data-rfd-draggable-context-id': contextId,\n        'data-rfd-draggable-id': draggableId,\n        style,\n        onTransitionEnd\n      },\n      dragHandleProps\n    };\n    return result;\n  }, [contextId, dragHandleProps, draggableId, mapped, onMoveEnd, setRef]);\n  const rubric = useMemo(() => ({\n    draggableId: descriptor.id,\n    type: descriptor.type,\n    source: {\n      index: descriptor.index,\n      droppableId: descriptor.droppableId\n    }\n  }), [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type]);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, children(provided, mapped.snapshot, rubric));\n};\n\nvar isStrictEqual = (a, b) => a === b;\n\nvar whatIsDraggedOverFromResult = result => {\n  const {\n    combine,\n    destination\n  } = result;\n  if (destination) {\n    return destination.droppableId;\n  }\n  if (combine) {\n    return combine.droppableId;\n  }\n  return null;\n};\n\nconst getCombineWithFromResult = result => {\n  return result.combine ? result.combine.draggableId : null;\n};\nconst getCombineWithFromImpact = impact => {\n  return impact.at && impact.at.type === 'COMBINE' ? impact.at.combine.draggableId : null;\n};\nfunction getDraggableSelector() {\n  const memoizedOffset = memoizeOne((x, y) => ({\n    x,\n    y\n  }));\n  const getMemoizedSnapshot = memoizeOne((mode, isClone, draggingOver = null, combineWith = null, dropping = null) => ({\n    isDragging: true,\n    isClone,\n    isDropAnimating: Boolean(dropping),\n    dropAnimation: dropping,\n    mode,\n    draggingOver,\n    combineWith,\n    combineTargetFor: null\n  }));\n  const getMemoizedProps = memoizeOne((offset, mode, dimension, isClone, draggingOver = null, combineWith = null, forceShouldAnimate = null) => ({\n    mapped: {\n      type: 'DRAGGING',\n      dropping: null,\n      draggingOver,\n      combineWith,\n      mode,\n      offset,\n      dimension,\n      forceShouldAnimate,\n      snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)\n    }\n  }));\n  const selector = (state, ownProps) => {\n    if (isDragging(state)) {\n      if (state.critical.draggable.id !== ownProps.draggableId) {\n        return null;\n      }\n      const offset = state.current.client.offset;\n      const dimension = state.dimensions.draggables[ownProps.draggableId];\n      const draggingOver = whatIsDraggedOver(state.impact);\n      const combineWith = getCombineWithFromImpact(state.impact);\n      const forceShouldAnimate = state.forceShouldAnimate;\n      return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);\n    }\n    if (state.phase === 'DROP_ANIMATING') {\n      const completed = state.completed;\n      if (completed.result.draggableId !== ownProps.draggableId) {\n        return null;\n      }\n      const isClone = ownProps.isClone;\n      const dimension = state.dimensions.draggables[ownProps.draggableId];\n      const result = completed.result;\n      const mode = result.mode;\n      const draggingOver = whatIsDraggedOverFromResult(result);\n      const combineWith = getCombineWithFromResult(result);\n      const duration = state.dropDuration;\n      const dropping = {\n        duration,\n        curve: curves.drop,\n        moveTo: state.newHomeClientOffset,\n        opacity: combineWith ? combine.opacity.drop : null,\n        scale: combineWith ? combine.scale.drop : null\n      };\n      return {\n        mapped: {\n          type: 'DRAGGING',\n          offset: state.newHomeClientOffset,\n          dimension,\n          dropping,\n          draggingOver,\n          combineWith,\n          mode,\n          forceShouldAnimate: null,\n          snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, dropping)\n        }\n      };\n    }\n    return null;\n  };\n  return selector;\n}\nfunction getSecondarySnapshot(combineTargetFor = null) {\n  return {\n    isDragging: false,\n    isDropAnimating: false,\n    isClone: false,\n    dropAnimation: null,\n    mode: null,\n    draggingOver: null,\n    combineTargetFor,\n    combineWith: null\n  };\n}\nconst atRest = {\n  mapped: {\n    type: 'SECONDARY',\n    offset: origin,\n    combineTargetFor: null,\n    shouldAnimateDisplacement: true,\n    snapshot: getSecondarySnapshot(null)\n  }\n};\nfunction getSecondarySelector() {\n  const memoizedOffset = memoizeOne((x, y) => ({\n    x,\n    y\n  }));\n  const getMemoizedSnapshot = memoizeOne(getSecondarySnapshot);\n  const getMemoizedProps = memoizeOne((offset, combineTargetFor = null, shouldAnimateDisplacement) => ({\n    mapped: {\n      type: 'SECONDARY',\n      offset,\n      combineTargetFor,\n      shouldAnimateDisplacement,\n      snapshot: getMemoizedSnapshot(combineTargetFor)\n    }\n  }));\n  const getFallback = combineTargetFor => {\n    return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;\n  };\n  const getProps = (ownId, draggingId, impact, afterCritical) => {\n    const visualDisplacement = impact.displaced.visible[ownId];\n    const isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);\n    const combine = tryGetCombine(impact);\n    const combineTargetFor = combine && combine.draggableId === ownId ? draggingId : null;\n    if (!visualDisplacement) {\n      if (!isAfterCriticalInVirtualList) {\n        return getFallback(combineTargetFor);\n      }\n      if (impact.displaced.invisible[ownId]) {\n        return null;\n      }\n      const change = negate(afterCritical.displacedBy.point);\n      const offset = memoizedOffset(change.x, change.y);\n      return getMemoizedProps(offset, combineTargetFor, true);\n    }\n    if (isAfterCriticalInVirtualList) {\n      return getFallback(combineTargetFor);\n    }\n    const displaceBy = impact.displacedBy.point;\n    const offset = memoizedOffset(displaceBy.x, displaceBy.y);\n    return getMemoizedProps(offset, combineTargetFor, visualDisplacement.shouldAnimate);\n  };\n  const selector = (state, ownProps) => {\n    if (isDragging(state)) {\n      if (state.critical.draggable.id === ownProps.draggableId) {\n        return null;\n      }\n      return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);\n    }\n    if (state.phase === 'DROP_ANIMATING') {\n      const completed = state.completed;\n      if (completed.result.draggableId === ownProps.draggableId) {\n        return null;\n      }\n      return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);\n    }\n    return null;\n  };\n  return selector;\n}\nconst makeMapStateToProps$1 = () => {\n  const draggingSelector = getDraggableSelector();\n  const secondarySelector = getSecondarySelector();\n  const selector = (state, ownProps) => draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;\n  return selector;\n};\nconst mapDispatchToProps$1 = {\n  dropAnimationFinished: dropAnimationFinished\n};\nconst ConnectedDraggable = (0,react_redux__WEBPACK_IMPORTED_MODULE_6__.connect)(makeMapStateToProps$1, mapDispatchToProps$1, null, {\n  context: StoreContext,\n  areStatePropsEqual: isStrictEqual\n})(Draggable);\n\nfunction PrivateDraggable(props) {\n  const droppableContext = useRequiredContext(DroppableContext);\n  const isUsingCloneFor = droppableContext.isUsingCloneFor;\n  if (isUsingCloneFor === props.draggableId && !props.isClone) {\n    return null;\n  }\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ConnectedDraggable, props);\n}\nfunction PublicDraggable(props) {\n  const isEnabled = typeof props.isDragDisabled === 'boolean' ? !props.isDragDisabled : true;\n  const canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);\n  const shouldRespectForcePress = Boolean(props.shouldRespectForcePress);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, props, {\n    isClone: false,\n    isEnabled: isEnabled,\n    canDragInteractiveElements: canDragInteractiveElements,\n    shouldRespectForcePress: shouldRespectForcePress\n  }));\n}\n\nconst isEqual = base => value => base === value;\nconst isScroll = isEqual('scroll');\nconst isAuto = isEqual('auto');\nconst isVisible = isEqual('visible');\nconst isEither = (overflow, fn) => fn(overflow.overflowX) || fn(overflow.overflowY);\nconst isBoth = (overflow, fn) => fn(overflow.overflowX) && fn(overflow.overflowY);\nconst isElementScrollable = el => {\n  const style = window.getComputedStyle(el);\n  const overflow = {\n    overflowX: style.overflowX,\n    overflowY: style.overflowY\n  };\n  return isEither(overflow, isScroll) || isEither(overflow, isAuto);\n};\nconst isBodyScrollable = () => {\n  if (false) {}\n  const body = getBodyElement();\n  const html = document.documentElement;\n  !html ?  true ? invariant() : 0 : void 0;\n  if (!isElementScrollable(body)) {\n    return false;\n  }\n  const htmlStyle = window.getComputedStyle(html);\n  const htmlOverflow = {\n    overflowX: htmlStyle.overflowX,\n    overflowY: htmlStyle.overflowY\n  };\n  if (isBoth(htmlOverflow, isVisible)) {\n    return false;\n  }\n   true ? warning(`\n    We have detected that your <body> element might be a scroll container.\n    We have found no reliable way of detecting whether the <body> element is a scroll container.\n    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)\n\n    Because we cannot determine if the <body> is a scroll container, and generally it is not one,\n    we will be treating the <body> as *not* a scroll container\n\n    More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/how-we-detect-scroll-containers.md\n  `) : 0;\n  return false;\n};\nconst getClosestScrollable = el => {\n  if (el == null) {\n    return null;\n  }\n  if (el === document.body) {\n    return isBodyScrollable() ? el : null;\n  }\n  if (el === document.documentElement) {\n    return null;\n  }\n  if (!isElementScrollable(el)) {\n    return getClosestScrollable(el.parentElement);\n  }\n  return el;\n};\n\nvar checkForNestedScrollContainers = scrollable => {\n  if (!scrollable) {\n    return;\n  }\n  const anotherScrollParent = getClosestScrollable(scrollable.parentElement);\n  if (!anotherScrollParent) {\n    return;\n  }\n   true ? warning(`\n    Droppable: unsupported nested scroll container detected.\n    A Droppable can only have one scroll parent (which can be itself)\n    Nested scroll containers are currently not supported.\n\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\n  `) : 0;\n};\n\nvar getScroll = el => ({\n  x: el.scrollLeft,\n  y: el.scrollTop\n});\n\nconst getIsFixed = el => {\n  if (!el) {\n    return false;\n  }\n  const style = window.getComputedStyle(el);\n  if (style.position === 'fixed') {\n    return true;\n  }\n  return getIsFixed(el.parentElement);\n};\nvar getEnv = start => {\n  const closestScrollable = getClosestScrollable(start);\n  const isFixedOnPage = getIsFixed(start);\n  return {\n    closestScrollable,\n    isFixedOnPage\n  };\n};\n\nvar getDroppableDimension = ({\n  descriptor,\n  isEnabled,\n  isCombineEnabled,\n  isFixedOnPage,\n  direction,\n  client,\n  page,\n  closest\n}) => {\n  const frame = (() => {\n    if (!closest) {\n      return null;\n    }\n    const {\n      scrollSize,\n      client: frameClient\n    } = closest;\n    const maxScroll = getMaxScroll({\n      scrollHeight: scrollSize.scrollHeight,\n      scrollWidth: scrollSize.scrollWidth,\n      height: frameClient.paddingBox.height,\n      width: frameClient.paddingBox.width\n    });\n    return {\n      pageMarginBox: closest.page.marginBox,\n      frameClient,\n      scrollSize,\n      shouldClipSubject: closest.shouldClipSubject,\n      scroll: {\n        initial: closest.scroll,\n        current: closest.scroll,\n        max: maxScroll,\n        diff: {\n          value: origin,\n          displacement: origin\n        }\n      }\n    };\n  })();\n  const axis = direction === 'vertical' ? vertical : horizontal;\n  const subject = getSubject({\n    page,\n    withPlaceholder: null,\n    axis,\n    frame\n  });\n  const dimension = {\n    descriptor,\n    isCombineEnabled,\n    isFixedOnPage,\n    axis,\n    isEnabled,\n    client,\n    page,\n    frame,\n    subject\n  };\n  return dimension;\n};\n\nconst getClient = (targetRef, closestScrollable) => {\n  const base = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getBox)(targetRef);\n  if (!closestScrollable) {\n    return base;\n  }\n  if (targetRef !== closestScrollable) {\n    return base;\n  }\n  const top = base.paddingBox.top - closestScrollable.scrollTop;\n  const left = base.paddingBox.left - closestScrollable.scrollLeft;\n  const bottom = top + closestScrollable.scrollHeight;\n  const right = left + closestScrollable.scrollWidth;\n  const paddingBox = {\n    top,\n    right,\n    bottom,\n    left\n  };\n  const borderBox = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.expand)(paddingBox, base.border);\n  const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.createBox)({\n    borderBox,\n    margin: base.margin,\n    border: base.border,\n    padding: base.padding\n  });\n  return client;\n};\nvar getDimension = ({\n  ref,\n  descriptor,\n  env,\n  windowScroll,\n  direction,\n  isDropDisabled,\n  isCombineEnabled,\n  shouldClipSubject\n}) => {\n  const closestScrollable = env.closestScrollable;\n  const client = getClient(ref, closestScrollable);\n  const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(client, windowScroll);\n  const closest = (() => {\n    if (!closestScrollable) {\n      return null;\n    }\n    const frameClient = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getBox)(closestScrollable);\n    const scrollSize = {\n      scrollHeight: closestScrollable.scrollHeight,\n      scrollWidth: closestScrollable.scrollWidth\n    };\n    return {\n      client: frameClient,\n      page: (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(frameClient, windowScroll),\n      scroll: getScroll(closestScrollable),\n      scrollSize,\n      shouldClipSubject\n    };\n  })();\n  const dimension = getDroppableDimension({\n    descriptor,\n    isEnabled: !isDropDisabled,\n    isCombineEnabled,\n    isFixedOnPage: env.isFixedOnPage,\n    direction,\n    client,\n    page,\n    closest\n  });\n  return dimension;\n};\n\nconst immediate = {\n  passive: false\n};\nconst delayed = {\n  passive: true\n};\nvar getListenerOptions = options => options.shouldPublishImmediately ? immediate : delayed;\n\nconst getClosestScrollableFromDrag = dragging => dragging && dragging.env.closestScrollable || null;\nfunction useDroppablePublisher(args) {\n  const whileDraggingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const appContext = useRequiredContext(AppContext);\n  const uniqueId = useUniqueId('droppable');\n  const {\n    registry,\n    marshal\n  } = appContext;\n  const previousRef = usePrevious(args);\n  const descriptor = useMemo(() => ({\n    id: args.droppableId,\n    type: args.type,\n    mode: args.mode\n  }), [args.droppableId, args.mode, args.type]);\n  const publishedDescriptorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(descriptor);\n  const memoizedUpdateScroll = useMemo(() => memoizeOne((x, y) => {\n    !whileDraggingRef.current ?  true ? invariant(false, 'Can only update scroll when dragging') : 0 : void 0;\n    const scroll = {\n      x,\n      y\n    };\n    marshal.updateDroppableScroll(descriptor.id, scroll);\n  }), [descriptor.id, marshal]);\n  const getClosestScroll = useCallback(() => {\n    const dragging = whileDraggingRef.current;\n    if (!dragging || !dragging.env.closestScrollable) {\n      return origin;\n    }\n    return getScroll(dragging.env.closestScrollable);\n  }, []);\n  const updateScroll = useCallback(() => {\n    const scroll = getClosestScroll();\n    memoizedUpdateScroll(scroll.x, scroll.y);\n  }, [getClosestScroll, memoizedUpdateScroll]);\n  const scheduleScrollUpdate = useMemo(() => (0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(updateScroll), [updateScroll]);\n  const onClosestScroll = useCallback(() => {\n    const dragging = whileDraggingRef.current;\n    const closest = getClosestScrollableFromDrag(dragging);\n    !(dragging && closest) ?  true ? invariant(false, 'Could not find scroll options while scrolling') : 0 : void 0;\n    const options = dragging.scrollOptions;\n    if (options.shouldPublishImmediately) {\n      updateScroll();\n      return;\n    }\n    scheduleScrollUpdate();\n  }, [scheduleScrollUpdate, updateScroll]);\n  const getDimensionAndWatchScroll = useCallback((windowScroll, options) => {\n    !!whileDraggingRef.current ?  true ? invariant(false, 'Cannot collect a droppable while a drag is occurring') : 0 : void 0;\n    const previous = previousRef.current;\n    const ref = previous.getDroppableRef();\n    !ref ?  true ? invariant(false, 'Cannot collect without a droppable ref') : 0 : void 0;\n    const env = getEnv(ref);\n    const dragging = {\n      ref,\n      descriptor,\n      env,\n      scrollOptions: options\n    };\n    whileDraggingRef.current = dragging;\n    const dimension = getDimension({\n      ref,\n      descriptor,\n      env,\n      windowScroll,\n      direction: previous.direction,\n      isDropDisabled: previous.isDropDisabled,\n      isCombineEnabled: previous.isCombineEnabled,\n      shouldClipSubject: !previous.ignoreContainerClipping\n    });\n    const scrollable = env.closestScrollable;\n    if (scrollable) {\n      scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);\n      scrollable.addEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));\n      if (true) {\n        checkForNestedScrollContainers(scrollable);\n      }\n    }\n    return dimension;\n  }, [appContext.contextId, descriptor, onClosestScroll, previousRef]);\n  const getScrollWhileDragging = useCallback(() => {\n    const dragging = whileDraggingRef.current;\n    const closest = getClosestScrollableFromDrag(dragging);\n    !(dragging && closest) ?  true ? invariant(false, 'Can only recollect Droppable client for Droppables that have a scroll container') : 0 : void 0;\n    return getScroll(closest);\n  }, []);\n  const dragStopped = useCallback(() => {\n    const dragging = whileDraggingRef.current;\n    !dragging ?  true ? invariant(false, 'Cannot stop drag when no active drag') : 0 : void 0;\n    const closest = getClosestScrollableFromDrag(dragging);\n    whileDraggingRef.current = null;\n    if (!closest) {\n      return;\n    }\n    scheduleScrollUpdate.cancel();\n    closest.removeAttribute(scrollContainer.contextId);\n    closest.removeEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));\n  }, [onClosestScroll, scheduleScrollUpdate]);\n  const scroll = useCallback(change => {\n    const dragging = whileDraggingRef.current;\n    !dragging ?  true ? invariant(false, 'Cannot scroll when there is no drag') : 0 : void 0;\n    const closest = getClosestScrollableFromDrag(dragging);\n    !closest ?  true ? invariant(false, 'Cannot scroll a droppable with no closest scrollable') : 0 : void 0;\n    closest.scrollTop += change.y;\n    closest.scrollLeft += change.x;\n  }, []);\n  const callbacks = useMemo(() => {\n    return {\n      getDimensionAndWatchScroll,\n      getScrollWhileDragging,\n      dragStopped,\n      scroll\n    };\n  }, [dragStopped, getDimensionAndWatchScroll, getScrollWhileDragging, scroll]);\n  const entry = useMemo(() => ({\n    uniqueId,\n    descriptor,\n    callbacks\n  }), [callbacks, descriptor, uniqueId]);\n  useIsomorphicLayoutEffect(() => {\n    publishedDescriptorRef.current = entry.descriptor;\n    registry.droppable.register(entry);\n    return () => {\n      if (whileDraggingRef.current) {\n         true ? warning('Unsupported: changing the droppableId or type of a Droppable during a drag') : 0;\n        dragStopped();\n      }\n      registry.droppable.unregister(entry);\n    };\n  }, [callbacks, descriptor, dragStopped, entry, marshal, registry.droppable]);\n  useIsomorphicLayoutEffect(() => {\n    if (!whileDraggingRef.current) {\n      return;\n    }\n    marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);\n  }, [args.isDropDisabled, marshal]);\n  useIsomorphicLayoutEffect(() => {\n    if (!whileDraggingRef.current) {\n      return;\n    }\n    marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);\n  }, [args.isCombineEnabled, marshal]);\n}\n\nfunction noop() {}\nconst empty = {\n  width: 0,\n  height: 0,\n  margin: noSpacing\n};\nconst getSize = ({\n  isAnimatingOpenOnMount,\n  placeholder,\n  animate\n}) => {\n  if (isAnimatingOpenOnMount) {\n    return empty;\n  }\n  if (animate === 'close') {\n    return empty;\n  }\n  return {\n    height: placeholder.client.borderBox.height,\n    width: placeholder.client.borderBox.width,\n    margin: placeholder.client.margin\n  };\n};\nconst getStyle = ({\n  isAnimatingOpenOnMount,\n  placeholder,\n  animate\n}) => {\n  const size = getSize({\n    isAnimatingOpenOnMount,\n    placeholder,\n    animate\n  });\n  return {\n    display: placeholder.display,\n    boxSizing: 'border-box',\n    width: size.width,\n    height: size.height,\n    marginTop: size.margin.top,\n    marginRight: size.margin.right,\n    marginBottom: size.margin.bottom,\n    marginLeft: size.margin.left,\n    flexShrink: '0',\n    flexGrow: '0',\n    pointerEvents: 'none',\n    transition: animate !== 'none' ? transitions.placeholder : null\n  };\n};\nconst Placeholder = props => {\n  const animateOpenTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const tryClearAnimateOpenTimer = useCallback(() => {\n    if (!animateOpenTimerRef.current) {\n      return;\n    }\n    clearTimeout(animateOpenTimerRef.current);\n    animateOpenTimerRef.current = null;\n  }, []);\n  const {\n    animate,\n    onTransitionEnd,\n    onClose,\n    contextId\n  } = props;\n  const [isAnimatingOpenOnMount, setIsAnimatingOpenOnMount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.animate === 'open');\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!isAnimatingOpenOnMount) {\n      return noop;\n    }\n    if (animate !== 'open') {\n      tryClearAnimateOpenTimer();\n      setIsAnimatingOpenOnMount(false);\n      return noop;\n    }\n    if (animateOpenTimerRef.current) {\n      return noop;\n    }\n    animateOpenTimerRef.current = setTimeout(() => {\n      animateOpenTimerRef.current = null;\n      setIsAnimatingOpenOnMount(false);\n    });\n    return tryClearAnimateOpenTimer;\n  }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);\n  const onSizeChangeEnd = useCallback(event => {\n    if (event.propertyName !== 'height') {\n      return;\n    }\n    onTransitionEnd();\n    if (animate === 'close') {\n      onClose();\n    }\n  }, [animate, onClose, onTransitionEnd]);\n  const style = getStyle({\n    isAnimatingOpenOnMount,\n    animate: props.animate,\n    placeholder: props.placeholder\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(props.placeholder.tagName, {\n    style,\n    'data-rfd-placeholder-context-id': contextId,\n    onTransitionEnd: onSizeChangeEnd,\n    ref: props.innerRef\n  });\n};\nvar Placeholder$1 = react__WEBPACK_IMPORTED_MODULE_0___default().memo(Placeholder);\n\nfunction isBoolean(value) {\n  return typeof value === 'boolean';\n}\nfunction runChecks(args, checks) {\n  checks.forEach(check => check(args));\n}\nconst shared = [function required({\n  props\n}) {\n  !props.droppableId ?  true ? invariant(false, 'A Droppable requires a droppableId prop') : 0 : void 0;\n  !(typeof props.droppableId === 'string') ?  true ? invariant(false, `A Droppable requires a [string] droppableId. Provided: [${typeof props.droppableId}]`) : 0 : void 0;\n}, function boolean({\n  props\n}) {\n  !isBoolean(props.isDropDisabled) ?  true ? invariant(false, 'isDropDisabled must be a boolean') : 0 : void 0;\n  !isBoolean(props.isCombineEnabled) ?  true ? invariant(false, 'isCombineEnabled must be a boolean') : 0 : void 0;\n  !isBoolean(props.ignoreContainerClipping) ?  true ? invariant(false, 'ignoreContainerClipping must be a boolean') : 0 : void 0;\n}, function ref({\n  getDroppableRef\n}) {\n  checkIsValidInnerRef(getDroppableRef());\n}];\nconst standard = [function placeholder({\n  props,\n  getPlaceholderRef\n}) {\n  if (!props.placeholder) {\n    return;\n  }\n  const ref = getPlaceholderRef();\n  if (ref) {\n    return;\n  }\n   true ? warning(`\n      Droppable setup issue [droppableId: \"${props.droppableId}\"]:\n      DroppableProvided > placeholder could not be found.\n\n      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.\n      More information: https://github.com/hello-pangea/dnd/blob/main/docs/api/droppable.md\n    `) : 0;\n}];\nconst virtual = [function hasClone({\n  props\n}) {\n  !props.renderClone ?  true ? invariant(false, 'Must provide a clone render function (renderClone) for virtual lists') : 0 : void 0;\n}, function hasNoPlaceholder({\n  getPlaceholderRef\n}) {\n  !!getPlaceholderRef() ?  true ? invariant(false, 'Expected virtual list to not have a placeholder') : 0 : void 0;\n}];\nfunction useValidation(args) {\n  useDevSetupWarning(() => {\n    runChecks(args, shared);\n    if (args.props.mode === 'standard') {\n      runChecks(args, standard);\n    }\n    if (args.props.mode === 'virtual') {\n      runChecks(args, virtual);\n    }\n  });\n}\n\nclass AnimateInOut extends (react__WEBPACK_IMPORTED_MODULE_0___default().PureComponent) {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      isVisible: Boolean(this.props.on),\n      data: this.props.on,\n      animate: this.props.shouldAnimate && this.props.on ? 'open' : 'none'\n    };\n    this.onClose = () => {\n      if (this.state.animate !== 'close') {\n        return;\n      }\n      this.setState({\n        isVisible: false\n      });\n    };\n  }\n  static getDerivedStateFromProps(props, state) {\n    if (!props.shouldAnimate) {\n      return {\n        isVisible: Boolean(props.on),\n        data: props.on,\n        animate: 'none'\n      };\n    }\n    if (props.on) {\n      return {\n        isVisible: true,\n        data: props.on,\n        animate: 'open'\n      };\n    }\n    if (state.isVisible) {\n      return {\n        isVisible: true,\n        data: state.data,\n        animate: 'close'\n      };\n    }\n    return {\n      isVisible: false,\n      animate: 'close',\n      data: null\n    };\n  }\n  render() {\n    if (!this.state.isVisible) {\n      return null;\n    }\n    const provided = {\n      onClose: this.onClose,\n      data: this.state.data,\n      animate: this.state.animate\n    };\n    return this.props.children(provided);\n  }\n}\n\nconst Droppable = props => {\n  const appContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AppContext);\n  !appContext ?  true ? invariant(false, 'Could not find app context') : 0 : void 0;\n  const {\n    contextId,\n    isMovementAllowed\n  } = appContext;\n  const droppableRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const placeholderRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const {\n    children,\n    droppableId,\n    type,\n    mode,\n    direction,\n    ignoreContainerClipping,\n    isDropDisabled,\n    isCombineEnabled,\n    snapshot,\n    useClone,\n    updateViewportMaxScroll,\n    getContainerForClone\n  } = props;\n  const getDroppableRef = useCallback(() => droppableRef.current, []);\n  const setDroppableRef = useCallback((value = null) => {\n    droppableRef.current = value;\n  }, []);\n  const getPlaceholderRef = useCallback(() => placeholderRef.current, []);\n  const setPlaceholderRef = useCallback((value = null) => {\n    placeholderRef.current = value;\n  }, []);\n  useValidation({\n    props,\n    getDroppableRef,\n    getPlaceholderRef\n  });\n  const onPlaceholderTransitionEnd = useCallback(() => {\n    if (isMovementAllowed()) {\n      updateViewportMaxScroll({\n        maxScroll: getMaxWindowScroll()\n      });\n    }\n  }, [isMovementAllowed, updateViewportMaxScroll]);\n  useDroppablePublisher({\n    droppableId,\n    type,\n    mode,\n    direction,\n    isDropDisabled,\n    isCombineEnabled,\n    ignoreContainerClipping,\n    getDroppableRef\n  });\n  const placeholder = useMemo(() => react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AnimateInOut, {\n    on: props.placeholder,\n    shouldAnimate: props.shouldAnimatePlaceholder\n  }, ({\n    onClose,\n    data,\n    animate\n  }) => react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Placeholder$1, {\n    placeholder: data,\n    onClose: onClose,\n    innerRef: setPlaceholderRef,\n    animate: animate,\n    contextId: contextId,\n    onTransitionEnd: onPlaceholderTransitionEnd\n  })), [contextId, onPlaceholderTransitionEnd, props.placeholder, props.shouldAnimatePlaceholder, setPlaceholderRef]);\n  const provided = useMemo(() => ({\n    innerRef: setDroppableRef,\n    placeholder,\n    droppableProps: {\n      'data-rfd-droppable-id': droppableId,\n      'data-rfd-droppable-context-id': contextId\n    }\n  }), [contextId, droppableId, placeholder, setDroppableRef]);\n  const isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;\n  const droppableContext = useMemo(() => ({\n    droppableId,\n    type,\n    isUsingCloneFor\n  }), [droppableId, isUsingCloneFor, type]);\n  function getClone() {\n    if (!useClone) {\n      return null;\n    }\n    const {\n      dragging,\n      render\n    } = useClone;\n    const node = react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, {\n      draggableId: dragging.draggableId,\n      index: dragging.source.index,\n      isClone: true,\n      isEnabled: true,\n      shouldRespectForcePress: false,\n      canDragInteractiveElements: true\n    }, (draggableProvided, draggableSnapshot) => render(draggableProvided, draggableSnapshot, dragging));\n    return react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(node, getContainerForClone());\n  }\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(DroppableContext.Provider, {\n    value: droppableContext\n  }, children(provided, snapshot), getClone());\n};\n\nfunction getBody() {\n  !document.body ?  true ? invariant(false, 'document.body is not ready') : 0 : void 0;\n  return document.body;\n}\nconst defaultProps = {\n  mode: 'standard',\n  type: 'DEFAULT',\n  direction: 'vertical',\n  isDropDisabled: false,\n  isCombineEnabled: false,\n  ignoreContainerClipping: false,\n  renderClone: null,\n  getContainerForClone: getBody\n};\nconst attachDefaultPropsToOwnProps = ownProps => {\n  let mergedProps = {\n    ...ownProps\n  };\n  let defaultPropKey;\n  for (defaultPropKey in defaultProps) {\n    if (ownProps[defaultPropKey] === undefined) {\n      mergedProps = {\n        ...mergedProps,\n        [defaultPropKey]: defaultProps[defaultPropKey]\n      };\n    }\n  }\n  return mergedProps;\n};\nconst isMatchingType = (type, critical) => type === critical.droppable.type;\nconst getDraggable = (critical, dimensions) => dimensions.draggables[critical.draggable.id];\nconst makeMapStateToProps = () => {\n  const idleWithAnimation = {\n    placeholder: null,\n    shouldAnimatePlaceholder: true,\n    snapshot: {\n      isDraggingOver: false,\n      draggingOverWith: null,\n      draggingFromThisWith: null,\n      isUsingPlaceholder: false\n    },\n    useClone: null\n  };\n  const idleWithoutAnimation = {\n    ...idleWithAnimation,\n    shouldAnimatePlaceholder: false\n  };\n  const getDraggableRubric = memoizeOne(descriptor => ({\n    draggableId: descriptor.id,\n    type: descriptor.type,\n    source: {\n      index: descriptor.index,\n      droppableId: descriptor.droppableId\n    }\n  }));\n  const getMapProps = memoizeOne((id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) => {\n    const draggableId = dragging.descriptor.id;\n    const isHome = dragging.descriptor.droppableId === id;\n    if (isHome) {\n      const useClone = renderClone ? {\n        render: renderClone,\n        dragging: getDraggableRubric(dragging.descriptor)\n      } : null;\n      const snapshot = {\n        isDraggingOver: isDraggingOverForConsumer,\n        draggingOverWith: isDraggingOverForConsumer ? draggableId : null,\n        draggingFromThisWith: draggableId,\n        isUsingPlaceholder: true\n      };\n      return {\n        placeholder: dragging.placeholder,\n        shouldAnimatePlaceholder: false,\n        snapshot,\n        useClone\n      };\n    }\n    if (!isEnabled) {\n      return idleWithoutAnimation;\n    }\n    if (!isDraggingOverForImpact) {\n      return idleWithAnimation;\n    }\n    const snapshot = {\n      isDraggingOver: isDraggingOverForConsumer,\n      draggingOverWith: draggableId,\n      draggingFromThisWith: null,\n      isUsingPlaceholder: true\n    };\n    return {\n      placeholder: dragging.placeholder,\n      shouldAnimatePlaceholder: true,\n      snapshot,\n      useClone: null\n    };\n  });\n  const selector = (state, ownProps) => {\n    const ownPropsWithDefaultProps = attachDefaultPropsToOwnProps(ownProps);\n    const id = ownPropsWithDefaultProps.droppableId;\n    const type = ownPropsWithDefaultProps.type;\n    const isEnabled = !ownPropsWithDefaultProps.isDropDisabled;\n    const renderClone = ownPropsWithDefaultProps.renderClone;\n    if (isDragging(state)) {\n      const critical = state.critical;\n      if (!isMatchingType(type, critical)) {\n        return idleWithoutAnimation;\n      }\n      const dragging = getDraggable(critical, state.dimensions);\n      const isDraggingOver = whatIsDraggedOver(state.impact) === id;\n      return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);\n    }\n    if (state.phase === 'DROP_ANIMATING') {\n      const completed = state.completed;\n      if (!isMatchingType(type, completed.critical)) {\n        return idleWithoutAnimation;\n      }\n      const dragging = getDraggable(completed.critical, state.dimensions);\n      return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, dragging, renderClone);\n    }\n    if (state.phase === 'IDLE' && state.completed && !state.shouldFlush) {\n      const completed = state.completed;\n      if (!isMatchingType(type, completed.critical)) {\n        return idleWithoutAnimation;\n      }\n      const wasOver = whatIsDraggedOver(completed.impact) === id;\n      const wasCombining = Boolean(completed.impact.at && completed.impact.at.type === 'COMBINE');\n      const isHome = completed.critical.droppable.id === id;\n      if (wasOver) {\n        return wasCombining ? idleWithAnimation : idleWithoutAnimation;\n      }\n      if (isHome) {\n        return idleWithAnimation;\n      }\n      return idleWithoutAnimation;\n    }\n    return idleWithoutAnimation;\n  };\n  return selector;\n};\nconst mapDispatchToProps = {\n  updateViewportMaxScroll: updateViewportMaxScroll\n};\nconst ConnectedDroppable = (0,react_redux__WEBPACK_IMPORTED_MODULE_6__.connect)(makeMapStateToProps, mapDispatchToProps, (stateProps, dispatchProps, ownProps) => {\n  return {\n    ...attachDefaultPropsToOwnProps(ownProps),\n    ...stateProps,\n    ...dispatchProps\n  };\n}, {\n  context: StoreContext,\n  areStatePropsEqual: isStrictEqual\n})(Droppable);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AaGVsbG8tcGFuZ2VhL2RuZC9kaXN0L2RuZC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Y7QUFDeEM7QUFDbUQ7QUFDbkQ7QUFDcUQ7QUFDdEU7QUFDMkI7O0FBRTFELHVCQUF1QixhQUFvQjtBQUMzQyw2QkFBNkIsR0FBRztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxpRkFBaUYsa0JBQWtCLGtCQUFrQix1Q0FBdUM7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLHFCQUFxQixhQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDhCQUE4QixTQUFTLElBQUksY0FBYztBQUN6RDtBQUNBOztBQUVBLDRCQUE0Qix3REFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0EsV0FBVyxDQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxjQUFjO0FBQ2QsY0FBYztBQUNkLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsK0JBQStCLG9CQUFvQjtBQUNuRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQiwrQkFBK0I7QUFDL0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLCtDQUFRO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUJBQXFCLDZDQUFNO0FBQzNCLG9CQUFvQiw2Q0FBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxpQkFBaUIsc0RBQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNEQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsS0FBcUMsaUJBQWlCLENBQVc7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEtBQXFDLDhEQUE4RCxDQUFXO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNEQUFPLENBQUMscURBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWU7QUFDZjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsV0FBVyxLQUFxQyxtRkFBbUYsQ0FBVztBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxhQUFhLEtBQXFDLGlCQUFpQixDQUFXO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSw2QkFBNkIscURBQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsS0FBcUMsZ0VBQWdFLENBQVc7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EscUNBQXFDLEtBQXFDLHVFQUF1RSxDQUFXO0FBQzVKLHdDQUF3QyxLQUFxQywwRkFBMEYsQ0FBVztBQUNsTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBcUMsb0ZBQW9GLENBQVc7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQXFDLDhHQUE4RyxDQUFXO0FBQ2hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsOENBQThDLHNEQUFPOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHFDQUFxQyxLQUFxQyxpQkFBaUIsQ0FBVztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFlBQVksS0FBcUMsMEVBQTBFLENBQVc7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBcUMscUdBQXFHLENBQVc7QUFDeEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSx1QkFBdUIsS0FBcUMsd0NBQXdDLENBQVc7QUFDL0c7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsSUFBSSxLQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQSxTQUFTLENBQU07QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQU87QUFDMUI7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtCQUFrQiwrQ0FBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9EQUFTO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxTQUFTLDBEQUFtQixDQUFDLHVEQUFjO0FBQzNDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9EQUFPO0FBQ2xDO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMERBQW1CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBEQUFtQixtQkFBbUIsOEVBQVEsR0FBRztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFFMUM7QUFDSDtBQUNBO0FBQ0EsVUFBVSxLQUFxQyxpQkFBaUIsQ0FBVztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUFxQztBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU8sQ0FBTTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBcUM7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyxDQUFNO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUscURBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQU07QUFDMUIsaUJBQWlCLHdEQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGVBQWUseURBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscURBQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9EQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRTRJIiwic291cmNlcyI6WyIvYXBwL25vZGVfbW9kdWxlcy9AaGVsbG8tcGFuZ2VhL2RuZC9kaXN0L2RuZC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NLCB7IGZsdXNoU3luYyB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBjcmVhdGVTdG9yZSBhcyBjcmVhdGVTdG9yZSQxLCBjb21wb3NlLCBhcHBseU1pZGRsZXdhcmUsIGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IFByb3ZpZGVyLCBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgZ2V0UmVjdCwgZXhwYW5kLCBvZmZzZXQsIHdpdGhTY3JvbGwsIGNhbGN1bGF0ZUJveCwgZ2V0Qm94LCBjcmVhdGVCb3ggfSBmcm9tICdjc3MtYm94LW1vZGVsJztcbmltcG9ydCByYWZTY2hkIGZyb20gJ3JhZi1zY2hkJztcbmltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcblxuY29uc3QgaXNQcm9kdWN0aW9uJDEgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuY29uc3Qgc3BhY2VzQW5kVGFicyA9IC9bIFxcdF17Mix9L2c7XG5jb25zdCBsaW5lU3RhcnRXaXRoU3BhY2VzID0gL15bIFxcdF0qL2dtO1xuY29uc3QgY2xlYW4kMiA9IHZhbHVlID0+IHZhbHVlLnJlcGxhY2Uoc3BhY2VzQW5kVGFicywgJyAnKS5yZXBsYWNlKGxpbmVTdGFydFdpdGhTcGFjZXMsICcnKS50cmltKCk7XG5jb25zdCBnZXREZXZNZXNzYWdlID0gbWVzc2FnZSA9PiBjbGVhbiQyKGBcbiAgJWNAaGVsbG8tcGFuZ2VhL2RuZFxuXG4gICVjJHtjbGVhbiQyKG1lc3NhZ2UpfVxuXG4gICVj8J+Rt+KAjSBUaGlzIGlzIGEgZGV2ZWxvcG1lbnQgb25seSBtZXNzYWdlLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMuXG5gKTtcbmNvbnN0IGdldEZvcm1hdHRlZE1lc3NhZ2UgPSBtZXNzYWdlID0+IFtnZXREZXZNZXNzYWdlKG1lc3NhZ2UpLCAnY29sb3I6ICMwMEM1ODQ7IGZvbnQtc2l6ZTogMS4yZW07IGZvbnQtd2VpZ2h0OiBib2xkOycsICdsaW5lLWhlaWdodDogMS41JywgJ2NvbG9yOiAjNzIzODc0OyddO1xuY29uc3QgaXNEaXNhYmxlZEZsYWcgPSAnX19AaGVsbG8tcGFuZ2VhL2RuZC1kaXNhYmxlLWRldi13YXJuaW5ncyc7XG5mdW5jdGlvbiBsb2codHlwZSwgbWVzc2FnZSkge1xuICBpZiAoaXNQcm9kdWN0aW9uJDEpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvd1tpc0Rpc2FibGVkRmxhZ10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZVt0eXBlXSguLi5nZXRGb3JtYXR0ZWRNZXNzYWdlKG1lc3NhZ2UpKTtcbn1cbmNvbnN0IHdhcm5pbmcgPSBsb2cuYmluZChudWxsLCAnd2FybicpO1xuY29uc3QgZXJyb3IgPSBsb2cuYmluZChudWxsLCAnZXJyb3InKTtcblxuZnVuY3Rpb24gbm9vcCQyKCkge31cblxuZnVuY3Rpb24gZ2V0T3B0aW9ucyhzaGFyZWQsIGZyb21CaW5kaW5nKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2hhcmVkLFxuICAgIC4uLmZyb21CaW5kaW5nXG4gIH07XG59XG5mdW5jdGlvbiBiaW5kRXZlbnRzKGVsLCBiaW5kaW5ncywgc2hhcmVkT3B0aW9ucykge1xuICBjb25zdCB1bmJpbmRpbmdzID0gYmluZGluZ3MubWFwKGJpbmRpbmcgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBnZXRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIGJpbmRpbmcub3B0aW9ucyk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihiaW5kaW5nLmV2ZW50TmFtZSwgYmluZGluZy5mbiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoYmluZGluZy5ldmVudE5hbWUsIGJpbmRpbmcuZm4sIG9wdGlvbnMpO1xuICAgIH07XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gdW5iaW5kQWxsKCkge1xuICAgIHVuYmluZGluZ3MuZm9yRWFjaCh1bmJpbmQgPT4ge1xuICAgICAgdW5iaW5kKCk7XG4gICAgfSk7XG4gIH07XG59XG5cbmNvbnN0IGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG5jb25zdCBwcmVmaXgkMSA9ICdJbnZhcmlhbnQgZmFpbGVkJztcbmNsYXNzIFJiZEludmFyaWFudCBleHRlbmRzIEVycm9yIHt9XG5SYmRJbnZhcmlhbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0aGlzLm1lc3NhZ2U7XG59O1xuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgdGhyb3cgbmV3IFJiZEludmFyaWFudChwcmVmaXgkMSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJiZEludmFyaWFudChgJHtwcmVmaXgkMX06ICR7bWVzc2FnZSB8fCAnJ31gKTtcbiAgfVxufVxuXG5jbGFzcyBFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLnVuYmluZCA9IG5vb3AkMjtcbiAgICB0aGlzLm9uV2luZG93RXJyb3IgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmdldENhbGxiYWNrcygpO1xuICAgICAgaWYgKGNhbGxiYWNrcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgY2FsbGJhY2tzLnRyeUFib3J0KCk7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgICBBbiBlcnJvciB3YXMgY2F1Z2h0IGJ5IG91ciB3aW5kb3cgJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB3aGlsZSBhIGRyYWcgd2FzIG9jY3VycmluZy5cbiAgICAgICAgVGhlIGFjdGl2ZSBkcmFnIGhhcyBiZWVuIGFib3J0ZWQuXG4gICAgICBgKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVyciA9IGV2ZW50LmVycm9yO1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFJiZEludmFyaWFudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRDYWxsYmFja3MgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgQXBwQ2FsbGJhY2tzIGluIDxFcnJvckJvdW5kYXJ5Lz4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhbGxiYWNrcztcbiAgICB9O1xuICAgIHRoaXMuc2V0Q2FsbGJhY2tzID0gY2FsbGJhY2tzID0+IHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51bmJpbmQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW3tcbiAgICAgIGV2ZW50TmFtZTogJ2Vycm9yJyxcbiAgICAgIGZuOiB0aGlzLm9uV2luZG93RXJyb3JcbiAgICB9XSk7XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFJiZEludmFyaWFudCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7fSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnVuYmluZCgpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLnNldENhbGxiYWNrcyk7XG4gIH1cbn1cblxuY29uc3QgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zID0gYFxuICBQcmVzcyBzcGFjZSBiYXIgdG8gc3RhcnQgYSBkcmFnLlxuICBXaGVuIGRyYWdnaW5nIHlvdSBjYW4gdXNlIHRoZSBhcnJvdyBrZXlzIHRvIG1vdmUgdGhlIGl0ZW0gYXJvdW5kIGFuZCBlc2NhcGUgdG8gY2FuY2VsLlxuICBTb21lIHNjcmVlbiByZWFkZXJzIG1heSByZXF1aXJlIHlvdSB0byBiZSBpbiBmb2N1cyBtb2RlIG9yIHRvIHVzZSB5b3VyIHBhc3MgdGhyb3VnaCBrZXlcbmA7XG5jb25zdCBwb3NpdGlvbiA9IGluZGV4ID0+IGluZGV4ICsgMTtcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gc3RhcnQgPT4gYFxuICBZb3UgaGF2ZSBsaWZ0ZWQgYW4gaXRlbSBpbiBwb3NpdGlvbiAke3Bvc2l0aW9uKHN0YXJ0LnNvdXJjZS5pbmRleCl9XG5gO1xuY29uc3Qgd2l0aExvY2F0aW9uID0gKHNvdXJjZSwgZGVzdGluYXRpb24pID0+IHtcbiAgY29uc3QgaXNJbkhvbWVMaXN0ID0gc291cmNlLmRyb3BwYWJsZUlkID09PSBkZXN0aW5hdGlvbi5kcm9wcGFibGVJZDtcbiAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IHBvc2l0aW9uKHNvdXJjZS5pbmRleCk7XG4gIGNvbnN0IGVuZFBvc2l0aW9uID0gcG9zaXRpb24oZGVzdGluYXRpb24uaW5kZXgpO1xuICBpZiAoaXNJbkhvbWVMaXN0KSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIFlvdSBoYXZlIG1vdmVkIHRoZSBpdGVtIGZyb20gcG9zaXRpb24gJHtzdGFydFBvc2l0aW9ufVxuICAgICAgdG8gcG9zaXRpb24gJHtlbmRQb3NpdGlvbn1cbiAgICBgO1xuICB9XG4gIHJldHVybiBgXG4gICAgWW91IGhhdmUgbW92ZWQgdGhlIGl0ZW0gZnJvbSBwb3NpdGlvbiAke3N0YXJ0UG9zaXRpb259XG4gICAgaW4gbGlzdCAke3NvdXJjZS5kcm9wcGFibGVJZH1cbiAgICB0byBsaXN0ICR7ZGVzdGluYXRpb24uZHJvcHBhYmxlSWR9XG4gICAgaW4gcG9zaXRpb24gJHtlbmRQb3NpdGlvbn1cbiAgYDtcbn07XG5jb25zdCB3aXRoQ29tYmluZSA9IChpZCwgc291cmNlLCBjb21iaW5lKSA9PiB7XG4gIGNvbnN0IGluSG9tZUxpc3QgPSBzb3VyY2UuZHJvcHBhYmxlSWQgPT09IGNvbWJpbmUuZHJvcHBhYmxlSWQ7XG4gIGlmIChpbkhvbWVMaXN0KSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIFRoZSBpdGVtICR7aWR9XG4gICAgICBoYXMgYmVlbiBjb21iaW5lZCB3aXRoICR7Y29tYmluZS5kcmFnZ2FibGVJZH1gO1xuICB9XG4gIHJldHVybiBgXG4gICAgICBUaGUgaXRlbSAke2lkfVxuICAgICAgaW4gbGlzdCAke3NvdXJjZS5kcm9wcGFibGVJZH1cbiAgICAgIGhhcyBiZWVuIGNvbWJpbmVkIHdpdGggJHtjb21iaW5lLmRyYWdnYWJsZUlkfVxuICAgICAgaW4gbGlzdCAke2NvbWJpbmUuZHJvcHBhYmxlSWR9XG4gICAgYDtcbn07XG5jb25zdCBvbkRyYWdVcGRhdGUgPSB1cGRhdGUgPT4ge1xuICBjb25zdCBsb2NhdGlvbiA9IHVwZGF0ZS5kZXN0aW5hdGlvbjtcbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIHdpdGhMb2NhdGlvbih1cGRhdGUuc291cmNlLCBsb2NhdGlvbik7XG4gIH1cbiAgY29uc3QgY29tYmluZSA9IHVwZGF0ZS5jb21iaW5lO1xuICBpZiAoY29tYmluZSkge1xuICAgIHJldHVybiB3aXRoQ29tYmluZSh1cGRhdGUuZHJhZ2dhYmxlSWQsIHVwZGF0ZS5zb3VyY2UsIGNvbWJpbmUpO1xuICB9XG4gIHJldHVybiAnWW91IGFyZSBvdmVyIGFuIGFyZWEgdGhhdCBjYW5ub3QgYmUgZHJvcHBlZCBvbic7XG59O1xuY29uc3QgcmV0dXJuZWRUb1N0YXJ0ID0gc291cmNlID0+IGBcbiAgVGhlIGl0ZW0gaGFzIHJldHVybmVkIHRvIGl0cyBzdGFydGluZyBwb3NpdGlvblxuICBvZiAke3Bvc2l0aW9uKHNvdXJjZS5pbmRleCl9XG5gO1xuY29uc3Qgb25EcmFnRW5kID0gcmVzdWx0ID0+IHtcbiAgaWYgKHJlc3VsdC5yZWFzb24gPT09ICdDQU5DRUwnKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIE1vdmVtZW50IGNhbmNlbGxlZC5cbiAgICAgICR7cmV0dXJuZWRUb1N0YXJ0KHJlc3VsdC5zb3VyY2UpfVxuICAgIGA7XG4gIH1cbiAgY29uc3QgbG9jYXRpb24gPSByZXN1bHQuZGVzdGluYXRpb247XG4gIGNvbnN0IGNvbWJpbmUgPSByZXN1bHQuY29tYmluZTtcbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIFlvdSBoYXZlIGRyb3BwZWQgdGhlIGl0ZW0uXG4gICAgICAke3dpdGhMb2NhdGlvbihyZXN1bHQuc291cmNlLCBsb2NhdGlvbil9XG4gICAgYDtcbiAgfVxuICBpZiAoY29tYmluZSkge1xuICAgIHJldHVybiBgXG4gICAgICBZb3UgaGF2ZSBkcm9wcGVkIHRoZSBpdGVtLlxuICAgICAgJHt3aXRoQ29tYmluZShyZXN1bHQuZHJhZ2dhYmxlSWQsIHJlc3VsdC5zb3VyY2UsIGNvbWJpbmUpfVxuICAgIGA7XG4gIH1cbiAgcmV0dXJuIGBcbiAgICBUaGUgaXRlbSBoYXMgYmVlbiBkcm9wcGVkIHdoaWxlIG5vdCBvdmVyIGEgZHJvcCBhcmVhLlxuICAgICR7cmV0dXJuZWRUb1N0YXJ0KHJlc3VsdC5zb3VyY2UpfVxuICBgO1xufTtcbmNvbnN0IHByZXNldCA9IHtcbiAgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zLFxuICBvbkRyYWdTdGFydCxcbiAgb25EcmFnVXBkYXRlLFxuICBvbkRyYWdFbmRcbn07XG5cbmZ1bmN0aW9uIGlzRXF1YWwkMihmaXJzdCwgc2Vjb25kKSB7XG4gIGlmIChmaXJzdCA9PT0gc2Vjb25kKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKE51bWJlci5pc05hTihmaXJzdCkgJiYgTnVtYmVyLmlzTmFOKHNlY29uZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhcmVJbnB1dHNFcXVhbChuZXdJbnB1dHMsIGxhc3RJbnB1dHMpIHtcbiAgaWYgKG5ld0lucHV0cy5sZW5ndGggIT09IGxhc3RJbnB1dHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3SW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFpc0VxdWFsJDIobmV3SW5wdXRzW2ldLCBsYXN0SW5wdXRzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdXNlTWVtbyhnZXRSZXN1bHQsIGlucHV0cykge1xuICBjb25zdCBpbml0aWFsID0gdXNlU3RhdGUoKCkgPT4gKHtcbiAgICBpbnB1dHMsXG4gICAgcmVzdWx0OiBnZXRSZXN1bHQoKVxuICB9KSlbMF07XG4gIGNvbnN0IGlzRmlyc3RSdW4gPSB1c2VSZWYodHJ1ZSk7XG4gIGNvbnN0IGNvbW1pdHRlZCA9IHVzZVJlZihpbml0aWFsKTtcbiAgY29uc3QgdXNlQ2FjaGUgPSBpc0ZpcnN0UnVuLmN1cnJlbnQgfHwgQm9vbGVhbihpbnB1dHMgJiYgY29tbWl0dGVkLmN1cnJlbnQuaW5wdXRzICYmIGFyZUlucHV0c0VxdWFsKGlucHV0cywgY29tbWl0dGVkLmN1cnJlbnQuaW5wdXRzKSk7XG4gIGNvbnN0IGNhY2hlID0gdXNlQ2FjaGUgPyBjb21taXR0ZWQuY3VycmVudCA6IHtcbiAgICBpbnB1dHMsXG4gICAgcmVzdWx0OiBnZXRSZXN1bHQoKVxuICB9O1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlzRmlyc3RSdW4uY3VycmVudCA9IGZhbHNlO1xuICAgIGNvbW1pdHRlZC5jdXJyZW50ID0gY2FjaGU7XG4gIH0sIFtjYWNoZV0pO1xuICByZXR1cm4gY2FjaGUucmVzdWx0O1xufVxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGlucHV0cykge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiBjYWxsYmFjaywgaW5wdXRzKTtcbn1cblxuY29uc3Qgb3JpZ2luID0ge1xuICB4OiAwLFxuICB5OiAwXG59O1xuY29uc3QgYWRkID0gKHBvaW50MSwgcG9pbnQyKSA9PiAoe1xuICB4OiBwb2ludDEueCArIHBvaW50Mi54LFxuICB5OiBwb2ludDEueSArIHBvaW50Mi55XG59KTtcbmNvbnN0IHN1YnRyYWN0ID0gKHBvaW50MSwgcG9pbnQyKSA9PiAoe1xuICB4OiBwb2ludDEueCAtIHBvaW50Mi54LFxuICB5OiBwb2ludDEueSAtIHBvaW50Mi55XG59KTtcbmNvbnN0IGlzRXF1YWwkMSA9IChwb2ludDEsIHBvaW50MikgPT4gcG9pbnQxLnggPT09IHBvaW50Mi54ICYmIHBvaW50MS55ID09PSBwb2ludDIueTtcbmNvbnN0IG5lZ2F0ZSA9IHBvaW50ID0+ICh7XG4gIHg6IHBvaW50LnggIT09IDAgPyAtcG9pbnQueCA6IDAsXG4gIHk6IHBvaW50LnkgIT09IDAgPyAtcG9pbnQueSA6IDBcbn0pO1xuY29uc3QgcGF0Y2ggPSAobGluZSwgdmFsdWUsIG90aGVyVmFsdWUgPSAwKSA9PiB7XG4gIGlmIChsaW5lID09PSAneCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdmFsdWUsXG4gICAgICB5OiBvdGhlclZhbHVlXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IG90aGVyVmFsdWUsXG4gICAgeTogdmFsdWVcbiAgfTtcbn07XG5jb25zdCBkaXN0YW5jZSA9IChwb2ludDEsIHBvaW50MikgPT4gTWF0aC5zcXJ0KChwb2ludDIueCAtIHBvaW50MS54KSAqKiAyICsgKHBvaW50Mi55IC0gcG9pbnQxLnkpICoqIDIpO1xuY29uc3QgY2xvc2VzdCQxID0gKHRhcmdldCwgcG9pbnRzKSA9PiBNYXRoLm1pbiguLi5wb2ludHMubWFwKHBvaW50ID0+IGRpc3RhbmNlKHRhcmdldCwgcG9pbnQpKSk7XG5jb25zdCBhcHBseSA9IGZuID0+IHBvaW50ID0+ICh7XG4gIHg6IGZuKHBvaW50LngpLFxuICB5OiBmbihwb2ludC55KVxufSk7XG5cbnZhciBleGVjdXRlQ2xpcCA9IChmcmFtZSwgc3ViamVjdCkgPT4ge1xuICBjb25zdCByZXN1bHQgPSBnZXRSZWN0KHtcbiAgICB0b3A6IE1hdGgubWF4KHN1YmplY3QudG9wLCBmcmFtZS50b3ApLFxuICAgIHJpZ2h0OiBNYXRoLm1pbihzdWJqZWN0LnJpZ2h0LCBmcmFtZS5yaWdodCksXG4gICAgYm90dG9tOiBNYXRoLm1pbihzdWJqZWN0LmJvdHRvbSwgZnJhbWUuYm90dG9tKSxcbiAgICBsZWZ0OiBNYXRoLm1heChzdWJqZWN0LmxlZnQsIGZyYW1lLmxlZnQpXG4gIH0pO1xuICBpZiAocmVzdWx0LndpZHRoIDw9IDAgfHwgcmVzdWx0LmhlaWdodCA8PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IG9mZnNldEJ5UG9zaXRpb24gPSAoc3BhY2luZywgcG9pbnQpID0+ICh7XG4gIHRvcDogc3BhY2luZy50b3AgKyBwb2ludC55LFxuICBsZWZ0OiBzcGFjaW5nLmxlZnQgKyBwb2ludC54LFxuICBib3R0b206IHNwYWNpbmcuYm90dG9tICsgcG9pbnQueSxcbiAgcmlnaHQ6IHNwYWNpbmcucmlnaHQgKyBwb2ludC54XG59KTtcbmNvbnN0IGdldENvcm5lcnMgPSBzcGFjaW5nID0+IFt7XG4gIHg6IHNwYWNpbmcubGVmdCxcbiAgeTogc3BhY2luZy50b3Bcbn0sIHtcbiAgeDogc3BhY2luZy5yaWdodCxcbiAgeTogc3BhY2luZy50b3Bcbn0sIHtcbiAgeDogc3BhY2luZy5sZWZ0LFxuICB5OiBzcGFjaW5nLmJvdHRvbVxufSwge1xuICB4OiBzcGFjaW5nLnJpZ2h0LFxuICB5OiBzcGFjaW5nLmJvdHRvbVxufV07XG5jb25zdCBub1NwYWNpbmcgPSB7XG4gIHRvcDogMCxcbiAgcmlnaHQ6IDAsXG4gIGJvdHRvbTogMCxcbiAgbGVmdDogMFxufTtcblxuY29uc3Qgc2Nyb2xsJDEgPSAodGFyZ2V0LCBmcmFtZSkgPT4ge1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gb2Zmc2V0QnlQb3NpdGlvbih0YXJnZXQsIGZyYW1lLnNjcm9sbC5kaWZmLmRpc3BsYWNlbWVudCk7XG59O1xuY29uc3QgaW5jcmVhc2UgPSAodGFyZ2V0LCBheGlzLCB3aXRoUGxhY2Vob2xkZXIpID0+IHtcbiAgaWYgKHdpdGhQbGFjZWhvbGRlciAmJiB3aXRoUGxhY2Vob2xkZXIuaW5jcmVhc2VkQnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgW2F4aXMuZW5kXTogdGFyZ2V0W2F4aXMuZW5kXSArIHdpdGhQbGFjZWhvbGRlci5pbmNyZWFzZWRCeVtheGlzLmxpbmVdXG4gICAgfTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbmNvbnN0IGNsaXAgPSAodGFyZ2V0LCBmcmFtZSkgPT4ge1xuICBpZiAoZnJhbWUgJiYgZnJhbWUuc2hvdWxkQ2xpcFN1YmplY3QpIHtcbiAgICByZXR1cm4gZXhlY3V0ZUNsaXAoZnJhbWUucGFnZU1hcmdpbkJveCwgdGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gZ2V0UmVjdCh0YXJnZXQpO1xufTtcbnZhciBnZXRTdWJqZWN0ID0gKHtcbiAgcGFnZSxcbiAgd2l0aFBsYWNlaG9sZGVyLFxuICBheGlzLFxuICBmcmFtZVxufSkgPT4ge1xuICBjb25zdCBzY3JvbGxlZCA9IHNjcm9sbCQxKHBhZ2UubWFyZ2luQm94LCBmcmFtZSk7XG4gIGNvbnN0IGluY3JlYXNlZCA9IGluY3JlYXNlKHNjcm9sbGVkLCBheGlzLCB3aXRoUGxhY2Vob2xkZXIpO1xuICBjb25zdCBjbGlwcGVkID0gY2xpcChpbmNyZWFzZWQsIGZyYW1lKTtcbiAgcmV0dXJuIHtcbiAgICBwYWdlLFxuICAgIHdpdGhQbGFjZWhvbGRlcixcbiAgICBhY3RpdmU6IGNsaXBwZWRcbiAgfTtcbn07XG5cbnZhciBzY3JvbGxEcm9wcGFibGUgPSAoZHJvcHBhYmxlLCBuZXdTY3JvbGwpID0+IHtcbiAgIWRyb3BwYWJsZS5mcmFtZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudCgpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IHNjcm9sbGFibGUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGNvbnN0IHNjcm9sbERpZmYgPSBzdWJ0cmFjdChuZXdTY3JvbGwsIHNjcm9sbGFibGUuc2Nyb2xsLmluaXRpYWwpO1xuICBjb25zdCBzY3JvbGxEaXNwbGFjZW1lbnQgPSBuZWdhdGUoc2Nyb2xsRGlmZik7XG4gIGNvbnN0IGZyYW1lID0ge1xuICAgIC4uLnNjcm9sbGFibGUsXG4gICAgc2Nyb2xsOiB7XG4gICAgICBpbml0aWFsOiBzY3JvbGxhYmxlLnNjcm9sbC5pbml0aWFsLFxuICAgICAgY3VycmVudDogbmV3U2Nyb2xsLFxuICAgICAgZGlmZjoge1xuICAgICAgICB2YWx1ZTogc2Nyb2xsRGlmZixcbiAgICAgICAgZGlzcGxhY2VtZW50OiBzY3JvbGxEaXNwbGFjZW1lbnRcbiAgICAgIH0sXG4gICAgICBtYXg6IHNjcm9sbGFibGUuc2Nyb2xsLm1heFxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgd2l0aFBsYWNlaG9sZGVyOiBkcm9wcGFibGUuc3ViamVjdC53aXRoUGxhY2Vob2xkZXIsXG4gICAgYXhpczogZHJvcHBhYmxlLmF4aXMsXG4gICAgZnJhbWVcbiAgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAuLi5kcm9wcGFibGUsXG4gICAgZnJhbWUsXG4gICAgc3ViamVjdFxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gbWVtb2l6ZU9uZShyZXN1bHRGbiwgaXNFcXVhbCA9IGFyZUlucHV0c0VxdWFsKSB7XG4gIGxldCBjYWNoZSA9IG51bGw7XG4gIGZ1bmN0aW9uIG1lbW9pemVkKC4uLm5ld0FyZ3MpIHtcbiAgICBpZiAoY2FjaGUgJiYgY2FjaGUubGFzdFRoaXMgPT09IHRoaXMgJiYgaXNFcXVhbChuZXdBcmdzLCBjYWNoZS5sYXN0QXJncykpIHtcbiAgICAgIHJldHVybiBjYWNoZS5sYXN0UmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBsYXN0UmVzdWx0ID0gcmVzdWx0Rm4uYXBwbHkodGhpcywgbmV3QXJncyk7XG4gICAgY2FjaGUgPSB7XG4gICAgICBsYXN0UmVzdWx0LFxuICAgICAgbGFzdEFyZ3M6IG5ld0FyZ3MsXG4gICAgICBsYXN0VGhpczogdGhpc1xuICAgIH07XG4gICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gIH1cbiAgbWVtb2l6ZWQuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBjYWNoZSA9IG51bGw7XG4gIH07XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuY29uc3QgdG9Ecm9wcGFibGVNYXAgPSBtZW1vaXplT25lKGRyb3BwYWJsZXMgPT4gZHJvcHBhYmxlcy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiB7XG4gIHByZXZpb3VzW2N1cnJlbnQuZGVzY3JpcHRvci5pZF0gPSBjdXJyZW50O1xuICByZXR1cm4gcHJldmlvdXM7XG59LCB7fSkpO1xuY29uc3QgdG9EcmFnZ2FibGVNYXAgPSBtZW1vaXplT25lKGRyYWdnYWJsZXMgPT4gZHJhZ2dhYmxlcy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiB7XG4gIHByZXZpb3VzW2N1cnJlbnQuZGVzY3JpcHRvci5pZF0gPSBjdXJyZW50O1xuICByZXR1cm4gcHJldmlvdXM7XG59LCB7fSkpO1xuY29uc3QgdG9Ecm9wcGFibGVMaXN0ID0gbWVtb2l6ZU9uZShkcm9wcGFibGVzID0+IE9iamVjdC52YWx1ZXMoZHJvcHBhYmxlcykpO1xuY29uc3QgdG9EcmFnZ2FibGVMaXN0ID0gbWVtb2l6ZU9uZShkcmFnZ2FibGVzID0+IE9iamVjdC52YWx1ZXMoZHJhZ2dhYmxlcykpO1xuXG52YXIgZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZSA9IG1lbW9pemVPbmUoKGRyb3BwYWJsZUlkLCBkcmFnZ2FibGVzKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IHRvRHJhZ2dhYmxlTGlzdChkcmFnZ2FibGVzKS5maWx0ZXIoZHJhZ2dhYmxlID0+IGRyb3BwYWJsZUlkID09PSBkcmFnZ2FibGUuZGVzY3JpcHRvci5kcm9wcGFibGVJZCkuc29ydCgoYSwgYikgPT4gYS5kZXNjcmlwdG9yLmluZGV4IC0gYi5kZXNjcmlwdG9yLmluZGV4KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5mdW5jdGlvbiB0cnlHZXREZXN0aW5hdGlvbihpbXBhY3QpIHtcbiAgaWYgKGltcGFjdC5hdCAmJiBpbXBhY3QuYXQudHlwZSA9PT0gJ1JFT1JERVInKSB7XG4gICAgcmV0dXJuIGltcGFjdC5hdC5kZXN0aW5hdGlvbjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHRyeUdldENvbWJpbmUoaW1wYWN0KSB7XG4gIGlmIChpbXBhY3QuYXQgJiYgaW1wYWN0LmF0LnR5cGUgPT09ICdDT01CSU5FJykge1xuICAgIHJldHVybiBpbXBhY3QuYXQuY29tYmluZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIHJlbW92ZURyYWdnYWJsZUZyb21MaXN0ID0gbWVtb2l6ZU9uZSgocmVtb3ZlLCBsaXN0KSA9PiBsaXN0LmZpbHRlcihpdGVtID0+IGl0ZW0uZGVzY3JpcHRvci5pZCAhPT0gcmVtb3ZlLmRlc2NyaXB0b3IuaWQpKTtcblxudmFyIG1vdmVUb05leHRDb21iaW5lID0gKHtcbiAgaXNNb3ZpbmdGb3J3YXJkLFxuICBkcmFnZ2FibGUsXG4gIGRlc3RpbmF0aW9uLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgcHJldmlvdXNJbXBhY3Rcbn0pID0+IHtcbiAgaWYgKCFkZXN0aW5hdGlvbi5pc0NvbWJpbmVFbmFibGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbG9jYXRpb24gPSB0cnlHZXREZXN0aW5hdGlvbihwcmV2aW91c0ltcGFjdCk7XG4gIGlmICghbG9jYXRpb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBnZXRJbXBhY3QodGFyZ2V0KSB7XG4gICAgY29uc3QgYXQgPSB7XG4gICAgICB0eXBlOiAnQ09NQklORScsXG4gICAgICBjb21iaW5lOiB7XG4gICAgICAgIGRyYWdnYWJsZUlkOiB0YXJnZXQsXG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucHJldmlvdXNJbXBhY3QsXG4gICAgICBhdFxuICAgIH07XG4gIH1cbiAgY29uc3QgYWxsID0gcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLmFsbDtcbiAgY29uc3QgY2xvc2VzdElkID0gYWxsLmxlbmd0aCA/IGFsbFswXSA6IG51bGw7XG4gIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICByZXR1cm4gY2xvc2VzdElkID8gZ2V0SW1wYWN0KGNsb3Nlc3RJZCkgOiBudWxsO1xuICB9XG4gIGNvbnN0IHdpdGhvdXREcmFnZ2FibGUgPSByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdChkcmFnZ2FibGUsIGluc2lkZURlc3RpbmF0aW9uKTtcbiAgaWYgKCFjbG9zZXN0SWQpIHtcbiAgICBpZiAoIXdpdGhvdXREcmFnZ2FibGUubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGFzdCA9IHdpdGhvdXREcmFnZ2FibGVbd2l0aG91dERyYWdnYWJsZS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gZ2V0SW1wYWN0KGxhc3QuZGVzY3JpcHRvci5pZCk7XG4gIH1cbiAgY29uc3QgaW5kZXhPZkNsb3Nlc3QgPSB3aXRob3V0RHJhZ2dhYmxlLmZpbmRJbmRleChkID0+IGQuZGVzY3JpcHRvci5pZCA9PT0gY2xvc2VzdElkKTtcbiAgIShpbmRleE9mQ2xvc2VzdCAhPT0gLTEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgZGlzcGxhY2VkIGl0ZW0gaW4gc2V0JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3QgcHJvcG9zZWRJbmRleCA9IGluZGV4T2ZDbG9zZXN0IC0gMTtcbiAgaWYgKHByb3Bvc2VkSW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYmVmb3JlID0gd2l0aG91dERyYWdnYWJsZVtwcm9wb3NlZEluZGV4XTtcbiAgcmV0dXJuIGdldEltcGFjdChiZWZvcmUuZGVzY3JpcHRvci5pZCk7XG59O1xuXG52YXIgaXNIb21lT2YgPSAoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbikgPT4gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQgPT09IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQ7XG5cbmNvbnN0IG5vRGlzcGxhY2VkQnkgPSB7XG4gIHBvaW50OiBvcmlnaW4sXG4gIHZhbHVlOiAwXG59O1xuY29uc3QgZW1wdHlHcm91cHMgPSB7XG4gIGludmlzaWJsZToge30sXG4gIHZpc2libGU6IHt9LFxuICBhbGw6IFtdXG59O1xuY29uc3Qgbm9JbXBhY3QgPSB7XG4gIGRpc3BsYWNlZDogZW1wdHlHcm91cHMsXG4gIGRpc3BsYWNlZEJ5OiBub0Rpc3BsYWNlZEJ5LFxuICBhdDogbnVsbFxufTtcblxudmFyIGlzV2l0aGluID0gKGxvd2VyQm91bmQsIHVwcGVyQm91bmQpID0+IHZhbHVlID0+IGxvd2VyQm91bmQgPD0gdmFsdWUgJiYgdmFsdWUgPD0gdXBwZXJCb3VuZDtcblxudmFyIGlzUGFydGlhbGx5VmlzaWJsZVRocm91Z2hGcmFtZSA9IGZyYW1lID0+IHtcbiAgY29uc3QgaXNXaXRoaW5WZXJ0aWNhbCA9IGlzV2l0aGluKGZyYW1lLnRvcCwgZnJhbWUuYm90dG9tKTtcbiAgY29uc3QgaXNXaXRoaW5Ib3Jpem9udGFsID0gaXNXaXRoaW4oZnJhbWUubGVmdCwgZnJhbWUucmlnaHQpO1xuICByZXR1cm4gc3ViamVjdCA9PiB7XG4gICAgY29uc3QgaXNDb250YWluZWQgPSBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QudG9wKSAmJiBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QuYm90dG9tKSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5sZWZ0KSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5yaWdodCk7XG4gICAgaWYgKGlzQ29udGFpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgaXNQYXJ0aWFsbHlWaXNpYmxlVmVydGljYWxseSA9IGlzV2l0aGluVmVydGljYWwoc3ViamVjdC50b3ApIHx8IGlzV2l0aGluVmVydGljYWwoc3ViamVjdC5ib3R0b20pO1xuICAgIGNvbnN0IGlzUGFydGlhbGx5VmlzaWJsZUhvcml6b250YWxseSA9IGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LmxlZnQpIHx8IGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LnJpZ2h0KTtcbiAgICBjb25zdCBpc1BhcnRpYWxseUNvbnRhaW5lZCA9IGlzUGFydGlhbGx5VmlzaWJsZVZlcnRpY2FsbHkgJiYgaXNQYXJ0aWFsbHlWaXNpYmxlSG9yaXpvbnRhbGx5O1xuICAgIGlmIChpc1BhcnRpYWxseUNvbnRhaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGlzQmlnZ2VyVmVydGljYWxseSA9IHN1YmplY3QudG9wIDwgZnJhbWUudG9wICYmIHN1YmplY3QuYm90dG9tID4gZnJhbWUuYm90dG9tO1xuICAgIGNvbnN0IGlzQmlnZ2VySG9yaXpvbnRhbGx5ID0gc3ViamVjdC5sZWZ0IDwgZnJhbWUubGVmdCAmJiBzdWJqZWN0LnJpZ2h0ID4gZnJhbWUucmlnaHQ7XG4gICAgY29uc3QgaXNUYXJnZXRCaWdnZXJUaGFuRnJhbWUgPSBpc0JpZ2dlclZlcnRpY2FsbHkgJiYgaXNCaWdnZXJIb3Jpem9udGFsbHk7XG4gICAgaWYgKGlzVGFyZ2V0QmlnZ2VyVGhhbkZyYW1lKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgaXNUYXJnZXRCaWdnZXJPbk9uZUF4aXMgPSBpc0JpZ2dlclZlcnRpY2FsbHkgJiYgaXNQYXJ0aWFsbHlWaXNpYmxlSG9yaXpvbnRhbGx5IHx8IGlzQmlnZ2VySG9yaXpvbnRhbGx5ICYmIGlzUGFydGlhbGx5VmlzaWJsZVZlcnRpY2FsbHk7XG4gICAgcmV0dXJuIGlzVGFyZ2V0QmlnZ2VyT25PbmVBeGlzO1xuICB9O1xufTtcblxudmFyIGlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWUgPSBmcmFtZSA9PiB7XG4gIGNvbnN0IGlzV2l0aGluVmVydGljYWwgPSBpc1dpdGhpbihmcmFtZS50b3AsIGZyYW1lLmJvdHRvbSk7XG4gIGNvbnN0IGlzV2l0aGluSG9yaXpvbnRhbCA9IGlzV2l0aGluKGZyYW1lLmxlZnQsIGZyYW1lLnJpZ2h0KTtcbiAgcmV0dXJuIHN1YmplY3QgPT4ge1xuICAgIGNvbnN0IGlzQ29udGFpbmVkID0gaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LnRvcCkgJiYgaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LmJvdHRvbSkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QubGVmdCkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QucmlnaHQpO1xuICAgIHJldHVybiBpc0NvbnRhaW5lZDtcbiAgfTtcbn07XG5cbmNvbnN0IHZlcnRpY2FsID0ge1xuICBkaXJlY3Rpb246ICd2ZXJ0aWNhbCcsXG4gIGxpbmU6ICd5JyxcbiAgY3Jvc3NBeGlzTGluZTogJ3gnLFxuICBzdGFydDogJ3RvcCcsXG4gIGVuZDogJ2JvdHRvbScsXG4gIHNpemU6ICdoZWlnaHQnLFxuICBjcm9zc0F4aXNTdGFydDogJ2xlZnQnLFxuICBjcm9zc0F4aXNFbmQ6ICdyaWdodCcsXG4gIGNyb3NzQXhpc1NpemU6ICd3aWR0aCdcbn07XG5jb25zdCBob3Jpem9udGFsID0ge1xuICBkaXJlY3Rpb246ICdob3Jpem9udGFsJyxcbiAgbGluZTogJ3gnLFxuICBjcm9zc0F4aXNMaW5lOiAneScsXG4gIHN0YXJ0OiAnbGVmdCcsXG4gIGVuZDogJ3JpZ2h0JyxcbiAgc2l6ZTogJ3dpZHRoJyxcbiAgY3Jvc3NBeGlzU3RhcnQ6ICd0b3AnLFxuICBjcm9zc0F4aXNFbmQ6ICdib3R0b20nLFxuICBjcm9zc0F4aXNTaXplOiAnaGVpZ2h0J1xufTtcblxudmFyIGlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWVPbkF4aXMgPSBheGlzID0+IGZyYW1lID0+IHtcbiAgY29uc3QgaXNXaXRoaW5WZXJ0aWNhbCA9IGlzV2l0aGluKGZyYW1lLnRvcCwgZnJhbWUuYm90dG9tKTtcbiAgY29uc3QgaXNXaXRoaW5Ib3Jpem9udGFsID0gaXNXaXRoaW4oZnJhbWUubGVmdCwgZnJhbWUucmlnaHQpO1xuICByZXR1cm4gc3ViamVjdCA9PiB7XG4gICAgaWYgKGF4aXMgPT09IHZlcnRpY2FsKSB7XG4gICAgICByZXR1cm4gaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LnRvcCkgJiYgaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LmJvdHRvbSk7XG4gICAgfVxuICAgIHJldHVybiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5sZWZ0KSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5yaWdodCk7XG4gIH07XG59O1xuXG5jb25zdCBnZXREcm9wcGFibGVEaXNwbGFjZWQgPSAodGFyZ2V0LCBkZXN0aW5hdGlvbikgPT4ge1xuICBjb25zdCBkaXNwbGFjZW1lbnQgPSBkZXN0aW5hdGlvbi5mcmFtZSA/IGRlc3RpbmF0aW9uLmZyYW1lLnNjcm9sbC5kaWZmLmRpc3BsYWNlbWVudCA6IG9yaWdpbjtcbiAgcmV0dXJuIG9mZnNldEJ5UG9zaXRpb24odGFyZ2V0LCBkaXNwbGFjZW1lbnQpO1xufTtcbmNvbnN0IGlzVmlzaWJsZUluRHJvcHBhYmxlID0gKHRhcmdldCwgZGVzdGluYXRpb24sIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKSA9PiB7XG4gIGlmICghZGVzdGluYXRpb24uc3ViamVjdC5hY3RpdmUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKGRlc3RpbmF0aW9uLnN1YmplY3QuYWN0aXZlKSh0YXJnZXQpO1xufTtcbmNvbnN0IGlzVmlzaWJsZUluVmlld3BvcnQgPSAodGFyZ2V0LCB2aWV3cG9ydCwgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4pID0+IGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKHZpZXdwb3J0KSh0YXJnZXQpO1xuY29uc3QgaXNWaXNpYmxlJDEgPSAoe1xuICB0YXJnZXQ6IHRvQmVEaXNwbGFjZWQsXG4gIGRlc3RpbmF0aW9uLFxuICB2aWV3cG9ydCxcbiAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCxcbiAgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm5cbn0pID0+IHtcbiAgY29uc3QgZGlzcGxhY2VkVGFyZ2V0ID0gd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCA/IGdldERyb3BwYWJsZURpc3BsYWNlZCh0b0JlRGlzcGxhY2VkLCBkZXN0aW5hdGlvbikgOiB0b0JlRGlzcGxhY2VkO1xuICByZXR1cm4gaXNWaXNpYmxlSW5Ecm9wcGFibGUoZGlzcGxhY2VkVGFyZ2V0LCBkZXN0aW5hdGlvbiwgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4pICYmIGlzVmlzaWJsZUluVmlld3BvcnQoZGlzcGxhY2VkVGFyZ2V0LCB2aWV3cG9ydCwgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4pO1xufTtcbmNvbnN0IGlzUGFydGlhbGx5VmlzaWJsZSA9IGFyZ3MgPT4gaXNWaXNpYmxlJDEoe1xuICAuLi5hcmdzLFxuICBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbjogaXNQYXJ0aWFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lXG59KTtcbmNvbnN0IGlzVG90YWxseVZpc2libGUgPSBhcmdzID0+IGlzVmlzaWJsZSQxKHtcbiAgLi4uYXJncyxcbiAgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm46IGlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWVcbn0pO1xuY29uc3QgaXNUb3RhbGx5VmlzaWJsZU9uQXhpcyA9IGFyZ3MgPT4gaXNWaXNpYmxlJDEoe1xuICAuLi5hcmdzLFxuICBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbjogaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZU9uQXhpcyhhcmdzLmRlc3RpbmF0aW9uLmF4aXMpXG59KTtcblxuY29uc3QgZ2V0U2hvdWxkQW5pbWF0ZSA9IChpZCwgbGFzdCwgZm9yY2VTaG91bGRBbmltYXRlKSA9PiB7XG4gIGlmICh0eXBlb2YgZm9yY2VTaG91bGRBbmltYXRlID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gZm9yY2VTaG91bGRBbmltYXRlO1xuICB9XG4gIGlmICghbGFzdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpbnZpc2libGUsXG4gICAgdmlzaWJsZVxuICB9ID0gbGFzdDtcbiAgaWYgKGludmlzaWJsZVtpZF0pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcHJldmlvdXMgPSB2aXNpYmxlW2lkXTtcbiAgcmV0dXJuIHByZXZpb3VzID8gcHJldmlvdXMuc2hvdWxkQW5pbWF0ZSA6IHRydWU7XG59O1xuZnVuY3Rpb24gZ2V0VGFyZ2V0KGRyYWdnYWJsZSwgZGlzcGxhY2VkQnkpIHtcbiAgY29uc3QgbWFyZ2luQm94ID0gZHJhZ2dhYmxlLnBhZ2UubWFyZ2luQm94O1xuICBjb25zdCBleHBhbmRCeSA9IHtcbiAgICB0b3A6IGRpc3BsYWNlZEJ5LnBvaW50LnksXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IGRpc3BsYWNlZEJ5LnBvaW50LnhcbiAgfTtcbiAgcmV0dXJuIGdldFJlY3QoZXhwYW5kKG1hcmdpbkJveCwgZXhwYW5kQnkpKTtcbn1cbmZ1bmN0aW9uIGdldERpc3BsYWNlbWVudEdyb3Vwcyh7XG4gIGFmdGVyRHJhZ2dpbmcsXG4gIGRlc3RpbmF0aW9uLFxuICBkaXNwbGFjZWRCeSxcbiAgdmlld3BvcnQsXG4gIGZvcmNlU2hvdWxkQW5pbWF0ZSxcbiAgbGFzdFxufSkge1xuICByZXR1cm4gYWZ0ZXJEcmFnZ2luZy5yZWR1Y2UoZnVuY3Rpb24gcHJvY2Vzcyhncm91cHMsIGRyYWdnYWJsZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChkcmFnZ2FibGUsIGRpc3BsYWNlZEJ5KTtcbiAgICBjb25zdCBpZCA9IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkO1xuICAgIGdyb3Vwcy5hbGwucHVzaChpZCk7XG4gICAgY29uc3QgaXNWaXNpYmxlID0gaXNQYXJ0aWFsbHlWaXNpYmxlKHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgdmlld3BvcnQsXG4gICAgICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50OiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKCFpc1Zpc2libGUpIHtcbiAgICAgIGdyb3Vwcy5pbnZpc2libGVbZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWRdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBncm91cHM7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZEFuaW1hdGUgPSBnZXRTaG91bGRBbmltYXRlKGlkLCBsYXN0LCBmb3JjZVNob3VsZEFuaW1hdGUpO1xuICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHtcbiAgICAgIGRyYWdnYWJsZUlkOiBpZCxcbiAgICAgIHNob3VsZEFuaW1hdGVcbiAgICB9O1xuICAgIGdyb3Vwcy52aXNpYmxlW2lkXSA9IGRpc3BsYWNlbWVudDtcbiAgICByZXR1cm4gZ3JvdXBzO1xuICB9LCB7XG4gICAgYWxsOiBbXSxcbiAgICB2aXNpYmxlOiB7fSxcbiAgICBpbnZpc2libGU6IHt9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRJbmRleE9mTGFzdEl0ZW0oZHJhZ2dhYmxlcywgb3B0aW9ucykge1xuICBpZiAoIWRyYWdnYWJsZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgaW5kZXhPZkxhc3RJdGVtID0gZHJhZ2dhYmxlc1tkcmFnZ2FibGVzLmxlbmd0aCAtIDFdLmRlc2NyaXB0b3IuaW5kZXg7XG4gIHJldHVybiBvcHRpb25zLmluSG9tZUxpc3QgPyBpbmRleE9mTGFzdEl0ZW0gOiBpbmRleE9mTGFzdEl0ZW0gKyAxO1xufVxuZnVuY3Rpb24gZ29BdEVuZCh7XG4gIGluc2lkZURlc3RpbmF0aW9uLFxuICBpbkhvbWVMaXN0LFxuICBkaXNwbGFjZWRCeSxcbiAgZGVzdGluYXRpb25cbn0pIHtcbiAgY29uc3QgbmV3SW5kZXggPSBnZXRJbmRleE9mTGFzdEl0ZW0oaW5zaWRlRGVzdGluYXRpb24sIHtcbiAgICBpbkhvbWVMaXN0XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGRpc3BsYWNlZDogZW1wdHlHcm91cHMsXG4gICAgZGlzcGxhY2VkQnksXG4gICAgYXQ6IHtcbiAgICAgIHR5cGU6ICdSRU9SREVSJyxcbiAgICAgIGRlc3RpbmF0aW9uOiB7XG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLFxuICAgICAgICBpbmRleDogbmV3SW5kZXhcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgZHJhZ2dhYmxlLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgZGVzdGluYXRpb24sXG4gIHZpZXdwb3J0LFxuICBkaXNwbGFjZWRCeSxcbiAgbGFzdCxcbiAgaW5kZXgsXG4gIGZvcmNlU2hvdWxkQW5pbWF0ZVxufSkge1xuICBjb25zdCBpbkhvbWVMaXN0ID0gaXNIb21lT2YoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbik7XG4gIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdvQXRFbmQoe1xuICAgICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBpbkhvbWVMaXN0LFxuICAgICAgZGlzcGxhY2VkQnksXG4gICAgICBkZXN0aW5hdGlvblxuICAgIH0pO1xuICB9XG4gIGNvbnN0IG1hdGNoID0gaW5zaWRlRGVzdGluYXRpb24uZmluZChpdGVtID0+IGl0ZW0uZGVzY3JpcHRvci5pbmRleCA9PT0gaW5kZXgpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIGdvQXRFbmQoe1xuICAgICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBpbkhvbWVMaXN0LFxuICAgICAgZGlzcGxhY2VkQnksXG4gICAgICBkZXN0aW5hdGlvblxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHdpdGhvdXREcmFnZ2luZyA9IHJlbW92ZURyYWdnYWJsZUZyb21MaXN0KGRyYWdnYWJsZSwgaW5zaWRlRGVzdGluYXRpb24pO1xuICBjb25zdCBzbGljZUZyb20gPSBpbnNpZGVEZXN0aW5hdGlvbi5pbmRleE9mKG1hdGNoKTtcbiAgY29uc3QgaW1wYWN0ZWQgPSB3aXRob3V0RHJhZ2dpbmcuc2xpY2Uoc2xpY2VGcm9tKTtcbiAgY29uc3QgZGlzcGxhY2VkID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nOiBpbXBhY3RlZCxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBsYXN0LFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGVcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZGlzcGxhY2VkLFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGF0OiB7XG4gICAgICB0eXBlOiAnUkVPUkRFUicsXG4gICAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgICBkcm9wcGFibGVJZDogZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCxcbiAgICAgICAgaW5kZXhcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChkcmFnZ2FibGVJZCwgYWZ0ZXJDcml0aWNhbCkge1xuICByZXR1cm4gQm9vbGVhbihhZnRlckNyaXRpY2FsLmVmZmVjdGVkW2RyYWdnYWJsZUlkXSk7XG59XG5cbnZhciBmcm9tQ29tYmluZSA9ICh7XG4gIGlzTW92aW5nRm9yd2FyZCxcbiAgZGVzdGluYXRpb24sXG4gIGRyYWdnYWJsZXMsXG4gIGNvbWJpbmUsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgaWYgKCFkZXN0aW5hdGlvbi5pc0NvbWJpbmVFbmFibGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY29tYmluZUlkID0gY29tYmluZS5kcmFnZ2FibGVJZDtcbiAgY29uc3QgY29tYmluZVdpdGggPSBkcmFnZ2FibGVzW2NvbWJpbmVJZF07XG4gIGNvbnN0IGNvbWJpbmVXaXRoSW5kZXggPSBjb21iaW5lV2l0aC5kZXNjcmlwdG9yLmluZGV4O1xuICBjb25zdCBkaWRDb21iaW5lV2l0aFN0YXJ0QWZ0ZXJDcml0aWNhbCA9IGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChjb21iaW5lSWQsIGFmdGVyQ3JpdGljYWwpO1xuICBpZiAoZGlkQ29tYmluZVdpdGhTdGFydEFmdGVyQ3JpdGljYWwpIHtcbiAgICBpZiAoaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgICByZXR1cm4gY29tYmluZVdpdGhJbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbWJpbmVXaXRoSW5kZXggLSAxO1xuICB9XG4gIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICByZXR1cm4gY29tYmluZVdpdGhJbmRleCArIDE7XG4gIH1cbiAgcmV0dXJuIGNvbWJpbmVXaXRoSW5kZXg7XG59O1xuXG52YXIgZnJvbVJlb3JkZXIgPSAoe1xuICBpc01vdmluZ0ZvcndhcmQsXG4gIGlzSW5Ib21lTGlzdCxcbiAgaW5zaWRlRGVzdGluYXRpb24sXG4gIGxvY2F0aW9uXG59KSA9PiB7XG4gIGlmICghaW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY3VycmVudEluZGV4ID0gbG9jYXRpb24uaW5kZXg7XG4gIGNvbnN0IHByb3Bvc2VkSW5kZXggPSBpc01vdmluZ0ZvcndhcmQgPyBjdXJyZW50SW5kZXggKyAxIDogY3VycmVudEluZGV4IC0gMTtcbiAgY29uc3QgZmlyc3RJbmRleCA9IGluc2lkZURlc3RpbmF0aW9uWzBdLmRlc2NyaXB0b3IuaW5kZXg7XG4gIGNvbnN0IGxhc3RJbmRleCA9IGluc2lkZURlc3RpbmF0aW9uW2luc2lkZURlc3RpbmF0aW9uLmxlbmd0aCAtIDFdLmRlc2NyaXB0b3IuaW5kZXg7XG4gIGNvbnN0IHVwcGVyQm91bmQgPSBpc0luSG9tZUxpc3QgPyBsYXN0SW5kZXggOiBsYXN0SW5kZXggKyAxO1xuICBpZiAocHJvcG9zZWRJbmRleCA8IGZpcnN0SW5kZXgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocHJvcG9zZWRJbmRleCA+IHVwcGVyQm91bmQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcHJvcG9zZWRJbmRleDtcbn07XG5cbnZhciBtb3ZlVG9OZXh0SW5kZXggPSAoe1xuICBpc01vdmluZ0ZvcndhcmQsXG4gIGlzSW5Ib21lTGlzdCxcbiAgZHJhZ2dhYmxlLFxuICBkcmFnZ2FibGVzLFxuICBkZXN0aW5hdGlvbixcbiAgaW5zaWRlRGVzdGluYXRpb24sXG4gIHByZXZpb3VzSW1wYWN0LFxuICB2aWV3cG9ydCxcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCB3YXNBdCA9IHByZXZpb3VzSW1wYWN0LmF0O1xuICAhd2FzQXQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgbW92ZSBpbiBkaXJlY3Rpb24gd2l0aG91dCBwcmV2aW91cyBpbXBhY3QgbG9jYXRpb24nKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBpZiAod2FzQXQudHlwZSA9PT0gJ1JFT1JERVInKSB7XG4gICAgY29uc3QgbmV3SW5kZXggPSBmcm9tUmVvcmRlcih7XG4gICAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgICBpc0luSG9tZUxpc3QsXG4gICAgICBsb2NhdGlvbjogd2FzQXQuZGVzdGluYXRpb24sXG4gICAgICBpbnNpZGVEZXN0aW5hdGlvblxuICAgIH0pO1xuICAgIGlmIChuZXdJbmRleCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGN1bGF0ZVJlb3JkZXJJbXBhY3Qoe1xuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBkZXN0aW5hdGlvbixcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgbGFzdDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgICAgZGlzcGxhY2VkQnk6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZEJ5LFxuICAgICAgaW5kZXg6IG5ld0luZGV4XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbmV3SW5kZXggPSBmcm9tQ29tYmluZSh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgY29tYmluZTogd2FzQXQuY29tYmluZSxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBpZiAobmV3SW5kZXggPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgICBkcmFnZ2FibGUsXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgZGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQsXG4gICAgbGFzdDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgIGRpc3BsYWNlZEJ5OiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWRCeSxcbiAgICBpbmRleDogbmV3SW5kZXhcbiAgfSk7XG59O1xuXG52YXIgZ2V0Q29tYmluZWRJdGVtRGlzcGxhY2VtZW50ID0gKHtcbiAgZGlzcGxhY2VkLFxuICBhZnRlckNyaXRpY2FsLFxuICBjb21iaW5lV2l0aCxcbiAgZGlzcGxhY2VkQnlcbn0pID0+IHtcbiAgY29uc3QgaXNEaXNwbGFjZWQgPSBCb29sZWFuKGRpc3BsYWNlZC52aXNpYmxlW2NvbWJpbmVXaXRoXSB8fCBkaXNwbGFjZWQuaW52aXNpYmxlW2NvbWJpbmVXaXRoXSk7XG4gIGlmIChkaWRTdGFydEFmdGVyQ3JpdGljYWwoY29tYmluZVdpdGgsIGFmdGVyQ3JpdGljYWwpKSB7XG4gICAgcmV0dXJuIGlzRGlzcGxhY2VkID8gb3JpZ2luIDogbmVnYXRlKGRpc3BsYWNlZEJ5LnBvaW50KTtcbiAgfVxuICByZXR1cm4gaXNEaXNwbGFjZWQgPyBkaXNwbGFjZWRCeS5wb2ludCA6IG9yaWdpbjtcbn07XG5cbnZhciB3aGVuQ29tYmluaW5nID0gKHtcbiAgYWZ0ZXJDcml0aWNhbCxcbiAgaW1wYWN0LFxuICBkcmFnZ2FibGVzXG59KSA9PiB7XG4gIGNvbnN0IGNvbWJpbmUgPSB0cnlHZXRDb21iaW5lKGltcGFjdCk7XG4gICFjb21iaW5lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3QgY29tYmluZVdpdGggPSBjb21iaW5lLmRyYWdnYWJsZUlkO1xuICBjb25zdCBjZW50ZXIgPSBkcmFnZ2FibGVzW2NvbWJpbmVXaXRoXS5wYWdlLmJvcmRlckJveC5jZW50ZXI7XG4gIGNvbnN0IGRpc3BsYWNlQnkgPSBnZXRDb21iaW5lZEl0ZW1EaXNwbGFjZW1lbnQoe1xuICAgIGRpc3BsYWNlZDogaW1wYWN0LmRpc3BsYWNlZCxcbiAgICBhZnRlckNyaXRpY2FsLFxuICAgIGNvbWJpbmVXaXRoLFxuICAgIGRpc3BsYWNlZEJ5OiBpbXBhY3QuZGlzcGxhY2VkQnlcbiAgfSk7XG4gIHJldHVybiBhZGQoY2VudGVyLCBkaXNwbGFjZUJ5KTtcbn07XG5cbmNvbnN0IGRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIgPSAoYXhpcywgYm94KSA9PiBib3gubWFyZ2luW2F4aXMuc3RhcnRdICsgYm94LmJvcmRlckJveFtheGlzLnNpemVdIC8gMjtcbmNvbnN0IGRpc3RhbmNlRnJvbUVuZFRvQm9yZGVyQm94Q2VudGVyID0gKGF4aXMsIGJveCkgPT4gYm94Lm1hcmdpbltheGlzLmVuZF0gKyBib3guYm9yZGVyQm94W2F4aXMuc2l6ZV0gLyAyO1xuY29uc3QgZ2V0Q3Jvc3NBeGlzQm9yZGVyQm94Q2VudGVyID0gKGF4aXMsIHRhcmdldCwgaXNNb3ZpbmcpID0+IHRhcmdldFtheGlzLmNyb3NzQXhpc1N0YXJ0XSArIGlzTW92aW5nLm1hcmdpbltheGlzLmNyb3NzQXhpc1N0YXJ0XSArIGlzTW92aW5nLmJvcmRlckJveFtheGlzLmNyb3NzQXhpc1NpemVdIC8gMjtcbmNvbnN0IGdvQWZ0ZXIgPSAoe1xuICBheGlzLFxuICBtb3ZlUmVsYXRpdmVUbyxcbiAgaXNNb3Zpbmdcbn0pID0+IHBhdGNoKGF4aXMubGluZSwgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94W2F4aXMuZW5kXSArIGRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIoYXhpcywgaXNNb3ZpbmcpLCBnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIoYXhpcywgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94LCBpc01vdmluZykpO1xuY29uc3QgZ29CZWZvcmUgPSAoe1xuICBheGlzLFxuICBtb3ZlUmVsYXRpdmVUbyxcbiAgaXNNb3Zpbmdcbn0pID0+IHBhdGNoKGF4aXMubGluZSwgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94W2F4aXMuc3RhcnRdIC0gZGlzdGFuY2VGcm9tRW5kVG9Cb3JkZXJCb3hDZW50ZXIoYXhpcywgaXNNb3ZpbmcpLCBnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIoYXhpcywgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94LCBpc01vdmluZykpO1xuY29uc3QgZ29JbnRvU3RhcnQgPSAoe1xuICBheGlzLFxuICBtb3ZlSW50byxcbiAgaXNNb3Zpbmdcbn0pID0+IHBhdGNoKGF4aXMubGluZSwgbW92ZUludG8uY29udGVudEJveFtheGlzLnN0YXJ0XSArIGRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIoYXhpcywgaXNNb3ZpbmcpLCBnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIoYXhpcywgbW92ZUludG8uY29udGVudEJveCwgaXNNb3ZpbmcpKTtcblxudmFyIHdoZW5SZW9yZGVyaW5nID0gKHtcbiAgaW1wYWN0LFxuICBkcmFnZ2FibGUsXG4gIGRyYWdnYWJsZXMsXG4gIGRyb3BwYWJsZSxcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZHJvcHBhYmxlLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICBjb25zdCBkcmFnZ2FibGVQYWdlID0gZHJhZ2dhYmxlLnBhZ2U7XG4gIGNvbnN0IGF4aXMgPSBkcm9wcGFibGUuYXhpcztcbiAgaWYgKCFpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZ29JbnRvU3RhcnQoe1xuICAgICAgYXhpcyxcbiAgICAgIG1vdmVJbnRvOiBkcm9wcGFibGUucGFnZSxcbiAgICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qge1xuICAgIGRpc3BsYWNlZCxcbiAgICBkaXNwbGFjZWRCeVxuICB9ID0gaW1wYWN0O1xuICBjb25zdCBjbG9zZXN0QWZ0ZXIgPSBkaXNwbGFjZWQuYWxsWzBdO1xuICBpZiAoY2xvc2VzdEFmdGVyKSB7XG4gICAgY29uc3QgY2xvc2VzdCA9IGRyYWdnYWJsZXNbY2xvc2VzdEFmdGVyXTtcbiAgICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsKGNsb3Nlc3RBZnRlciwgYWZ0ZXJDcml0aWNhbCkpIHtcbiAgICAgIHJldHVybiBnb0JlZm9yZSh7XG4gICAgICAgIGF4aXMsXG4gICAgICAgIG1vdmVSZWxhdGl2ZVRvOiBjbG9zZXN0LnBhZ2UsXG4gICAgICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgd2l0aERpc3BsYWNlbWVudCA9IG9mZnNldChjbG9zZXN0LnBhZ2UsIGRpc3BsYWNlZEJ5LnBvaW50KTtcbiAgICByZXR1cm4gZ29CZWZvcmUoe1xuICAgICAgYXhpcyxcbiAgICAgIG1vdmVSZWxhdGl2ZVRvOiB3aXRoRGlzcGxhY2VtZW50LFxuICAgICAgaXNNb3Zpbmc6IGRyYWdnYWJsZVBhZ2VcbiAgICB9KTtcbiAgfVxuICBjb25zdCBsYXN0ID0gaW5zaWRlRGVzdGluYXRpb25baW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoIC0gMV07XG4gIGlmIChsYXN0LmRlc2NyaXB0b3IuaWQgPT09IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkKSB7XG4gICAgcmV0dXJuIGRyYWdnYWJsZVBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgfVxuICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsKGxhc3QuZGVzY3JpcHRvci5pZCwgYWZ0ZXJDcml0aWNhbCkpIHtcbiAgICBjb25zdCBwYWdlID0gb2Zmc2V0KGxhc3QucGFnZSwgbmVnYXRlKGFmdGVyQ3JpdGljYWwuZGlzcGxhY2VkQnkucG9pbnQpKTtcbiAgICByZXR1cm4gZ29BZnRlcih7XG4gICAgICBheGlzLFxuICAgICAgbW92ZVJlbGF0aXZlVG86IHBhZ2UsXG4gICAgICBpc01vdmluZzogZHJhZ2dhYmxlUGFnZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBnb0FmdGVyKHtcbiAgICBheGlzLFxuICAgIG1vdmVSZWxhdGl2ZVRvOiBsYXN0LnBhZ2UsXG4gICAgaXNNb3Zpbmc6IGRyYWdnYWJsZVBhZ2VcbiAgfSk7XG59O1xuXG52YXIgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCA9IChkcm9wcGFibGUsIHBvaW50KSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG4gIHJldHVybiBhZGQocG9pbnQsIGZyYW1lLnNjcm9sbC5kaWZmLmRpc3BsYWNlbWVudCk7XG59O1xuXG5jb25zdCBnZXRSZXN1bHRXaXRob3V0RHJvcHBhYmxlRGlzcGxhY2VtZW50ID0gKHtcbiAgaW1wYWN0LFxuICBkcmFnZ2FibGUsXG4gIGRyb3BwYWJsZSxcbiAgZHJhZ2dhYmxlcyxcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCBvcmlnaW5hbCA9IGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveC5jZW50ZXI7XG4gIGNvbnN0IGF0ID0gaW1wYWN0LmF0O1xuICBpZiAoIWRyb3BwYWJsZSkge1xuICAgIHJldHVybiBvcmlnaW5hbDtcbiAgfVxuICBpZiAoIWF0KSB7XG4gICAgcmV0dXJuIG9yaWdpbmFsO1xuICB9XG4gIGlmIChhdC50eXBlID09PSAnUkVPUkRFUicpIHtcbiAgICByZXR1cm4gd2hlblJlb3JkZXJpbmcoe1xuICAgICAgaW1wYWN0LFxuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgZHJhZ2dhYmxlcyxcbiAgICAgIGRyb3BwYWJsZSxcbiAgICAgIGFmdGVyQ3JpdGljYWxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gd2hlbkNvbWJpbmluZyh7XG4gICAgaW1wYWN0LFxuICAgIGRyYWdnYWJsZXMsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbn07XG52YXIgZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3QgPSBhcmdzID0+IHtcbiAgY29uc3Qgd2l0aG91dERpc3BsYWNlbWVudCA9IGdldFJlc3VsdFdpdGhvdXREcm9wcGFibGVEaXNwbGFjZW1lbnQoYXJncyk7XG4gIGNvbnN0IGRyb3BwYWJsZSA9IGFyZ3MuZHJvcHBhYmxlO1xuICBjb25zdCB3aXRoRGlzcGxhY2VtZW50ID0gZHJvcHBhYmxlID8gd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudChkcm9wcGFibGUsIHdpdGhvdXREaXNwbGFjZW1lbnQpIDogd2l0aG91dERpc3BsYWNlbWVudDtcbiAgcmV0dXJuIHdpdGhEaXNwbGFjZW1lbnQ7XG59O1xuXG52YXIgc2Nyb2xsVmlld3BvcnQgPSAodmlld3BvcnQsIG5ld1Njcm9sbCkgPT4ge1xuICBjb25zdCBkaWZmID0gc3VidHJhY3QobmV3U2Nyb2xsLCB2aWV3cG9ydC5zY3JvbGwuaW5pdGlhbCk7XG4gIGNvbnN0IGRpc3BsYWNlbWVudCA9IG5lZ2F0ZShkaWZmKTtcbiAgY29uc3QgZnJhbWUgPSBnZXRSZWN0KHtcbiAgICB0b3A6IG5ld1Njcm9sbC55LFxuICAgIGJvdHRvbTogbmV3U2Nyb2xsLnkgKyB2aWV3cG9ydC5mcmFtZS5oZWlnaHQsXG4gICAgbGVmdDogbmV3U2Nyb2xsLngsXG4gICAgcmlnaHQ6IG5ld1Njcm9sbC54ICsgdmlld3BvcnQuZnJhbWUud2lkdGhcbiAgfSk7XG4gIGNvbnN0IHVwZGF0ZWQgPSB7XG4gICAgZnJhbWUsXG4gICAgc2Nyb2xsOiB7XG4gICAgICBpbml0aWFsOiB2aWV3cG9ydC5zY3JvbGwuaW5pdGlhbCxcbiAgICAgIG1heDogdmlld3BvcnQuc2Nyb2xsLm1heCxcbiAgICAgIGN1cnJlbnQ6IG5ld1Njcm9sbCxcbiAgICAgIGRpZmY6IHtcbiAgICAgICAgdmFsdWU6IGRpZmYsXG4gICAgICAgIGRpc3BsYWNlbWVudFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHVwZGF0ZWQ7XG59O1xuXG5mdW5jdGlvbiBnZXREcmFnZ2FibGVzJDEoaWRzLCBkcmFnZ2FibGVzKSB7XG4gIHJldHVybiBpZHMubWFwKGlkID0+IGRyYWdnYWJsZXNbaWRdKTtcbn1cbmZ1bmN0aW9uIHRyeUdldFZpc2libGUoaWQsIGdyb3Vwcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IGdyb3Vwc1tpXS52aXNpYmxlW2lkXTtcbiAgICBpZiAoZGlzcGxhY2VtZW50KSB7XG4gICAgICByZXR1cm4gZGlzcGxhY2VtZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbnZhciBzcGVjdWxhdGl2ZWx5SW5jcmVhc2UgPSAoe1xuICBpbXBhY3QsXG4gIHZpZXdwb3J0LFxuICBkZXN0aW5hdGlvbixcbiAgZHJhZ2dhYmxlcyxcbiAgbWF4U2Nyb2xsQ2hhbmdlXG59KSA9PiB7XG4gIGNvbnN0IHNjcm9sbGVkVmlld3BvcnQgPSBzY3JvbGxWaWV3cG9ydCh2aWV3cG9ydCwgYWRkKHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50LCBtYXhTY3JvbGxDaGFuZ2UpKTtcbiAgY29uc3Qgc2Nyb2xsZWREcm9wcGFibGUgPSBkZXN0aW5hdGlvbi5mcmFtZSA/IHNjcm9sbERyb3BwYWJsZShkZXN0aW5hdGlvbiwgYWRkKGRlc3RpbmF0aW9uLmZyYW1lLnNjcm9sbC5jdXJyZW50LCBtYXhTY3JvbGxDaGFuZ2UpKSA6IGRlc3RpbmF0aW9uO1xuICBjb25zdCBsYXN0ID0gaW1wYWN0LmRpc3BsYWNlZDtcbiAgY29uc3Qgd2l0aFZpZXdwb3J0U2Nyb2xsID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nOiBnZXREcmFnZ2FibGVzJDEobGFzdC5hbGwsIGRyYWdnYWJsZXMpLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZEJ5OiBpbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgdmlld3BvcnQ6IHNjcm9sbGVkVmlld3BvcnQuZnJhbWUsXG4gICAgbGFzdCxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZhbHNlXG4gIH0pO1xuICBjb25zdCB3aXRoRHJvcHBhYmxlU2Nyb2xsID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nOiBnZXREcmFnZ2FibGVzJDEobGFzdC5hbGwsIGRyYWdnYWJsZXMpLFxuICAgIGRlc3RpbmF0aW9uOiBzY3JvbGxlZERyb3BwYWJsZSxcbiAgICBkaXNwbGFjZWRCeTogaW1wYWN0LmRpc3BsYWNlZEJ5LFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICBsYXN0LFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IGludmlzaWJsZSA9IHt9O1xuICBjb25zdCB2aXNpYmxlID0ge307XG4gIGNvbnN0IGdyb3VwcyA9IFtsYXN0LCB3aXRoVmlld3BvcnRTY3JvbGwsIHdpdGhEcm9wcGFibGVTY3JvbGxdO1xuICBsYXN0LmFsbC5mb3JFYWNoKGlkID0+IHtcbiAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB0cnlHZXRWaXNpYmxlKGlkLCBncm91cHMpO1xuICAgIGlmIChkaXNwbGFjZW1lbnQpIHtcbiAgICAgIHZpc2libGVbaWRdID0gZGlzcGxhY2VtZW50O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZpc2libGVbaWRdID0gdHJ1ZTtcbiAgfSk7XG4gIGNvbnN0IG5ld0ltcGFjdCA9IHtcbiAgICAuLi5pbXBhY3QsXG4gICAgZGlzcGxhY2VkOiB7XG4gICAgICBhbGw6IGxhc3QuYWxsLFxuICAgICAgaW52aXNpYmxlLFxuICAgICAgdmlzaWJsZVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIG5ld0ltcGFjdDtcbn07XG5cbnZhciB3aXRoVmlld3BvcnREaXNwbGFjZW1lbnQgPSAodmlld3BvcnQsIHBvaW50KSA9PiBhZGQodmlld3BvcnQuc2Nyb2xsLmRpZmYuZGlzcGxhY2VtZW50LCBwb2ludCk7XG5cbnZhciBnZXRDbGllbnRGcm9tUGFnZUJvcmRlckJveENlbnRlciA9ICh7XG4gIHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gIGRyYWdnYWJsZSxcbiAgdmlld3BvcnRcbn0pID0+IHtcbiAgY29uc3Qgd2l0aG91dFBhZ2VTY3JvbGxDaGFuZ2UgPSB3aXRoVmlld3BvcnREaXNwbGFjZW1lbnQodmlld3BvcnQsIHBhZ2VCb3JkZXJCb3hDZW50ZXIpO1xuICBjb25zdCBvZmZzZXQgPSBzdWJ0cmFjdCh3aXRob3V0UGFnZVNjcm9sbENoYW5nZSwgZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcik7XG4gIHJldHVybiBhZGQoZHJhZ2dhYmxlLmNsaWVudC5ib3JkZXJCb3guY2VudGVyLCBvZmZzZXQpO1xufTtcblxudmFyIGlzVG90YWxseVZpc2libGVJbk5ld0xvY2F0aW9uID0gKHtcbiAgZHJhZ2dhYmxlLFxuICBkZXN0aW5hdGlvbixcbiAgbmV3UGFnZUJvcmRlckJveENlbnRlcixcbiAgdmlld3BvcnQsXG4gIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQsXG4gIG9ubHlPbk1haW5BeGlzID0gZmFsc2Vcbn0pID0+IHtcbiAgY29uc3QgY2hhbmdlTmVlZGVkID0gc3VidHJhY3QobmV3UGFnZUJvcmRlckJveENlbnRlciwgZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcik7XG4gIGNvbnN0IHNoaWZ0ZWQgPSBvZmZzZXRCeVBvc2l0aW9uKGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveCwgY2hhbmdlTmVlZGVkKTtcbiAgY29uc3QgYXJncyA9IHtcbiAgICB0YXJnZXQ6IHNoaWZ0ZWQsXG4gICAgZGVzdGluYXRpb24sXG4gICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCxcbiAgICB2aWV3cG9ydFxuICB9O1xuICByZXR1cm4gb25seU9uTWFpbkF4aXMgPyBpc1RvdGFsbHlWaXNpYmxlT25BeGlzKGFyZ3MpIDogaXNUb3RhbGx5VmlzaWJsZShhcmdzKTtcbn07XG5cbnZhciBtb3ZlVG9OZXh0UGxhY2UgPSAoe1xuICBpc01vdmluZ0ZvcndhcmQsXG4gIGRyYWdnYWJsZSxcbiAgZGVzdGluYXRpb24sXG4gIGRyYWdnYWJsZXMsXG4gIHByZXZpb3VzSW1wYWN0LFxuICB2aWV3cG9ydCxcbiAgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICBwcmV2aW91c0NsaWVudFNlbGVjdGlvbixcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBpZiAoIWRlc3RpbmF0aW9uLmlzRW5hYmxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGluc2lkZURlc3RpbmF0aW9uID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgaXNJbkhvbWVMaXN0ID0gaXNIb21lT2YoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbik7XG4gIGNvbnN0IGltcGFjdCA9IG1vdmVUb05leHRDb21iaW5lKHtcbiAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIHByZXZpb3VzSW1wYWN0XG4gIH0pIHx8IG1vdmVUb05leHRJbmRleCh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgIGlzSW5Ib21lTGlzdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBwcmV2aW91c0ltcGFjdCxcbiAgICB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBpZiAoIWltcGFjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHBhZ2VCb3JkZXJCb3hDZW50ZXIgPSBnZXRQYWdlQm9yZGVyQm94Q2VudGVyRnJvbUltcGFjdCh7XG4gICAgaW1wYWN0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcm9wcGFibGU6IGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgY29uc3QgaXNWaXNpYmxlSW5OZXdMb2NhdGlvbiA9IGlzVG90YWxseVZpc2libGVJbk5ld0xvY2F0aW9uKHtcbiAgICBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb24sXG4gICAgbmV3UGFnZUJvcmRlckJveENlbnRlcjogcGFnZUJvcmRlckJveENlbnRlcixcbiAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudDogZmFsc2UsXG4gICAgb25seU9uTWFpbkF4aXM6IHRydWVcbiAgfSk7XG4gIGlmIChpc1Zpc2libGVJbk5ld0xvY2F0aW9uKSB7XG4gICAgY29uc3QgY2xpZW50U2VsZWN0aW9uID0gZ2V0Q2xpZW50RnJvbVBhZ2VCb3JkZXJCb3hDZW50ZXIoe1xuICAgICAgcGFnZUJvcmRlckJveENlbnRlcixcbiAgICAgIGRyYWdnYWJsZSxcbiAgICAgIHZpZXdwb3J0XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsaWVudFNlbGVjdGlvbixcbiAgICAgIGltcGFjdCxcbiAgICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBudWxsXG4gICAgfTtcbiAgfVxuICBjb25zdCBkaXN0YW5jZSA9IHN1YnRyYWN0KHBhZ2VCb3JkZXJCb3hDZW50ZXIsIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcik7XG4gIGNvbnN0IGNhdXRpb3VzID0gc3BlY3VsYXRpdmVseUluY3JlYXNlKHtcbiAgICBpbXBhY3QsXG4gICAgdmlld3BvcnQsXG4gICAgZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBtYXhTY3JvbGxDaGFuZ2U6IGRpc3RhbmNlXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNsaWVudFNlbGVjdGlvbjogcHJldmlvdXNDbGllbnRTZWxlY3Rpb24sXG4gICAgaW1wYWN0OiBjYXV0aW91cyxcbiAgICBzY3JvbGxKdW1wUmVxdWVzdDogZGlzdGFuY2VcbiAgfTtcbn07XG5cbmNvbnN0IGdldEtub3duQWN0aXZlID0gZHJvcHBhYmxlID0+IHtcbiAgY29uc3QgcmVjdCA9IGRyb3BwYWJsZS5zdWJqZWN0LmFjdGl2ZTtcbiAgIXJlY3QgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZ2V0IGNsaXBwZWQgYXJlYSBmcm9tIGRyb3BwYWJsZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIHJldHVybiByZWN0O1xufTtcbnZhciBnZXRCZXN0Q3Jvc3NBeGlzRHJvcHBhYmxlID0gKHtcbiAgaXNNb3ZpbmdGb3J3YXJkLFxuICBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICBzb3VyY2UsXG4gIGRyb3BwYWJsZXMsXG4gIHZpZXdwb3J0XG59KSA9PiB7XG4gIGNvbnN0IGFjdGl2ZSA9IHNvdXJjZS5zdWJqZWN0LmFjdGl2ZTtcbiAgaWYgKCFhY3RpdmUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBheGlzID0gc291cmNlLmF4aXM7XG4gIGNvbnN0IGlzQmV0d2VlblNvdXJjZUNsaXBwZWQgPSBpc1dpdGhpbihhY3RpdmVbYXhpcy5zdGFydF0sIGFjdGl2ZVtheGlzLmVuZF0pO1xuICBjb25zdCBjYW5kaWRhdGVzID0gdG9Ecm9wcGFibGVMaXN0KGRyb3BwYWJsZXMpLmZpbHRlcihkcm9wcGFibGUgPT4gZHJvcHBhYmxlICE9PSBzb3VyY2UpLmZpbHRlcihkcm9wcGFibGUgPT4gZHJvcHBhYmxlLmlzRW5hYmxlZCkuZmlsdGVyKGRyb3BwYWJsZSA9PiBCb29sZWFuKGRyb3BwYWJsZS5zdWJqZWN0LmFjdGl2ZSkpLmZpbHRlcihkcm9wcGFibGUgPT4gaXNQYXJ0aWFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lKHZpZXdwb3J0LmZyYW1lKShnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpKSkuZmlsdGVyKGRyb3BwYWJsZSA9PiB7XG4gICAgY29uc3QgYWN0aXZlT2ZUYXJnZXQgPSBnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpO1xuICAgIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICAgIHJldHVybiBhY3RpdmVbYXhpcy5jcm9zc0F4aXNFbmRdIDwgYWN0aXZlT2ZUYXJnZXRbYXhpcy5jcm9zc0F4aXNFbmRdO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlT2ZUYXJnZXRbYXhpcy5jcm9zc0F4aXNTdGFydF0gPCBhY3RpdmVbYXhpcy5jcm9zc0F4aXNTdGFydF07XG4gIH0pLmZpbHRlcihkcm9wcGFibGUgPT4ge1xuICAgIGNvbnN0IGFjdGl2ZU9mVGFyZ2V0ID0gZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKTtcbiAgICBjb25zdCBpc0JldHdlZW5EZXN0aW5hdGlvbkNsaXBwZWQgPSBpc1dpdGhpbihhY3RpdmVPZlRhcmdldFtheGlzLnN0YXJ0XSwgYWN0aXZlT2ZUYXJnZXRbYXhpcy5lbmRdKTtcbiAgICByZXR1cm4gaXNCZXR3ZWVuU291cmNlQ2xpcHBlZChhY3RpdmVPZlRhcmdldFtheGlzLnN0YXJ0XSkgfHwgaXNCZXR3ZWVuU291cmNlQ2xpcHBlZChhY3RpdmVPZlRhcmdldFtheGlzLmVuZF0pIHx8IGlzQmV0d2VlbkRlc3RpbmF0aW9uQ2xpcHBlZChhY3RpdmVbYXhpcy5zdGFydF0pIHx8IGlzQmV0d2VlbkRlc3RpbmF0aW9uQ2xpcHBlZChhY3RpdmVbYXhpcy5lbmRdKTtcbiAgfSkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IGZpcnN0ID0gZ2V0S25vd25BY3RpdmUoYSlbYXhpcy5jcm9zc0F4aXNTdGFydF07XG4gICAgY29uc3Qgc2Vjb25kID0gZ2V0S25vd25BY3RpdmUoYilbYXhpcy5jcm9zc0F4aXNTdGFydF07XG4gICAgaWYgKGlzTW92aW5nRm9yd2FyZCkge1xuICAgICAgcmV0dXJuIGZpcnN0IC0gc2Vjb25kO1xuICAgIH1cbiAgICByZXR1cm4gc2Vjb25kIC0gZmlyc3Q7XG4gIH0pLmZpbHRlcigoZHJvcHBhYmxlLCBpbmRleCwgYXJyYXkpID0+IGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSlbYXhpcy5jcm9zc0F4aXNTdGFydF0gPT09IGdldEtub3duQWN0aXZlKGFycmF5WzBdKVtheGlzLmNyb3NzQXhpc1N0YXJ0XSk7XG4gIGlmICghY2FuZGlkYXRlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gY2FuZGlkYXRlc1swXTtcbiAgfVxuICBjb25zdCBjb250YWlucyA9IGNhbmRpZGF0ZXMuZmlsdGVyKGRyb3BwYWJsZSA9PiB7XG4gICAgY29uc3QgaXNXaXRoaW5Ecm9wcGFibGUgPSBpc1dpdGhpbihnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpW2F4aXMuc3RhcnRdLCBnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpW2F4aXMuZW5kXSk7XG4gICAgcmV0dXJuIGlzV2l0aGluRHJvcHBhYmxlKHBhZ2VCb3JkZXJCb3hDZW50ZXJbYXhpcy5saW5lXSk7XG4gIH0pO1xuICBpZiAoY29udGFpbnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zWzBdO1xuICB9XG4gIGlmIChjb250YWlucy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zLnNvcnQoKGEsIGIpID0+IGdldEtub3duQWN0aXZlKGEpW2F4aXMuc3RhcnRdIC0gZ2V0S25vd25BY3RpdmUoYilbYXhpcy5zdGFydF0pWzBdO1xuICB9XG4gIHJldHVybiBjYW5kaWRhdGVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCBmaXJzdCA9IGNsb3Nlc3QkMShwYWdlQm9yZGVyQm94Q2VudGVyLCBnZXRDb3JuZXJzKGdldEtub3duQWN0aXZlKGEpKSk7XG4gICAgY29uc3Qgc2Vjb25kID0gY2xvc2VzdCQxKHBhZ2VCb3JkZXJCb3hDZW50ZXIsIGdldENvcm5lcnMoZ2V0S25vd25BY3RpdmUoYikpKTtcbiAgICBpZiAoZmlyc3QgIT09IHNlY29uZCkge1xuICAgICAgcmV0dXJuIGZpcnN0IC0gc2Vjb25kO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0S25vd25BY3RpdmUoYSlbYXhpcy5zdGFydF0gLSBnZXRLbm93bkFjdGl2ZShiKVtheGlzLnN0YXJ0XTtcbiAgfSlbMF07XG59O1xuXG5jb25zdCBnZXRDdXJyZW50UGFnZUJvcmRlckJveENlbnRlciA9IChkcmFnZ2FibGUsIGFmdGVyQ3JpdGljYWwpID0+IHtcbiAgY29uc3Qgb3JpZ2luYWwgPSBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3guY2VudGVyO1xuICByZXR1cm4gZGlkU3RhcnRBZnRlckNyaXRpY2FsKGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkLCBhZnRlckNyaXRpY2FsKSA/IHN1YnRyYWN0KG9yaWdpbmFsLCBhZnRlckNyaXRpY2FsLmRpc3BsYWNlZEJ5LnBvaW50KSA6IG9yaWdpbmFsO1xufTtcbmNvbnN0IGdldEN1cnJlbnRQYWdlQm9yZGVyQm94ID0gKGRyYWdnYWJsZSwgYWZ0ZXJDcml0aWNhbCkgPT4ge1xuICBjb25zdCBvcmlnaW5hbCA9IGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveDtcbiAgcmV0dXJuIGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCwgYWZ0ZXJDcml0aWNhbCkgPyBvZmZzZXRCeVBvc2l0aW9uKG9yaWdpbmFsLCBuZWdhdGUoYWZ0ZXJDcml0aWNhbC5kaXNwbGFjZWRCeS5wb2ludCkpIDogb3JpZ2luYWw7XG59O1xuXG52YXIgZ2V0Q2xvc2VzdERyYWdnYWJsZSA9ICh7XG4gIHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gIHZpZXdwb3J0LFxuICBkZXN0aW5hdGlvbixcbiAgaW5zaWRlRGVzdGluYXRpb24sXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3Qgc29ydGVkID0gaW5zaWRlRGVzdGluYXRpb24uZmlsdGVyKGRyYWdnYWJsZSA9PiBpc1RvdGFsbHlWaXNpYmxlKHtcbiAgICB0YXJnZXQ6IGdldEN1cnJlbnRQYWdlQm9yZGVyQm94KGRyYWdnYWJsZSwgYWZ0ZXJDcml0aWNhbCksXG4gICAgZGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQ6IHRydWVcbiAgfSkpLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCBkaXN0YW5jZVRvQSA9IGRpc3RhbmNlKHBhZ2VCb3JkZXJCb3hDZW50ZXIsIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQoZGVzdGluYXRpb24sIGdldEN1cnJlbnRQYWdlQm9yZGVyQm94Q2VudGVyKGEsIGFmdGVyQ3JpdGljYWwpKSk7XG4gICAgY29uc3QgZGlzdGFuY2VUb0IgPSBkaXN0YW5jZShwYWdlQm9yZGVyQm94Q2VudGVyLCB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50KGRlc3RpbmF0aW9uLCBnZXRDdXJyZW50UGFnZUJvcmRlckJveENlbnRlcihiLCBhZnRlckNyaXRpY2FsKSkpO1xuICAgIGlmIChkaXN0YW5jZVRvQSA8IGRpc3RhbmNlVG9CKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChkaXN0YW5jZVRvQiA8IGRpc3RhbmNlVG9BKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGEuZGVzY3JpcHRvci5pbmRleCAtIGIuZGVzY3JpcHRvci5pbmRleDtcbiAgfSk7XG4gIHJldHVybiBzb3J0ZWRbMF0gfHwgbnVsbDtcbn07XG5cbnZhciBnZXREaXNwbGFjZWRCeSA9IG1lbW9pemVPbmUoZnVuY3Rpb24gZ2V0RGlzcGxhY2VkQnkoYXhpcywgZGlzcGxhY2VCeSkge1xuICBjb25zdCBkaXNwbGFjZW1lbnQgPSBkaXNwbGFjZUJ5W2F4aXMubGluZV07XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IGRpc3BsYWNlbWVudCxcbiAgICBwb2ludDogcGF0Y2goYXhpcy5saW5lLCBkaXNwbGFjZW1lbnQpXG4gIH07XG59KTtcblxuY29uc3QgZ2V0UmVxdWlyZWRHcm93dGhGb3JQbGFjZWhvbGRlciA9IChkcm9wcGFibGUsIHBsYWNlaG9sZGVyU2l6ZSwgZHJhZ2dhYmxlcykgPT4ge1xuICBjb25zdCBheGlzID0gZHJvcHBhYmxlLmF4aXM7XG4gIGlmIChkcm9wcGFibGUuZGVzY3JpcHRvci5tb2RlID09PSAndmlydHVhbCcpIHtcbiAgICByZXR1cm4gcGF0Y2goYXhpcy5saW5lLCBwbGFjZWhvbGRlclNpemVbYXhpcy5saW5lXSk7XG4gIH1cbiAgY29uc3QgYXZhaWxhYmxlU3BhY2UgPSBkcm9wcGFibGUuc3ViamVjdC5wYWdlLmNvbnRlbnRCb3hbYXhpcy5zaXplXTtcbiAgY29uc3QgaW5zaWRlRHJvcHBhYmxlID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShkcm9wcGFibGUuZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IHNwYWNlVXNlZCA9IGluc2lkZURyb3BwYWJsZS5yZWR1Y2UoKHN1bSwgZGltZW5zaW9uKSA9PiBzdW0gKyBkaW1lbnNpb24uY2xpZW50Lm1hcmdpbkJveFtheGlzLnNpemVdLCAwKTtcbiAgY29uc3QgcmVxdWlyZWRTcGFjZSA9IHNwYWNlVXNlZCArIHBsYWNlaG9sZGVyU2l6ZVtheGlzLmxpbmVdO1xuICBjb25zdCBuZWVkc1RvR3Jvd0J5ID0gcmVxdWlyZWRTcGFjZSAtIGF2YWlsYWJsZVNwYWNlO1xuICBpZiAobmVlZHNUb0dyb3dCeSA8PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHBhdGNoKGF4aXMubGluZSwgbmVlZHNUb0dyb3dCeSk7XG59O1xuY29uc3Qgd2l0aE1heFNjcm9sbCA9IChmcmFtZSwgbWF4KSA9PiAoe1xuICAuLi5mcmFtZSxcbiAgc2Nyb2xsOiB7XG4gICAgLi4uZnJhbWUuc2Nyb2xsLFxuICAgIG1heFxuICB9XG59KTtcbmNvbnN0IGFkZFBsYWNlaG9sZGVyID0gKGRyb3BwYWJsZSwgZHJhZ2dhYmxlLCBkcmFnZ2FibGVzKSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICAhIWlzSG9tZU9mKGRyYWdnYWJsZSwgZHJvcHBhYmxlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBub3QgYWRkIHBsYWNlaG9sZGVyIHNwYWNlIHRvIGhvbWUgbGlzdCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICEhZHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGFkZCBwbGFjZWhvbGRlciBzaXplIHRvIGEgc3ViamVjdCB3aGVuIGl0IGFscmVhZHkgaGFzIG9uZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IHBsYWNlaG9sZGVyU2l6ZSA9IGdldERpc3BsYWNlZEJ5KGRyb3BwYWJsZS5heGlzLCBkcmFnZ2FibGUuZGlzcGxhY2VCeSkucG9pbnQ7XG4gIGNvbnN0IHJlcXVpcmVkR3Jvd3RoID0gZ2V0UmVxdWlyZWRHcm93dGhGb3JQbGFjZWhvbGRlcihkcm9wcGFibGUsIHBsYWNlaG9sZGVyU2l6ZSwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IGFkZGVkID0ge1xuICAgIHBsYWNlaG9sZGVyU2l6ZSxcbiAgICBpbmNyZWFzZWRCeTogcmVxdWlyZWRHcm93dGgsXG4gICAgb2xkRnJhbWVNYXhTY3JvbGw6IGRyb3BwYWJsZS5mcmFtZSA/IGRyb3BwYWJsZS5mcmFtZS5zY3JvbGwubWF4IDogbnVsbFxuICB9O1xuICBpZiAoIWZyYW1lKSB7XG4gICAgY29uc3Qgc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgICAgcGFnZTogZHJvcHBhYmxlLnN1YmplY3QucGFnZSxcbiAgICAgIHdpdGhQbGFjZWhvbGRlcjogYWRkZWQsXG4gICAgICBheGlzOiBkcm9wcGFibGUuYXhpcyxcbiAgICAgIGZyYW1lOiBkcm9wcGFibGUuZnJhbWVcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZHJvcHBhYmxlLFxuICAgICAgc3ViamVjdFxuICAgIH07XG4gIH1cbiAgY29uc3QgbWF4U2Nyb2xsID0gcmVxdWlyZWRHcm93dGggPyBhZGQoZnJhbWUuc2Nyb2xsLm1heCwgcmVxdWlyZWRHcm93dGgpIDogZnJhbWUuc2Nyb2xsLm1heDtcbiAgY29uc3QgbmV3RnJhbWUgPSB3aXRoTWF4U2Nyb2xsKGZyYW1lLCBtYXhTY3JvbGwpO1xuICBjb25zdCBzdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgcGFnZTogZHJvcHBhYmxlLnN1YmplY3QucGFnZSxcbiAgICB3aXRoUGxhY2Vob2xkZXI6IGFkZGVkLFxuICAgIGF4aXM6IGRyb3BwYWJsZS5heGlzLFxuICAgIGZyYW1lOiBuZXdGcmFtZVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kcm9wcGFibGUsXG4gICAgc3ViamVjdCxcbiAgICBmcmFtZTogbmV3RnJhbWVcbiAgfTtcbn07XG5jb25zdCByZW1vdmVQbGFjZWhvbGRlciA9IGRyb3BwYWJsZSA9PiB7XG4gIGNvbnN0IGFkZGVkID0gZHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyO1xuICAhYWRkZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcmVtb3ZlIHBsYWNlaG9sZGVyIGZvcm0gc3ViamVjdCB3aGVuIHRoZXJlIHdhcyBub25lJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGlmICghZnJhbWUpIHtcbiAgICBjb25zdCBzdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgICBwYWdlOiBkcm9wcGFibGUuc3ViamVjdC5wYWdlLFxuICAgICAgYXhpczogZHJvcHBhYmxlLmF4aXMsXG4gICAgICBmcmFtZTogbnVsbCxcbiAgICAgIHdpdGhQbGFjZWhvbGRlcjogbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kcm9wcGFibGUsXG4gICAgICBzdWJqZWN0XG4gICAgfTtcbiAgfVxuICBjb25zdCBvbGRNYXhTY3JvbGwgPSBhZGRlZC5vbGRGcmFtZU1heFNjcm9sbDtcbiAgIW9sZE1heFNjcm9sbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGRyb3BwYWJsZSB3aXRoIGZyYW1lIHRvIGhhdmUgb2xkIG1heCBmcmFtZSBzY3JvbGwgd2hlbiByZW1vdmluZyBwbGFjZWhvbGRlcicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IG5ld0ZyYW1lID0gd2l0aE1heFNjcm9sbChmcmFtZSwgb2xkTWF4U2Nyb2xsKTtcbiAgY29uc3Qgc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgYXhpczogZHJvcHBhYmxlLmF4aXMsXG4gICAgZnJhbWU6IG5ld0ZyYW1lLFxuICAgIHdpdGhQbGFjZWhvbGRlcjogbnVsbFxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kcm9wcGFibGUsXG4gICAgc3ViamVjdCxcbiAgICBmcmFtZTogbmV3RnJhbWVcbiAgfTtcbn07XG5cbnZhciBtb3ZlVG9OZXdEcm9wcGFibGUgPSAoe1xuICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gIG1vdmVSZWxhdGl2ZVRvLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgZHJhZ2dhYmxlLFxuICBkcmFnZ2FibGVzLFxuICBkZXN0aW5hdGlvbixcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgaWYgKCFtb3ZlUmVsYXRpdmVUbykge1xuICAgIGlmIChpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwcm9wb3NlZCA9IHtcbiAgICAgIGRpc3BsYWNlZDogZW1wdHlHcm91cHMsXG4gICAgICBkaXNwbGFjZWRCeTogbm9EaXNwbGFjZWRCeSxcbiAgICAgIGF0OiB7XG4gICAgICAgIHR5cGU6ICdSRU9SREVSJyxcbiAgICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgICBkcm9wcGFibGVJZDogZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCxcbiAgICAgICAgICBpbmRleDogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwcm9wb3NlZFBhZ2VCb3JkZXJCb3hDZW50ZXIgPSBnZXRQYWdlQm9yZGVyQm94Q2VudGVyRnJvbUltcGFjdCh7XG4gICAgICBpbXBhY3Q6IHByb3Bvc2VkLFxuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbixcbiAgICAgIGRyYWdnYWJsZXMsXG4gICAgICBhZnRlckNyaXRpY2FsXG4gICAgfSk7XG4gICAgY29uc3Qgd2l0aFBsYWNlaG9sZGVyID0gaXNIb21lT2YoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbikgPyBkZXN0aW5hdGlvbiA6IGFkZFBsYWNlaG9sZGVyKGRlc3RpbmF0aW9uLCBkcmFnZ2FibGUsIGRyYWdnYWJsZXMpO1xuICAgIGNvbnN0IGlzVmlzaWJsZUluTmV3TG9jYXRpb24gPSBpc1RvdGFsbHlWaXNpYmxlSW5OZXdMb2NhdGlvbih7XG4gICAgICBkcmFnZ2FibGUsXG4gICAgICBkZXN0aW5hdGlvbjogd2l0aFBsYWNlaG9sZGVyLFxuICAgICAgbmV3UGFnZUJvcmRlckJveENlbnRlcjogcHJvcG9zZWRQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudDogZmFsc2UsXG4gICAgICBvbmx5T25NYWluQXhpczogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBpc1Zpc2libGVJbk5ld0xvY2F0aW9uID8gcHJvcG9zZWQgOiBudWxsO1xuICB9XG4gIGNvbnN0IGlzR29pbmdCZWZvcmVUYXJnZXQgPSBCb29sZWFuKHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcltkZXN0aW5hdGlvbi5heGlzLmxpbmVdIDw9IG1vdmVSZWxhdGl2ZVRvLnBhZ2UuYm9yZGVyQm94LmNlbnRlcltkZXN0aW5hdGlvbi5heGlzLmxpbmVdKTtcbiAgY29uc3QgcHJvcG9zZWRJbmRleCA9ICgoKSA9PiB7XG4gICAgY29uc3QgcmVsYXRpdmVUbyA9IG1vdmVSZWxhdGl2ZVRvLmRlc2NyaXB0b3IuaW5kZXg7XG4gICAgaWYgKG1vdmVSZWxhdGl2ZVRvLmRlc2NyaXB0b3IuaWQgPT09IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkKSB7XG4gICAgICByZXR1cm4gcmVsYXRpdmVUbztcbiAgICB9XG4gICAgaWYgKGlzR29pbmdCZWZvcmVUYXJnZXQpIHtcbiAgICAgIHJldHVybiByZWxhdGl2ZVRvO1xuICAgIH1cbiAgICByZXR1cm4gcmVsYXRpdmVUbyArIDE7XG4gIH0pKCk7XG4gIGNvbnN0IGRpc3BsYWNlZEJ5ID0gZ2V0RGlzcGxhY2VkQnkoZGVzdGluYXRpb24uYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpO1xuICByZXR1cm4gY2FsY3VsYXRlUmVvcmRlckltcGFjdCh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIHZpZXdwb3J0LFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGxhc3Q6IGVtcHR5R3JvdXBzLFxuICAgIGluZGV4OiBwcm9wb3NlZEluZGV4XG4gIH0pO1xufTtcblxudmFyIG1vdmVDcm9zc0F4aXMgPSAoe1xuICBpc01vdmluZ0ZvcndhcmQsXG4gIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgZHJhZ2dhYmxlLFxuICBpc092ZXIsXG4gIGRyYWdnYWJsZXMsXG4gIGRyb3BwYWJsZXMsXG4gIHZpZXdwb3J0LFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGNvbnN0IGRlc3RpbmF0aW9uID0gZ2V0QmVzdENyb3NzQXhpc0Ryb3BwYWJsZSh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgIHBhZ2VCb3JkZXJCb3hDZW50ZXI6IHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICBzb3VyY2U6IGlzT3ZlcixcbiAgICBkcm9wcGFibGVzLFxuICAgIHZpZXdwb3J0XG4gIH0pO1xuICBpZiAoIWRlc3RpbmF0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaW5zaWRlRGVzdGluYXRpb24gPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICBjb25zdCBtb3ZlUmVsYXRpdmVUbyA9IGdldENsb3Nlc3REcmFnZ2FibGUoe1xuICAgIHBhZ2VCb3JkZXJCb3hDZW50ZXI6IHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICB2aWV3cG9ydCxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBjb25zdCBpbXBhY3QgPSBtb3ZlVG9OZXdEcm9wcGFibGUoe1xuICAgIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBtb3ZlUmVsYXRpdmVUbyxcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBpZiAoIWltcGFjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHBhZ2VCb3JkZXJCb3hDZW50ZXIgPSBnZXRQYWdlQm9yZGVyQm94Q2VudGVyRnJvbUltcGFjdCh7XG4gICAgaW1wYWN0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcm9wcGFibGU6IGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgY29uc3QgY2xpZW50U2VsZWN0aW9uID0gZ2V0Q2xpZW50RnJvbVBhZ2VCb3JkZXJCb3hDZW50ZXIoe1xuICAgIHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZHJhZ2dhYmxlLFxuICAgIHZpZXdwb3J0XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNsaWVudFNlbGVjdGlvbixcbiAgICBpbXBhY3QsXG4gICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IG51bGxcbiAgfTtcbn07XG5cbnZhciB3aGF0SXNEcmFnZ2VkT3ZlciA9IGltcGFjdCA9PiB7XG4gIGNvbnN0IGF0ID0gaW1wYWN0LmF0O1xuICBpZiAoIWF0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGF0LnR5cGUgPT09ICdSRU9SREVSJykge1xuICAgIHJldHVybiBhdC5kZXN0aW5hdGlvbi5kcm9wcGFibGVJZDtcbiAgfVxuICByZXR1cm4gYXQuY29tYmluZS5kcm9wcGFibGVJZDtcbn07XG5cbmNvbnN0IGdldERyb3BwYWJsZU92ZXIkMSA9IChpbXBhY3QsIGRyb3BwYWJsZXMpID0+IHtcbiAgY29uc3QgaWQgPSB3aGF0SXNEcmFnZ2VkT3ZlcihpbXBhY3QpO1xuICByZXR1cm4gaWQgPyBkcm9wcGFibGVzW2lkXSA6IG51bGw7XG59O1xudmFyIG1vdmVJbkRpcmVjdGlvbiA9ICh7XG4gIHN0YXRlLFxuICB0eXBlXG59KSA9PiB7XG4gIGNvbnN0IGlzQWN0dWFsbHlPdmVyID0gZ2V0RHJvcHBhYmxlT3ZlciQxKHN0YXRlLmltcGFjdCwgc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzKTtcbiAgY29uc3QgaXNNYWluQXhpc01vdmVtZW50QWxsb3dlZCA9IEJvb2xlYW4oaXNBY3R1YWxseU92ZXIpO1xuICBjb25zdCBob21lID0gc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW3N0YXRlLmNyaXRpY2FsLmRyb3BwYWJsZS5pZF07XG4gIGNvbnN0IGlzT3ZlciA9IGlzQWN0dWFsbHlPdmVyIHx8IGhvbWU7XG4gIGNvbnN0IGRpcmVjdGlvbiA9IGlzT3Zlci5heGlzLmRpcmVjdGlvbjtcbiAgY29uc3QgaXNNb3ZpbmdPbk1haW5BeGlzID0gZGlyZWN0aW9uID09PSAndmVydGljYWwnICYmICh0eXBlID09PSAnTU9WRV9VUCcgfHwgdHlwZSA9PT0gJ01PVkVfRE9XTicpIHx8IGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnICYmICh0eXBlID09PSAnTU9WRV9MRUZUJyB8fCB0eXBlID09PSAnTU9WRV9SSUdIVCcpO1xuICBpZiAoaXNNb3ZpbmdPbk1haW5BeGlzICYmICFpc01haW5BeGlzTW92ZW1lbnRBbGxvd2VkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaXNNb3ZpbmdGb3J3YXJkID0gdHlwZSA9PT0gJ01PVkVfRE9XTicgfHwgdHlwZSA9PT0gJ01PVkVfUklHSFQnO1xuICBjb25zdCBkcmFnZ2FibGUgPSBzdGF0ZS5kaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgY29uc3QgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyID0gc3RhdGUuY3VycmVudC5wYWdlLmJvcmRlckJveENlbnRlcjtcbiAgY29uc3Qge1xuICAgIGRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlc1xuICB9ID0gc3RhdGUuZGltZW5zaW9ucztcbiAgcmV0dXJuIGlzTW92aW5nT25NYWluQXhpcyA/IG1vdmVUb05leHRQbGFjZSh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb246IGlzT3ZlcixcbiAgICBkcmFnZ2FibGVzLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydCxcbiAgICBwcmV2aW91c0NsaWVudFNlbGVjdGlvbjogc3RhdGUuY3VycmVudC5jbGllbnQuc2VsZWN0aW9uLFxuICAgIHByZXZpb3VzSW1wYWN0OiBzdGF0ZS5pbXBhY3QsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbFxuICB9KSA6IG1vdmVDcm9zc0F4aXMoe1xuICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGlzT3ZlcixcbiAgICBkcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXMsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycgfHwgc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJztcbn1cblxuZnVuY3Rpb24gaXNQb3NpdGlvbkluRnJhbWUoZnJhbWUpIHtcbiAgY29uc3QgaXNXaXRoaW5WZXJ0aWNhbCA9IGlzV2l0aGluKGZyYW1lLnRvcCwgZnJhbWUuYm90dG9tKTtcbiAgY29uc3QgaXNXaXRoaW5Ib3Jpem9udGFsID0gaXNXaXRoaW4oZnJhbWUubGVmdCwgZnJhbWUucmlnaHQpO1xuICByZXR1cm4gZnVuY3Rpb24gcnVuKHBvaW50KSB7XG4gICAgcmV0dXJuIGlzV2l0aGluVmVydGljYWwocG9pbnQueSkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHBvaW50LngpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRIYXNPdmVybGFwKGZpcnN0LCBzZWNvbmQpIHtcbiAgcmV0dXJuIGZpcnN0LmxlZnQgPCBzZWNvbmQucmlnaHQgJiYgZmlyc3QucmlnaHQgPiBzZWNvbmQubGVmdCAmJiBmaXJzdC50b3AgPCBzZWNvbmQuYm90dG9tICYmIGZpcnN0LmJvdHRvbSA+IHNlY29uZC50b3A7XG59XG5mdW5jdGlvbiBnZXRGdXJ0aGVzdEF3YXkoe1xuICBwYWdlQm9yZGVyQm94LFxuICBkcmFnZ2FibGUsXG4gIGNhbmRpZGF0ZXNcbn0pIHtcbiAgY29uc3Qgc3RhcnRDZW50ZXIgPSBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3guY2VudGVyO1xuICBjb25zdCBzb3J0ZWQgPSBjYW5kaWRhdGVzLm1hcChjYW5kaWRhdGUgPT4ge1xuICAgIGNvbnN0IGF4aXMgPSBjYW5kaWRhdGUuYXhpcztcbiAgICBjb25zdCB0YXJnZXQgPSBwYXRjaChjYW5kaWRhdGUuYXhpcy5saW5lLCBwYWdlQm9yZGVyQm94LmNlbnRlcltheGlzLmxpbmVdLCBjYW5kaWRhdGUucGFnZS5ib3JkZXJCb3guY2VudGVyW2F4aXMuY3Jvc3NBeGlzTGluZV0pO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogY2FuZGlkYXRlLmRlc2NyaXB0b3IuaWQsXG4gICAgICBkaXN0YW5jZTogZGlzdGFuY2Uoc3RhcnRDZW50ZXIsIHRhcmdldClcbiAgICB9O1xuICB9KS5zb3J0KChhLCBiKSA9PiBiLmRpc3RhbmNlIC0gYS5kaXN0YW5jZSk7XG4gIHJldHVybiBzb3J0ZWRbMF0gPyBzb3J0ZWRbMF0uaWQgOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RHJvcHBhYmxlT3Zlcih7XG4gIHBhZ2VCb3JkZXJCb3gsXG4gIGRyYWdnYWJsZSxcbiAgZHJvcHBhYmxlc1xufSkge1xuICBjb25zdCBjYW5kaWRhdGVzID0gdG9Ecm9wcGFibGVMaXN0KGRyb3BwYWJsZXMpLmZpbHRlcihpdGVtID0+IHtcbiAgICBpZiAoIWl0ZW0uaXNFbmFibGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZSA9IGl0ZW0uc3ViamVjdC5hY3RpdmU7XG4gICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFnZXRIYXNPdmVybGFwKHBhZ2VCb3JkZXJCb3gsIGFjdGl2ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlzUG9zaXRpb25JbkZyYW1lKGFjdGl2ZSkocGFnZUJvcmRlckJveC5jZW50ZXIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgYXhpcyA9IGl0ZW0uYXhpcztcbiAgICBjb25zdCBjaGlsZENlbnRlciA9IGFjdGl2ZS5jZW50ZXJbYXhpcy5jcm9zc0F4aXNMaW5lXTtcbiAgICBjb25zdCBjcm9zc0F4aXNTdGFydCA9IHBhZ2VCb3JkZXJCb3hbYXhpcy5jcm9zc0F4aXNTdGFydF07XG4gICAgY29uc3QgY3Jvc3NBeGlzRW5kID0gcGFnZUJvcmRlckJveFtheGlzLmNyb3NzQXhpc0VuZF07XG4gICAgY29uc3QgaXNDb250YWluZWQgPSBpc1dpdGhpbihhY3RpdmVbYXhpcy5jcm9zc0F4aXNTdGFydF0sIGFjdGl2ZVtheGlzLmNyb3NzQXhpc0VuZF0pO1xuICAgIGNvbnN0IGlzU3RhcnRDb250YWluZWQgPSBpc0NvbnRhaW5lZChjcm9zc0F4aXNTdGFydCk7XG4gICAgY29uc3QgaXNFbmRDb250YWluZWQgPSBpc0NvbnRhaW5lZChjcm9zc0F4aXNFbmQpO1xuICAgIGlmICghaXNTdGFydENvbnRhaW5lZCAmJiAhaXNFbmRDb250YWluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNTdGFydENvbnRhaW5lZCkge1xuICAgICAgcmV0dXJuIGNyb3NzQXhpc1N0YXJ0IDwgY2hpbGRDZW50ZXI7XG4gICAgfVxuICAgIHJldHVybiBjcm9zc0F4aXNFbmQgPiBjaGlsZENlbnRlcjtcbiAgfSk7XG4gIGlmICghY2FuZGlkYXRlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gY2FuZGlkYXRlc1swXS5kZXNjcmlwdG9yLmlkO1xuICB9XG4gIHJldHVybiBnZXRGdXJ0aGVzdEF3YXkoe1xuICAgIHBhZ2VCb3JkZXJCb3gsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGNhbmRpZGF0ZXNcbiAgfSk7XG59XG5cbmNvbnN0IG9mZnNldFJlY3RCeVBvc2l0aW9uID0gKHJlY3QsIHBvaW50KSA9PiBnZXRSZWN0KG9mZnNldEJ5UG9zaXRpb24ocmVjdCwgcG9pbnQpKTtcblxudmFyIHdpdGhEcm9wcGFibGVTY3JvbGwgPSAoZHJvcHBhYmxlLCBhcmVhKSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIGFyZWE7XG4gIH1cbiAgcmV0dXJuIG9mZnNldFJlY3RCeVBvc2l0aW9uKGFyZWEsIGZyYW1lLnNjcm9sbC5kaWZmLnZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIGdldElzRGlzcGxhY2VkKHtcbiAgZGlzcGxhY2VkLFxuICBpZFxufSkge1xuICByZXR1cm4gQm9vbGVhbihkaXNwbGFjZWQudmlzaWJsZVtpZF0gfHwgZGlzcGxhY2VkLmludmlzaWJsZVtpZF0pO1xufVxuXG5mdW5jdGlvbiBhdEluZGV4KHtcbiAgZHJhZ2dhYmxlLFxuICBjbG9zZXN0LFxuICBpbkhvbWVMaXN0XG59KSB7XG4gIGlmICghY2xvc2VzdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghaW5Ib21lTGlzdCkge1xuICAgIHJldHVybiBjbG9zZXN0LmRlc2NyaXB0b3IuaW5kZXg7XG4gIH1cbiAgaWYgKGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleCA+IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmluZGV4KSB7XG4gICAgcmV0dXJuIGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleCAtIDE7XG4gIH1cbiAgcmV0dXJuIGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleDtcbn1cbnZhciBnZXRSZW9yZGVySW1wYWN0ID0gKHtcbiAgcGFnZUJvcmRlckJveFdpdGhEcm9wcGFibGVTY3JvbGw6IHRhcmdldFJlY3QsXG4gIGRyYWdnYWJsZSxcbiAgZGVzdGluYXRpb24sXG4gIGluc2lkZURlc3RpbmF0aW9uLFxuICBsYXN0LFxuICB2aWV3cG9ydCxcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCBheGlzID0gZGVzdGluYXRpb24uYXhpcztcbiAgY29uc3QgZGlzcGxhY2VkQnkgPSBnZXREaXNwbGFjZWRCeShkZXN0aW5hdGlvbi5heGlzLCBkcmFnZ2FibGUuZGlzcGxhY2VCeSk7XG4gIGNvbnN0IGRpc3BsYWNlbWVudCA9IGRpc3BsYWNlZEJ5LnZhbHVlO1xuICBjb25zdCB0YXJnZXRTdGFydCA9IHRhcmdldFJlY3RbYXhpcy5zdGFydF07XG4gIGNvbnN0IHRhcmdldEVuZCA9IHRhcmdldFJlY3RbYXhpcy5lbmRdO1xuICBjb25zdCB3aXRob3V0RHJhZ2dpbmcgPSByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdChkcmFnZ2FibGUsIGluc2lkZURlc3RpbmF0aW9uKTtcbiAgY29uc3QgY2xvc2VzdCA9IHdpdGhvdXREcmFnZ2luZy5maW5kKGNoaWxkID0+IHtcbiAgICBjb25zdCBpZCA9IGNoaWxkLmRlc2NyaXB0b3IuaWQ7XG4gICAgY29uc3QgY2hpbGRDZW50ZXIgPSBjaGlsZC5wYWdlLmJvcmRlckJveC5jZW50ZXJbYXhpcy5saW5lXTtcbiAgICBjb25zdCBkaWRTdGFydEFmdGVyQ3JpdGljYWwkMSA9IGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChpZCwgYWZ0ZXJDcml0aWNhbCk7XG4gICAgY29uc3QgaXNEaXNwbGFjZWQgPSBnZXRJc0Rpc3BsYWNlZCh7XG4gICAgICBkaXNwbGFjZWQ6IGxhc3QsXG4gICAgICBpZFxuICAgIH0pO1xuICAgIGlmIChkaWRTdGFydEFmdGVyQ3JpdGljYWwkMSkge1xuICAgICAgaWYgKGlzRGlzcGxhY2VkKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRFbmQgPD0gY2hpbGRDZW50ZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0U3RhcnQgPCBjaGlsZENlbnRlciAtIGRpc3BsYWNlbWVudDtcbiAgICB9XG4gICAgaWYgKGlzRGlzcGxhY2VkKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0RW5kIDw9IGNoaWxkQ2VudGVyICsgZGlzcGxhY2VtZW50O1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0U3RhcnQgPCBjaGlsZENlbnRlcjtcbiAgfSkgfHwgbnVsbDtcbiAgY29uc3QgbmV3SW5kZXggPSBhdEluZGV4KHtcbiAgICBkcmFnZ2FibGUsXG4gICAgY2xvc2VzdCxcbiAgICBpbkhvbWVMaXN0OiBpc0hvbWVPZihkcmFnZ2FibGUsIGRlc3RpbmF0aW9uKVxuICB9KTtcbiAgcmV0dXJuIGNhbGN1bGF0ZVJlb3JkZXJJbXBhY3Qoe1xuICAgIGRyYWdnYWJsZSxcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBkZXN0aW5hdGlvbixcbiAgICB2aWV3cG9ydCxcbiAgICBsYXN0LFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGluZGV4OiBuZXdJbmRleFxuICB9KTtcbn07XG5cbmNvbnN0IGNvbWJpbmVUaHJlc2hvbGREaXZpc29yID0gNDtcbnZhciBnZXRDb21iaW5lSW1wYWN0ID0gKHtcbiAgZHJhZ2dhYmxlLFxuICBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbDogdGFyZ2V0UmVjdCxcbiAgcHJldmlvdXNJbXBhY3QsXG4gIGRlc3RpbmF0aW9uLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBpZiAoIWRlc3RpbmF0aW9uLmlzQ29tYmluZUVuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBheGlzID0gZGVzdGluYXRpb24uYXhpcztcbiAgY29uc3QgZGlzcGxhY2VkQnkgPSBnZXREaXNwbGFjZWRCeShkZXN0aW5hdGlvbi5heGlzLCBkcmFnZ2FibGUuZGlzcGxhY2VCeSk7XG4gIGNvbnN0IGRpc3BsYWNlbWVudCA9IGRpc3BsYWNlZEJ5LnZhbHVlO1xuICBjb25zdCB0YXJnZXRTdGFydCA9IHRhcmdldFJlY3RbYXhpcy5zdGFydF07XG4gIGNvbnN0IHRhcmdldEVuZCA9IHRhcmdldFJlY3RbYXhpcy5lbmRdO1xuICBjb25zdCB3aXRob3V0RHJhZ2dpbmcgPSByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdChkcmFnZ2FibGUsIGluc2lkZURlc3RpbmF0aW9uKTtcbiAgY29uc3QgY29tYmluZVdpdGggPSB3aXRob3V0RHJhZ2dpbmcuZmluZChjaGlsZCA9PiB7XG4gICAgY29uc3QgaWQgPSBjaGlsZC5kZXNjcmlwdG9yLmlkO1xuICAgIGNvbnN0IGNoaWxkUmVjdCA9IGNoaWxkLnBhZ2UuYm9yZGVyQm94O1xuICAgIGNvbnN0IGNoaWxkU2l6ZSA9IGNoaWxkUmVjdFtheGlzLnNpemVdO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IGNoaWxkU2l6ZSAvIGNvbWJpbmVUaHJlc2hvbGREaXZpc29yO1xuICAgIGNvbnN0IGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbCQxID0gZGlkU3RhcnRBZnRlckNyaXRpY2FsKGlkLCBhZnRlckNyaXRpY2FsKTtcbiAgICBjb25zdCBpc0Rpc3BsYWNlZCA9IGdldElzRGlzcGxhY2VkKHtcbiAgICAgIGRpc3BsYWNlZDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgICAgaWRcbiAgICB9KTtcbiAgICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEpIHtcbiAgICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0RW5kID4gY2hpbGRSZWN0W2F4aXMuc3RhcnRdICsgdGhyZXNob2xkICYmIHRhcmdldEVuZCA8IGNoaWxkUmVjdFtheGlzLmVuZF0gLSB0aHJlc2hvbGQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0U3RhcnQgPiBjaGlsZFJlY3RbYXhpcy5zdGFydF0gLSBkaXNwbGFjZW1lbnQgKyB0aHJlc2hvbGQgJiYgdGFyZ2V0U3RhcnQgPCBjaGlsZFJlY3RbYXhpcy5lbmRdIC0gZGlzcGxhY2VtZW50IC0gdGhyZXNob2xkO1xuICAgIH1cbiAgICBpZiAoaXNEaXNwbGFjZWQpIHtcbiAgICAgIHJldHVybiB0YXJnZXRFbmQgPiBjaGlsZFJlY3RbYXhpcy5zdGFydF0gKyBkaXNwbGFjZW1lbnQgKyB0aHJlc2hvbGQgJiYgdGFyZ2V0RW5kIDwgY2hpbGRSZWN0W2F4aXMuZW5kXSArIGRpc3BsYWNlbWVudCAtIHRocmVzaG9sZDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFN0YXJ0ID4gY2hpbGRSZWN0W2F4aXMuc3RhcnRdICsgdGhyZXNob2xkICYmIHRhcmdldFN0YXJ0IDwgY2hpbGRSZWN0W2F4aXMuZW5kXSAtIHRocmVzaG9sZDtcbiAgfSk7XG4gIGlmICghY29tYmluZVdpdGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBpbXBhY3QgPSB7XG4gICAgZGlzcGxhY2VkQnksXG4gICAgZGlzcGxhY2VkOiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQsXG4gICAgYXQ6IHtcbiAgICAgIHR5cGU6ICdDT01CSU5FJyxcbiAgICAgIGNvbWJpbmU6IHtcbiAgICAgICAgZHJhZ2dhYmxlSWQ6IGNvbWJpbmVXaXRoLmRlc2NyaXB0b3IuaWQsXG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkXG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gaW1wYWN0O1xufTtcblxudmFyIGdldERyYWdJbXBhY3QgPSAoe1xuICBwYWdlT2Zmc2V0LFxuICBkcmFnZ2FibGUsXG4gIGRyYWdnYWJsZXMsXG4gIGRyb3BwYWJsZXMsXG4gIHByZXZpb3VzSW1wYWN0LFxuICB2aWV3cG9ydCxcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCBwYWdlQm9yZGVyQm94ID0gb2Zmc2V0UmVjdEJ5UG9zaXRpb24oZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LCBwYWdlT2Zmc2V0KTtcbiAgY29uc3QgZGVzdGluYXRpb25JZCA9IGdldERyb3BwYWJsZU92ZXIoe1xuICAgIHBhZ2VCb3JkZXJCb3gsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyb3BwYWJsZXNcbiAgfSk7XG4gIGlmICghZGVzdGluYXRpb25JZCkge1xuICAgIHJldHVybiBub0ltcGFjdDtcbiAgfVxuICBjb25zdCBkZXN0aW5hdGlvbiA9IGRyb3BwYWJsZXNbZGVzdGluYXRpb25JZF07XG4gIGNvbnN0IGluc2lkZURlc3RpbmF0aW9uID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgcGFnZUJvcmRlckJveFdpdGhEcm9wcGFibGVTY3JvbGwgPSB3aXRoRHJvcHBhYmxlU2Nyb2xsKGRlc3RpbmF0aW9uLCBwYWdlQm9yZGVyQm94KTtcbiAgcmV0dXJuIGdldENvbWJpbmVJbXBhY3Qoe1xuICAgIHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsLFxuICAgIGRyYWdnYWJsZSxcbiAgICBwcmV2aW91c0ltcGFjdCxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pIHx8IGdldFJlb3JkZXJJbXBhY3Qoe1xuICAgIHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsLFxuICAgIGRyYWdnYWJsZSxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBsYXN0OiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQsXG4gICAgdmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbn07XG5cbnZhciBwYXRjaERyb3BwYWJsZU1hcCA9IChkcm9wcGFibGVzLCB1cGRhdGVkKSA9PiAoe1xuICAuLi5kcm9wcGFibGVzLFxuICBbdXBkYXRlZC5kZXNjcmlwdG9yLmlkXTogdXBkYXRlZFxufSk7XG5cbmNvbnN0IGNsZWFyVW51c2VkUGxhY2Vob2xkZXIgPSAoe1xuICBwcmV2aW91c0ltcGFjdCxcbiAgaW1wYWN0LFxuICBkcm9wcGFibGVzXG59KSA9PiB7XG4gIGNvbnN0IGxhc3QgPSB3aGF0SXNEcmFnZ2VkT3ZlcihwcmV2aW91c0ltcGFjdCk7XG4gIGNvbnN0IG5vdyA9IHdoYXRJc0RyYWdnZWRPdmVyKGltcGFjdCk7XG4gIGlmICghbGFzdCkge1xuICAgIHJldHVybiBkcm9wcGFibGVzO1xuICB9XG4gIGlmIChsYXN0ID09PSBub3cpIHtcbiAgICByZXR1cm4gZHJvcHBhYmxlcztcbiAgfVxuICBjb25zdCBsYXN0RHJvcHBhYmxlID0gZHJvcHBhYmxlc1tsYXN0XTtcbiAgaWYgKCFsYXN0RHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIGRyb3BwYWJsZXM7XG4gIH1cbiAgY29uc3QgdXBkYXRlZCA9IHJlbW92ZVBsYWNlaG9sZGVyKGxhc3REcm9wcGFibGUpO1xuICByZXR1cm4gcGF0Y2hEcm9wcGFibGVNYXAoZHJvcHBhYmxlcywgdXBkYXRlZCk7XG59O1xudmFyIHJlY29tcHV0ZVBsYWNlaG9sZGVycyA9ICh7XG4gIGRyYWdnYWJsZSxcbiAgZHJhZ2dhYmxlcyxcbiAgZHJvcHBhYmxlcyxcbiAgcHJldmlvdXNJbXBhY3QsXG4gIGltcGFjdFxufSkgPT4ge1xuICBjb25zdCBjbGVhbmVkID0gY2xlYXJVbnVzZWRQbGFjZWhvbGRlcih7XG4gICAgcHJldmlvdXNJbXBhY3QsXG4gICAgaW1wYWN0LFxuICAgIGRyb3BwYWJsZXNcbiAgfSk7XG4gIGNvbnN0IGlzT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKGltcGFjdCk7XG4gIGlmICghaXNPdmVyKSB7XG4gICAgcmV0dXJuIGNsZWFuZWQ7XG4gIH1cbiAgY29uc3QgZHJvcHBhYmxlID0gZHJvcHBhYmxlc1tpc092ZXJdO1xuICBpZiAoaXNIb21lT2YoZHJhZ2dhYmxlLCBkcm9wcGFibGUpKSB7XG4gICAgcmV0dXJuIGNsZWFuZWQ7XG4gIH1cbiAgaWYgKGRyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBjbGVhbmVkO1xuICB9XG4gIGNvbnN0IHBhdGNoZWQgPSBhZGRQbGFjZWhvbGRlcihkcm9wcGFibGUsIGRyYWdnYWJsZSwgZHJhZ2dhYmxlcyk7XG4gIHJldHVybiBwYXRjaERyb3BwYWJsZU1hcChjbGVhbmVkLCBwYXRjaGVkKTtcbn07XG5cbnZhciB1cGRhdGUgPSAoe1xuICBzdGF0ZSxcbiAgY2xpZW50U2VsZWN0aW9uOiBmb3JjZWRDbGllbnRTZWxlY3Rpb24sXG4gIGRpbWVuc2lvbnM6IGZvcmNlZERpbWVuc2lvbnMsXG4gIHZpZXdwb3J0OiBmb3JjZWRWaWV3cG9ydCxcbiAgaW1wYWN0OiBmb3JjZWRJbXBhY3QsXG4gIHNjcm9sbEp1bXBSZXF1ZXN0XG59KSA9PiB7XG4gIGNvbnN0IHZpZXdwb3J0ID0gZm9yY2VkVmlld3BvcnQgfHwgc3RhdGUudmlld3BvcnQ7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSBmb3JjZWREaW1lbnNpb25zIHx8IHN0YXRlLmRpbWVuc2lvbnM7XG4gIGNvbnN0IGNsaWVudFNlbGVjdGlvbiA9IGZvcmNlZENsaWVudFNlbGVjdGlvbiB8fCBzdGF0ZS5jdXJyZW50LmNsaWVudC5zZWxlY3Rpb247XG4gIGNvbnN0IG9mZnNldCA9IHN1YnRyYWN0KGNsaWVudFNlbGVjdGlvbiwgc3RhdGUuaW5pdGlhbC5jbGllbnQuc2VsZWN0aW9uKTtcbiAgY29uc3QgY2xpZW50ID0ge1xuICAgIG9mZnNldCxcbiAgICBzZWxlY3Rpb246IGNsaWVudFNlbGVjdGlvbixcbiAgICBib3JkZXJCb3hDZW50ZXI6IGFkZChzdGF0ZS5pbml0aWFsLmNsaWVudC5ib3JkZXJCb3hDZW50ZXIsIG9mZnNldClcbiAgfTtcbiAgY29uc3QgcGFnZSA9IHtcbiAgICBzZWxlY3Rpb246IGFkZChjbGllbnQuc2VsZWN0aW9uLCB2aWV3cG9ydC5zY3JvbGwuY3VycmVudCksXG4gICAgYm9yZGVyQm94Q2VudGVyOiBhZGQoY2xpZW50LmJvcmRlckJveENlbnRlciwgdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQpLFxuICAgIG9mZnNldDogYWRkKGNsaWVudC5vZmZzZXQsIHZpZXdwb3J0LnNjcm9sbC5kaWZmLnZhbHVlKVxuICB9O1xuICBjb25zdCBjdXJyZW50ID0ge1xuICAgIGNsaWVudCxcbiAgICBwYWdlXG4gIH07XG4gIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgZGltZW5zaW9ucyxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgY3VycmVudFxuICAgIH07XG4gIH1cbiAgY29uc3QgZHJhZ2dhYmxlID0gZGltZW5zaW9ucy5kcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gIGNvbnN0IG5ld0ltcGFjdCA9IGZvcmNlZEltcGFjdCB8fCBnZXREcmFnSW1wYWN0KHtcbiAgICBwYWdlT2Zmc2V0OiBwYWdlLm9mZnNldCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXM6IGRpbWVuc2lvbnMuZHJvcHBhYmxlcyxcbiAgICBwcmV2aW91c0ltcGFjdDogc3RhdGUuaW1wYWN0LFxuICAgIHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGNvbnN0IHdpdGhVcGRhdGVkUGxhY2Vob2xkZXJzID0gcmVjb21wdXRlUGxhY2Vob2xkZXJzKHtcbiAgICBkcmFnZ2FibGUsXG4gICAgaW1wYWN0OiBuZXdJbXBhY3QsXG4gICAgcHJldmlvdXNJbXBhY3Q6IHN0YXRlLmltcGFjdCxcbiAgICBkcmFnZ2FibGVzOiBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlczogZGltZW5zaW9ucy5kcm9wcGFibGVzXG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgY3VycmVudCxcbiAgICBkaW1lbnNpb25zOiB7XG4gICAgICBkcmFnZ2FibGVzOiBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgICBkcm9wcGFibGVzOiB3aXRoVXBkYXRlZFBsYWNlaG9sZGVyc1xuICAgIH0sXG4gICAgaW1wYWN0OiBuZXdJbXBhY3QsXG4gICAgdmlld3BvcnQsXG4gICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IHNjcm9sbEp1bXBSZXF1ZXN0IHx8IG51bGwsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBzY3JvbGxKdW1wUmVxdWVzdCA/IGZhbHNlIDogbnVsbFxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gZ2V0RHJhZ2dhYmxlcyhpZHMsIGRyYWdnYWJsZXMpIHtcbiAgcmV0dXJuIGlkcy5tYXAoaWQgPT4gZHJhZ2dhYmxlc1tpZF0pO1xufVxudmFyIHJlY29tcHV0ZSA9ICh7XG4gIGltcGFjdCxcbiAgdmlld3BvcnQsXG4gIGRyYWdnYWJsZXMsXG4gIGRlc3RpbmF0aW9uLFxuICBmb3JjZVNob3VsZEFuaW1hdGVcbn0pID0+IHtcbiAgY29uc3QgbGFzdCA9IGltcGFjdC5kaXNwbGFjZWQ7XG4gIGNvbnN0IGFmdGVyRHJhZ2dpbmcgPSBnZXREcmFnZ2FibGVzKGxhc3QuYWxsLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgZGlzcGxhY2VkID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZEJ5OiBpbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZSxcbiAgICBsYXN0XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIC4uLmltcGFjdCxcbiAgICBkaXNwbGFjZWRcbiAgfTtcbn07XG5cbnZhciBnZXRDbGllbnRCb3JkZXJCb3hDZW50ZXIgPSAoe1xuICBpbXBhY3QsXG4gIGRyYWdnYWJsZSxcbiAgZHJvcHBhYmxlLFxuICBkcmFnZ2FibGVzLFxuICB2aWV3cG9ydCxcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCBwYWdlQm9yZGVyQm94Q2VudGVyID0gZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3Qoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGUsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgcmV0dXJuIGdldENsaWVudEZyb21QYWdlQm9yZGVyQm94Q2VudGVyKHtcbiAgICBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIGRyYWdnYWJsZSxcbiAgICB2aWV3cG9ydFxuICB9KTtcbn07XG5cbnZhciByZWZyZXNoU25hcCA9ICh7XG4gIHN0YXRlLFxuICBkaW1lbnNpb25zOiBmb3JjZWREaW1lbnNpb25zLFxuICB2aWV3cG9ydDogZm9yY2VkVmlld3BvcnRcbn0pID0+IHtcbiAgIShzdGF0ZS5tb3ZlbWVudE1vZGUgPT09ICdTTkFQJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBjb25zdCBuZWVkc1Zpc2liaWxpdHlDaGVjayA9IHN0YXRlLmltcGFjdDtcbiAgY29uc3Qgdmlld3BvcnQgPSBmb3JjZWRWaWV3cG9ydCB8fCBzdGF0ZS52aWV3cG9ydDtcbiAgY29uc3QgZGltZW5zaW9ucyA9IGZvcmNlZERpbWVuc2lvbnMgfHwgc3RhdGUuZGltZW5zaW9ucztcbiAgY29uc3Qge1xuICAgIGRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlc1xuICB9ID0gZGltZW5zaW9ucztcbiAgY29uc3QgZHJhZ2dhYmxlID0gZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCBpc092ZXIgPSB3aGF0SXNEcmFnZ2VkT3ZlcihuZWVkc1Zpc2liaWxpdHlDaGVjayk7XG4gICFpc092ZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdNdXN0IGJlIG92ZXIgYSBkZXN0aW5hdGlvbiBpbiBTTkFQIG1vdmVtZW50IG1vZGUnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBjb25zdCBkZXN0aW5hdGlvbiA9IGRyb3BwYWJsZXNbaXNPdmVyXTtcbiAgY29uc3QgaW1wYWN0ID0gcmVjb21wdXRlKHtcbiAgICBpbXBhY3Q6IG5lZWRzVmlzaWJpbGl0eUNoZWNrLFxuICAgIHZpZXdwb3J0LFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZXNcbiAgfSk7XG4gIGNvbnN0IGNsaWVudFNlbGVjdGlvbiA9IGdldENsaWVudEJvcmRlckJveENlbnRlcih7XG4gICAgaW1wYWN0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcm9wcGFibGU6IGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgdmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgcmV0dXJuIHVwZGF0ZSh7XG4gICAgaW1wYWN0LFxuICAgIGNsaWVudFNlbGVjdGlvbixcbiAgICBzdGF0ZSxcbiAgICBkaW1lbnNpb25zLFxuICAgIHZpZXdwb3J0XG4gIH0pO1xufTtcblxudmFyIGdldEhvbWVMb2NhdGlvbiA9IGRlc2NyaXB0b3IgPT4gKHtcbiAgaW5kZXg6IGRlc2NyaXB0b3IuaW5kZXgsXG4gIGRyb3BwYWJsZUlkOiBkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXG59KTtcblxudmFyIGdldExpZnRFZmZlY3QgPSAoe1xuICBkcmFnZ2FibGUsXG4gIGhvbWUsXG4gIGRyYWdnYWJsZXMsXG4gIHZpZXdwb3J0XG59KSA9PiB7XG4gIGNvbnN0IGRpc3BsYWNlZEJ5ID0gZ2V0RGlzcGxhY2VkQnkoaG9tZS5heGlzLCBkcmFnZ2FibGUuZGlzcGxhY2VCeSk7XG4gIGNvbnN0IGluc2lkZUhvbWUgPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGhvbWUuZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IHJhd0luZGV4ID0gaW5zaWRlSG9tZS5pbmRleE9mKGRyYWdnYWJsZSk7XG4gICEocmF3SW5kZXggIT09IC0xKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGRyYWdnYWJsZSB0byBiZSBpbnNpZGUgaG9tZSBsaXN0JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3QgYWZ0ZXJEcmFnZ2luZyA9IGluc2lkZUhvbWUuc2xpY2UocmF3SW5kZXggKyAxKTtcbiAgY29uc3QgZWZmZWN0ZWQgPSBhZnRlckRyYWdnaW5nLnJlZHVjZSgocHJldmlvdXMsIGl0ZW0pID0+IHtcbiAgICBwcmV2aW91c1tpdGVtLmRlc2NyaXB0b3IuaWRdID0gdHJ1ZTtcbiAgICByZXR1cm4gcHJldmlvdXM7XG4gIH0sIHt9KTtcbiAgY29uc3QgYWZ0ZXJDcml0aWNhbCA9IHtcbiAgICBpblZpcnR1YWxMaXN0OiBob21lLmRlc2NyaXB0b3IubW9kZSA9PT0gJ3ZpcnR1YWwnLFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGVmZmVjdGVkXG4gIH07XG4gIGNvbnN0IGRpc3BsYWNlZCA9IGdldERpc3BsYWNlbWVudEdyb3Vwcyh7XG4gICAgYWZ0ZXJEcmFnZ2luZyxcbiAgICBkZXN0aW5hdGlvbjogaG9tZSxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBsYXN0OiBudWxsLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBpbXBhY3QgPSB7XG4gICAgZGlzcGxhY2VkLFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGF0OiB7XG4gICAgICB0eXBlOiAnUkVPUkRFUicsXG4gICAgICBkZXN0aW5hdGlvbjogZ2V0SG9tZUxvY2F0aW9uKGRyYWdnYWJsZS5kZXNjcmlwdG9yKVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBpbXBhY3QsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9O1xufTtcblxudmFyIHBhdGNoRGltZW5zaW9uTWFwID0gKGRpbWVuc2lvbnMsIHVwZGF0ZWQpID0+ICh7XG4gIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgZHJvcHBhYmxlczogcGF0Y2hEcm9wcGFibGVNYXAoZGltZW5zaW9ucy5kcm9wcGFibGVzLCB1cGRhdGVkKVxufSk7XG5cbmNvbnN0IHN0YXJ0ID0ga2V5ID0+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59O1xuY29uc3QgZmluaXNoID0ga2V5ID0+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59O1xuXG52YXIgb2Zmc2V0RHJhZ2dhYmxlID0gKHtcbiAgZHJhZ2dhYmxlLFxuICBvZmZzZXQ6IG9mZnNldCQxLFxuICBpbml0aWFsV2luZG93U2Nyb2xsXG59KSA9PiB7XG4gIGNvbnN0IGNsaWVudCA9IG9mZnNldChkcmFnZ2FibGUuY2xpZW50LCBvZmZzZXQkMSk7XG4gIGNvbnN0IHBhZ2UgPSB3aXRoU2Nyb2xsKGNsaWVudCwgaW5pdGlhbFdpbmRvd1Njcm9sbCk7XG4gIGNvbnN0IG1vdmVkID0ge1xuICAgIC4uLmRyYWdnYWJsZSxcbiAgICBwbGFjZWhvbGRlcjoge1xuICAgICAgLi4uZHJhZ2dhYmxlLnBsYWNlaG9sZGVyLFxuICAgICAgY2xpZW50XG4gICAgfSxcbiAgICBjbGllbnQsXG4gICAgcGFnZVxuICB9O1xuICByZXR1cm4gbW92ZWQ7XG59O1xuXG52YXIgZ2V0RnJhbWUgPSBkcm9wcGFibGUgPT4ge1xuICBjb25zdCBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgIWZyYW1lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgRHJvcHBhYmxlIHRvIGhhdmUgYSBmcmFtZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIHJldHVybiBmcmFtZTtcbn07XG5cbnZhciBhZGp1c3RBZGRpdGlvbnNGb3JTY3JvbGxDaGFuZ2VzID0gKHtcbiAgYWRkaXRpb25zLFxuICB1cGRhdGVkRHJvcHBhYmxlcyxcbiAgdmlld3BvcnRcbn0pID0+IHtcbiAgY29uc3Qgd2luZG93U2Nyb2xsQ2hhbmdlID0gdmlld3BvcnQuc2Nyb2xsLmRpZmYudmFsdWU7XG4gIHJldHVybiBhZGRpdGlvbnMubWFwKGRyYWdnYWJsZSA9PiB7XG4gICAgY29uc3QgZHJvcHBhYmxlSWQgPSBkcmFnZ2FibGUuZGVzY3JpcHRvci5kcm9wcGFibGVJZDtcbiAgICBjb25zdCBtb2RpZmllZCA9IHVwZGF0ZWREcm9wcGFibGVzW2Ryb3BwYWJsZUlkXTtcbiAgICBjb25zdCBmcmFtZSA9IGdldEZyYW1lKG1vZGlmaWVkKTtcbiAgICBjb25zdCBkcm9wcGFibGVTY3JvbGxDaGFuZ2UgPSBmcmFtZS5zY3JvbGwuZGlmZi52YWx1ZTtcbiAgICBjb25zdCB0b3RhbENoYW5nZSA9IGFkZCh3aW5kb3dTY3JvbGxDaGFuZ2UsIGRyb3BwYWJsZVNjcm9sbENoYW5nZSk7XG4gICAgY29uc3QgbW92ZWQgPSBvZmZzZXREcmFnZ2FibGUoe1xuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgb2Zmc2V0OiB0b3RhbENoYW5nZSxcbiAgICAgIGluaXRpYWxXaW5kb3dTY3JvbGw6IHZpZXdwb3J0LnNjcm9sbC5pbml0aWFsXG4gICAgfSk7XG4gICAgcmV0dXJuIG1vdmVkO1xuICB9KTtcbn07XG5cbnZhciBwdWJsaXNoV2hpbGVEcmFnZ2luZ0luVmlydHVhbCA9ICh7XG4gIHN0YXRlLFxuICBwdWJsaXNoZWRcbn0pID0+IHtcbiAgc3RhcnQoKTtcbiAgY29uc3Qgd2l0aFNjcm9sbENoYW5nZSA9IHB1Ymxpc2hlZC5tb2RpZmllZC5tYXAodXBkYXRlID0+IHtcbiAgICBjb25zdCBleGlzdGluZyA9IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1t1cGRhdGUuZHJvcHBhYmxlSWRdO1xuICAgIGNvbnN0IHNjcm9sbGVkID0gc2Nyb2xsRHJvcHBhYmxlKGV4aXN0aW5nLCB1cGRhdGUuc2Nyb2xsKTtcbiAgICByZXR1cm4gc2Nyb2xsZWQ7XG4gIH0pO1xuICBjb25zdCBkcm9wcGFibGVzID0ge1xuICAgIC4uLnN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlcyxcbiAgICAuLi50b0Ryb3BwYWJsZU1hcCh3aXRoU2Nyb2xsQ2hhbmdlKVxuICB9O1xuICBjb25zdCB1cGRhdGVkQWRkaXRpb25zID0gdG9EcmFnZ2FibGVNYXAoYWRqdXN0QWRkaXRpb25zRm9yU2Nyb2xsQ2hhbmdlcyh7XG4gICAgYWRkaXRpb25zOiBwdWJsaXNoZWQuYWRkaXRpb25zLFxuICAgIHVwZGF0ZWREcm9wcGFibGVzOiBkcm9wcGFibGVzLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydFxuICB9KSk7XG4gIGNvbnN0IGRyYWdnYWJsZXMgPSB7XG4gICAgLi4uc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgIC4uLnVwZGF0ZWRBZGRpdGlvbnNcbiAgfTtcbiAgcHVibGlzaGVkLnJlbW92YWxzLmZvckVhY2goaWQgPT4ge1xuICAgIGRlbGV0ZSBkcmFnZ2FibGVzW2lkXTtcbiAgfSk7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSB7XG4gICAgZHJvcHBhYmxlcyxcbiAgICBkcmFnZ2FibGVzXG4gIH07XG4gIGNvbnN0IHdhc092ZXJJZCA9IHdoYXRJc0RyYWdnZWRPdmVyKHN0YXRlLmltcGFjdCk7XG4gIGNvbnN0IHdhc092ZXIgPSB3YXNPdmVySWQgPyBkaW1lbnNpb25zLmRyb3BwYWJsZXNbd2FzT3ZlcklkXSA6IG51bGw7XG4gIGNvbnN0IGRyYWdnYWJsZSA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCBob21lID0gZGltZW5zaW9ucy5kcm9wcGFibGVzW3N0YXRlLmNyaXRpY2FsLmRyb3BwYWJsZS5pZF07XG4gIGNvbnN0IHtcbiAgICBpbXBhY3Q6IG9uTGlmdEltcGFjdCxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0gPSBnZXRMaWZ0RWZmZWN0KHtcbiAgICBkcmFnZ2FibGUsXG4gICAgaG9tZSxcbiAgICBkcmFnZ2FibGVzLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydFxuICB9KTtcbiAgY29uc3QgcHJldmlvdXNJbXBhY3QgPSB3YXNPdmVyICYmIHdhc092ZXIuaXNDb21iaW5lRW5hYmxlZCA/IHN0YXRlLmltcGFjdCA6IG9uTGlmdEltcGFjdDtcbiAgY29uc3QgaW1wYWN0ID0gZ2V0RHJhZ0ltcGFjdCh7XG4gICAgcGFnZU9mZnNldDogc3RhdGUuY3VycmVudC5wYWdlLm9mZnNldCxcbiAgICBkcmFnZ2FibGU6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdLFxuICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzOiBkaW1lbnNpb25zLmRyb3BwYWJsZXMsXG4gICAgcHJldmlvdXNJbXBhY3QsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGZpbmlzaCgpO1xuICBjb25zdCBkcmFnZ2luZ1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIHBoYXNlOiAnRFJBR0dJTkcnLFxuICAgIGltcGFjdCxcbiAgICBvbkxpZnRJbXBhY3QsXG4gICAgZGltZW5zaW9ucyxcbiAgICBhZnRlckNyaXRpY2FsLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogZmFsc2VcbiAgfTtcbiAgaWYgKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycpIHtcbiAgICByZXR1cm4gZHJhZ2dpbmdTdGF0ZTtcbiAgfVxuICBjb25zdCBkcm9wUGVuZGluZyA9IHtcbiAgICAuLi5kcmFnZ2luZ1N0YXRlLFxuICAgIHBoYXNlOiAnRFJPUF9QRU5ESU5HJyxcbiAgICByZWFzb246IHN0YXRlLnJlYXNvbixcbiAgICBpc1dhaXRpbmc6IGZhbHNlXG4gIH07XG4gIHJldHVybiBkcm9wUGVuZGluZztcbn07XG5cbmNvbnN0IGlzU25hcHBpbmcgPSBzdGF0ZSA9PiBzdGF0ZS5tb3ZlbWVudE1vZGUgPT09ICdTTkFQJztcbmNvbnN0IHBvc3REcm9wcGFibGVDaGFuZ2UgPSAoc3RhdGUsIHVwZGF0ZWQsIGlzRW5hYmxlZENoYW5naW5nKSA9PiB7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSBwYXRjaERpbWVuc2lvbk1hcChzdGF0ZS5kaW1lbnNpb25zLCB1cGRhdGVkKTtcbiAgaWYgKCFpc1NuYXBwaW5nKHN0YXRlKSB8fCBpc0VuYWJsZWRDaGFuZ2luZykge1xuICAgIHJldHVybiB1cGRhdGUoe1xuICAgICAgc3RhdGUsXG4gICAgICBkaW1lbnNpb25zXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlZnJlc2hTbmFwKHtcbiAgICBzdGF0ZSxcbiAgICBkaW1lbnNpb25zXG4gIH0pO1xufTtcbmZ1bmN0aW9uIHJlbW92ZVNjcm9sbEp1bXBSZXF1ZXN0KHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5pc0RyYWdnaW5nICYmIHN0YXRlLm1vdmVtZW50TW9kZSA9PT0gJ1NOQVAnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IG51bGxcbiAgICB9O1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbmNvbnN0IGlkbGUkMiA9IHtcbiAgcGhhc2U6ICdJRExFJyxcbiAgY29tcGxldGVkOiBudWxsLFxuICBzaG91bGRGbHVzaDogZmFsc2Vcbn07XG52YXIgcmVkdWNlciA9IChzdGF0ZSA9IGlkbGUkMiwgYWN0aW9uKSA9PiB7XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5pZGxlJDIsXG4gICAgICBzaG91bGRGbHVzaDogdHJ1ZVxuICAgIH07XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnSU5JVElBTF9QVUJMSVNIJykge1xuICAgICEoc3RhdGUucGhhc2UgPT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdJTklUSUFMX1BVQkxJU0ggbXVzdCBjb21lIGFmdGVyIGEgSURMRSBwaGFzZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3Qge1xuICAgICAgY3JpdGljYWwsXG4gICAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICBtb3ZlbWVudE1vZGVcbiAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgY29uc3QgZHJhZ2dhYmxlID0gZGltZW5zaW9ucy5kcmFnZ2FibGVzW2NyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gICAgY29uc3QgaG9tZSA9IGRpbWVuc2lvbnMuZHJvcHBhYmxlc1tjcml0aWNhbC5kcm9wcGFibGUuaWRdO1xuICAgIGNvbnN0IGNsaWVudCA9IHtcbiAgICAgIHNlbGVjdGlvbjogY2xpZW50U2VsZWN0aW9uLFxuICAgICAgYm9yZGVyQm94Q2VudGVyOiBkcmFnZ2FibGUuY2xpZW50LmJvcmRlckJveC5jZW50ZXIsXG4gICAgICBvZmZzZXQ6IG9yaWdpblxuICAgIH07XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgIGNsaWVudCxcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgc2VsZWN0aW9uOiBhZGQoY2xpZW50LnNlbGVjdGlvbiwgdmlld3BvcnQuc2Nyb2xsLmluaXRpYWwpLFxuICAgICAgICBib3JkZXJCb3hDZW50ZXI6IGFkZChjbGllbnQuc2VsZWN0aW9uLCB2aWV3cG9ydC5zY3JvbGwuaW5pdGlhbCksXG4gICAgICAgIG9mZnNldDogYWRkKGNsaWVudC5zZWxlY3Rpb24sIHZpZXdwb3J0LnNjcm9sbC5kaWZmLnZhbHVlKVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNXaW5kb3dTY3JvbGxBbGxvd2VkID0gdG9Ecm9wcGFibGVMaXN0KGRpbWVuc2lvbnMuZHJvcHBhYmxlcykuZXZlcnkoaXRlbSA9PiAhaXRlbS5pc0ZpeGVkT25QYWdlKTtcbiAgICBjb25zdCB7XG4gICAgICBpbXBhY3QsXG4gICAgICBhZnRlckNyaXRpY2FsXG4gICAgfSA9IGdldExpZnRFZmZlY3Qoe1xuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgaG9tZSxcbiAgICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICAgIHZpZXdwb3J0XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgcGhhc2U6ICdEUkFHR0lORycsXG4gICAgICBpc0RyYWdnaW5nOiB0cnVlLFxuICAgICAgY3JpdGljYWwsXG4gICAgICBtb3ZlbWVudE1vZGUsXG4gICAgICBkaW1lbnNpb25zLFxuICAgICAgaW5pdGlhbCxcbiAgICAgIGN1cnJlbnQ6IGluaXRpYWwsXG4gICAgICBpc1dpbmRvd1Njcm9sbEFsbG93ZWQsXG4gICAgICBpbXBhY3QsXG4gICAgICBhZnRlckNyaXRpY2FsLFxuICAgICAgb25MaWZ0SW1wYWN0OiBpbXBhY3QsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBudWxsLFxuICAgICAgZm9yY2VTaG91bGRBbmltYXRlOiBudWxsXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0NPTExFQ1RJT05fU1RBUlRJTkcnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgICEoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ29sbGVjdGlvbiBjYW5ub3Qgc3RhcnQgZnJvbSBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBwaGFzZTogJ0NPTExFQ1RJTkcnXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ1BVQkxJU0hfV0hJTEVfRFJBR0dJTkcnKSB7XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBVbmV4cGVjdGVkICR7YWN0aW9uLnR5cGV9IHJlY2VpdmVkIGluIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gcHVibGlzaFdoaWxlRHJhZ2dpbmdJblZpcnR1YWwoe1xuICAgICAgc3RhdGUsXG4gICAgICBwdWJsaXNoZWQ6IGFjdGlvbi5wYXlsb2FkXG4gICAgfSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnTU9WRScpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgICFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGAke2FjdGlvbi50eXBlfSBub3QgcGVybWl0dGVkIGluIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBjbGllbnQ6IGNsaWVudFNlbGVjdGlvblxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICBpZiAoaXNFcXVhbCQxKGNsaWVudFNlbGVjdGlvbiwgc3RhdGUuY3VycmVudC5jbGllbnQuc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlKHtcbiAgICAgIHN0YXRlLFxuICAgICAgY2xpZW50U2VsZWN0aW9uLFxuICAgICAgaW1wYWN0OiBpc1NuYXBwaW5nKHN0YXRlKSA/IHN0YXRlLmltcGFjdCA6IG51bGxcbiAgICB9KTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdVUERBVEVfRFJPUFBBQkxFX1NDUk9MTCcpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlU2Nyb2xsSnVtcFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykge1xuICAgICAgcmV0dXJuIHJlbW92ZVNjcm9sbEp1bXBSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgIWlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYCR7YWN0aW9uLnR5cGV9IG5vdCBwZXJtaXR0ZWQgaW4gcGhhc2UgJHtzdGF0ZS5waGFzZX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgbmV3U2Nyb2xsXG4gICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIGNvbnN0IHRhcmdldCA9IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1tpZF07XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgY29uc3Qgc2Nyb2xsZWQgPSBzY3JvbGxEcm9wcGFibGUodGFyZ2V0LCBuZXdTY3JvbGwpO1xuICAgIHJldHVybiBwb3N0RHJvcHBhYmxlQ2hhbmdlKHN0YXRlLCBzY3JvbGxlZCwgZmFsc2UpO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ1VQREFURV9EUk9QUEFCTEVfSVNfRU5BQkxFRCcpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgICFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBBdHRlbXB0aW5nIHRvIG1vdmUgaW4gYW4gdW5zdXBwb3J0ZWQgcGhhc2UgJHtzdGF0ZS5waGFzZX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgaXNFbmFibGVkXG4gICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIGNvbnN0IHRhcmdldCA9IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1tpZF07XG4gICAgIXRhcmdldCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBmaW5kIERyb3BwYWJsZVtpZDogJHtpZH1dIHRvIHRvZ2dsZSBpdHMgZW5hYmxlZCBzdGF0ZWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgISh0YXJnZXQuaXNFbmFibGVkICE9PSBpc0VuYWJsZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgVHJ5aW5nIHRvIHNldCBkcm9wcGFibGUgaXNFbmFibGVkIHRvICR7U3RyaW5nKGlzRW5hYmxlZCl9XG4gICAgICBidXQgaXQgaXMgYWxyZWFkeSAke1N0cmluZyh0YXJnZXQuaXNFbmFibGVkKX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSB7XG4gICAgICAuLi50YXJnZXQsXG4gICAgICBpc0VuYWJsZWRcbiAgICB9O1xuICAgIHJldHVybiBwb3N0RHJvcHBhYmxlQ2hhbmdlKHN0YXRlLCB1cGRhdGVkLCB0cnVlKTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdVUERBVEVfRFJPUFBBQkxFX0lTX0NPTUJJTkVfRU5BQkxFRCcpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgICFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBBdHRlbXB0aW5nIHRvIG1vdmUgaW4gYW4gdW5zdXBwb3J0ZWQgcGhhc2UgJHtzdGF0ZS5waGFzZX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgaXNDb21iaW5lRW5hYmxlZFxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICBjb25zdCB0YXJnZXQgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbaWRdO1xuICAgICF0YXJnZXQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgZmluZCBEcm9wcGFibGVbaWQ6ICR7aWR9XSB0byB0b2dnbGUgaXRzIGlzQ29tYmluZUVuYWJsZWQgc3RhdGVgKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgICEodGFyZ2V0LmlzQ29tYmluZUVuYWJsZWQgIT09IGlzQ29tYmluZUVuYWJsZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgVHJ5aW5nIHRvIHNldCBkcm9wcGFibGUgaXNDb21iaW5lRW5hYmxlZCB0byAke1N0cmluZyhpc0NvbWJpbmVFbmFibGVkKX1cbiAgICAgIGJ1dCBpdCBpcyBhbHJlYWR5ICR7U3RyaW5nKHRhcmdldC5pc0NvbWJpbmVFbmFibGVkKX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSB7XG4gICAgICAuLi50YXJnZXQsXG4gICAgICBpc0NvbWJpbmVFbmFibGVkXG4gICAgfTtcbiAgICByZXR1cm4gcG9zdERyb3BwYWJsZUNoYW5nZShzdGF0ZSwgdXBkYXRlZCwgdHJ1ZSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnTU9WRV9CWV9XSU5ET1dfU0NST0xMJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgIWlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBtb3ZlIGJ5IHdpbmRvdyBpbiBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgIXN0YXRlLmlzV2luZG93U2Nyb2xsQWxsb3dlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1dpbmRvdyBzY3JvbGxpbmcgaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgZm9yIGZpeGVkIGxpc3RzJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBuZXdTY3JvbGwgPSBhY3Rpb24ucGF5bG9hZC5uZXdTY3JvbGw7XG4gICAgaWYgKGlzRXF1YWwkMShzdGF0ZS52aWV3cG9ydC5zY3JvbGwuY3VycmVudCwgbmV3U2Nyb2xsKSkge1xuICAgICAgcmV0dXJuIHJlbW92ZVNjcm9sbEp1bXBSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgY29uc3Qgdmlld3BvcnQgPSBzY3JvbGxWaWV3cG9ydChzdGF0ZS52aWV3cG9ydCwgbmV3U2Nyb2xsKTtcbiAgICBpZiAoaXNTbmFwcGluZyhzdGF0ZSkpIHtcbiAgICAgIHJldHVybiByZWZyZXNoU25hcCh7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICB2aWV3cG9ydFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGUoe1xuICAgICAgc3RhdGUsXG4gICAgICB2aWV3cG9ydFxuICAgIH0pO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ1VQREFURV9WSUVXUE9SVF9NQVhfU0NST0xMJykge1xuICAgIGlmICghaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGNvbnN0IG1heFNjcm9sbCA9IGFjdGlvbi5wYXlsb2FkLm1heFNjcm9sbDtcbiAgICBpZiAoaXNFcXVhbCQxKG1heFNjcm9sbCwgc3RhdGUudmlld3BvcnQuc2Nyb2xsLm1heCkpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgY29uc3Qgd2l0aE1heFNjcm9sbCA9IHtcbiAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LFxuICAgICAgc2Nyb2xsOiB7XG4gICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LnNjcm9sbCxcbiAgICAgICAgbWF4OiBtYXhTY3JvbGxcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHZpZXdwb3J0OiB3aXRoTWF4U2Nyb2xsXG4gICAgfTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdNT1ZFX1VQJyB8fCBhY3Rpb24udHlwZSA9PT0gJ01PVkVfRE9XTicgfHwgYWN0aW9uLnR5cGUgPT09ICdNT1ZFX0xFRlQnIHx8IGFjdGlvbi50eXBlID09PSAnTU9WRV9SSUdIVCcpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGAke2FjdGlvbi50eXBlfSByZWNlaXZlZCB3aGlsZSBub3QgaW4gRFJBR0dJTkcgcGhhc2VgKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IG1vdmVJbkRpcmVjdGlvbih7XG4gICAgICBzdGF0ZSxcbiAgICAgIHR5cGU6IGFjdGlvbi50eXBlXG4gICAgfSk7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZSh7XG4gICAgICBzdGF0ZSxcbiAgICAgIGltcGFjdDogcmVzdWx0LmltcGFjdCxcbiAgICAgIGNsaWVudFNlbGVjdGlvbjogcmVzdWx0LmNsaWVudFNlbGVjdGlvbixcbiAgICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiByZXN1bHQuc2Nyb2xsSnVtcFJlcXVlc3RcbiAgICB9KTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgY29uc3QgcmVhc29uID0gYWN0aW9uLnBheWxvYWQucmVhc29uO1xuICAgICEoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBtb3ZlIGludG8gdGhlIERST1BfUEVORElORyBwaGFzZSBmcm9tIHRoZSBDT0xMRUNUSU5HIHBoYXNlJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgcGhhc2U6ICdEUk9QX1BFTkRJTkcnLFxuICAgICAgaXNXYWl0aW5nOiB0cnVlLFxuICAgICAgcmVhc29uXG4gICAgfTtcbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9BTklNQVRFJykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbXBsZXRlZCxcbiAgICAgIGRyb3BEdXJhdGlvbixcbiAgICAgIG5ld0hvbWVDbGllbnRPZmZzZXRcbiAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IGFuaW1hdGUgZHJvcCBmcm9tIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBwaGFzZTogJ0RST1BfQU5JTUFUSU5HJyxcbiAgICAgIGNvbXBsZXRlZCxcbiAgICAgIGRyb3BEdXJhdGlvbixcbiAgICAgIG5ld0hvbWVDbGllbnRPZmZzZXQsXG4gICAgICBkaW1lbnNpb25zOiBzdGF0ZS5kaW1lbnNpb25zXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tcGxldGVkXG4gICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIHJldHVybiB7XG4gICAgICBwaGFzZTogJ0lETEUnLFxuICAgICAgY29tcGxldGVkLFxuICAgICAgc2hvdWxkRmx1c2g6IGZhbHNlXG4gICAgfTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59O1xuXG5mdW5jdGlvbiBndWFyZChhY3Rpb24sIHByZWRpY2F0ZSkge1xuICByZXR1cm4gYWN0aW9uIGluc3RhbmNlb2YgT2JqZWN0ICYmICd0eXBlJyBpbiBhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IHByZWRpY2F0ZTtcbn1cbmNvbnN0IGJlZm9yZUluaXRpYWxDYXB0dXJlID0gYXJncyA9PiAoe1xuICB0eXBlOiAnQkVGT1JFX0lOSVRJQUxfQ0FQVFVSRScsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgbGlmdCQxID0gYXJncyA9PiAoe1xuICB0eXBlOiAnTElGVCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgaW5pdGlhbFB1Ymxpc2ggPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdJTklUSUFMX1BVQkxJU0gnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IHB1Ymxpc2hXaGlsZURyYWdnaW5nID0gYXJncyA9PiAoe1xuICB0eXBlOiAnUFVCTElTSF9XSElMRV9EUkFHR0lORycsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgY29sbGVjdGlvblN0YXJ0aW5nID0gKCkgPT4gKHtcbiAgdHlwZTogJ0NPTExFQ1RJT05fU1RBUlRJTkcnLFxuICBwYXlsb2FkOiBudWxsXG59KTtcbmNvbnN0IHVwZGF0ZURyb3BwYWJsZVNjcm9sbCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ1VQREFURV9EUk9QUEFCTEVfU0NST0xMJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdVUERBVEVfRFJPUFBBQkxFX0lTX0VOQUJMRUQnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IHVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdVUERBVEVfRFJPUFBBQkxFX0lTX0NPTUJJTkVfRU5BQkxFRCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgbW92ZSA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ01PVkUnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IG1vdmVCeVdpbmRvd1Njcm9sbCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ01PVkVfQllfV0lORE9XX1NDUk9MTCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGwgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdVUERBVEVfVklFV1BPUlRfTUFYX1NDUk9MTCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgbW92ZVVwID0gKCkgPT4gKHtcbiAgdHlwZTogJ01PVkVfVVAnLFxuICBwYXlsb2FkOiBudWxsXG59KTtcbmNvbnN0IG1vdmVEb3duID0gKCkgPT4gKHtcbiAgdHlwZTogJ01PVkVfRE9XTicsXG4gIHBheWxvYWQ6IG51bGxcbn0pO1xuY29uc3QgbW92ZVJpZ2h0ID0gKCkgPT4gKHtcbiAgdHlwZTogJ01PVkVfUklHSFQnLFxuICBwYXlsb2FkOiBudWxsXG59KTtcbmNvbnN0IG1vdmVMZWZ0ID0gKCkgPT4gKHtcbiAgdHlwZTogJ01PVkVfTEVGVCcsXG4gIHBheWxvYWQ6IG51bGxcbn0pO1xuY29uc3QgZmx1c2ggPSAoKSA9PiAoe1xuICB0eXBlOiAnRkxVU0gnLFxuICBwYXlsb2FkOiBudWxsXG59KTtcbmNvbnN0IGFuaW1hdGVEcm9wID0gYXJncyA9PiAoe1xuICB0eXBlOiAnRFJPUF9BTklNQVRFJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBjb21wbGV0ZURyb3AgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdEUk9QX0NPTVBMRVRFJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBkcm9wID0gYXJncyA9PiAoe1xuICB0eXBlOiAnRFJPUCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgZHJvcFBlbmRpbmcgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdEUk9QX1BFTkRJTkcnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGRyb3BBbmltYXRpb25GaW5pc2hlZCA9ICgpID0+ICh7XG4gIHR5cGU6ICdEUk9QX0FOSU1BVElPTl9GSU5JU0hFRCcsXG4gIHBheWxvYWQ6IG51bGxcbn0pO1xuXG5mdW5jdGlvbiBjaGVja0luZGV4ZXMoaW5zaWRlRGVzdGluYXRpb24pIHtcbiAgaWYgKGluc2lkZURlc3RpbmF0aW9uLmxlbmd0aCA8PSAxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGluZGV4ZXMgPSBpbnNpZGVEZXN0aW5hdGlvbi5tYXAoZCA9PiBkLmRlc2NyaXB0b3IuaW5kZXgpO1xuICBjb25zdCBlcnJvcnMgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudCA9IGluZGV4ZXNbaV07XG4gICAgY29uc3QgcHJldmlvdXMgPSBpbmRleGVzW2kgLSAxXTtcbiAgICBpZiAoY3VycmVudCAhPT0gcHJldmlvdXMgKyAxKSB7XG4gICAgICBlcnJvcnNbY3VycmVudF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoIU9iamVjdC5rZXlzKGVycm9ycykubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZvcm1hdHRlZCA9IGluZGV4ZXMubWFwKGluZGV4ID0+IHtcbiAgICBjb25zdCBoYXNFcnJvciA9IEJvb2xlYW4oZXJyb3JzW2luZGV4XSk7XG4gICAgcmV0dXJuIGhhc0Vycm9yID8gYFvwn5SlJHtpbmRleH1dYCA6IGAke2luZGV4fWA7XG4gIH0pLmpvaW4oJywgJyk7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgIERldGVjdGVkIG5vbi1jb25zZWN1dGl2ZSA8RHJhZ2dhYmxlIC8+IGluZGV4ZXMuXG5cbiAgICAoVGhpcyBjYW4gY2F1c2UgdW5leHBlY3RlZCBidWdzKVxuXG4gICAgJHtmb3JtYXR0ZWR9XG4gIGApIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVEaW1lbnNpb25zKGNyaXRpY2FsLCBkaW1lbnNpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgaW5zaWRlRGVzdGluYXRpb24gPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGNyaXRpY2FsLmRyb3BwYWJsZS5pZCwgZGltZW5zaW9ucy5kcmFnZ2FibGVzKTtcbiAgICBjaGVja0luZGV4ZXMoaW5zaWRlRGVzdGluYXRpb24pO1xuICB9XG59XG5cbnZhciBsaWZ0ID0gbWFyc2hhbCA9PiAoe1xuICBnZXRTdGF0ZSxcbiAgZGlzcGF0Y2hcbn0pID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgaWYgKCFndWFyZChhY3Rpb24sICdMSUZUJykpIHtcbiAgICBuZXh0KGFjdGlvbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpZCxcbiAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgbW92ZW1lbnRNb2RlXG4gIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgY29uc3QgaW5pdGlhbCA9IGdldFN0YXRlKCk7XG4gIGlmIChpbml0aWFsLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgZGlzcGF0Y2goY29tcGxldGVEcm9wKHtcbiAgICAgIGNvbXBsZXRlZDogaW5pdGlhbC5jb21wbGV0ZWRcbiAgICB9KSk7XG4gIH1cbiAgIShnZXRTdGF0ZSgpLnBoYXNlID09PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBwaGFzZSB0byBzdGFydCBhIGRyYWcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBkaXNwYXRjaChmbHVzaCgpKTtcbiAgZGlzcGF0Y2goYmVmb3JlSW5pdGlhbENhcHR1cmUoe1xuICAgIGRyYWdnYWJsZUlkOiBpZCxcbiAgICBtb3ZlbWVudE1vZGVcbiAgfSkpO1xuICBjb25zdCBzY3JvbGxPcHRpb25zID0ge1xuICAgIHNob3VsZFB1Ymxpc2hJbW1lZGlhdGVseTogbW92ZW1lbnRNb2RlID09PSAnU05BUCdcbiAgfTtcbiAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICBkcmFnZ2FibGVJZDogaWQsXG4gICAgc2Nyb2xsT3B0aW9uc1xuICB9O1xuICBjb25zdCB7XG4gICAgY3JpdGljYWwsXG4gICAgZGltZW5zaW9ucyxcbiAgICB2aWV3cG9ydFxuICB9ID0gbWFyc2hhbC5zdGFydFB1Ymxpc2hpbmcocmVxdWVzdCk7XG4gIHZhbGlkYXRlRGltZW5zaW9ucyhjcml0aWNhbCwgZGltZW5zaW9ucyk7XG4gIGRpc3BhdGNoKGluaXRpYWxQdWJsaXNoKHtcbiAgICBjcml0aWNhbCxcbiAgICBkaW1lbnNpb25zLFxuICAgIGNsaWVudFNlbGVjdGlvbixcbiAgICBtb3ZlbWVudE1vZGUsXG4gICAgdmlld3BvcnRcbiAgfSkpO1xufTtcblxudmFyIHN0eWxlID0gbWFyc2hhbCA9PiAoKSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmIChndWFyZChhY3Rpb24sICdJTklUSUFMX1BVQkxJU0gnKSkge1xuICAgIG1hcnNoYWwuZHJhZ2dpbmcoKTtcbiAgfVxuICBpZiAoZ3VhcmQoYWN0aW9uLCAnRFJPUF9BTklNQVRFJykpIHtcbiAgICBtYXJzaGFsLmRyb3BwaW5nKGFjdGlvbi5wYXlsb2FkLmNvbXBsZXRlZC5yZXN1bHQucmVhc29uKTtcbiAgfVxuICBpZiAoZ3VhcmQoYWN0aW9uLCAnRkxVU0gnKSB8fCBndWFyZChhY3Rpb24sICdEUk9QX0NPTVBMRVRFJykpIHtcbiAgICBtYXJzaGFsLnJlc3RpbmcoKTtcbiAgfVxuICBuZXh0KGFjdGlvbik7XG59O1xuXG5jb25zdCBjdXJ2ZXMgPSB7XG4gIG91dE9mVGhlV2F5OiAnY3ViaWMtYmV6aWVyKDAuMiwgMCwgMCwgMSknLFxuICBkcm9wOiAnY3ViaWMtYmV6aWVyKC4yLDEsLjEsMSknXG59O1xuY29uc3QgY29tYmluZSA9IHtcbiAgb3BhY2l0eToge1xuICAgIGRyb3A6IDAsXG4gICAgY29tYmluaW5nOiAwLjdcbiAgfSxcbiAgc2NhbGU6IHtcbiAgICBkcm9wOiAwLjc1XG4gIH1cbn07XG5jb25zdCB0aW1pbmdzID0ge1xuICBvdXRPZlRoZVdheTogMC4yLFxuICBtaW5Ecm9wVGltZTogMC4zMyxcbiAgbWF4RHJvcFRpbWU6IDAuNTVcbn07XG5jb25zdCBvdXRPZlRoZVdheVRpbWluZyA9IGAke3RpbWluZ3Mub3V0T2ZUaGVXYXl9cyAke2N1cnZlcy5vdXRPZlRoZVdheX1gO1xuY29uc3QgdHJhbnNpdGlvbnMgPSB7XG4gIGZsdWlkOiBgb3BhY2l0eSAke291dE9mVGhlV2F5VGltaW5nfWAsXG4gIHNuYXA6IGB0cmFuc2Zvcm0gJHtvdXRPZlRoZVdheVRpbWluZ30sIG9wYWNpdHkgJHtvdXRPZlRoZVdheVRpbWluZ31gLFxuICBkcm9wOiBkdXJhdGlvbiA9PiB7XG4gICAgY29uc3QgdGltaW5nID0gYCR7ZHVyYXRpb259cyAke2N1cnZlcy5kcm9wfWA7XG4gICAgcmV0dXJuIGB0cmFuc2Zvcm0gJHt0aW1pbmd9LCBvcGFjaXR5ICR7dGltaW5nfWA7XG4gIH0sXG4gIG91dE9mVGhlV2F5OiBgdHJhbnNmb3JtICR7b3V0T2ZUaGVXYXlUaW1pbmd9YCxcbiAgcGxhY2Vob2xkZXI6IGBoZWlnaHQgJHtvdXRPZlRoZVdheVRpbWluZ30sIHdpZHRoICR7b3V0T2ZUaGVXYXlUaW1pbmd9LCBtYXJnaW4gJHtvdXRPZlRoZVdheVRpbWluZ31gXG59O1xuY29uc3QgbW92ZVRvID0gb2Zmc2V0ID0+IGlzRXF1YWwkMShvZmZzZXQsIG9yaWdpbikgPyB1bmRlZmluZWQgOiBgdHJhbnNsYXRlKCR7b2Zmc2V0Lnh9cHgsICR7b2Zmc2V0Lnl9cHgpYDtcbmNvbnN0IHRyYW5zZm9ybXMgPSB7XG4gIG1vdmVUbyxcbiAgZHJvcDogKG9mZnNldCwgaXNDb21iaW5pbmcpID0+IHtcbiAgICBjb25zdCB0cmFuc2xhdGUgPSBtb3ZlVG8ob2Zmc2V0KTtcbiAgICBpZiAoIXRyYW5zbGF0ZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCFpc0NvbWJpbmluZykge1xuICAgICAgcmV0dXJuIHRyYW5zbGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3RyYW5zbGF0ZX0gc2NhbGUoJHtjb21iaW5lLnNjYWxlLmRyb3B9KWA7XG4gIH1cbn07XG5cbmNvbnN0IHtcbiAgbWluRHJvcFRpbWUsXG4gIG1heERyb3BUaW1lXG59ID0gdGltaW5ncztcbmNvbnN0IGRyb3BUaW1lUmFuZ2UgPSBtYXhEcm9wVGltZSAtIG1pbkRyb3BUaW1lO1xuY29uc3QgbWF4RHJvcFRpbWVBdERpc3RhbmNlID0gMTUwMDtcbmNvbnN0IGNhbmNlbERyb3BNb2RpZmllciA9IDAuNjtcbnZhciBnZXREcm9wRHVyYXRpb24gPSAoe1xuICBjdXJyZW50LFxuICBkZXN0aW5hdGlvbixcbiAgcmVhc29uXG59KSA9PiB7XG4gIGNvbnN0IGRpc3RhbmNlJDEgPSBkaXN0YW5jZShjdXJyZW50LCBkZXN0aW5hdGlvbik7XG4gIGlmIChkaXN0YW5jZSQxIDw9IDApIHtcbiAgICByZXR1cm4gbWluRHJvcFRpbWU7XG4gIH1cbiAgaWYgKGRpc3RhbmNlJDEgPj0gbWF4RHJvcFRpbWVBdERpc3RhbmNlKSB7XG4gICAgcmV0dXJuIG1heERyb3BUaW1lO1xuICB9XG4gIGNvbnN0IHBlcmNlbnRhZ2UgPSBkaXN0YW5jZSQxIC8gbWF4RHJvcFRpbWVBdERpc3RhbmNlO1xuICBjb25zdCBkdXJhdGlvbiA9IG1pbkRyb3BUaW1lICsgZHJvcFRpbWVSYW5nZSAqIHBlcmNlbnRhZ2U7XG4gIGNvbnN0IHdpdGhEdXJhdGlvbiA9IHJlYXNvbiA9PT0gJ0NBTkNFTCcgPyBkdXJhdGlvbiAqIGNhbmNlbERyb3BNb2RpZmllciA6IGR1cmF0aW9uO1xuICByZXR1cm4gTnVtYmVyKHdpdGhEdXJhdGlvbi50b0ZpeGVkKDIpKTtcbn07XG5cbnZhciBnZXROZXdIb21lQ2xpZW50T2Zmc2V0ID0gKHtcbiAgaW1wYWN0LFxuICBkcmFnZ2FibGUsXG4gIGRpbWVuc2lvbnMsXG4gIHZpZXdwb3J0LFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBkcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXNcbiAgfSA9IGRpbWVuc2lvbnM7XG4gIGNvbnN0IGRyb3BwYWJsZUlkID0gd2hhdElzRHJhZ2dlZE92ZXIoaW1wYWN0KTtcbiAgY29uc3QgZGVzdGluYXRpb24gPSBkcm9wcGFibGVJZCA/IGRyb3BwYWJsZXNbZHJvcHBhYmxlSWRdIDogbnVsbDtcbiAgY29uc3QgaG9tZSA9IGRyb3BwYWJsZXNbZHJhZ2dhYmxlLmRlc2NyaXB0b3IuZHJvcHBhYmxlSWRdO1xuICBjb25zdCBuZXdDbGllbnRDZW50ZXIgPSBnZXRDbGllbnRCb3JkZXJCb3hDZW50ZXIoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBhZnRlckNyaXRpY2FsLFxuICAgIGRyb3BwYWJsZTogZGVzdGluYXRpb24gfHwgaG9tZSxcbiAgICB2aWV3cG9ydFxuICB9KTtcbiAgY29uc3Qgb2Zmc2V0ID0gc3VidHJhY3QobmV3Q2xpZW50Q2VudGVyLCBkcmFnZ2FibGUuY2xpZW50LmJvcmRlckJveC5jZW50ZXIpO1xuICByZXR1cm4gb2Zmc2V0O1xufTtcblxudmFyIGdldERyb3BJbXBhY3QgPSAoe1xuICBkcmFnZ2FibGVzLFxuICByZWFzb24sXG4gIGxhc3RJbXBhY3QsXG4gIGhvbWUsXG4gIHZpZXdwb3J0LFxuICBvbkxpZnRJbXBhY3Rcbn0pID0+IHtcbiAgaWYgKCFsYXN0SW1wYWN0LmF0IHx8IHJlYXNvbiAhPT0gJ0RST1AnKSB7XG4gICAgY29uc3QgcmVjb21wdXRlZEhvbWVJbXBhY3QgPSByZWNvbXB1dGUoe1xuICAgICAgZHJhZ2dhYmxlcyxcbiAgICAgIGltcGFjdDogb25MaWZ0SW1wYWN0LFxuICAgICAgZGVzdGluYXRpb246IGhvbWUsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBpbXBhY3Q6IHJlY29tcHV0ZWRIb21lSW1wYWN0LFxuICAgICAgZGlkRHJvcEluc2lkZURyb3BwYWJsZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGlmIChsYXN0SW1wYWN0LmF0LnR5cGUgPT09ICdSRU9SREVSJykge1xuICAgIHJldHVybiB7XG4gICAgICBpbXBhY3Q6IGxhc3RJbXBhY3QsXG4gICAgICBkaWREcm9wSW5zaWRlRHJvcHBhYmxlOiB0cnVlXG4gICAgfTtcbiAgfVxuICBjb25zdCB3aXRob3V0TW92ZW1lbnQgPSB7XG4gICAgLi4ubGFzdEltcGFjdCxcbiAgICBkaXNwbGFjZWQ6IGVtcHR5R3JvdXBzXG4gIH07XG4gIHJldHVybiB7XG4gICAgaW1wYWN0OiB3aXRob3V0TW92ZW1lbnQsXG4gICAgZGlkRHJvcEluc2lkZURyb3BwYWJsZTogdHJ1ZVxuICB9O1xufTtcblxuY29uc3QgZHJvcE1pZGRsZXdhcmUgPSAoe1xuICBnZXRTdGF0ZSxcbiAgZGlzcGF0Y2hcbn0pID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgaWYgKCFndWFyZChhY3Rpb24sICdEUk9QJykpIHtcbiAgICBuZXh0KGFjdGlvbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgY29uc3QgcmVhc29uID0gYWN0aW9uLnBheWxvYWQucmVhc29uO1xuICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykge1xuICAgIGRpc3BhdGNoKGRyb3BQZW5kaW5nKHtcbiAgICAgIHJlYXNvblxuICAgIH0pKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHN0YXRlLnBoYXNlID09PSAnSURMRScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaXNXYWl0aW5nRm9yRHJvcCA9IHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJyAmJiBzdGF0ZS5pc1dhaXRpbmc7XG4gICEhaXNXYWl0aW5nRm9yRHJvcCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0EgRFJPUCBhY3Rpb24gb2NjdXJyZWQgd2hpbGUgRFJPUF9QRU5ESU5HIGFuZCBzdGlsbCB3YWl0aW5nJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IGRyb3AgaW4gcGhhc2U6ICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3QgY3JpdGljYWwgPSBzdGF0ZS5jcml0aWNhbDtcbiAgY29uc3QgZGltZW5zaW9ucyA9IHN0YXRlLmRpbWVuc2lvbnM7XG4gIGNvbnN0IGRyYWdnYWJsZSA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCB7XG4gICAgaW1wYWN0LFxuICAgIGRpZERyb3BJbnNpZGVEcm9wcGFibGVcbiAgfSA9IGdldERyb3BJbXBhY3Qoe1xuICAgIHJlYXNvbixcbiAgICBsYXN0SW1wYWN0OiBzdGF0ZS5pbXBhY3QsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbCxcbiAgICBvbkxpZnRJbXBhY3Q6IHN0YXRlLm9uTGlmdEltcGFjdCxcbiAgICBob21lOiBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJvcHBhYmxlLmlkXSxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnQsXG4gICAgZHJhZ2dhYmxlczogc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzXG4gIH0pO1xuICBjb25zdCBkZXN0aW5hdGlvbiA9IGRpZERyb3BJbnNpZGVEcm9wcGFibGUgPyB0cnlHZXREZXN0aW5hdGlvbihpbXBhY3QpIDogbnVsbDtcbiAgY29uc3QgY29tYmluZSA9IGRpZERyb3BJbnNpZGVEcm9wcGFibGUgPyB0cnlHZXRDb21iaW5lKGltcGFjdCkgOiBudWxsO1xuICBjb25zdCBzb3VyY2UgPSB7XG4gICAgaW5kZXg6IGNyaXRpY2FsLmRyYWdnYWJsZS5pbmRleCxcbiAgICBkcm9wcGFibGVJZDogY3JpdGljYWwuZHJvcHBhYmxlLmlkXG4gIH07XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBkcmFnZ2FibGVJZDogZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQsXG4gICAgdHlwZTogZHJhZ2dhYmxlLmRlc2NyaXB0b3IudHlwZSxcbiAgICBzb3VyY2UsXG4gICAgcmVhc29uLFxuICAgIG1vZGU6IHN0YXRlLm1vdmVtZW50TW9kZSxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBjb21iaW5lXG4gIH07XG4gIGNvbnN0IG5ld0hvbWVDbGllbnRPZmZzZXQgPSBnZXROZXdIb21lQ2xpZW50T2Zmc2V0KHtcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRpbWVuc2lvbnMsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGNvbnN0IGNvbXBsZXRlZCA9IHtcbiAgICBjcml0aWNhbDogc3RhdGUuY3JpdGljYWwsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbCxcbiAgICByZXN1bHQsXG4gICAgaW1wYWN0XG4gIH07XG4gIGNvbnN0IGlzQW5pbWF0aW9uUmVxdWlyZWQgPSAhaXNFcXVhbCQxKHN0YXRlLmN1cnJlbnQuY2xpZW50Lm9mZnNldCwgbmV3SG9tZUNsaWVudE9mZnNldCkgfHwgQm9vbGVhbihyZXN1bHQuY29tYmluZSk7XG4gIGlmICghaXNBbmltYXRpb25SZXF1aXJlZCkge1xuICAgIGRpc3BhdGNoKGNvbXBsZXRlRHJvcCh7XG4gICAgICBjb21wbGV0ZWRcbiAgICB9KSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRyb3BEdXJhdGlvbiA9IGdldERyb3BEdXJhdGlvbih7XG4gICAgY3VycmVudDogc3RhdGUuY3VycmVudC5jbGllbnQub2Zmc2V0LFxuICAgIGRlc3RpbmF0aW9uOiBuZXdIb21lQ2xpZW50T2Zmc2V0LFxuICAgIHJlYXNvblxuICB9KTtcbiAgY29uc3QgYXJncyA9IHtcbiAgICBuZXdIb21lQ2xpZW50T2Zmc2V0LFxuICAgIGRyb3BEdXJhdGlvbixcbiAgICBjb21wbGV0ZWRcbiAgfTtcbiAgZGlzcGF0Y2goYW5pbWF0ZURyb3AoYXJncykpO1xufTtcblxudmFyIGdldFdpbmRvd1Njcm9sbCA9ICgpID0+ICh7XG4gIHg6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgeTogd2luZG93LnBhZ2VZT2Zmc2V0XG59KTtcblxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmluZGluZyh1cGRhdGUpIHtcbiAgcmV0dXJuIHtcbiAgICBldmVudE5hbWU6ICdzY3JvbGwnLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0sXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgIT09IHdpbmRvdyAmJiBldmVudC50YXJnZXQgIT09IHdpbmRvdy5kb2N1bWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxMaXN0ZW5lcih7XG4gIG9uV2luZG93U2Nyb2xsXG59KSB7XG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbCgpIHtcbiAgICBvbldpbmRvd1Njcm9sbChnZXRXaW5kb3dTY3JvbGwoKSk7XG4gIH1cbiAgY29uc3Qgc2NoZWR1bGVkID0gcmFmU2NoZCh1cGRhdGVTY3JvbGwpO1xuICBjb25zdCBiaW5kaW5nID0gZ2V0V2luZG93U2Nyb2xsQmluZGluZyhzY2hlZHVsZWQpO1xuICBsZXQgdW5iaW5kID0gbm9vcCQyO1xuICBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdW5iaW5kICE9PSBub29wJDI7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgISFpc0FjdGl2ZSgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0YXJ0IHNjcm9sbCBsaXN0ZW5lciB3aGVuIGFscmVhZHkgYWN0aXZlJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICB1bmJpbmQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW2JpbmRpbmddKTtcbiAgfVxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICFpc0FjdGl2ZSgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0b3Agc2Nyb2xsIGxpc3RlbmVyIHdoZW4gbm90IGFjdGl2ZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgc2NoZWR1bGVkLmNhbmNlbCgpO1xuICAgIHVuYmluZCgpO1xuICAgIHVuYmluZCA9IG5vb3AkMjtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0LFxuICAgIHN0b3AsXG4gICAgaXNBY3RpdmVcbiAgfTtcbn1cblxuY29uc3Qgc2hvdWxkU3RvcCQxID0gYWN0aW9uID0+IGd1YXJkKGFjdGlvbiwgJ0RST1BfQ09NUExFVEUnKSB8fCBndWFyZChhY3Rpb24sICdEUk9QX0FOSU1BVEUnKSB8fCBndWFyZChhY3Rpb24sICdGTFVTSCcpO1xuY29uc3Qgc2Nyb2xsTGlzdGVuZXIgPSBzdG9yZSA9PiB7XG4gIGNvbnN0IGxpc3RlbmVyID0gZ2V0U2Nyb2xsTGlzdGVuZXIoe1xuICAgIG9uV2luZG93U2Nyb2xsOiBuZXdTY3JvbGwgPT4ge1xuICAgICAgc3RvcmUuZGlzcGF0Y2gobW92ZUJ5V2luZG93U2Nyb2xsKHtcbiAgICAgICAgbmV3U2Nyb2xsXG4gICAgICB9KSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5leHQgPT4gYWN0aW9uID0+IHtcbiAgICBpZiAoIWxpc3RlbmVyLmlzQWN0aXZlKCkgJiYgZ3VhcmQoYWN0aW9uLCAnSU5JVElBTF9QVUJMSVNIJykpIHtcbiAgICAgIGxpc3RlbmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIGlmIChsaXN0ZW5lci5pc0FjdGl2ZSgpICYmIHNob3VsZFN0b3AkMShhY3Rpb24pKSB7XG4gICAgICBsaXN0ZW5lci5zdG9wKCk7XG4gICAgfVxuICAgIG5leHQoYWN0aW9uKTtcbiAgfTtcbn07XG5cbnZhciBnZXRFeHBpcmluZ0Fubm91bmNlID0gYW5ub3VuY2UgPT4ge1xuICBsZXQgd2FzQ2FsbGVkID0gZmFsc2U7XG4gIGxldCBpc0V4cGlyZWQgPSBmYWxzZTtcbiAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaXNFeHBpcmVkID0gdHJ1ZTtcbiAgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IG1lc3NhZ2UgPT4ge1xuICAgIGlmICh3YXNDYWxsZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ0Fubm91bmNlbWVudCBhbHJlYWR5IG1hZGUuIE5vdCBtYWtpbmcgYSBzZWNvbmQgYW5ub3VuY2VtZW50JykgOiB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0V4cGlyZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgICBBbm5vdW5jZW1lbnRzIGNhbm5vdCBiZSBtYWRlIGFzeW5jaHJvbm91c2x5LlxuICAgICAgICBEZWZhdWx0IG1lc3NhZ2UgaGFzIGFscmVhZHkgYmVlbiBhbm5vdW5jZWQuXG4gICAgICBgKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FzQ2FsbGVkID0gdHJ1ZTtcbiAgICBhbm5vdW5jZShtZXNzYWdlKTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgfTtcbiAgcmVzdWx0Lndhc0NhbGxlZCA9ICgpID0+IHdhc0NhbGxlZDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBnZXRBc3luY01hcnNoYWwgPSAoKSA9PiB7XG4gIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgY29uc3QgZXhlY3V0ZSA9IHRpbWVySWQgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gZW50cmllcy5maW5kSW5kZXgoaXRlbSA9PiBpdGVtLnRpbWVySWQgPT09IHRpbWVySWQpO1xuICAgICEoaW5kZXggIT09IC0xKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIHRpbWVyJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBbZW50cnldID0gZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGVudHJ5LmNhbGxiYWNrKCk7XG4gIH07XG4gIGNvbnN0IGFkZCA9IGZuID0+IHtcbiAgICBjb25zdCB0aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiBleGVjdXRlKHRpbWVySWQpKTtcbiAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgIHRpbWVySWQsXG4gICAgICBjYWxsYmFjazogZm5cbiAgICB9O1xuICAgIGVudHJpZXMucHVzaChlbnRyeSk7XG4gIH07XG4gIGNvbnN0IGZsdXNoID0gKCkgPT4ge1xuICAgIGlmICghZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2hhbGxvdyA9IFsuLi5lbnRyaWVzXTtcbiAgICBlbnRyaWVzLmxlbmd0aCA9IDA7XG4gICAgc2hhbGxvdy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgIGNsZWFyVGltZW91dChlbnRyeS50aW1lcklkKTtcbiAgICAgIGVudHJ5LmNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgYWRkLFxuICAgIGZsdXNoXG4gIH07XG59O1xuXG5jb25zdCBhcmVMb2NhdGlvbnNFcXVhbCA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gIGlmIChmaXJzdCA9PSBudWxsICYmIHNlY29uZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGZpcnN0ID09IG51bGwgfHwgc2Vjb25kID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGZpcnN0LmRyb3BwYWJsZUlkID09PSBzZWNvbmQuZHJvcHBhYmxlSWQgJiYgZmlyc3QuaW5kZXggPT09IHNlY29uZC5pbmRleDtcbn07XG5jb25zdCBpc0NvbWJpbmVFcXVhbCA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gIGlmIChmaXJzdCA9PSBudWxsICYmIHNlY29uZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGZpcnN0ID09IG51bGwgfHwgc2Vjb25kID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGZpcnN0LmRyYWdnYWJsZUlkID09PSBzZWNvbmQuZHJhZ2dhYmxlSWQgJiYgZmlyc3QuZHJvcHBhYmxlSWQgPT09IHNlY29uZC5kcm9wcGFibGVJZDtcbn07XG5jb25zdCBpc0NyaXRpY2FsRXF1YWwgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xuICBpZiAoZmlyc3QgPT09IHNlY29uZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGlzRHJhZ2dhYmxlRXF1YWwgPSBmaXJzdC5kcmFnZ2FibGUuaWQgPT09IHNlY29uZC5kcmFnZ2FibGUuaWQgJiYgZmlyc3QuZHJhZ2dhYmxlLmRyb3BwYWJsZUlkID09PSBzZWNvbmQuZHJhZ2dhYmxlLmRyb3BwYWJsZUlkICYmIGZpcnN0LmRyYWdnYWJsZS50eXBlID09PSBzZWNvbmQuZHJhZ2dhYmxlLnR5cGUgJiYgZmlyc3QuZHJhZ2dhYmxlLmluZGV4ID09PSBzZWNvbmQuZHJhZ2dhYmxlLmluZGV4O1xuICBjb25zdCBpc0Ryb3BwYWJsZUVxdWFsID0gZmlyc3QuZHJvcHBhYmxlLmlkID09PSBzZWNvbmQuZHJvcHBhYmxlLmlkICYmIGZpcnN0LmRyb3BwYWJsZS50eXBlID09PSBzZWNvbmQuZHJvcHBhYmxlLnR5cGU7XG4gIHJldHVybiBpc0RyYWdnYWJsZUVxdWFsICYmIGlzRHJvcHBhYmxlRXF1YWw7XG59O1xuXG5jb25zdCB3aXRoVGltaW5ncyA9IChrZXksIGZuKSA9PiB7XG4gIHN0YXJ0KCk7XG4gIGZuKCk7XG4gIGZpbmlzaCgpO1xufTtcbmNvbnN0IGdldERyYWdTdGFydCA9IChjcml0aWNhbCwgbW9kZSkgPT4gKHtcbiAgZHJhZ2dhYmxlSWQ6IGNyaXRpY2FsLmRyYWdnYWJsZS5pZCxcbiAgdHlwZTogY3JpdGljYWwuZHJvcHBhYmxlLnR5cGUsXG4gIHNvdXJjZToge1xuICAgIGRyb3BwYWJsZUlkOiBjcml0aWNhbC5kcm9wcGFibGUuaWQsXG4gICAgaW5kZXg6IGNyaXRpY2FsLmRyYWdnYWJsZS5pbmRleFxuICB9LFxuICBtb2RlXG59KTtcbmZ1bmN0aW9uIGV4ZWN1dGUocmVzcG9uZGVyLCBkYXRhLCBhbm5vdW5jZSwgZ2V0RGVmYXVsdE1lc3NhZ2UpIHtcbiAgaWYgKCFyZXNwb25kZXIpIHtcbiAgICBhbm5vdW5jZShnZXREZWZhdWx0TWVzc2FnZShkYXRhKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHdpbGxFeHBpcmUgPSBnZXRFeHBpcmluZ0Fubm91bmNlKGFubm91bmNlKTtcbiAgY29uc3QgcHJvdmlkZWQgPSB7XG4gICAgYW5ub3VuY2U6IHdpbGxFeHBpcmVcbiAgfTtcbiAgcmVzcG9uZGVyKGRhdGEsIHByb3ZpZGVkKTtcbiAgaWYgKCF3aWxsRXhwaXJlLndhc0NhbGxlZCgpKSB7XG4gICAgYW5ub3VuY2UoZ2V0RGVmYXVsdE1lc3NhZ2UoZGF0YSkpO1xuICB9XG59XG52YXIgZ2V0UHVibGlzaGVyID0gKGdldFJlc3BvbmRlcnMsIGFubm91bmNlKSA9PiB7XG4gIGNvbnN0IGFzeW5jTWFyc2hhbCA9IGdldEFzeW5jTWFyc2hhbCgpO1xuICBsZXQgZHJhZ2dpbmcgPSBudWxsO1xuICBjb25zdCBiZWZvcmVDYXB0dXJlID0gKGRyYWdnYWJsZUlkLCBtb2RlKSA9PiB7XG4gICAgISFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaXJlIG9uQmVmb3JlQ2FwdHVyZSBhcyBhIGRyYWcgc3RhcnQgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIHdpdGhUaW1pbmdzKCdvbkJlZm9yZUNhcHR1cmUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBmbiA9IGdldFJlc3BvbmRlcnMoKS5vbkJlZm9yZUNhcHR1cmU7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgY29uc3QgYmVmb3JlID0ge1xuICAgICAgICAgIGRyYWdnYWJsZUlkLFxuICAgICAgICAgIG1vZGVcbiAgICAgICAgfTtcbiAgICAgICAgZm4oYmVmb3JlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgYmVmb3JlU3RhcnQgPSAoY3JpdGljYWwsIG1vZGUpID0+IHtcbiAgICAhIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpcmUgb25CZWZvcmVEcmFnU3RhcnQgYXMgYSBkcmFnIHN0YXJ0IGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICB3aXRoVGltaW5ncygnb25CZWZvcmVEcmFnU3RhcnQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBmbiA9IGdldFJlc3BvbmRlcnMoKS5vbkJlZm9yZURyYWdTdGFydDtcbiAgICAgIGlmIChmbikge1xuICAgICAgICBmbihnZXREcmFnU3RhcnQoY3JpdGljYWwsIG1vZGUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgc3RhcnQgPSAoY3JpdGljYWwsIG1vZGUpID0+IHtcbiAgICAhIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpcmUgb25CZWZvcmVEcmFnU3RhcnQgYXMgYSBkcmFnIHN0YXJ0IGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBkYXRhID0gZ2V0RHJhZ1N0YXJ0KGNyaXRpY2FsLCBtb2RlKTtcbiAgICBkcmFnZ2luZyA9IHtcbiAgICAgIG1vZGUsXG4gICAgICBsYXN0Q3JpdGljYWw6IGNyaXRpY2FsLFxuICAgICAgbGFzdExvY2F0aW9uOiBkYXRhLnNvdXJjZSxcbiAgICAgIGxhc3RDb21iaW5lOiBudWxsXG4gICAgfTtcbiAgICBhc3luY01hcnNoYWwuYWRkKCgpID0+IHtcbiAgICAgIHdpdGhUaW1pbmdzKCdvbkRyYWdTdGFydCcsICgpID0+IGV4ZWN1dGUoZ2V0UmVzcG9uZGVycygpLm9uRHJhZ1N0YXJ0LCBkYXRhLCBhbm5vdW5jZSwgcHJlc2V0Lm9uRHJhZ1N0YXJ0KSk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHVwZGF0ZSA9IChjcml0aWNhbCwgaW1wYWN0KSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSB0cnlHZXREZXN0aW5hdGlvbihpbXBhY3QpO1xuICAgIGNvbnN0IGNvbWJpbmUgPSB0cnlHZXRDb21iaW5lKGltcGFjdCk7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpcmUgb25EcmFnTW92ZSB3aGVuIG9uRHJhZ1N0YXJ0IGhhcyBub3QgYmVlbiBjYWxsZWQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IGhhc0NyaXRpY2FsQ2hhbmdlZCA9ICFpc0NyaXRpY2FsRXF1YWwoY3JpdGljYWwsIGRyYWdnaW5nLmxhc3RDcml0aWNhbCk7XG4gICAgaWYgKGhhc0NyaXRpY2FsQ2hhbmdlZCkge1xuICAgICAgZHJhZ2dpbmcubGFzdENyaXRpY2FsID0gY3JpdGljYWw7XG4gICAgfVxuICAgIGNvbnN0IGhhc0xvY2F0aW9uQ2hhbmdlZCA9ICFhcmVMb2NhdGlvbnNFcXVhbChkcmFnZ2luZy5sYXN0TG9jYXRpb24sIGxvY2F0aW9uKTtcbiAgICBpZiAoaGFzTG9jYXRpb25DaGFuZ2VkKSB7XG4gICAgICBkcmFnZ2luZy5sYXN0TG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICB9XG4gICAgY29uc3QgaGFzR3JvdXBpbmdDaGFuZ2VkID0gIWlzQ29tYmluZUVxdWFsKGRyYWdnaW5nLmxhc3RDb21iaW5lLCBjb21iaW5lKTtcbiAgICBpZiAoaGFzR3JvdXBpbmdDaGFuZ2VkKSB7XG4gICAgICBkcmFnZ2luZy5sYXN0Q29tYmluZSA9IGNvbWJpbmU7XG4gICAgfVxuICAgIGlmICghaGFzQ3JpdGljYWxDaGFuZ2VkICYmICFoYXNMb2NhdGlvbkNoYW5nZWQgJiYgIWhhc0dyb3VwaW5nQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgLi4uZ2V0RHJhZ1N0YXJ0KGNyaXRpY2FsLCBkcmFnZ2luZy5tb2RlKSxcbiAgICAgIGNvbWJpbmUsXG4gICAgICBkZXN0aW5hdGlvbjogbG9jYXRpb25cbiAgICB9O1xuICAgIGFzeW5jTWFyc2hhbC5hZGQoKCkgPT4ge1xuICAgICAgd2l0aFRpbWluZ3MoJ29uRHJhZ1VwZGF0ZScsICgpID0+IGV4ZWN1dGUoZ2V0UmVzcG9uZGVycygpLm9uRHJhZ1VwZGF0ZSwgZGF0YSwgYW5ub3VuY2UsIHByZXNldC5vbkRyYWdVcGRhdGUpKTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZmx1c2ggPSAoKSA9PiB7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgZmx1c2ggcmVzcG9uZGVycyB3aGlsZSBkcmFnZ2luZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgYXN5bmNNYXJzaGFsLmZsdXNoKCk7XG4gIH07XG4gIGNvbnN0IGRyb3AgPSByZXN1bHQgPT4ge1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaXJlIG9uRHJhZ0VuZCB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIG9uRHJhZ1N0YXJ0JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBkcmFnZ2luZyA9IG51bGw7XG4gICAgd2l0aFRpbWluZ3MoJ29uRHJhZ0VuZCcsICgpID0+IGV4ZWN1dGUoZ2V0UmVzcG9uZGVycygpLm9uRHJhZ0VuZCwgcmVzdWx0LCBhbm5vdW5jZSwgcHJlc2V0Lm9uRHJhZ0VuZCkpO1xuICB9O1xuICBjb25zdCBhYm9ydCA9ICgpID0+IHtcbiAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIC4uLmdldERyYWdTdGFydChkcmFnZ2luZy5sYXN0Q3JpdGljYWwsIGRyYWdnaW5nLm1vZGUpLFxuICAgICAgY29tYmluZTogbnVsbCxcbiAgICAgIGRlc3RpbmF0aW9uOiBudWxsLFxuICAgICAgcmVhc29uOiAnQ0FOQ0VMJ1xuICAgIH07XG4gICAgZHJvcChyZXN1bHQpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGJlZm9yZUNhcHR1cmUsXG4gICAgYmVmb3JlU3RhcnQsXG4gICAgc3RhcnQsXG4gICAgdXBkYXRlLFxuICAgIGZsdXNoLFxuICAgIGRyb3AsXG4gICAgYWJvcnRcbiAgfTtcbn07XG5cbnZhciByZXNwb25kZXJzID0gKGdldFJlc3BvbmRlcnMsIGFubm91bmNlKSA9PiB7XG4gIGNvbnN0IHB1Ymxpc2hlciA9IGdldFB1Ymxpc2hlcihnZXRSZXNwb25kZXJzLCBhbm5vdW5jZSk7XG4gIHJldHVybiBzdG9yZSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgaWYgKGd1YXJkKGFjdGlvbiwgJ0JFRk9SRV9JTklUSUFMX0NBUFRVUkUnKSkge1xuICAgICAgcHVibGlzaGVyLmJlZm9yZUNhcHR1cmUoYWN0aW9uLnBheWxvYWQuZHJhZ2dhYmxlSWQsIGFjdGlvbi5wYXlsb2FkLm1vdmVtZW50TW9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChndWFyZChhY3Rpb24sICdJTklUSUFMX1BVQkxJU0gnKSkge1xuICAgICAgY29uc3QgY3JpdGljYWwgPSBhY3Rpb24ucGF5bG9hZC5jcml0aWNhbDtcbiAgICAgIHB1Ymxpc2hlci5iZWZvcmVTdGFydChjcml0aWNhbCwgYWN0aW9uLnBheWxvYWQubW92ZW1lbnRNb2RlKTtcbiAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgIHB1Ymxpc2hlci5zdGFydChjcml0aWNhbCwgYWN0aW9uLnBheWxvYWQubW92ZW1lbnRNb2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGd1YXJkKGFjdGlvbiwgJ0RST1BfQ09NUExFVEUnKSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYWN0aW9uLnBheWxvYWQuY29tcGxldGVkLnJlc3VsdDtcbiAgICAgIHB1Ymxpc2hlci5mbHVzaCgpO1xuICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgcHVibGlzaGVyLmRyb3AocmVzdWx0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIGlmIChndWFyZChhY3Rpb24sICdGTFVTSCcpKSB7XG4gICAgICBwdWJsaXNoZXIuYWJvcnQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgcHVibGlzaGVyLnVwZGF0ZShzdGF0ZS5jcml0aWNhbCwgc3RhdGUuaW1wYWN0KTtcbiAgICB9XG4gIH07XG59O1xuXG5jb25zdCBkcm9wQW5pbWF0aW9uRmluaXNoTWlkZGxld2FyZSA9IHN0b3JlID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgaWYgKCFndWFyZChhY3Rpb24sICdEUk9QX0FOSU1BVElPTl9GSU5JU0hFRCcpKSB7XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICEoc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpbmlzaCBhIGRyb3AgYW5pbWF0aW5nIHdoZW4gbm8gZHJvcCBpcyBvY2N1cnJpbmcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBzdG9yZS5kaXNwYXRjaChjb21wbGV0ZURyb3Aoe1xuICAgIGNvbXBsZXRlZDogc3RhdGUuY29tcGxldGVkXG4gIH0pKTtcbn07XG5cbmNvbnN0IGRyb3BBbmltYXRpb25GbHVzaE9uU2Nyb2xsTWlkZGxld2FyZSA9IHN0b3JlID0+IHtcbiAgbGV0IHVuYmluZCA9IG51bGw7XG4gIGxldCBmcmFtZUlkID0gbnVsbDtcbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgaWYgKGZyYW1lSWQpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lSWQpO1xuICAgICAgZnJhbWVJZCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh1bmJpbmQpIHtcbiAgICAgIHVuYmluZCgpO1xuICAgICAgdW5iaW5kID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5leHQgPT4gYWN0aW9uID0+IHtcbiAgICBpZiAoZ3VhcmQoYWN0aW9uLCAnRkxVU0gnKSB8fCBndWFyZChhY3Rpb24sICdEUk9QX0NPTVBMRVRFJykgfHwgZ3VhcmQoYWN0aW9uLCAnRFJPUF9BTklNQVRJT05fRklOSVNIRUQnKSkge1xuICAgICAgY2xlYXIoKTtcbiAgICB9XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIGlmICghZ3VhcmQoYWN0aW9uLCAnRFJPUF9BTklNQVRFJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmluZGluZyA9IHtcbiAgICAgIGV2ZW50TmFtZTogJ3Njcm9sbCcsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9LFxuICAgICAgZm46IGZ1bmN0aW9uIGZsdXNoRHJvcEFuaW1hdGlvbigpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICAgICAgICBzdG9yZS5kaXNwYXRjaChkcm9wQW5pbWF0aW9uRmluaXNoZWQoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgZnJhbWVJZCA9IG51bGw7XG4gICAgICB1bmJpbmQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW2JpbmRpbmddKTtcbiAgICB9KTtcbiAgfTtcbn07XG5cbnZhciBkaW1lbnNpb25NYXJzaGFsU3RvcHBlciA9IG1hcnNoYWwgPT4gKCkgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICBpZiAoZ3VhcmQoYWN0aW9uLCAnRFJPUF9DT01QTEVURScpIHx8IGd1YXJkKGFjdGlvbiwgJ0ZMVVNIJykgfHwgZ3VhcmQoYWN0aW9uLCAnRFJPUF9BTklNQVRFJykpIHtcbiAgICBtYXJzaGFsLnN0b3BQdWJsaXNoaW5nKCk7XG4gIH1cbiAgbmV4dChhY3Rpb24pO1xufTtcblxudmFyIGZvY3VzID0gbWFyc2hhbCA9PiB7XG4gIGxldCBpc1dhdGNoaW5nID0gZmFsc2U7XG4gIHJldHVybiAoKSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgaWYgKGd1YXJkKGFjdGlvbiwgJ0lOSVRJQUxfUFVCTElTSCcpKSB7XG4gICAgICBpc1dhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIG1hcnNoYWwudHJ5UmVjb3JkRm9jdXMoYWN0aW9uLnBheWxvYWQuY3JpdGljYWwuZHJhZ2dhYmxlLmlkKTtcbiAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgIG1hcnNoYWwudHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIGlmICghaXNXYXRjaGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZ3VhcmQoYWN0aW9uLCAnRkxVU0gnKSkge1xuICAgICAgaXNXYXRjaGluZyA9IGZhbHNlO1xuICAgICAgbWFyc2hhbC50cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZ3VhcmQoYWN0aW9uLCAnRFJPUF9DT01QTEVURScpKSB7XG4gICAgICBpc1dhdGNoaW5nID0gZmFsc2U7XG4gICAgICBjb25zdCByZXN1bHQgPSBhY3Rpb24ucGF5bG9hZC5jb21wbGV0ZWQucmVzdWx0O1xuICAgICAgaWYgKHJlc3VsdC5jb21iaW5lKSB7XG4gICAgICAgIG1hcnNoYWwudHJ5U2hpZnRSZWNvcmQocmVzdWx0LmRyYWdnYWJsZUlkLCByZXN1bHQuY29tYmluZS5kcmFnZ2FibGVJZCk7XG4gICAgICB9XG4gICAgICBtYXJzaGFsLnRyeVJlc3RvcmVGb2N1c1JlY29yZGVkKCk7XG4gICAgfVxuICB9O1xufTtcblxuY29uc3Qgc2hvdWxkU3RvcCA9IGFjdGlvbiA9PiBndWFyZChhY3Rpb24sICdEUk9QX0NPTVBMRVRFJykgfHwgZ3VhcmQoYWN0aW9uLCAnRFJPUF9BTklNQVRFJykgfHwgZ3VhcmQoYWN0aW9uLCAnRkxVU0gnKTtcbnZhciBhdXRvU2Nyb2xsID0gYXV0b1Njcm9sbGVyID0+IHN0b3JlID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgaWYgKHNob3VsZFN0b3AoYWN0aW9uKSkge1xuICAgIGF1dG9TY3JvbGxlci5zdG9wKCk7XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZ3VhcmQoYWN0aW9uLCAnSU5JVElBTF9QVUJMSVNIJykpIHtcbiAgICBuZXh0KGFjdGlvbik7XG4gICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICEoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcGhhc2UgdG8gYmUgRFJBR0dJTkcgYWZ0ZXIgSU5JVElBTF9QVUJMSVNIJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBhdXRvU2Nyb2xsZXIuc3RhcnQoc3RhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuICBuZXh0KGFjdGlvbik7XG4gIGF1dG9TY3JvbGxlci5zY3JvbGwoc3RvcmUuZ2V0U3RhdGUoKSk7XG59O1xuXG5jb25zdCBwZW5kaW5nRHJvcCA9IHN0b3JlID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgbmV4dChhY3Rpb24pO1xuICBpZiAoIWd1YXJkKGFjdGlvbiwgJ1BVQkxJU0hfV0hJTEVfRFJBR0dJTkcnKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwb3N0QWN0aW9uU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBpZiAocG9zdEFjdGlvblN0YXRlLnBoYXNlICE9PSAnRFJPUF9QRU5ESU5HJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocG9zdEFjdGlvblN0YXRlLmlzV2FpdGluZykge1xuICAgIHJldHVybjtcbiAgfVxuICBzdG9yZS5kaXNwYXRjaChkcm9wKHtcbiAgICByZWFzb246IHBvc3RBY3Rpb25TdGF0ZS5yZWFzb25cbiAgfSkpO1xufTtcblxuY29uc3QgY29tcG9zZUVuaGFuY2VycyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyA/IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18oe1xuICBuYW1lOiAnQGhlbGxvLXBhbmdlYS9kbmQnXG59KSA6IGNvbXBvc2U7XG52YXIgY3JlYXRlU3RvcmUgPSAoe1xuICBkaW1lbnNpb25NYXJzaGFsLFxuICBmb2N1c01hcnNoYWwsXG4gIHN0eWxlTWFyc2hhbCxcbiAgZ2V0UmVzcG9uZGVycyxcbiAgYW5ub3VuY2UsXG4gIGF1dG9TY3JvbGxlclxufSkgPT4gY3JlYXRlU3RvcmUkMShyZWR1Y2VyLCBjb21wb3NlRW5oYW5jZXJzKGFwcGx5TWlkZGxld2FyZShzdHlsZShzdHlsZU1hcnNoYWwpLCBkaW1lbnNpb25NYXJzaGFsU3RvcHBlcihkaW1lbnNpb25NYXJzaGFsKSwgbGlmdChkaW1lbnNpb25NYXJzaGFsKSwgZHJvcE1pZGRsZXdhcmUsIGRyb3BBbmltYXRpb25GaW5pc2hNaWRkbGV3YXJlLCBkcm9wQW5pbWF0aW9uRmx1c2hPblNjcm9sbE1pZGRsZXdhcmUsIHBlbmRpbmdEcm9wLCBhdXRvU2Nyb2xsKGF1dG9TY3JvbGxlciksIHNjcm9sbExpc3RlbmVyLCBmb2N1cyhmb2N1c01hcnNoYWwpLCByZXNwb25kZXJzKGdldFJlc3BvbmRlcnMsIGFubm91bmNlKSkpKTtcblxuY29uc3QgY2xlYW4kMSA9ICgpID0+ICh7XG4gIGFkZGl0aW9uczoge30sXG4gIHJlbW92YWxzOiB7fSxcbiAgbW9kaWZpZWQ6IHt9XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZVB1Ymxpc2hlcih7XG4gIHJlZ2lzdHJ5LFxuICBjYWxsYmFja3Ncbn0pIHtcbiAgbGV0IHN0YWdpbmcgPSBjbGVhbiQxKCk7XG4gIGxldCBmcmFtZUlkID0gbnVsbDtcbiAgY29uc3QgY29sbGVjdCA9ICgpID0+IHtcbiAgICBpZiAoZnJhbWVJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFja3MuY29sbGVjdGlvblN0YXJ0aW5nKCk7XG4gICAgZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBmcmFtZUlkID0gbnVsbDtcbiAgICAgIHN0YXJ0KCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFkZGl0aW9ucyxcbiAgICAgICAgcmVtb3ZhbHMsXG4gICAgICAgIG1vZGlmaWVkXG4gICAgICB9ID0gc3RhZ2luZztcbiAgICAgIGNvbnN0IGFkZGVkID0gT2JqZWN0LmtleXMoYWRkaXRpb25zKS5tYXAoaWQgPT4gcmVnaXN0cnkuZHJhZ2dhYmxlLmdldEJ5SWQoaWQpLmdldERpbWVuc2lvbihvcmlnaW4pKS5zb3J0KChhLCBiKSA9PiBhLmRlc2NyaXB0b3IuaW5kZXggLSBiLmRlc2NyaXB0b3IuaW5kZXgpO1xuICAgICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5rZXlzKG1vZGlmaWVkKS5tYXAoaWQgPT4ge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRCeUlkKGlkKTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsID0gZW50cnkuY2FsbGJhY2tzLmdldFNjcm9sbFdoaWxlRHJhZ2dpbmcoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkcm9wcGFibGVJZDogaWQsXG4gICAgICAgICAgc2Nyb2xsXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgYWRkaXRpb25zOiBhZGRlZCxcbiAgICAgICAgcmVtb3ZhbHM6IE9iamVjdC5rZXlzKHJlbW92YWxzKSxcbiAgICAgICAgbW9kaWZpZWQ6IHVwZGF0ZWRcbiAgICAgIH07XG4gICAgICBzdGFnaW5nID0gY2xlYW4kMSgpO1xuICAgICAgZmluaXNoKCk7XG4gICAgICBjYWxsYmFja3MucHVibGlzaChyZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBhZGQgPSBlbnRyeSA9PiB7XG4gICAgY29uc3QgaWQgPSBlbnRyeS5kZXNjcmlwdG9yLmlkO1xuICAgIHN0YWdpbmcuYWRkaXRpb25zW2lkXSA9IGVudHJ5O1xuICAgIHN0YWdpbmcubW9kaWZpZWRbZW50cnkuZGVzY3JpcHRvci5kcm9wcGFibGVJZF0gPSB0cnVlO1xuICAgIGlmIChzdGFnaW5nLnJlbW92YWxzW2lkXSkge1xuICAgICAgZGVsZXRlIHN0YWdpbmcucmVtb3ZhbHNbaWRdO1xuICAgIH1cbiAgICBjb2xsZWN0KCk7XG4gIH07XG4gIGNvbnN0IHJlbW92ZSA9IGVudHJ5ID0+IHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gZW50cnkuZGVzY3JpcHRvcjtcbiAgICBzdGFnaW5nLnJlbW92YWxzW2Rlc2NyaXB0b3IuaWRdID0gdHJ1ZTtcbiAgICBzdGFnaW5nLm1vZGlmaWVkW2Rlc2NyaXB0b3IuZHJvcHBhYmxlSWRdID0gdHJ1ZTtcbiAgICBpZiAoc3RhZ2luZy5hZGRpdGlvbnNbZGVzY3JpcHRvci5pZF0pIHtcbiAgICAgIGRlbGV0ZSBzdGFnaW5nLmFkZGl0aW9uc1tkZXNjcmlwdG9yLmlkXTtcbiAgICB9XG4gICAgY29sbGVjdCgpO1xuICB9O1xuICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgIGlmICghZnJhbWVJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICBmcmFtZUlkID0gbnVsbDtcbiAgICBzdGFnaW5nID0gY2xlYW4kMSgpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGFkZCxcbiAgICByZW1vdmUsXG4gICAgc3RvcFxuICB9O1xufVxuXG52YXIgZ2V0TWF4U2Nyb2xsID0gKHtcbiAgc2Nyb2xsSGVpZ2h0LFxuICBzY3JvbGxXaWR0aCxcbiAgaGVpZ2h0LFxuICB3aWR0aFxufSkgPT4ge1xuICBjb25zdCBtYXhTY3JvbGwgPSBzdWJ0cmFjdCh7XG4gICAgeDogc2Nyb2xsV2lkdGgsXG4gICAgeTogc2Nyb2xsSGVpZ2h0XG4gIH0sIHtcbiAgICB4OiB3aWR0aCxcbiAgICB5OiBoZWlnaHRcbiAgfSk7XG4gIGNvbnN0IGFkanVzdGVkTWF4U2Nyb2xsID0ge1xuICAgIHg6IE1hdGgubWF4KDAsIG1heFNjcm9sbC54KSxcbiAgICB5OiBNYXRoLm1heCgwLCBtYXhTY3JvbGwueSlcbiAgfTtcbiAgcmV0dXJuIGFkanVzdGVkTWF4U2Nyb2xsO1xufTtcblxudmFyIGdldERvY3VtZW50RWxlbWVudCA9ICgpID0+IHtcbiAgY29uc3QgZG9jID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAhZG9jID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpbmQgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGRvYztcbn07XG5cbnZhciBnZXRNYXhXaW5kb3dTY3JvbGwgPSAoKSA9PiB7XG4gIGNvbnN0IGRvYyA9IGdldERvY3VtZW50RWxlbWVudCgpO1xuICBjb25zdCBtYXhTY3JvbGwgPSBnZXRNYXhTY3JvbGwoe1xuICAgIHNjcm9sbEhlaWdodDogZG9jLnNjcm9sbEhlaWdodCxcbiAgICBzY3JvbGxXaWR0aDogZG9jLnNjcm9sbFdpZHRoLFxuICAgIHdpZHRoOiBkb2MuY2xpZW50V2lkdGgsXG4gICAgaGVpZ2h0OiBkb2MuY2xpZW50SGVpZ2h0XG4gIH0pO1xuICByZXR1cm4gbWF4U2Nyb2xsO1xufTtcblxudmFyIGdldFZpZXdwb3J0ID0gKCkgPT4ge1xuICBjb25zdCBzY3JvbGwgPSBnZXRXaW5kb3dTY3JvbGwoKTtcbiAgY29uc3QgbWF4U2Nyb2xsID0gZ2V0TWF4V2luZG93U2Nyb2xsKCk7XG4gIGNvbnN0IHRvcCA9IHNjcm9sbC55O1xuICBjb25zdCBsZWZ0ID0gc2Nyb2xsLng7XG4gIGNvbnN0IGRvYyA9IGdldERvY3VtZW50RWxlbWVudCgpO1xuICBjb25zdCB3aWR0aCA9IGRvYy5jbGllbnRXaWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gZG9jLmNsaWVudEhlaWdodDtcbiAgY29uc3QgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gIGNvbnN0IGJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgY29uc3QgZnJhbWUgPSBnZXRSZWN0KHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICBib3R0b21cbiAgfSk7XG4gIGNvbnN0IHZpZXdwb3J0ID0ge1xuICAgIGZyYW1lLFxuICAgIHNjcm9sbDoge1xuICAgICAgaW5pdGlhbDogc2Nyb2xsLFxuICAgICAgY3VycmVudDogc2Nyb2xsLFxuICAgICAgbWF4OiBtYXhTY3JvbGwsXG4gICAgICBkaWZmOiB7XG4gICAgICAgIHZhbHVlOiBvcmlnaW4sXG4gICAgICAgIGRpc3BsYWNlbWVudDogb3JpZ2luXG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gdmlld3BvcnQ7XG59O1xuXG52YXIgZ2V0SW5pdGlhbFB1Ymxpc2ggPSAoe1xuICBjcml0aWNhbCxcbiAgc2Nyb2xsT3B0aW9ucyxcbiAgcmVnaXN0cnlcbn0pID0+IHtcbiAgc3RhcnQoKTtcbiAgY29uc3Qgdmlld3BvcnQgPSBnZXRWaWV3cG9ydCgpO1xuICBjb25zdCB3aW5kb3dTY3JvbGwgPSB2aWV3cG9ydC5zY3JvbGwuY3VycmVudDtcbiAgY29uc3QgaG9tZSA9IGNyaXRpY2FsLmRyb3BwYWJsZTtcbiAgY29uc3QgZHJvcHBhYmxlcyA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRBbGxCeVR5cGUoaG9tZS50eXBlKS5tYXAoZW50cnkgPT4gZW50cnkuY2FsbGJhY2tzLmdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsKHdpbmRvd1Njcm9sbCwgc2Nyb2xsT3B0aW9ucykpO1xuICBjb25zdCBkcmFnZ2FibGVzID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmdldEFsbEJ5VHlwZShjcml0aWNhbC5kcmFnZ2FibGUudHlwZSkubWFwKGVudHJ5ID0+IGVudHJ5LmdldERpbWVuc2lvbih3aW5kb3dTY3JvbGwpKTtcbiAgY29uc3QgZGltZW5zaW9ucyA9IHtcbiAgICBkcmFnZ2FibGVzOiB0b0RyYWdnYWJsZU1hcChkcmFnZ2FibGVzKSxcbiAgICBkcm9wcGFibGVzOiB0b0Ryb3BwYWJsZU1hcChkcm9wcGFibGVzKVxuICB9O1xuICBmaW5pc2goKTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGRpbWVuc2lvbnMsXG4gICAgY3JpdGljYWwsXG4gICAgdmlld3BvcnRcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZFB1Ymxpc2hVcGRhdGUocmVnaXN0cnksIGRyYWdnaW5nLCBlbnRyeSkge1xuICBpZiAoZW50cnkuZGVzY3JpcHRvci5pZCA9PT0gZHJhZ2dpbmcuaWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGVudHJ5LmRlc2NyaXB0b3IudHlwZSAhPT0gZHJhZ2dpbmcudHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBob21lID0gcmVnaXN0cnkuZHJvcHBhYmxlLmdldEJ5SWQoZW50cnkuZGVzY3JpcHRvci5kcm9wcGFibGVJZCk7XG4gIGlmIChob21lLmRlc2NyaXB0b3IubW9kZSAhPT0gJ3ZpcnR1YWwnKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gYWRkIG9yIHJlbW92ZSBhIERyYWdnYWJsZSBbaWQ6ICR7ZW50cnkuZGVzY3JpcHRvci5pZH1dXG4gICAgICB3aGlsZSBhIGRyYWcgaXMgb2NjdXJyaW5nLiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciB2aXJ0dWFsIGxpc3RzLlxuXG4gICAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2hlbGxvLXBhbmdlYS9kbmQvYmxvYi9tYWluL2RvY3MvcGF0dGVybnMvdmlydHVhbC1saXN0cy5tZFxuICAgIGApIDogdm9pZCAwO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbnZhciBjcmVhdGVEaW1lbnNpb25NYXJzaGFsID0gKHJlZ2lzdHJ5LCBjYWxsYmFja3MpID0+IHtcbiAgbGV0IGNvbGxlY3Rpb24gPSBudWxsO1xuICBjb25zdCBwdWJsaXNoZXIgPSBjcmVhdGVQdWJsaXNoZXIoe1xuICAgIGNhbGxiYWNrczoge1xuICAgICAgcHVibGlzaDogY2FsbGJhY2tzLnB1Ymxpc2hXaGlsZURyYWdnaW5nLFxuICAgICAgY29sbGVjdGlvblN0YXJ0aW5nOiBjYWxsYmFja3MuY29sbGVjdGlvblN0YXJ0aW5nXG4gICAgfSxcbiAgICByZWdpc3RyeVxuICB9KTtcbiAgY29uc3QgdXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkID0gKGlkLCBpc0VuYWJsZWQpID0+IHtcbiAgICAhcmVnaXN0cnkuZHJvcHBhYmxlLmV4aXN0cyhpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgdXBkYXRlIGlzIGVuYWJsZWQgZmxhZyBvZiBEcm9wcGFibGUgJHtpZH0gYXMgaXQgaXMgbm90IHJlZ2lzdGVyZWRgKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFja3MudXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkKHtcbiAgICAgIGlkLFxuICAgICAgaXNFbmFibGVkXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQgPSAoaWQsIGlzQ29tYmluZUVuYWJsZWQpID0+IHtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgIXJlZ2lzdHJ5LmRyb3BwYWJsZS5leGlzdHMoaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IHVwZGF0ZSBpc0NvbWJpbmVFbmFibGVkIGZsYWcgb2YgRHJvcHBhYmxlICR7aWR9IGFzIGl0IGlzIG5vdCByZWdpc3RlcmVkYCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjYWxsYmFja3MudXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCh7XG4gICAgICBpZCxcbiAgICAgIGlzQ29tYmluZUVuYWJsZWRcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlRHJvcHBhYmxlU2Nyb2xsID0gKGlkLCBuZXdTY3JvbGwpID0+IHtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgIXJlZ2lzdHJ5LmRyb3BwYWJsZS5leGlzdHMoaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IHVwZGF0ZSB0aGUgc2Nyb2xsIG9uIERyb3BwYWJsZSAke2lkfSBhcyBpdCBpcyBub3QgcmVnaXN0ZXJlZGApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY2FsbGJhY2tzLnVwZGF0ZURyb3BwYWJsZVNjcm9sbCh7XG4gICAgICBpZCxcbiAgICAgIG5ld1Njcm9sbFxuICAgIH0pO1xuICB9O1xuICBjb25zdCBzY3JvbGxEcm9wcGFibGUgPSAoaWQsIGNoYW5nZSkgPT4ge1xuICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QnlJZChpZCkuY2FsbGJhY2tzLnNjcm9sbChjaGFuZ2UpO1xuICB9O1xuICBjb25zdCBzdG9wUHVibGlzaGluZyA9ICgpID0+IHtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHVibGlzaGVyLnN0b3AoKTtcbiAgICBjb25zdCBob21lID0gY29sbGVjdGlvbi5jcml0aWNhbC5kcm9wcGFibGU7XG4gICAgcmVnaXN0cnkuZHJvcHBhYmxlLmdldEFsbEJ5VHlwZShob21lLnR5cGUpLmZvckVhY2goZW50cnkgPT4gZW50cnkuY2FsbGJhY2tzLmRyYWdTdG9wcGVkKCkpO1xuICAgIGNvbGxlY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICBjb2xsZWN0aW9uID0gbnVsbDtcbiAgfTtcbiAgY29uc3Qgc3Vic2NyaWJlciA9IGV2ZW50ID0+IHtcbiAgICAhY29sbGVjdGlvbiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBvbmx5IGJlIHN1YnNjcmliZWQgd2hlbiBhIGNvbGxlY3Rpb24gaXMgb2NjdXJyaW5nJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBkcmFnZ2luZyA9IGNvbGxlY3Rpb24uY3JpdGljYWwuZHJhZ2dhYmxlO1xuICAgIGlmIChldmVudC50eXBlID09PSAnQURESVRJT04nKSB7XG4gICAgICBpZiAoc2hvdWxkUHVibGlzaFVwZGF0ZShyZWdpc3RyeSwgZHJhZ2dpbmcsIGV2ZW50LnZhbHVlKSkge1xuICAgICAgICBwdWJsaXNoZXIuYWRkKGV2ZW50LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdSRU1PVkFMJykge1xuICAgICAgaWYgKHNob3VsZFB1Ymxpc2hVcGRhdGUocmVnaXN0cnksIGRyYWdnaW5nLCBldmVudC52YWx1ZSkpIHtcbiAgICAgICAgcHVibGlzaGVyLnJlbW92ZShldmVudC52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBzdGFydFB1Ymxpc2hpbmcgPSByZXF1ZXN0ID0+IHtcbiAgICAhIWNvbGxlY3Rpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RhcnQgY2FwdHVyaW5nIGNyaXRpY2FsIGRpbWVuc2lvbnMgYXMgdGhlcmUgaXMgYWxyZWFkeSBhIGNvbGxlY3Rpb24nKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IGVudHJ5ID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmdldEJ5SWQocmVxdWVzdC5kcmFnZ2FibGVJZCk7XG4gICAgY29uc3QgaG9tZSA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRCeUlkKGVudHJ5LmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQpO1xuICAgIGNvbnN0IGNyaXRpY2FsID0ge1xuICAgICAgZHJhZ2dhYmxlOiBlbnRyeS5kZXNjcmlwdG9yLFxuICAgICAgZHJvcHBhYmxlOiBob21lLmRlc2NyaXB0b3JcbiAgICB9O1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gcmVnaXN0cnkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIGNvbGxlY3Rpb24gPSB7XG4gICAgICBjcml0aWNhbCxcbiAgICAgIHVuc3Vic2NyaWJlXG4gICAgfTtcbiAgICByZXR1cm4gZ2V0SW5pdGlhbFB1Ymxpc2goe1xuICAgICAgY3JpdGljYWwsXG4gICAgICByZWdpc3RyeSxcbiAgICAgIHNjcm9sbE9wdGlvbnM6IHJlcXVlc3Quc2Nyb2xsT3B0aW9uc1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBtYXJzaGFsID0ge1xuICAgIHVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCxcbiAgICB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkLFxuICAgIHNjcm9sbERyb3BwYWJsZSxcbiAgICB1cGRhdGVEcm9wcGFibGVTY3JvbGwsXG4gICAgc3RhcnRQdWJsaXNoaW5nLFxuICAgIHN0b3BQdWJsaXNoaW5nXG4gIH07XG4gIHJldHVybiBtYXJzaGFsO1xufTtcblxudmFyIGNhblN0YXJ0RHJhZyA9IChzdGF0ZSwgaWQpID0+IHtcbiAgaWYgKHN0YXRlLnBoYXNlID09PSAnSURMRScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoc3RhdGUucGhhc2UgIT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHN0YXRlLmNvbXBsZXRlZC5yZXN1bHQuZHJhZ2dhYmxlSWQgPT09IGlkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBzdGF0ZS5jb21wbGV0ZWQucmVzdWx0LnJlYXNvbiA9PT0gJ0RST1AnO1xufTtcblxudmFyIHNjcm9sbFdpbmRvdyA9IGNoYW5nZSA9PiB7XG4gIHdpbmRvdy5zY3JvbGxCeShjaGFuZ2UueCwgY2hhbmdlLnkpO1xufTtcblxuY29uc3QgZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZXMgPSBtZW1vaXplT25lKGRyb3BwYWJsZXMgPT4gdG9Ecm9wcGFibGVMaXN0KGRyb3BwYWJsZXMpLmZpbHRlcihkcm9wcGFibGUgPT4ge1xuICBpZiAoIWRyb3BwYWJsZS5pc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFkcm9wcGFibGUuZnJhbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KSk7XG5jb25zdCBnZXRTY3JvbGxhYmxlRHJvcHBhYmxlT3ZlciA9ICh0YXJnZXQsIGRyb3BwYWJsZXMpID0+IHtcbiAgY29uc3QgbWF5YmUgPSBnZXRTY3JvbGxhYmxlRHJvcHBhYmxlcyhkcm9wcGFibGVzKS5maW5kKGRyb3BwYWJsZSA9PiB7XG4gICAgIWRyb3BwYWJsZS5mcmFtZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgcmVzdWx0JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gaXNQb3NpdGlvbkluRnJhbWUoZHJvcHBhYmxlLmZyYW1lLnBhZ2VNYXJnaW5Cb3gpKHRhcmdldCk7XG4gIH0pIHx8IG51bGw7XG4gIHJldHVybiBtYXliZTtcbn07XG52YXIgZ2V0QmVzdFNjcm9sbGFibGVEcm9wcGFibGUgPSAoe1xuICBjZW50ZXIsXG4gIGRlc3RpbmF0aW9uLFxuICBkcm9wcGFibGVzXG59KSA9PiB7XG4gIGlmIChkZXN0aW5hdGlvbikge1xuICAgIGNvbnN0IGRpbWVuc2lvbiA9IGRyb3BwYWJsZXNbZGVzdGluYXRpb25dO1xuICAgIGlmICghZGltZW5zaW9uLmZyYW1lKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRpbWVuc2lvbjtcbiAgfVxuICBjb25zdCBkaW1lbnNpb24gPSBnZXRTY3JvbGxhYmxlRHJvcHBhYmxlT3ZlcihjZW50ZXIsIGRyb3BwYWJsZXMpO1xuICByZXR1cm4gZGltZW5zaW9uO1xufTtcblxuY29uc3QgZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnMgPSB7XG4gIHN0YXJ0RnJvbVBlcmNlbnRhZ2U6IDAuMjUsXG4gIG1heFNjcm9sbEF0UGVyY2VudGFnZTogMC4wNSxcbiAgbWF4UGl4ZWxTY3JvbGw6IDI4LFxuICBlYXNlOiBwZXJjZW50YWdlID0+IHBlcmNlbnRhZ2UgKiogMixcbiAgZHVyYXRpb25EYW1wZW5pbmc6IHtcbiAgICBzdG9wRGFtcGVuaW5nQXQ6IDEyMDAsXG4gICAgYWNjZWxlcmF0ZUF0OiAzNjBcbiAgfSxcbiAgZGlzYWJsZWQ6IGZhbHNlXG59O1xuXG52YXIgZ2V0RGlzdGFuY2VUaHJlc2hvbGRzID0gKGNvbnRhaW5lciwgYXhpcywgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyA9ICgpID0+IGRlZmF1bHRBdXRvU2Nyb2xsZXJPcHRpb25zKSA9PiB7XG4gIGNvbnN0IGF1dG9TY3JvbGxlck9wdGlvbnMgPSBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKCk7XG4gIGNvbnN0IHN0YXJ0U2Nyb2xsaW5nRnJvbSA9IGNvbnRhaW5lcltheGlzLnNpemVdICogYXV0b1Njcm9sbGVyT3B0aW9ucy5zdGFydEZyb21QZXJjZW50YWdlO1xuICBjb25zdCBtYXhTY3JvbGxWYWx1ZUF0ID0gY29udGFpbmVyW2F4aXMuc2l6ZV0gKiBhdXRvU2Nyb2xsZXJPcHRpb25zLm1heFNjcm9sbEF0UGVyY2VudGFnZTtcbiAgY29uc3QgdGhyZXNob2xkcyA9IHtcbiAgICBzdGFydFNjcm9sbGluZ0Zyb20sXG4gICAgbWF4U2Nyb2xsVmFsdWVBdFxuICB9O1xuICByZXR1cm4gdGhyZXNob2xkcztcbn07XG5cbnZhciBnZXRQZXJjZW50YWdlID0gKHtcbiAgc3RhcnRPZlJhbmdlLFxuICBlbmRPZlJhbmdlLFxuICBjdXJyZW50XG59KSA9PiB7XG4gIGNvbnN0IHJhbmdlID0gZW5kT2ZSYW5nZSAtIHN0YXJ0T2ZSYW5nZTtcbiAgaWYgKHJhbmdlID09PSAwKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICBEZXRlY3RlZCBkaXN0YW5jZSByYW5nZSBvZiAwIGluIHRoZSBmbHVpZCBhdXRvIHNjcm9sbGVyXG4gICAgICBUaGlzIGlzIHVuZXhwZWN0ZWQgYW5kIHdvdWxkIGNhdXNlIGEgZGl2aWRlIGJ5IDAgaXNzdWUuXG4gICAgICBOb3QgYWxsb3dpbmcgYW4gYXV0byBzY3JvbGxcbiAgICBgKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBjdXJyZW50SW5SYW5nZSA9IGN1cnJlbnQgLSBzdGFydE9mUmFuZ2U7XG4gIGNvbnN0IHBlcmNlbnRhZ2UgPSBjdXJyZW50SW5SYW5nZSAvIHJhbmdlO1xuICByZXR1cm4gcGVyY2VudGFnZTtcbn07XG5cbnZhciBtaW5TY3JvbGwgPSAxO1xuXG52YXIgZ2V0VmFsdWVGcm9tRGlzdGFuY2UgPSAoZGlzdGFuY2VUb0VkZ2UsIHRocmVzaG9sZHMsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMgPSAoKSA9PiBkZWZhdWx0QXV0b1Njcm9sbGVyT3B0aW9ucykgPT4ge1xuICBjb25zdCBhdXRvU2Nyb2xsZXJPcHRpb25zID0gZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucygpO1xuICBpZiAoZGlzdGFuY2VUb0VkZ2UgPiB0aHJlc2hvbGRzLnN0YXJ0U2Nyb2xsaW5nRnJvbSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChkaXN0YW5jZVRvRWRnZSA8PSB0aHJlc2hvbGRzLm1heFNjcm9sbFZhbHVlQXQpIHtcbiAgICByZXR1cm4gYXV0b1Njcm9sbGVyT3B0aW9ucy5tYXhQaXhlbFNjcm9sbDtcbiAgfVxuICBpZiAoZGlzdGFuY2VUb0VkZ2UgPT09IHRocmVzaG9sZHMuc3RhcnRTY3JvbGxpbmdGcm9tKSB7XG4gICAgcmV0dXJuIG1pblNjcm9sbDtcbiAgfVxuICBjb25zdCBwZXJjZW50YWdlRnJvbU1heFNjcm9sbFZhbHVlQXQgPSBnZXRQZXJjZW50YWdlKHtcbiAgICBzdGFydE9mUmFuZ2U6IHRocmVzaG9sZHMubWF4U2Nyb2xsVmFsdWVBdCxcbiAgICBlbmRPZlJhbmdlOiB0aHJlc2hvbGRzLnN0YXJ0U2Nyb2xsaW5nRnJvbSxcbiAgICBjdXJyZW50OiBkaXN0YW5jZVRvRWRnZVxuICB9KTtcbiAgY29uc3QgcGVyY2VudGFnZUZyb21TdGFydFNjcm9sbGluZ0Zyb20gPSAxIC0gcGVyY2VudGFnZUZyb21NYXhTY3JvbGxWYWx1ZUF0O1xuICBjb25zdCBzY3JvbGwgPSBhdXRvU2Nyb2xsZXJPcHRpb25zLm1heFBpeGVsU2Nyb2xsICogYXV0b1Njcm9sbGVyT3B0aW9ucy5lYXNlKHBlcmNlbnRhZ2VGcm9tU3RhcnRTY3JvbGxpbmdGcm9tKTtcbiAgcmV0dXJuIE1hdGguY2VpbChzY3JvbGwpO1xufTtcblxudmFyIGRhbXBlblZhbHVlQnlUaW1lID0gKHByb3Bvc2VkU2Nyb2xsLCBkcmFnU3RhcnRUaW1lLCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKSA9PiB7XG4gIGNvbnN0IGF1dG9TY3JvbGxlck9wdGlvbnMgPSBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKCk7XG4gIGNvbnN0IGFjY2VsZXJhdGVBdCA9IGF1dG9TY3JvbGxlck9wdGlvbnMuZHVyYXRpb25EYW1wZW5pbmcuYWNjZWxlcmF0ZUF0O1xuICBjb25zdCBzdG9wQXQgPSBhdXRvU2Nyb2xsZXJPcHRpb25zLmR1cmF0aW9uRGFtcGVuaW5nLnN0b3BEYW1wZW5pbmdBdDtcbiAgY29uc3Qgc3RhcnRPZlJhbmdlID0gZHJhZ1N0YXJ0VGltZTtcbiAgY29uc3QgZW5kT2ZSYW5nZSA9IHN0b3BBdDtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgcnVuVGltZSA9IG5vdyAtIHN0YXJ0T2ZSYW5nZTtcbiAgaWYgKHJ1blRpbWUgPj0gc3RvcEF0KSB7XG4gICAgcmV0dXJuIHByb3Bvc2VkU2Nyb2xsO1xuICB9XG4gIGlmIChydW5UaW1lIDwgYWNjZWxlcmF0ZUF0KSB7XG4gICAgcmV0dXJuIG1pblNjcm9sbDtcbiAgfVxuICBjb25zdCBiZXR3ZWVuQWNjZWxlcmF0ZUF0QW5kU3RvcEF0UGVyY2VudGFnZSA9IGdldFBlcmNlbnRhZ2Uoe1xuICAgIHN0YXJ0T2ZSYW5nZTogYWNjZWxlcmF0ZUF0LFxuICAgIGVuZE9mUmFuZ2UsXG4gICAgY3VycmVudDogcnVuVGltZVxuICB9KTtcbiAgY29uc3Qgc2Nyb2xsID0gcHJvcG9zZWRTY3JvbGwgKiBhdXRvU2Nyb2xsZXJPcHRpb25zLmVhc2UoYmV0d2VlbkFjY2VsZXJhdGVBdEFuZFN0b3BBdFBlcmNlbnRhZ2UpO1xuICByZXR1cm4gTWF0aC5jZWlsKHNjcm9sbCk7XG59O1xuXG52YXIgZ2V0VmFsdWUgPSAoe1xuICBkaXN0YW5jZVRvRWRnZSxcbiAgdGhyZXNob2xkcyxcbiAgZHJhZ1N0YXJ0VGltZSxcbiAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCBzY3JvbGwgPSBnZXRWYWx1ZUZyb21EaXN0YW5jZShkaXN0YW5jZVRvRWRnZSwgdGhyZXNob2xkcywgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyk7XG4gIGlmIChzY3JvbGwgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoIXNob3VsZFVzZVRpbWVEYW1wZW5pbmcpIHtcbiAgICByZXR1cm4gc2Nyb2xsO1xuICB9XG4gIHJldHVybiBNYXRoLm1heChkYW1wZW5WYWx1ZUJ5VGltZShzY3JvbGwsIGRyYWdTdGFydFRpbWUsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMpLCBtaW5TY3JvbGwpO1xufTtcblxudmFyIGdldFNjcm9sbE9uQXhpcyA9ICh7XG4gIGNvbnRhaW5lcixcbiAgZGlzdGFuY2VUb0VkZ2VzLFxuICBkcmFnU3RhcnRUaW1lLFxuICBheGlzLFxuICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IHRocmVzaG9sZHMgPSBnZXREaXN0YW5jZVRocmVzaG9sZHMoY29udGFpbmVyLCBheGlzLCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKTtcbiAgY29uc3QgaXNDbG9zZXJUb0VuZCA9IGRpc3RhbmNlVG9FZGdlc1theGlzLmVuZF0gPCBkaXN0YW5jZVRvRWRnZXNbYXhpcy5zdGFydF07XG4gIGlmIChpc0Nsb3NlclRvRW5kKSB7XG4gICAgcmV0dXJuIGdldFZhbHVlKHtcbiAgICAgIGRpc3RhbmNlVG9FZGdlOiBkaXN0YW5jZVRvRWRnZXNbYXhpcy5lbmRdLFxuICAgICAgdGhyZXNob2xkcyxcbiAgICAgIGRyYWdTdGFydFRpbWUsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiAtMSAqIGdldFZhbHVlKHtcbiAgICBkaXN0YW5jZVRvRWRnZTogZGlzdGFuY2VUb0VkZ2VzW2F4aXMuc3RhcnRdLFxuICAgIHRocmVzaG9sZHMsXG4gICAgZHJhZ1N0YXJ0VGltZSxcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSk7XG59O1xuXG52YXIgYWRqdXN0Rm9yU2l6ZUxpbWl0cyA9ICh7XG4gIGNvbnRhaW5lcixcbiAgc3ViamVjdCxcbiAgcHJvcG9zZWRTY3JvbGxcbn0pID0+IHtcbiAgY29uc3QgaXNUb29CaWdWZXJ0aWNhbGx5ID0gc3ViamVjdC5oZWlnaHQgPiBjb250YWluZXIuaGVpZ2h0O1xuICBjb25zdCBpc1Rvb0JpZ0hvcml6b250YWxseSA9IHN1YmplY3Qud2lkdGggPiBjb250YWluZXIud2lkdGg7XG4gIGlmICghaXNUb29CaWdIb3Jpem9udGFsbHkgJiYgIWlzVG9vQmlnVmVydGljYWxseSkge1xuICAgIHJldHVybiBwcm9wb3NlZFNjcm9sbDtcbiAgfVxuICBpZiAoaXNUb29CaWdIb3Jpem9udGFsbHkgJiYgaXNUb29CaWdWZXJ0aWNhbGx5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBpc1Rvb0JpZ0hvcml6b250YWxseSA/IDAgOiBwcm9wb3NlZFNjcm9sbC54LFxuICAgIHk6IGlzVG9vQmlnVmVydGljYWxseSA/IDAgOiBwcm9wb3NlZFNjcm9sbC55XG4gIH07XG59O1xuXG5jb25zdCBjbGVhbiA9IGFwcGx5KHZhbHVlID0+IHZhbHVlID09PSAwID8gMCA6IHZhbHVlKTtcbnZhciBnZXRTY3JvbGwkMSA9ICh7XG4gIGRyYWdTdGFydFRpbWUsXG4gIGNvbnRhaW5lcixcbiAgc3ViamVjdCxcbiAgY2VudGVyLFxuICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IGRpc3RhbmNlVG9FZGdlcyA9IHtcbiAgICB0b3A6IGNlbnRlci55IC0gY29udGFpbmVyLnRvcCxcbiAgICByaWdodDogY29udGFpbmVyLnJpZ2h0IC0gY2VudGVyLngsXG4gICAgYm90dG9tOiBjb250YWluZXIuYm90dG9tIC0gY2VudGVyLnksXG4gICAgbGVmdDogY2VudGVyLnggLSBjb250YWluZXIubGVmdFxuICB9O1xuICBjb25zdCB5ID0gZ2V0U2Nyb2xsT25BeGlzKHtcbiAgICBjb250YWluZXIsXG4gICAgZGlzdGFuY2VUb0VkZ2VzLFxuICAgIGRyYWdTdGFydFRpbWUsXG4gICAgYXhpczogdmVydGljYWwsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xuICBjb25zdCB4ID0gZ2V0U2Nyb2xsT25BeGlzKHtcbiAgICBjb250YWluZXIsXG4gICAgZGlzdGFuY2VUb0VkZ2VzLFxuICAgIGRyYWdTdGFydFRpbWUsXG4gICAgYXhpczogaG9yaXpvbnRhbCxcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSk7XG4gIGNvbnN0IHJlcXVpcmVkID0gY2xlYW4oe1xuICAgIHgsXG4gICAgeVxuICB9KTtcbiAgaWYgKGlzRXF1YWwkMShyZXF1aXJlZCwgb3JpZ2luKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGxpbWl0ZWQgPSBhZGp1c3RGb3JTaXplTGltaXRzKHtcbiAgICBjb250YWluZXIsXG4gICAgc3ViamVjdCxcbiAgICBwcm9wb3NlZFNjcm9sbDogcmVxdWlyZWRcbiAgfSk7XG4gIGlmICghbGltaXRlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBpc0VxdWFsJDEobGltaXRlZCwgb3JpZ2luKSA/IG51bGwgOiBsaW1pdGVkO1xufTtcblxuY29uc3Qgc21hbGxlc3RTaWduZWQgPSBhcHBseSh2YWx1ZSA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiB2YWx1ZSA+IDAgPyAxIDogLTE7XG59KTtcbmNvbnN0IGdldE92ZXJsYXAgPSAoKCkgPT4ge1xuICBjb25zdCBnZXRSZW1haW5kZXIgPSAodGFyZ2V0LCBtYXgpID0+IHtcbiAgICBpZiAodGFyZ2V0IDwgMCkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgaWYgKHRhcmdldCA+IG1heCkge1xuICAgICAgcmV0dXJuIHRhcmdldCAtIG1heDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIHJldHVybiAoe1xuICAgIGN1cnJlbnQsXG4gICAgbWF4LFxuICAgIGNoYW5nZVxuICB9KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0U2Nyb2xsID0gYWRkKGN1cnJlbnQsIGNoYW5nZSk7XG4gICAgY29uc3Qgb3ZlcmxhcCA9IHtcbiAgICAgIHg6IGdldFJlbWFpbmRlcih0YXJnZXRTY3JvbGwueCwgbWF4LngpLFxuICAgICAgeTogZ2V0UmVtYWluZGVyKHRhcmdldFNjcm9sbC55LCBtYXgueSlcbiAgICB9O1xuICAgIGlmIChpc0VxdWFsJDEob3ZlcmxhcCwgb3JpZ2luKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBvdmVybGFwO1xuICB9O1xufSkoKTtcbmNvbnN0IGNhblBhcnRpYWxseVNjcm9sbCA9ICh7XG4gIG1heDogcmF3TWF4LFxuICBjdXJyZW50LFxuICBjaGFuZ2Vcbn0pID0+IHtcbiAgY29uc3QgbWF4ID0ge1xuICAgIHg6IE1hdGgubWF4KGN1cnJlbnQueCwgcmF3TWF4LngpLFxuICAgIHk6IE1hdGgubWF4KGN1cnJlbnQueSwgcmF3TWF4LnkpXG4gIH07XG4gIGNvbnN0IHNtYWxsZXN0Q2hhbmdlID0gc21hbGxlc3RTaWduZWQoY2hhbmdlKTtcbiAgY29uc3Qgb3ZlcmxhcCA9IGdldE92ZXJsYXAoe1xuICAgIG1heCxcbiAgICBjdXJyZW50LFxuICAgIGNoYW5nZTogc21hbGxlc3RDaGFuZ2VcbiAgfSk7XG4gIGlmICghb3ZlcmxhcCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChzbWFsbGVzdENoYW5nZS54ICE9PSAwICYmIG92ZXJsYXAueCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChzbWFsbGVzdENoYW5nZS55ICE9PSAwICYmIG92ZXJsYXAueSA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBjYW5TY3JvbGxXaW5kb3cgPSAodmlld3BvcnQsIGNoYW5nZSkgPT4gY2FuUGFydGlhbGx5U2Nyb2xsKHtcbiAgY3VycmVudDogdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQsXG4gIG1heDogdmlld3BvcnQuc2Nyb2xsLm1heCxcbiAgY2hhbmdlXG59KTtcbmNvbnN0IGdldFdpbmRvd092ZXJsYXAgPSAodmlld3BvcnQsIGNoYW5nZSkgPT4ge1xuICBpZiAoIWNhblNjcm9sbFdpbmRvdyh2aWV3cG9ydCwgY2hhbmdlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IG1heCA9IHZpZXdwb3J0LnNjcm9sbC5tYXg7XG4gIGNvbnN0IGN1cnJlbnQgPSB2aWV3cG9ydC5zY3JvbGwuY3VycmVudDtcbiAgcmV0dXJuIGdldE92ZXJsYXAoe1xuICAgIGN1cnJlbnQsXG4gICAgbWF4LFxuICAgIGNoYW5nZVxuICB9KTtcbn07XG5jb25zdCBjYW5TY3JvbGxEcm9wcGFibGUgPSAoZHJvcHBhYmxlLCBjaGFuZ2UpID0+IHtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGlmICghZnJhbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGNhblBhcnRpYWxseVNjcm9sbCh7XG4gICAgY3VycmVudDogZnJhbWUuc2Nyb2xsLmN1cnJlbnQsXG4gICAgbWF4OiBmcmFtZS5zY3JvbGwubWF4LFxuICAgIGNoYW5nZVxuICB9KTtcbn07XG5jb25zdCBnZXREcm9wcGFibGVPdmVybGFwID0gKGRyb3BwYWJsZSwgY2hhbmdlKSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFjYW5TY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLCBjaGFuZ2UpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGdldE92ZXJsYXAoe1xuICAgIGN1cnJlbnQ6IGZyYW1lLnNjcm9sbC5jdXJyZW50LFxuICAgIG1heDogZnJhbWUuc2Nyb2xsLm1heCxcbiAgICBjaGFuZ2VcbiAgfSk7XG59O1xuXG52YXIgZ2V0V2luZG93U2Nyb2xsQ2hhbmdlID0gKHtcbiAgdmlld3BvcnQsXG4gIHN1YmplY3QsXG4gIGNlbnRlcixcbiAgZHJhZ1N0YXJ0VGltZSxcbiAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCBzY3JvbGwgPSBnZXRTY3JvbGwkMSh7XG4gICAgZHJhZ1N0YXJ0VGltZSxcbiAgICBjb250YWluZXI6IHZpZXdwb3J0LmZyYW1lLFxuICAgIHN1YmplY3QsXG4gICAgY2VudGVyLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9KTtcbiAgcmV0dXJuIHNjcm9sbCAmJiBjYW5TY3JvbGxXaW5kb3codmlld3BvcnQsIHNjcm9sbCkgPyBzY3JvbGwgOiBudWxsO1xufTtcblxudmFyIGdldERyb3BwYWJsZVNjcm9sbENoYW5nZSA9ICh7XG4gIGRyb3BwYWJsZSxcbiAgc3ViamVjdCxcbiAgY2VudGVyLFxuICBkcmFnU3RhcnRUaW1lLFxuICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc2Nyb2xsID0gZ2V0U2Nyb2xsJDEoe1xuICAgIGRyYWdTdGFydFRpbWUsXG4gICAgY29udGFpbmVyOiBmcmFtZS5wYWdlTWFyZ2luQm94LFxuICAgIHN1YmplY3QsXG4gICAgY2VudGVyLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9KTtcbiAgcmV0dXJuIHNjcm9sbCAmJiBjYW5TY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLCBzY3JvbGwpID8gc2Nyb2xsIDogbnVsbDtcbn07XG5cbnZhciBzY3JvbGwgPSAoe1xuICBzdGF0ZSxcbiAgZHJhZ1N0YXJ0VGltZSxcbiAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgc2Nyb2xsV2luZG93LFxuICBzY3JvbGxEcm9wcGFibGUsXG4gIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3QgY2VudGVyID0gc3RhdGUuY3VycmVudC5wYWdlLmJvcmRlckJveENlbnRlcjtcbiAgY29uc3QgZHJhZ2dhYmxlID0gc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gIGNvbnN0IHN1YmplY3QgPSBkcmFnZ2FibGUucGFnZS5tYXJnaW5Cb3g7XG4gIGlmIChzdGF0ZS5pc1dpbmRvd1Njcm9sbEFsbG93ZWQpIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHN0YXRlLnZpZXdwb3J0O1xuICAgIGNvbnN0IGNoYW5nZSA9IGdldFdpbmRvd1Njcm9sbENoYW5nZSh7XG4gICAgICBkcmFnU3RhcnRUaW1lLFxuICAgICAgdmlld3BvcnQsXG4gICAgICBzdWJqZWN0LFxuICAgICAgY2VudGVyLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlKSB7XG4gICAgICBzY3JvbGxXaW5kb3coY2hhbmdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY29uc3QgZHJvcHBhYmxlID0gZ2V0QmVzdFNjcm9sbGFibGVEcm9wcGFibGUoe1xuICAgIGNlbnRlcixcbiAgICBkZXN0aW5hdGlvbjogd2hhdElzRHJhZ2dlZE92ZXIoc3RhdGUuaW1wYWN0KSxcbiAgICBkcm9wcGFibGVzOiBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNcbiAgfSk7XG4gIGlmICghZHJvcHBhYmxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNoYW5nZSA9IGdldERyb3BwYWJsZVNjcm9sbENoYW5nZSh7XG4gICAgZHJhZ1N0YXJ0VGltZSxcbiAgICBkcm9wcGFibGUsXG4gICAgc3ViamVjdCxcbiAgICBjZW50ZXIsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xuICBpZiAoY2hhbmdlKSB7XG4gICAgc2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZS5kZXNjcmlwdG9yLmlkLCBjaGFuZ2UpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlRmx1aWRTY3JvbGxlciA9ICh7XG4gIHNjcm9sbFdpbmRvdyxcbiAgc2Nyb2xsRHJvcHBhYmxlLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zID0gKCkgPT4gZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3Qgc2NoZWR1bGVXaW5kb3dTY3JvbGwgPSByYWZTY2hkKHNjcm9sbFdpbmRvdyk7XG4gIGNvbnN0IHNjaGVkdWxlRHJvcHBhYmxlU2Nyb2xsID0gcmFmU2NoZChzY3JvbGxEcm9wcGFibGUpO1xuICBsZXQgZHJhZ2dpbmcgPSBudWxsO1xuICBjb25zdCB0cnlTY3JvbGwgPSBzdGF0ZSA9PiB7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZsdWlkIHNjcm9sbCBpZiBub3QgZHJhZ2dpbmcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHtcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgICBkcmFnU3RhcnRUaW1lXG4gICAgfSA9IGRyYWdnaW5nO1xuICAgIHNjcm9sbCh7XG4gICAgICBzdGF0ZSxcbiAgICAgIHNjcm9sbFdpbmRvdzogc2NoZWR1bGVXaW5kb3dTY3JvbGwsXG4gICAgICBzY3JvbGxEcm9wcGFibGU6IHNjaGVkdWxlRHJvcHBhYmxlU2Nyb2xsLFxuICAgICAgZHJhZ1N0YXJ0VGltZSxcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHN0YXJ0JDEgPSBzdGF0ZSA9PiB7XG4gICAgc3RhcnQoKTtcbiAgICAhIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0YXJ0IGF1dG8gc2Nyb2xsaW5nIHdoZW4gYWxyZWFkeSBzdGFydGVkJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBkcmFnU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgd2FzU2Nyb2xsTmVlZGVkID0gZmFsc2U7XG4gICAgY29uc3QgZmFrZVNjcm9sbENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgd2FzU2Nyb2xsTmVlZGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIHNjcm9sbCh7XG4gICAgICBzdGF0ZSxcbiAgICAgIGRyYWdTdGFydFRpbWU6IDAsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiBmYWxzZSxcbiAgICAgIHNjcm9sbFdpbmRvdzogZmFrZVNjcm9sbENhbGxiYWNrLFxuICAgICAgc2Nyb2xsRHJvcHBhYmxlOiBmYWtlU2Nyb2xsQ2FsbGJhY2ssXG4gICAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gICAgfSk7XG4gICAgZHJhZ2dpbmcgPSB7XG4gICAgICBkcmFnU3RhcnRUaW1lLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZzogd2FzU2Nyb2xsTmVlZGVkXG4gICAgfTtcbiAgICBmaW5pc2goKTtcbiAgICBpZiAod2FzU2Nyb2xsTmVlZGVkKSB7XG4gICAgICB0cnlTY3JvbGwoc3RhdGUpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVkdWxlV2luZG93U2Nyb2xsLmNhbmNlbCgpO1xuICAgIHNjaGVkdWxlRHJvcHBhYmxlU2Nyb2xsLmNhbmNlbCgpO1xuICAgIGRyYWdnaW5nID0gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQkMSxcbiAgICBzdG9wLFxuICAgIHNjcm9sbDogdHJ5U2Nyb2xsXG4gIH07XG59O1xuXG52YXIgY3JlYXRlSnVtcFNjcm9sbGVyID0gKHtcbiAgbW92ZSxcbiAgc2Nyb2xsRHJvcHBhYmxlLFxuICBzY3JvbGxXaW5kb3dcbn0pID0+IHtcbiAgY29uc3QgbW92ZUJ5T2Zmc2V0ID0gKHN0YXRlLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBjbGllbnQgPSBhZGQoc3RhdGUuY3VycmVudC5jbGllbnQuc2VsZWN0aW9uLCBvZmZzZXQpO1xuICAgIG1vdmUoe1xuICAgICAgY2xpZW50XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHNjcm9sbERyb3BwYWJsZUFzTXVjaEFzSXRDYW4gPSAoZHJvcHBhYmxlLCBjaGFuZ2UpID0+IHtcbiAgICBpZiAoIWNhblNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUsIGNoYW5nZSkpIHtcbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIGNvbnN0IG92ZXJsYXAgPSBnZXREcm9wcGFibGVPdmVybGFwKGRyb3BwYWJsZSwgY2hhbmdlKTtcbiAgICBpZiAoIW92ZXJsYXApIHtcbiAgICAgIHNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUuZGVzY3JpcHRvci5pZCwgY2hhbmdlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB3aGF0VGhlRHJvcHBhYmxlQ2FuU2Nyb2xsID0gc3VidHJhY3QoY2hhbmdlLCBvdmVybGFwKTtcbiAgICBzY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLmRlc2NyaXB0b3IuaWQsIHdoYXRUaGVEcm9wcGFibGVDYW5TY3JvbGwpO1xuICAgIGNvbnN0IHJlbWFpbmRlciA9IHN1YnRyYWN0KGNoYW5nZSwgd2hhdFRoZURyb3BwYWJsZUNhblNjcm9sbCk7XG4gICAgcmV0dXJuIHJlbWFpbmRlcjtcbiAgfTtcbiAgY29uc3Qgc2Nyb2xsV2luZG93QXNNdWNoQXNJdENhbiA9IChpc1dpbmRvd1Njcm9sbEFsbG93ZWQsIHZpZXdwb3J0LCBjaGFuZ2UpID0+IHtcbiAgICBpZiAoIWlzV2luZG93U2Nyb2xsQWxsb3dlZCkge1xuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgaWYgKCFjYW5TY3JvbGxXaW5kb3codmlld3BvcnQsIGNoYW5nZSkpIHtcbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIGNvbnN0IG92ZXJsYXAgPSBnZXRXaW5kb3dPdmVybGFwKHZpZXdwb3J0LCBjaGFuZ2UpO1xuICAgIGlmICghb3ZlcmxhcCkge1xuICAgICAgc2Nyb2xsV2luZG93KGNoYW5nZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgd2hhdFRoZVdpbmRvd0NhblNjcm9sbCA9IHN1YnRyYWN0KGNoYW5nZSwgb3ZlcmxhcCk7XG4gICAgc2Nyb2xsV2luZG93KHdoYXRUaGVXaW5kb3dDYW5TY3JvbGwpO1xuICAgIGNvbnN0IHJlbWFpbmRlciA9IHN1YnRyYWN0KGNoYW5nZSwgd2hhdFRoZVdpbmRvd0NhblNjcm9sbCk7XG4gICAgcmV0dXJuIHJlbWFpbmRlcjtcbiAgfTtcbiAgY29uc3QganVtcFNjcm9sbGVyID0gc3RhdGUgPT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBzdGF0ZS5zY3JvbGxKdW1wUmVxdWVzdDtcbiAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpO1xuICAgICFkZXN0aW5hdGlvbiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwZXJmb3JtIGEganVtcCBzY3JvbGwgd2hlbiB0aGVyZSBpcyBubyBkZXN0aW5hdGlvbicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgZHJvcHBhYmxlUmVtYWluZGVyID0gc2Nyb2xsRHJvcHBhYmxlQXNNdWNoQXNJdENhbihzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbZGVzdGluYXRpb25dLCByZXF1ZXN0KTtcbiAgICBpZiAoIWRyb3BwYWJsZVJlbWFpbmRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2aWV3cG9ydCA9IHN0YXRlLnZpZXdwb3J0O1xuICAgIGNvbnN0IHdpbmRvd1JlbWFpbmRlciA9IHNjcm9sbFdpbmRvd0FzTXVjaEFzSXRDYW4oc3RhdGUuaXNXaW5kb3dTY3JvbGxBbGxvd2VkLCB2aWV3cG9ydCwgZHJvcHBhYmxlUmVtYWluZGVyKTtcbiAgICBpZiAoIXdpbmRvd1JlbWFpbmRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtb3ZlQnlPZmZzZXQoc3RhdGUsIHdpbmRvd1JlbWFpbmRlcik7XG4gIH07XG4gIHJldHVybiBqdW1wU2Nyb2xsZXI7XG59O1xuXG52YXIgY3JlYXRlQXV0b1Njcm9sbGVyID0gKHtcbiAgc2Nyb2xsRHJvcHBhYmxlLFxuICBzY3JvbGxXaW5kb3csXG4gIG1vdmUsXG4gIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3QgZmx1aWRTY3JvbGxlciA9IGNyZWF0ZUZsdWlkU2Nyb2xsZXIoe1xuICAgIHNjcm9sbFdpbmRvdyxcbiAgICBzY3JvbGxEcm9wcGFibGUsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9KTtcbiAgY29uc3QganVtcFNjcm9sbCA9IGNyZWF0ZUp1bXBTY3JvbGxlcih7XG4gICAgbW92ZSxcbiAgICBzY3JvbGxXaW5kb3csXG4gICAgc2Nyb2xsRHJvcHBhYmxlXG4gIH0pO1xuICBjb25zdCBzY3JvbGwgPSBzdGF0ZSA9PiB7XG4gICAgY29uc3QgYXV0b1Njcm9sbGVyT3B0aW9ucyA9IGdldEF1dG9TY3JvbGxlck9wdGlvbnMoKTtcbiAgICBpZiAoYXV0b1Njcm9sbGVyT3B0aW9ucy5kaXNhYmxlZCB8fCBzdGF0ZS5waGFzZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3RhdGUubW92ZW1lbnRNb2RlID09PSAnRkxVSUQnKSB7XG4gICAgICBmbHVpZFNjcm9sbGVyLnNjcm9sbChzdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghc3RhdGUuc2Nyb2xsSnVtcFJlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAganVtcFNjcm9sbChzdGF0ZSk7XG4gIH07XG4gIGNvbnN0IHNjcm9sbGVyID0ge1xuICAgIHNjcm9sbCxcbiAgICBzdGFydDogZmx1aWRTY3JvbGxlci5zdGFydCxcbiAgICBzdG9wOiBmbHVpZFNjcm9sbGVyLnN0b3BcbiAgfTtcbiAgcmV0dXJuIHNjcm9sbGVyO1xufTtcblxuY29uc3QgcHJlZml4ID0gJ2RhdGEtcmZkJztcbmNvbnN0IGRyYWdIYW5kbGUgPSAoKCkgPT4ge1xuICBjb25zdCBiYXNlID0gYCR7cHJlZml4fS1kcmFnLWhhbmRsZWA7XG4gIHJldHVybiB7XG4gICAgYmFzZSxcbiAgICBkcmFnZ2FibGVJZDogYCR7YmFzZX0tZHJhZ2dhYmxlLWlkYCxcbiAgICBjb250ZXh0SWQ6IGAke2Jhc2V9LWNvbnRleHQtaWRgXG4gIH07XG59KSgpO1xuY29uc3QgZHJhZ2dhYmxlID0gKCgpID0+IHtcbiAgY29uc3QgYmFzZSA9IGAke3ByZWZpeH0tZHJhZ2dhYmxlYDtcbiAgcmV0dXJuIHtcbiAgICBiYXNlLFxuICAgIGNvbnRleHRJZDogYCR7YmFzZX0tY29udGV4dC1pZGAsXG4gICAgaWQ6IGAke2Jhc2V9LWlkYFxuICB9O1xufSkoKTtcbmNvbnN0IGRyb3BwYWJsZSA9ICgoKSA9PiB7XG4gIGNvbnN0IGJhc2UgPSBgJHtwcmVmaXh9LWRyb3BwYWJsZWA7XG4gIHJldHVybiB7XG4gICAgYmFzZSxcbiAgICBjb250ZXh0SWQ6IGAke2Jhc2V9LWNvbnRleHQtaWRgLFxuICAgIGlkOiBgJHtiYXNlfS1pZGBcbiAgfTtcbn0pKCk7XG5jb25zdCBzY3JvbGxDb250YWluZXIgPSB7XG4gIGNvbnRleHRJZDogYCR7cHJlZml4fS1zY3JvbGwtY29udGFpbmVyLWNvbnRleHQtaWRgXG59O1xuXG5jb25zdCBtYWtlR2V0U2VsZWN0b3IgPSBjb250ZXh0ID0+IGF0dHJpYnV0ZSA9PiBgWyR7YXR0cmlidXRlfT1cIiR7Y29udGV4dH1cIl1gO1xuY29uc3QgZ2V0U3R5bGVzID0gKHJ1bGVzLCBwcm9wZXJ0eSkgPT4gcnVsZXMubWFwKHJ1bGUgPT4ge1xuICBjb25zdCB2YWx1ZSA9IHJ1bGUuc3R5bGVzW3Byb3BlcnR5XTtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gYCR7cnVsZS5zZWxlY3Rvcn0geyAke3ZhbHVlfSB9YDtcbn0pLmpvaW4oJyAnKTtcbmNvbnN0IG5vUG9pbnRlckV2ZW50cyA9ICdwb2ludGVyLWV2ZW50czogbm9uZTsnO1xudmFyIGdldFN0eWxlcyQxID0gY29udGV4dElkID0+IHtcbiAgY29uc3QgZ2V0U2VsZWN0b3IgPSBtYWtlR2V0U2VsZWN0b3IoY29udGV4dElkKTtcbiAgY29uc3QgZHJhZ0hhbmRsZSQxID0gKCgpID0+IHtcbiAgICBjb25zdCBncmFiQ3Vyc29yID0gYFxuICAgICAgY3Vyc29yOiAtd2Via2l0LWdyYWI7XG4gICAgICBjdXJzb3I6IGdyYWI7XG4gICAgYDtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0b3I6IGdldFNlbGVjdG9yKGRyYWdIYW5kbGUuY29udGV4dElkKSxcbiAgICAgIHN0eWxlczoge1xuICAgICAgICBhbHdheXM6IGBcbiAgICAgICAgICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XG4gICAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsMCwwLDApO1xuICAgICAgICAgIHRvdWNoLWFjdGlvbjogbWFuaXB1bGF0aW9uO1xuICAgICAgICBgLFxuICAgICAgICByZXN0aW5nOiBncmFiQ3Vyc29yLFxuICAgICAgICBkcmFnZ2luZzogbm9Qb2ludGVyRXZlbnRzLFxuICAgICAgICBkcm9wQW5pbWF0aW5nOiBncmFiQ3Vyc29yXG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbiAgY29uc3QgZHJhZ2dhYmxlJDEgPSAoKCkgPT4ge1xuICAgIGNvbnN0IHRyYW5zaXRpb24gPSBgXG4gICAgICB0cmFuc2l0aW9uOiAke3RyYW5zaXRpb25zLm91dE9mVGhlV2F5fTtcbiAgICBgO1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RvcjogZ2V0U2VsZWN0b3IoZHJhZ2dhYmxlLmNvbnRleHRJZCksXG4gICAgICBzdHlsZXM6IHtcbiAgICAgICAgZHJhZ2dpbmc6IHRyYW5zaXRpb24sXG4gICAgICAgIGRyb3BBbmltYXRpbmc6IHRyYW5zaXRpb24sXG4gICAgICAgIHVzZXJDYW5jZWw6IHRyYW5zaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuICBjb25zdCBkcm9wcGFibGUkMSA9IHtcbiAgICBzZWxlY3RvcjogZ2V0U2VsZWN0b3IoZHJvcHBhYmxlLmNvbnRleHRJZCksXG4gICAgc3R5bGVzOiB7XG4gICAgICBhbHdheXM6IGBvdmVyZmxvdy1hbmNob3I6IG5vbmU7YFxuICAgIH1cbiAgfTtcbiAgY29uc3QgYm9keSA9IHtcbiAgICBzZWxlY3RvcjogJ2JvZHknLFxuICAgIHN0eWxlczoge1xuICAgICAgZHJhZ2dpbmc6IGBcbiAgICAgICAgY3Vyc29yOiBncmFiYmluZztcbiAgICAgICAgY3Vyc29yOiAtd2Via2l0LWdyYWJiaW5nO1xuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICBvdmVyZmxvdy1hbmNob3I6IG5vbmU7XG4gICAgICBgXG4gICAgfVxuICB9O1xuICBjb25zdCBydWxlcyA9IFtkcmFnZ2FibGUkMSwgZHJhZ0hhbmRsZSQxLCBkcm9wcGFibGUkMSwgYm9keV07XG4gIHJldHVybiB7XG4gICAgYWx3YXlzOiBnZXRTdHlsZXMocnVsZXMsICdhbHdheXMnKSxcbiAgICByZXN0aW5nOiBnZXRTdHlsZXMocnVsZXMsICdyZXN0aW5nJyksXG4gICAgZHJhZ2dpbmc6IGdldFN0eWxlcyhydWxlcywgJ2RyYWdnaW5nJyksXG4gICAgZHJvcEFuaW1hdGluZzogZ2V0U3R5bGVzKHJ1bGVzLCAnZHJvcEFuaW1hdGluZycpLFxuICAgIHVzZXJDYW5jZWw6IGdldFN0eWxlcyhydWxlcywgJ3VzZXJDYW5jZWwnKVxuICB9O1xufTtcblxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbmNvbnN0IGdldEhlYWQgPSAoKSA9PiB7XG4gIGNvbnN0IGhlYWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkJyk7XG4gICFoZWFkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpbmQgdGhlIGhlYWQgdG8gYXBwZW5kIGEgc3R5bGUgdG8nKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICByZXR1cm4gaGVhZDtcbn07XG5jb25zdCBjcmVhdGVTdHlsZUVsID0gbm9uY2UgPT4ge1xuICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIGlmIChub25jZSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XG4gIH1cbiAgZWwudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gIHJldHVybiBlbDtcbn07XG5mdW5jdGlvbiB1c2VTdHlsZU1hcnNoYWwoY29udGV4dElkLCBub25jZSkge1xuICBjb25zdCBzdHlsZXMgPSB1c2VNZW1vKCgpID0+IGdldFN0eWxlcyQxKGNvbnRleHRJZCksIFtjb250ZXh0SWRdKTtcbiAgY29uc3QgYWx3YXlzUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBkeW5hbWljUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBzZXREeW5hbWljU3R5bGUgPSB1c2VDYWxsYmFjayhtZW1vaXplT25lKHByb3Bvc2VkID0+IHtcbiAgICBjb25zdCBlbCA9IGR5bmFtaWNSZWYuY3VycmVudDtcbiAgICAhZWwgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc2V0IGR5bmFtaWMgc3R5bGUgZWxlbWVudCBpZiBpdCBpcyBub3Qgc2V0JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBlbC50ZXh0Q29udGVudCA9IHByb3Bvc2VkO1xuICB9KSwgW10pO1xuICBjb25zdCBzZXRBbHdheXNTdHlsZSA9IHVzZUNhbGxiYWNrKHByb3Bvc2VkID0+IHtcbiAgICBjb25zdCBlbCA9IGFsd2F5c1JlZi5jdXJyZW50O1xuICAgICFlbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzZXQgZHluYW1pYyBzdHlsZSBlbGVtZW50IGlmIGl0IGlzIG5vdCBzZXQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGVsLnRleHRDb250ZW50ID0gcHJvcG9zZWQ7XG4gIH0sIFtdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgISghYWx3YXlzUmVmLmN1cnJlbnQgJiYgIWR5bmFtaWNSZWYuY3VycmVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdzdHlsZSBlbGVtZW50cyBhbHJlYWR5IG1vdW50ZWQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IGFsd2F5cyA9IGNyZWF0ZVN0eWxlRWwobm9uY2UpO1xuICAgIGNvbnN0IGR5bmFtaWMgPSBjcmVhdGVTdHlsZUVsKG5vbmNlKTtcbiAgICBhbHdheXNSZWYuY3VycmVudCA9IGFsd2F5cztcbiAgICBkeW5hbWljUmVmLmN1cnJlbnQgPSBkeW5hbWljO1xuICAgIGFsd2F5cy5zZXRBdHRyaWJ1dGUoYCR7cHJlZml4fS1hbHdheXNgLCBjb250ZXh0SWQpO1xuICAgIGR5bmFtaWMuc2V0QXR0cmlidXRlKGAke3ByZWZpeH0tZHluYW1pY2AsIGNvbnRleHRJZCk7XG4gICAgZ2V0SGVhZCgpLmFwcGVuZENoaWxkKGFsd2F5cyk7XG4gICAgZ2V0SGVhZCgpLmFwcGVuZENoaWxkKGR5bmFtaWMpO1xuICAgIHNldEFsd2F5c1N0eWxlKHN0eWxlcy5hbHdheXMpO1xuICAgIHNldER5bmFtaWNTdHlsZShzdHlsZXMucmVzdGluZyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IHJlbW92ZSA9IHJlZiA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSByZWYuY3VycmVudDtcbiAgICAgICAgIWN1cnJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgdW5tb3VudCByZWYgYXMgaXQgaXMgbm90IHNldCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgICAgIGdldEhlYWQoKS5yZW1vdmVDaGlsZChjdXJyZW50KTtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIHJlbW92ZShhbHdheXNSZWYpO1xuICAgICAgcmVtb3ZlKGR5bmFtaWNSZWYpO1xuICAgIH07XG4gIH0sIFtub25jZSwgc2V0QWx3YXlzU3R5bGUsIHNldER5bmFtaWNTdHlsZSwgc3R5bGVzLmFsd2F5cywgc3R5bGVzLnJlc3RpbmcsIGNvbnRleHRJZF0pO1xuICBjb25zdCBkcmFnZ2luZyA9IHVzZUNhbGxiYWNrKCgpID0+IHNldER5bmFtaWNTdHlsZShzdHlsZXMuZHJhZ2dpbmcpLCBbc2V0RHluYW1pY1N0eWxlLCBzdHlsZXMuZHJhZ2dpbmddKTtcbiAgY29uc3QgZHJvcHBpbmcgPSB1c2VDYWxsYmFjayhyZWFzb24gPT4ge1xuICAgIGlmIChyZWFzb24gPT09ICdEUk9QJykge1xuICAgICAgc2V0RHluYW1pY1N0eWxlKHN0eWxlcy5kcm9wQW5pbWF0aW5nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0RHluYW1pY1N0eWxlKHN0eWxlcy51c2VyQ2FuY2VsKTtcbiAgfSwgW3NldER5bmFtaWNTdHlsZSwgc3R5bGVzLmRyb3BBbmltYXRpbmcsIHN0eWxlcy51c2VyQ2FuY2VsXSk7XG4gIGNvbnN0IHJlc3RpbmcgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFkeW5hbWljUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0RHluYW1pY1N0eWxlKHN0eWxlcy5yZXN0aW5nKTtcbiAgfSwgW3NldER5bmFtaWNTdHlsZSwgc3R5bGVzLnJlc3RpbmddKTtcbiAgY29uc3QgbWFyc2hhbCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBkcmFnZ2luZyxcbiAgICBkcm9wcGluZyxcbiAgICByZXN0aW5nXG4gIH0pLCBbZHJhZ2dpbmcsIGRyb3BwaW5nLCByZXN0aW5nXSk7XG4gIHJldHVybiBtYXJzaGFsO1xufVxuXG5mdW5jdGlvbiBxdWVyeVNlbGVjdG9yQWxsKHBhcmVudE5vZGUsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xufVxuXG52YXIgZ2V0V2luZG93RnJvbUVsID0gZWwgPT4ge1xuICBpZiAoZWwgJiYgZWwub3duZXJEb2N1bWVudCAmJiBlbC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSB7XG4gICAgcmV0dXJuIGVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdztcbn07XG5cbmZ1bmN0aW9uIGlzSHRtbEVsZW1lbnQoZWwpIHtcbiAgcmV0dXJuIGVsIGluc3RhbmNlb2YgZ2V0V2luZG93RnJvbUVsKGVsKS5IVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZmluZERyYWdIYW5kbGUoY29udGV4dElkLCBkcmFnZ2FibGVJZCkge1xuICBjb25zdCBzZWxlY3RvciA9IGBbJHtkcmFnSGFuZGxlLmNvbnRleHRJZH09XCIke2NvbnRleHRJZH1cIl1gO1xuICBjb25zdCBwb3NzaWJsZSA9IHF1ZXJ5U2VsZWN0b3JBbGwoZG9jdW1lbnQsIHNlbGVjdG9yKTtcbiAgaWYgKCFwb3NzaWJsZS5sZW5ndGgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBVbmFibGUgdG8gZmluZCBhbnkgZHJhZyBoYW5kbGVzIGluIHRoZSBjb250ZXh0IFwiJHtjb250ZXh0SWR9XCJgKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBoYW5kbGUgPSBwb3NzaWJsZS5maW5kKGVsID0+IHtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKGRyYWdIYW5kbGUuZHJhZ2dhYmxlSWQpID09PSBkcmFnZ2FibGVJZDtcbiAgfSk7XG4gIGlmICghaGFuZGxlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgVW5hYmxlIHRvIGZpbmQgZHJhZyBoYW5kbGUgd2l0aCBpZCBcIiR7ZHJhZ2dhYmxlSWR9XCIgYXMgbm8gaGFuZGxlIHdpdGggYSBtYXRjaGluZyBpZCB3YXMgZm91bmRgKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIWlzSHRtbEVsZW1lbnQoaGFuZGxlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ2RyYWcgaGFuZGxlIG5lZWRzIHRvIGJlIGEgSFRNTEVsZW1lbnQnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaGFuZGxlO1xufVxuXG5mdW5jdGlvbiB1c2VGb2N1c01hcnNoYWwoY29udGV4dElkKSB7XG4gIGNvbnN0IGVudHJpZXNSZWYgPSB1c2VSZWYoe30pO1xuICBjb25zdCByZWNvcmRSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHJlc3RvcmVGb2N1c0ZyYW1lUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBpc01vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCByZWdpc3RlciA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHJlZ2lzdGVyKGlkLCBmb2N1cykge1xuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgaWQsXG4gICAgICBmb2N1c1xuICAgIH07XG4gICAgZW50cmllc1JlZi5jdXJyZW50W2lkXSA9IGVudHJ5O1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnJlZ2lzdGVyKCkge1xuICAgICAgY29uc3QgZW50cmllcyA9IGVudHJpZXNSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBlbnRyaWVzW2lkXTtcbiAgICAgIGlmIChjdXJyZW50ICE9PSBlbnRyeSkge1xuICAgICAgICBkZWxldGUgZW50cmllc1tpZF07XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCB0cnlHaXZlRm9jdXMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB0cnlHaXZlRm9jdXModHJ5R2l2ZUZvY3VzVG8pIHtcbiAgICBjb25zdCBoYW5kbGUgPSBmaW5kRHJhZ0hhbmRsZShjb250ZXh0SWQsIHRyeUdpdmVGb2N1c1RvKTtcbiAgICBpZiAoaGFuZGxlICYmIGhhbmRsZSAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgaGFuZGxlLmZvY3VzKCk7XG4gICAgfVxuICB9LCBbY29udGV4dElkXSk7XG4gIGNvbnN0IHRyeVNoaWZ0UmVjb3JkID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5U2hpZnRSZWNvcmQocHJldmlvdXMsIHJlZGlyZWN0VG8pIHtcbiAgICBpZiAocmVjb3JkUmVmLmN1cnJlbnQgPT09IHByZXZpb3VzKSB7XG4gICAgICByZWNvcmRSZWYuY3VycmVudCA9IHJlZGlyZWN0VG87XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHRyeVJlc3RvcmVGb2N1c1JlY29yZGVkID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQoKSB7XG4gICAgaWYgKHJlc3RvcmVGb2N1c0ZyYW1lUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFpc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXN0b3JlRm9jdXNGcmFtZVJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHJlc3RvcmVGb2N1c0ZyYW1lUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgY29uc3QgcmVjb3JkID0gcmVjb3JkUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgIHRyeUdpdmVGb2N1cyhyZWNvcmQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbdHJ5R2l2ZUZvY3VzXSk7XG4gIGNvbnN0IHRyeVJlY29yZEZvY3VzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5UmVjb3JkRm9jdXMoaWQpIHtcbiAgICByZWNvcmRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgY29uc3QgZm9jdXNlZCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKCFmb2N1c2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmb2N1c2VkLmdldEF0dHJpYnV0ZShkcmFnSGFuZGxlLmRyYWdnYWJsZUlkKSAhPT0gaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVjb3JkUmVmLmN1cnJlbnQgPSBpZDtcbiAgfSwgW10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFyRnJhbWVPblVubW91bnQoKSB7XG4gICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgY29uc3QgZnJhbWVJZCA9IHJlc3RvcmVGb2N1c0ZyYW1lUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoZnJhbWVJZCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IG1hcnNoYWwgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgcmVnaXN0ZXIsXG4gICAgdHJ5UmVjb3JkRm9jdXMsXG4gICAgdHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQsXG4gICAgdHJ5U2hpZnRSZWNvcmRcbiAgfSksIFtyZWdpc3RlciwgdHJ5UmVjb3JkRm9jdXMsIHRyeVJlc3RvcmVGb2N1c1JlY29yZGVkLCB0cnlTaGlmdFJlY29yZF0pO1xuICByZXR1cm4gbWFyc2hhbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVnaXN0cnkoKSB7XG4gIGNvbnN0IGVudHJpZXMgPSB7XG4gICAgZHJhZ2dhYmxlczoge30sXG4gICAgZHJvcHBhYmxlczoge31cbiAgfTtcbiAgY29uc3Qgc3Vic2NyaWJlcnMgPSBbXTtcbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGNiKSB7XG4gICAgc3Vic2NyaWJlcnMucHVzaChjYik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgY29uc3QgaW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKGNiKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3Vic2NyaWJlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeShldmVudCkge1xuICAgIGlmIChzdWJzY3JpYmVycy5sZW5ndGgpIHtcbiAgICAgIHN1YnNjcmliZXJzLmZvckVhY2goY2IgPT4gY2IoZXZlbnQpKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZmluZERyYWdnYWJsZUJ5SWQoaWQpIHtcbiAgICByZXR1cm4gZW50cmllcy5kcmFnZ2FibGVzW2lkXSB8fCBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGdldERyYWdnYWJsZUJ5SWQoaWQpIHtcbiAgICBjb25zdCBlbnRyeSA9IGZpbmREcmFnZ2FibGVCeUlkKGlkKTtcbiAgICAhZW50cnkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgZmluZCBkcmFnZ2FibGUgZW50cnkgd2l0aCBpZCBbJHtpZH1dYCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZW50cnk7XG4gIH1cbiAgY29uc3QgZHJhZ2dhYmxlQVBJID0ge1xuICAgIHJlZ2lzdGVyOiBlbnRyeSA9PiB7XG4gICAgICBlbnRyaWVzLmRyYWdnYWJsZXNbZW50cnkuZGVzY3JpcHRvci5pZF0gPSBlbnRyeTtcbiAgICAgIG5vdGlmeSh7XG4gICAgICAgIHR5cGU6ICdBRERJVElPTicsXG4gICAgICAgIHZhbHVlOiBlbnRyeVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB1cGRhdGU6IChlbnRyeSwgbGFzdCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IGVudHJpZXMuZHJhZ2dhYmxlc1tsYXN0LmRlc2NyaXB0b3IuaWRdO1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50LnVuaXF1ZUlkICE9PSBlbnRyeS51bmlxdWVJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWxldGUgZW50cmllcy5kcmFnZ2FibGVzW2xhc3QuZGVzY3JpcHRvci5pZF07XG4gICAgICBlbnRyaWVzLmRyYWdnYWJsZXNbZW50cnkuZGVzY3JpcHRvci5pZF0gPSBlbnRyeTtcbiAgICB9LFxuICAgIHVucmVnaXN0ZXI6IGVudHJ5ID0+IHtcbiAgICAgIGNvbnN0IGRyYWdnYWJsZUlkID0gZW50cnkuZGVzY3JpcHRvci5pZDtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBmaW5kRHJhZ2dhYmxlQnlJZChkcmFnZ2FibGVJZCk7XG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVudHJ5LnVuaXF1ZUlkICE9PSBjdXJyZW50LnVuaXF1ZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBlbnRyaWVzLmRyYWdnYWJsZXNbZHJhZ2dhYmxlSWRdO1xuICAgICAgaWYgKGVudHJpZXMuZHJvcHBhYmxlc1tlbnRyeS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkXSkge1xuICAgICAgICBub3RpZnkoe1xuICAgICAgICAgIHR5cGU6ICdSRU1PVkFMJyxcbiAgICAgICAgICB2YWx1ZTogZW50cnlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRCeUlkOiBnZXREcmFnZ2FibGVCeUlkLFxuICAgIGZpbmRCeUlkOiBmaW5kRHJhZ2dhYmxlQnlJZCxcbiAgICBleGlzdHM6IGlkID0+IEJvb2xlYW4oZmluZERyYWdnYWJsZUJ5SWQoaWQpKSxcbiAgICBnZXRBbGxCeVR5cGU6IHR5cGUgPT4gT2JqZWN0LnZhbHVlcyhlbnRyaWVzLmRyYWdnYWJsZXMpLmZpbHRlcihlbnRyeSA9PiBlbnRyeS5kZXNjcmlwdG9yLnR5cGUgPT09IHR5cGUpXG4gIH07XG4gIGZ1bmN0aW9uIGZpbmREcm9wcGFibGVCeUlkKGlkKSB7XG4gICAgcmV0dXJuIGVudHJpZXMuZHJvcHBhYmxlc1tpZF0gfHwgbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBnZXREcm9wcGFibGVCeUlkKGlkKSB7XG4gICAgY29uc3QgZW50cnkgPSBmaW5kRHJvcHBhYmxlQnlJZChpZCk7XG4gICAgIWVudHJ5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IGZpbmQgZHJvcHBhYmxlIGVudHJ5IHdpdGggaWQgWyR7aWR9XWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9XG4gIGNvbnN0IGRyb3BwYWJsZUFQSSA9IHtcbiAgICByZWdpc3RlcjogZW50cnkgPT4ge1xuICAgICAgZW50cmllcy5kcm9wcGFibGVzW2VudHJ5LmRlc2NyaXB0b3IuaWRdID0gZW50cnk7XG4gICAgfSxcbiAgICB1bnJlZ2lzdGVyOiBlbnRyeSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gZmluZERyb3BwYWJsZUJ5SWQoZW50cnkuZGVzY3JpcHRvci5pZCk7XG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVudHJ5LnVuaXF1ZUlkICE9PSBjdXJyZW50LnVuaXF1ZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBlbnRyaWVzLmRyb3BwYWJsZXNbZW50cnkuZGVzY3JpcHRvci5pZF07XG4gICAgfSxcbiAgICBnZXRCeUlkOiBnZXREcm9wcGFibGVCeUlkLFxuICAgIGZpbmRCeUlkOiBmaW5kRHJvcHBhYmxlQnlJZCxcbiAgICBleGlzdHM6IGlkID0+IEJvb2xlYW4oZmluZERyb3BwYWJsZUJ5SWQoaWQpKSxcbiAgICBnZXRBbGxCeVR5cGU6IHR5cGUgPT4gT2JqZWN0LnZhbHVlcyhlbnRyaWVzLmRyb3BwYWJsZXMpLmZpbHRlcihlbnRyeSA9PiBlbnRyeS5kZXNjcmlwdG9yLnR5cGUgPT09IHR5cGUpXG4gIH07XG4gIGZ1bmN0aW9uIGNsZWFuKCkge1xuICAgIGVudHJpZXMuZHJhZ2dhYmxlcyA9IHt9O1xuICAgIGVudHJpZXMuZHJvcHBhYmxlcyA9IHt9O1xuICAgIHN1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZUFQSSxcbiAgICBkcm9wcGFibGU6IGRyb3BwYWJsZUFQSSxcbiAgICBzdWJzY3JpYmUsXG4gICAgY2xlYW5cbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlUmVnaXN0cnkoKSB7XG4gIGNvbnN0IHJlZ2lzdHJ5ID0gdXNlTWVtbyhjcmVhdGVSZWdpc3RyeSwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgcmVnaXN0cnkuY2xlYW4oKTtcbiAgICB9O1xuICB9LCBbcmVnaXN0cnldKTtcbiAgcmV0dXJuIHJlZ2lzdHJ5O1xufVxuXG52YXIgU3RvcmVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxudmFyIGdldEJvZHlFbGVtZW50ID0gKCkgPT4ge1xuICBjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgIWJvZHkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmluZCBkb2N1bWVudC5ib2R5JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGJvZHk7XG59O1xuXG5jb25zdCB2aXN1YWxseUhpZGRlbiA9IHtcbiAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gIHdpZHRoOiAnMXB4JyxcbiAgaGVpZ2h0OiAnMXB4JyxcbiAgbWFyZ2luOiAnLTFweCcsXG4gIGJvcmRlcjogJzAnLFxuICBwYWRkaW5nOiAnMCcsXG4gIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgY2xpcDogJ3JlY3QoMCAwIDAgMCknLFxuICAnY2xpcC1wYXRoJzogJ2luc2V0KDEwMCUpJ1xufTtcblxuY29uc3QgZ2V0SWQgPSBjb250ZXh0SWQgPT4gYHJmZC1hbm5vdW5jZW1lbnQtJHtjb250ZXh0SWR9YDtcbmZ1bmN0aW9uIHVzZUFubm91bmNlcihjb250ZXh0SWQpIHtcbiAgY29uc3QgaWQgPSB1c2VNZW1vKCgpID0+IGdldElkKGNvbnRleHRJZCksIFtjb250ZXh0SWRdKTtcbiAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZWYuY3VycmVudCA9IGVsO1xuICAgIGVsLmlkID0gaWQ7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnYXNzZXJ0aXZlJyk7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWF0b21pYycsICd0cnVlJyk7XG4gICAgX2V4dGVuZHMoZWwuc3R5bGUsIHZpc3VhbGx5SGlkZGVuKTtcbiAgICBnZXRCb2R5RWxlbWVudCgpLmFwcGVuZENoaWxkKGVsKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICBjb25zdCBib2R5ID0gZ2V0Qm9keUVsZW1lbnQoKTtcbiAgICAgICAgaWYgKGJvZHkuY29udGFpbnMoZWwpKSB7XG4gICAgICAgICAgYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsID09PSByZWYuY3VycmVudCkge1xuICAgICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgW2lkXSk7XG4gIGNvbnN0IGFubm91bmNlID0gdXNlQ2FsbGJhY2sobWVzc2FnZSA9PiB7XG4gICAgY29uc3QgZWwgPSByZWYuY3VycmVudDtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICBBIHNjcmVlbiByZWFkZXIgbWVzc2FnZSB3YXMgdHJ5aW5nIHRvIGJlIGFubm91bmNlZCBidXQgaXQgd2FzIHVuYWJsZSB0byBkbyBzby5cbiAgICAgIFRoaXMgY2FuIG9jY3VyIGlmIHlvdSB1bm1vdW50IHlvdXIgPERyYWdEcm9wQ29udGV4dCAvPiBpbiB5b3VyIG9uRHJhZ0VuZC5cbiAgICAgIENvbnNpZGVyIGNhbGxpbmcgcHJvdmlkZWQuYW5ub3VuY2UoKSBiZWZvcmUgdGhlIHVubW91bnQgc28gdGhhdCB0aGUgaW5zdHJ1Y3Rpb24gd2lsbFxuICAgICAgbm90IGJlIGxvc3QgZm9yIHVzZXJzIHJlbHlpbmcgb24gYSBzY3JlZW4gcmVhZGVyLlxuXG4gICAgICBNZXNzYWdlIG5vdCBwYXNzZWQgdG8gc2NyZWVuIHJlYWRlcjpcblxuICAgICAgXCIke21lc3NhZ2V9XCJcbiAgICBgKSA6IHZvaWQgMDtcbiAgfSwgW10pO1xuICByZXR1cm4gYW5ub3VuY2U7XG59XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBzZXBhcmF0b3I6ICc6Oidcbn07XG5mdW5jdGlvbiB1c2VVbmlxdWVJZChwcmVmaXgsIG9wdGlvbnMgPSBkZWZhdWx0cykge1xuICBjb25zdCBpZCA9IFJlYWN0LnVzZUlkKCk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IGAke3ByZWZpeH0ke29wdGlvbnMuc2VwYXJhdG9yfSR7aWR9YCwgW29wdGlvbnMuc2VwYXJhdG9yLCBwcmVmaXgsIGlkXSk7XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRJZCh7XG4gIGNvbnRleHRJZCxcbiAgdW5pcXVlSWRcbn0pIHtcbiAgcmV0dXJuIGByZmQtaGlkZGVuLXRleHQtJHtjb250ZXh0SWR9LSR7dW5pcXVlSWR9YDtcbn1cbmZ1bmN0aW9uIHVzZUhpZGRlblRleHRFbGVtZW50KHtcbiAgY29udGV4dElkLFxuICB0ZXh0XG59KSB7XG4gIGNvbnN0IHVuaXF1ZUlkID0gdXNlVW5pcXVlSWQoJ2hpZGRlbi10ZXh0Jywge1xuICAgIHNlcGFyYXRvcjogJy0nXG4gIH0pO1xuICBjb25zdCBpZCA9IHVzZU1lbW8oKCkgPT4gZ2V0RWxlbWVudElkKHtcbiAgICBjb250ZXh0SWQsXG4gICAgdW5pcXVlSWRcbiAgfSksIFt1bmlxdWVJZCwgY29udGV4dElkXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiBtb3VudCgpIHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsLmlkID0gaWQ7XG4gICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgZ2V0Qm9keUVsZW1lbnQoKS5hcHBlbmRDaGlsZChlbCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICBjb25zdCBib2R5ID0gZ2V0Qm9keUVsZW1lbnQoKTtcbiAgICAgIGlmIChib2R5LmNvbnRhaW5zKGVsKSkge1xuICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbaWQsIHRleHRdKTtcbiAgcmV0dXJuIGlkO1xufVxuXG52YXIgQXBwQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbnZhciBwZWVyRGVwZW5kZW5jaWVzID0ge1xuXHRyZWFjdDogXCJeMTguMC4wIHx8IF4xOS4wLjBcIn07XG5cbmNvbnN0IHNlbXZlciA9IC8oXFxkKylcXC4oXFxkKylcXC4oXFxkKykvO1xuY29uc3QgZ2V0VmVyc2lvbiA9IHZhbHVlID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gc2VtdmVyLmV4ZWModmFsdWUpO1xuICAhKHJlc3VsdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYFVuYWJsZSB0byBwYXJzZSBSZWFjdCB2ZXJzaW9uICR7dmFsdWV9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3QgbWFqb3IgPSBOdW1iZXIocmVzdWx0WzFdKTtcbiAgY29uc3QgbWlub3IgPSBOdW1iZXIocmVzdWx0WzJdKTtcbiAgY29uc3QgcGF0Y2ggPSBOdW1iZXIocmVzdWx0WzNdKTtcbiAgcmV0dXJuIHtcbiAgICBtYWpvcixcbiAgICBtaW5vcixcbiAgICBwYXRjaCxcbiAgICByYXc6IHZhbHVlXG4gIH07XG59O1xuY29uc3QgaXNTYXRpc2ZpZWQgPSAoZXhwZWN0ZWQsIGFjdHVhbCkgPT4ge1xuICBpZiAoYWN0dWFsLm1ham9yID4gZXhwZWN0ZWQubWFqb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYWN0dWFsLm1ham9yIDwgZXhwZWN0ZWQubWFqb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFjdHVhbC5taW5vciA+IGV4cGVjdGVkLm1pbm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGFjdHVhbC5taW5vciA8IGV4cGVjdGVkLm1pbm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBhY3R1YWwucGF0Y2ggPj0gZXhwZWN0ZWQucGF0Y2g7XG59O1xudmFyIGNoZWNrUmVhY3RWZXJzaW9uID0gKHBlZXJEZXBWYWx1ZSwgYWN0dWFsVmFsdWUpID0+IHtcbiAgY29uc3QgcGVlckRlcCA9IGdldFZlcnNpb24ocGVlckRlcFZhbHVlKTtcbiAgY29uc3QgYWN0dWFsID0gZ2V0VmVyc2lvbihhY3R1YWxWYWx1ZSk7XG4gIGlmIChpc1NhdGlzZmllZChwZWVyRGVwLCBhY3R1YWwpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgIFJlYWN0IHZlcnNpb246IFske2FjdHVhbC5yYXd9XVxuICAgIGRvZXMgbm90IHNhdGlzZnkgZXhwZWN0ZWQgcGVlciBkZXBlbmRlbmN5IHZlcnNpb246IFske3BlZXJEZXAucmF3fV1cblxuICAgIFRoaXMgY2FuIHJlc3VsdCBpbiBydW4gdGltZSBidWdzLCBhbmQgZXZlbiBmYXRhbCBjcmFzaGVzXG4gIGApIDogdm9pZCAwO1xufTtcblxuY29uc3Qgc3VmZml4ID0gYFxuICBXZSBleHBlY3QgYSBodG1sNSBkb2N0eXBlOiA8IWRvY3R5cGUgaHRtbD5cbiAgVGhpcyBpcyB0byBlbnN1cmUgY29uc2lzdGVudCBicm93c2VyIGxheW91dCBhbmQgbWVhc3VyZW1lbnRcblxuICBNb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vaGVsbG8tcGFuZ2VhL2RuZC9ibG9iL21haW4vZG9jcy9ndWlkZXMvZG9jdHlwZS5tZFxuYDtcbnZhciBjaGVja0RvY3R5cGUgPSBkb2MgPT4ge1xuICBjb25zdCBkb2N0eXBlID0gZG9jLmRvY3R5cGU7XG4gIGlmICghZG9jdHlwZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgTm8gPCFkb2N0eXBlIGh0bWw+IGZvdW5kLlxuXG4gICAgICAke3N1ZmZpeH1cbiAgICBgKSA6IHZvaWQgMDtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGRvY3R5cGUubmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnaHRtbCcpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgIFVuZXhwZWN0ZWQgPCFkb2N0eXBlPiBmb3VuZDogKCR7ZG9jdHlwZS5uYW1lfSlcblxuICAgICAgJHtzdWZmaXh9XG4gICAgYCkgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKGRvY3R5cGUucHVibGljSWQgIT09ICcnKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICBVbmV4cGVjdGVkIDwhZG9jdHlwZT4gcHVibGljSWQgZm91bmQ6ICgke2RvY3R5cGUucHVibGljSWR9KVxuICAgICAgQSBodG1sNSBkb2N0eXBlIGRvZXMgbm90IGhhdmUgYSBwdWJsaWNJZFxuXG4gICAgICAke3N1ZmZpeH1cbiAgICBgKSA6IHZvaWQgMDtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXNlRGV2KHVzZUhvb2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB1c2VIb29rKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlRGV2U2V0dXBXYXJuaW5nKGZuLCBpbnB1dHMpIHtcbiAgdXNlRGV2KCgpID0+IHtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IoYFxuICAgICAgICAgIEEgc2V0dXAgcHJvYmxlbSB3YXMgZW5jb3VudGVyZWQuXG5cbiAgICAgICAgICA+ICR7ZS5tZXNzYWdlfVxuICAgICAgICBgKTtcbiAgICAgIH1cbiAgICB9LCBpbnB1dHMpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlU3RhcnR1cFZhbGlkYXRpb24oKSB7XG4gIHVzZURldlNldHVwV2FybmluZygoKSA9PiB7XG4gICAgY2hlY2tSZWFjdFZlcnNpb24ocGVlckRlcGVuZGVuY2llcy5yZWFjdCwgUmVhY3QudmVyc2lvbik7XG4gICAgY2hlY2tEb2N0eXBlKGRvY3VtZW50KTtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiB1c2VQcmV2aW91cyhjdXJyZW50KSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZihjdXJyZW50KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IGN1cnJlbnQ7XG4gIH0pO1xuICByZXR1cm4gcmVmO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIGxldCBsb2NrID0gbnVsbDtcbiAgZnVuY3Rpb24gaXNDbGFpbWVkKCkge1xuICAgIHJldHVybiBCb29sZWFuKGxvY2spO1xuICB9XG4gIGZ1bmN0aW9uIGlzQWN0aXZlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsb2NrO1xuICB9XG4gIGZ1bmN0aW9uIGNsYWltKGFiYW5kb24pIHtcbiAgICAhIWxvY2sgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY2xhaW0gbG9jayBhcyBpdCBpcyBhbHJlYWR5IGNsYWltZWQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IG5ld0xvY2sgPSB7XG4gICAgICBhYmFuZG9uXG4gICAgfTtcbiAgICBsb2NrID0gbmV3TG9jaztcbiAgICByZXR1cm4gbmV3TG9jaztcbiAgfVxuICBmdW5jdGlvbiByZWxlYXNlKCkge1xuICAgICFsb2NrID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHJlbGVhc2UgbG9jayB3aGVuIHRoZXJlIGlzIG5vIGxvY2snKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGxvY2sgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHRyeUFiYW5kb24oKSB7XG4gICAgaWYgKGxvY2spIHtcbiAgICAgIGxvY2suYWJhbmRvbigpO1xuICAgICAgcmVsZWFzZSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGlzQ2xhaW1lZCxcbiAgICBpc0FjdGl2ZSxcbiAgICBjbGFpbSxcbiAgICByZWxlYXNlLFxuICAgIHRyeUFiYW5kb25cbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNEcmFnZ2luZyhzdGF0ZSkge1xuICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gc3RhdGUuaXNEcmFnZ2luZztcbn1cblxuY29uc3QgdGFiID0gOTtcbmNvbnN0IGVudGVyID0gMTM7XG5jb25zdCBlc2NhcGUgPSAyNztcbmNvbnN0IHNwYWNlID0gMzI7XG5jb25zdCBwYWdlVXAgPSAzMztcbmNvbnN0IHBhZ2VEb3duID0gMzQ7XG5jb25zdCBlbmQgPSAzNTtcbmNvbnN0IGhvbWUgPSAzNjtcbmNvbnN0IGFycm93TGVmdCA9IDM3O1xuY29uc3QgYXJyb3dVcCA9IDM4O1xuY29uc3QgYXJyb3dSaWdodCA9IDM5O1xuY29uc3QgYXJyb3dEb3duID0gNDA7XG5cbmNvbnN0IHByZXZlbnRlZEtleXMgPSB7XG4gIFtlbnRlcl06IHRydWUsXG4gIFt0YWJdOiB0cnVlXG59O1xudmFyIHByZXZlbnRTdGFuZGFyZEtleUV2ZW50cyA9IGV2ZW50ID0+IHtcbiAgaWYgKHByZXZlbnRlZEtleXNbZXZlbnQua2V5Q29kZV0pIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59O1xuXG5jb25zdCBzdXBwb3J0ZWRFdmVudE5hbWUgPSAoKCkgPT4ge1xuICBjb25zdCBiYXNlID0gJ3Zpc2liaWxpdHljaGFuZ2UnO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBbYmFzZSwgYG1zJHtiYXNlfWAsIGB3ZWJraXQke2Jhc2V9YCwgYG1veiR7YmFzZX1gLCBgbyR7YmFzZX1gXTtcbiAgY29uc3Qgc3VwcG9ydGVkID0gY2FuZGlkYXRlcy5maW5kKGV2ZW50TmFtZSA9PiBgb24ke2V2ZW50TmFtZX1gIGluIGRvY3VtZW50KTtcbiAgcmV0dXJuIHN1cHBvcnRlZCB8fCBiYXNlO1xufSkoKTtcblxuY29uc3QgcHJpbWFyeUJ1dHRvbiA9IDA7XG5jb25zdCBzbG9wcHlDbGlja1RocmVzaG9sZCA9IDU7XG5mdW5jdGlvbiBpc1Nsb3BweUNsaWNrVGhyZXNob2xkRXhjZWVkZWQob3JpZ2luYWwsIGN1cnJlbnQpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGN1cnJlbnQueCAtIG9yaWdpbmFsLngpID49IHNsb3BweUNsaWNrVGhyZXNob2xkIHx8IE1hdGguYWJzKGN1cnJlbnQueSAtIG9yaWdpbmFsLnkpID49IHNsb3BweUNsaWNrVGhyZXNob2xkO1xufVxuY29uc3QgaWRsZSQxID0ge1xuICB0eXBlOiAnSURMRSdcbn07XG5mdW5jdGlvbiBnZXRDYXB0dXJlQmluZGluZ3Moe1xuICBjYW5jZWwsXG4gIGNvbXBsZXRlZCxcbiAgZ2V0UGhhc2UsXG4gIHNldFBoYXNlXG59KSB7XG4gIHJldHVybiBbe1xuICAgIGV2ZW50TmFtZTogJ21vdXNlbW92ZScsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYnV0dG9uLFxuICAgICAgICBjbGllbnRYLFxuICAgICAgICBjbGllbnRZXG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICBpZiAoYnV0dG9uICE9PSBwcmltYXJ5QnV0dG9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvaW50ID0ge1xuICAgICAgICB4OiBjbGllbnRYLFxuICAgICAgICB5OiBjbGllbnRZXG4gICAgICB9O1xuICAgICAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICAgaWYgKHBoYXNlLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcGhhc2UuYWN0aW9ucy5tb3ZlKHBvaW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgIShwaGFzZS50eXBlID09PSAnUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGJlIElETEUnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgICAgY29uc3QgcGVuZGluZyA9IHBoYXNlLnBvaW50O1xuICAgICAgaWYgKCFpc1Nsb3BweUNsaWNrVGhyZXNob2xkRXhjZWVkZWQocGVuZGluZywgcG9pbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBhY3Rpb25zID0gcGhhc2UuYWN0aW9ucy5mbHVpZExpZnQocG9pbnQpO1xuICAgICAgc2V0UGhhc2Uoe1xuICAgICAgICB0eXBlOiAnRFJBR0dJTkcnLFxuICAgICAgICBhY3Rpb25zXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdtb3VzZXVwJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICAgaWYgKHBoYXNlLnR5cGUgIT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBwaGFzZS5hY3Rpb25zLmRyb3Aoe1xuICAgICAgICBzaG91bGRCbG9ja05leHRDbGljazogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdtb3VzZWRvd24nLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBpZiAoZ2V0UGhhc2UoKS50eXBlID09PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBjYW5jZWwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdrZXlkb3duJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICAgaWYgKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGVzY2FwZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcHJldmVudFN0YW5kYXJkS2V5RXZlbnRzKGV2ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdyZXNpemUnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3Njcm9sbCcsXG4gICAgb3B0aW9uczoge1xuICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSxcbiAgICBmbjogKCkgPT4ge1xuICAgICAgaWYgKGdldFBoYXNlKCkudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3dlYmtpdG1vdXNlZm9yY2Vkb3duJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICAgIShwaGFzZS50eXBlICE9PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBwaGFzZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgICBpZiAocGhhc2UuYWN0aW9ucy5zaG91bGRSZXNwZWN0Rm9yY2VQcmVzcygpKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogc3VwcG9ydGVkRXZlbnROYW1lLFxuICAgIGZuOiBjYW5jZWxcbiAgfV07XG59XG5mdW5jdGlvbiB1c2VNb3VzZVNlbnNvcihhcGkpIHtcbiAgY29uc3QgcGhhc2VSZWYgPSB1c2VSZWYoaWRsZSQxKTtcbiAgY29uc3QgdW5iaW5kRXZlbnRzUmVmID0gdXNlUmVmKG5vb3AkMik7XG4gIGNvbnN0IHN0YXJ0Q2FwdHVyZUJpbmRpbmcgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgZXZlbnROYW1lOiAnbW91c2Vkb3duJyxcbiAgICBmbjogZnVuY3Rpb24gb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5idXR0b24gIT09IHByaW1hcnlCdXR0b24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZ2dhYmxlSWQgPSBhcGkuZmluZENsb3Nlc3REcmFnZ2FibGVJZChldmVudCk7XG4gICAgICBpZiAoIWRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdGlvbnMgPSBhcGkudHJ5R2V0TG9jayhkcmFnZ2FibGVJZCwgc3RvcCwge1xuICAgICAgICBzb3VyY2VFdmVudDogZXZlbnRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBwb2ludCA9IHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgICAgfTtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICBzdGFydFBlbmRpbmdEcmFnKGFjdGlvbnMsIHBvaW50KTtcbiAgICB9XG4gIH0pLCBbYXBpXSk7XG4gIGNvbnN0IHByZXZlbnRGb3JjZVByZXNzQmluZGluZyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBldmVudE5hbWU6ICd3ZWJraXRtb3VzZWZvcmNld2lsbGJlZ2luJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaWQgPSBhcGkuZmluZENsb3Nlc3REcmFnZ2FibGVJZChldmVudCk7XG4gICAgICBpZiAoIWlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBhcGkuZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUoaWQpO1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghYXBpLmNhbkdldExvY2soaWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9KSwgW2FwaV0pO1xuICBjb25zdCBsaXN0ZW5Gb3JDYXB0dXJlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gbGlzdGVuRm9yQ2FwdHVyZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBbcHJldmVudEZvcmNlUHJlc3NCaW5kaW5nLCBzdGFydENhcHR1cmVCaW5kaW5nXSwgb3B0aW9ucyk7XG4gIH0sIFtwcmV2ZW50Rm9yY2VQcmVzc0JpbmRpbmcsIHN0YXJ0Q2FwdHVyZUJpbmRpbmddKTtcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50ID0gcGhhc2VSZWYuY3VycmVudDtcbiAgICBpZiAoY3VycmVudC50eXBlID09PSAnSURMRScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGhhc2VSZWYuY3VycmVudCA9IGlkbGUkMTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgfSwgW2xpc3RlbkZvckNhcHR1cmVdKTtcbiAgY29uc3QgY2FuY2VsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHBoYXNlID0gcGhhc2VSZWYuY3VycmVudDtcbiAgICBzdG9wKCk7XG4gICAgaWYgKHBoYXNlLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgIHBoYXNlLmFjdGlvbnMuY2FuY2VsKHtcbiAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICBwaGFzZS5hY3Rpb25zLmFib3J0KCk7XG4gICAgfVxuICB9LCBbc3RvcF0pO1xuICBjb25zdCBiaW5kQ2FwdHVyaW5nRXZlbnRzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gYmluZENhcHR1cmluZ0V2ZW50cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBiaW5kaW5ncyA9IGdldENhcHR1cmVCaW5kaW5ncyh7XG4gICAgICBjYW5jZWwsXG4gICAgICBjb21wbGV0ZWQ6IHN0b3AsXG4gICAgICBnZXRQaGFzZTogKCkgPT4gcGhhc2VSZWYuY3VycmVudCxcbiAgICAgIHNldFBoYXNlOiBwaGFzZSA9PiB7XG4gICAgICAgIHBoYXNlUmVmLmN1cnJlbnQgPSBwaGFzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBiaW5kaW5ncywgb3B0aW9ucyk7XG4gIH0sIFtjYW5jZWwsIHN0b3BdKTtcbiAgY29uc3Qgc3RhcnRQZW5kaW5nRHJhZyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHN0YXJ0UGVuZGluZ0RyYWcoYWN0aW9ucywgcG9pbnQpIHtcbiAgICAhKHBoYXNlUmVmLmN1cnJlbnQudHlwZSA9PT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIG1vdmUgZnJvbSBJRExFIHRvIFBFTkRJTkcgZHJhZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgcGhhc2VSZWYuY3VycmVudCA9IHtcbiAgICAgIHR5cGU6ICdQRU5ESU5HJyxcbiAgICAgIHBvaW50LFxuICAgICAgYWN0aW9uc1xuICAgIH07XG4gICAgYmluZENhcHR1cmluZ0V2ZW50cygpO1xuICB9LCBbYmluZENhcHR1cmluZ0V2ZW50c10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgfTtcbiAgfSwgW2xpc3RlbkZvckNhcHR1cmVdKTtcbn1cblxuZnVuY3Rpb24gbm9vcCQxKCkge31cbmNvbnN0IHNjcm9sbEp1bXBLZXlzID0ge1xuICBbcGFnZURvd25dOiB0cnVlLFxuICBbcGFnZVVwXTogdHJ1ZSxcbiAgW2hvbWVdOiB0cnVlLFxuICBbZW5kXTogdHJ1ZVxufTtcbmZ1bmN0aW9uIGdldERyYWdnaW5nQmluZGluZ3MoYWN0aW9ucywgc3RvcCkge1xuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgc3RvcCgpO1xuICAgIGFjdGlvbnMuY2FuY2VsKCk7XG4gIH1cbiAgZnVuY3Rpb24gZHJvcCgpIHtcbiAgICBzdG9wKCk7XG4gICAgYWN0aW9ucy5kcm9wKCk7XG4gIH1cbiAgcmV0dXJuIFt7XG4gICAgZXZlbnROYW1lOiAna2V5ZG93bicsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBlc2NhcGUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBzcGFjZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkcm9wKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBhcnJvd0Rvd24pIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYWN0aW9ucy5tb3ZlRG93bigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gYXJyb3dVcCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBhY3Rpb25zLm1vdmVVcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gYXJyb3dSaWdodCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBhY3Rpb25zLm1vdmVSaWdodCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gYXJyb3dMZWZ0KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGFjdGlvbnMubW92ZUxlZnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNjcm9sbEp1bXBLZXlzW2V2ZW50LmtleUNvZGVdKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHByZXZlbnRTdGFuZGFyZEtleUV2ZW50cyhldmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnbW91c2Vkb3duJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdtb3VzZXVwJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdjbGljaycsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAndG91Y2hzdGFydCcsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAncmVzaXplJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICd3aGVlbCcsXG4gICAgZm46IGNhbmNlbCxcbiAgICBvcHRpb25zOiB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiBzdXBwb3J0ZWRFdmVudE5hbWUsXG4gICAgZm46IGNhbmNlbFxuICB9XTtcbn1cbmZ1bmN0aW9uIHVzZUtleWJvYXJkU2Vuc29yKGFwaSkge1xuICBjb25zdCB1bmJpbmRFdmVudHNSZWYgPSB1c2VSZWYobm9vcCQxKTtcbiAgY29uc3Qgc3RhcnRDYXB0dXJlQmluZGluZyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBldmVudE5hbWU6ICdrZXlkb3duJyxcbiAgICBmbjogZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSAhPT0gc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZ2dhYmxlSWQgPSBhcGkuZmluZENsb3Nlc3REcmFnZ2FibGVJZChldmVudCk7XG4gICAgICBpZiAoIWRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZURyYWcgPSBhcGkudHJ5R2V0TG9jayhkcmFnZ2FibGVJZCwgc3RvcCwge1xuICAgICAgICBzb3VyY2VFdmVudDogZXZlbnRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFwcmVEcmFnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBsZXQgaXNDYXB0dXJpbmcgPSB0cnVlO1xuICAgICAgY29uc3QgYWN0aW9ucyA9IHByZURyYWcuc25hcExpZnQoKTtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAhaXNDYXB0dXJpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RvcCBjYXB0dXJpbmcgYSBrZXlib2FyZCBkcmFnIHdoZW4gbm90IGNhcHR1cmluZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgICAgIGlzQ2FwdHVyaW5nID0gZmFsc2U7XG4gICAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgICAgIH1cbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIGdldERyYWdnaW5nQmluZGluZ3MoYWN0aW9ucywgc3RvcCksIHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIFthcGldKTtcbiAgY29uc3QgbGlzdGVuRm9yQ2FwdHVyZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVN0YXJ0Q2FwdHVyZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBbc3RhcnRDYXB0dXJlQmluZGluZ10sIG9wdGlvbnMpO1xuICB9LCBbc3RhcnRDYXB0dXJlQmluZGluZ10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgfTtcbiAgfSwgW2xpc3RlbkZvckNhcHR1cmVdKTtcbn1cblxuY29uc3QgaWRsZSA9IHtcbiAgdHlwZTogJ0lETEUnXG59O1xuY29uc3QgdGltZUZvckxvbmdQcmVzcyA9IDEyMDtcbmNvbnN0IGZvcmNlUHJlc3NUaHJlc2hvbGQgPSAwLjE1O1xuZnVuY3Rpb24gZ2V0V2luZG93QmluZGluZ3Moe1xuICBjYW5jZWwsXG4gIGdldFBoYXNlXG59KSB7XG4gIHJldHVybiBbe1xuICAgIGV2ZW50TmFtZTogJ29yaWVudGF0aW9uY2hhbmdlJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdyZXNpemUnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ2NvbnRleHRtZW51JyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdrZXlkb3duJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgaWYgKGdldFBoYXNlKCkudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGVzY2FwZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgY2FuY2VsKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiBzdXBwb3J0ZWRFdmVudE5hbWUsXG4gICAgZm46IGNhbmNlbFxuICB9XTtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZUJpbmRpbmdzKHtcbiAgY2FuY2VsLFxuICBjb21wbGV0ZWQsXG4gIGdldFBoYXNlXG59KSB7XG4gIHJldHVybiBbe1xuICAgIGV2ZW50TmFtZTogJ3RvdWNobW92ZScsXG4gICAgb3B0aW9uczoge1xuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9LFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGhhc2UuaGFzTW92ZWQgPSB0cnVlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGllbnRYLFxuICAgICAgICBjbGllbnRZXG4gICAgICB9ID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICAgIGNvbnN0IHBvaW50ID0ge1xuICAgICAgICB4OiBjbGllbnRYLFxuICAgICAgICB5OiBjbGllbnRZXG4gICAgICB9O1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHBoYXNlLmFjdGlvbnMubW92ZShwb2ludCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAndG91Y2hlbmQnLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHBoYXNlLmFjdGlvbnMuZHJvcCh7XG4gICAgICAgIHNob3VsZEJsb2NrTmV4dENsaWNrOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3RvdWNoY2FuY2VsJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgaWYgKGdldFBoYXNlKCkudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNhbmNlbCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3RvdWNoZm9yY2VjaGFuZ2UnLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICAhKHBoYXNlLnR5cGUgIT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgICAgY29uc3QgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgaWYgKCF0b3VjaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpc0ZvcmNlUHJlc3MgPSB0b3VjaC5mb3JjZSA+PSBmb3JjZVByZXNzVGhyZXNob2xkO1xuICAgICAgaWYgKCFpc0ZvcmNlUHJlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hvdWxkUmVzcGVjdCA9IHBoYXNlLmFjdGlvbnMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgICAgaWYgKHNob3VsZFJlc3BlY3QpIHtcbiAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVzcGVjdCkge1xuICAgICAgICBpZiAocGhhc2UuaGFzTW92ZWQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6IHN1cHBvcnRlZEV2ZW50TmFtZSxcbiAgICBmbjogY2FuY2VsXG4gIH1dO1xufVxuZnVuY3Rpb24gdXNlVG91Y2hTZW5zb3IoYXBpKSB7XG4gIGNvbnN0IHBoYXNlUmVmID0gdXNlUmVmKGlkbGUpO1xuICBjb25zdCB1bmJpbmRFdmVudHNSZWYgPSB1c2VSZWYobm9vcCQyKTtcbiAgY29uc3QgZ2V0UGhhc2UgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBnZXRQaGFzZSgpIHtcbiAgICByZXR1cm4gcGhhc2VSZWYuY3VycmVudDtcbiAgfSwgW10pO1xuICBjb25zdCBzZXRQaGFzZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHNldFBoYXNlKHBoYXNlKSB7XG4gICAgcGhhc2VSZWYuY3VycmVudCA9IHBoYXNlO1xuICB9LCBbXSk7XG4gIGNvbnN0IHN0YXJ0Q2FwdHVyZUJpbmRpbmcgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgZXZlbnROYW1lOiAndG91Y2hzdGFydCcsXG4gICAgZm46IGZ1bmN0aW9uIG9uVG91Y2hTdGFydChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZ2dhYmxlSWQgPSBhcGkuZmluZENsb3Nlc3REcmFnZ2FibGVJZChldmVudCk7XG4gICAgICBpZiAoIWRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdGlvbnMgPSBhcGkudHJ5R2V0TG9jayhkcmFnZ2FibGVJZCwgc3RvcCwge1xuICAgICAgICBzb3VyY2VFdmVudDogZXZlbnRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xpZW50WCxcbiAgICAgICAgY2xpZW50WVxuICAgICAgfSA9IHRvdWNoO1xuICAgICAgY29uc3QgcG9pbnQgPSB7XG4gICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgIHk6IGNsaWVudFlcbiAgICAgIH07XG4gICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgICAgc3RhcnRQZW5kaW5nRHJhZyhhY3Rpb25zLCBwb2ludCk7XG4gICAgfVxuICB9KSwgW2FwaV0pO1xuICBjb25zdCBsaXN0ZW5Gb3JDYXB0dXJlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gbGlzdGVuRm9yQ2FwdHVyZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBbc3RhcnRDYXB0dXJlQmluZGluZ10sIG9wdGlvbnMpO1xuICB9LCBbc3RhcnRDYXB0dXJlQmluZGluZ10pO1xuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBwaGFzZVJlZi5jdXJyZW50O1xuICAgIGlmIChjdXJyZW50LnR5cGUgPT09ICdJRExFJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudC50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgIGNsZWFyVGltZW91dChjdXJyZW50LmxvbmdQcmVzc1RpbWVySWQpO1xuICAgIH1cbiAgICBzZXRQaGFzZShpZGxlKTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgfSwgW2xpc3RlbkZvckNhcHR1cmUsIHNldFBoYXNlXSk7XG4gIGNvbnN0IGNhbmNlbCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBwaGFzZSA9IHBoYXNlUmVmLmN1cnJlbnQ7XG4gICAgc3RvcCgpO1xuICAgIGlmIChwaGFzZS50eXBlID09PSAnRFJBR0dJTkcnKSB7XG4gICAgICBwaGFzZS5hY3Rpb25zLmNhbmNlbCh7XG4gICAgICAgIHNob3VsZEJsb2NrTmV4dENsaWNrOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgcGhhc2UuYWN0aW9ucy5hYm9ydCgpO1xuICAgIH1cbiAgfSwgW3N0b3BdKTtcbiAgY29uc3QgYmluZENhcHR1cmluZ0V2ZW50cyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIGJpbmRDYXB0dXJpbmdFdmVudHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIGNhbmNlbCxcbiAgICAgIGNvbXBsZXRlZDogc3RvcCxcbiAgICAgIGdldFBoYXNlXG4gICAgfTtcbiAgICBjb25zdCB1bmJpbmRUYXJnZXQgPSBiaW5kRXZlbnRzKHdpbmRvdywgZ2V0SGFuZGxlQmluZGluZ3MoYXJncyksIG9wdGlvbnMpO1xuICAgIGNvbnN0IHVuYmluZFdpbmRvdyA9IGJpbmRFdmVudHMod2luZG93LCBnZXRXaW5kb3dCaW5kaW5ncyhhcmdzKSwgb3B0aW9ucyk7XG4gICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQgPSBmdW5jdGlvbiB1bmJpbmRBbGwoKSB7XG4gICAgICB1bmJpbmRUYXJnZXQoKTtcbiAgICAgIHVuYmluZFdpbmRvdygpO1xuICAgIH07XG4gIH0sIFtjYW5jZWwsIGdldFBoYXNlLCBzdG9wXSk7XG4gIGNvbnN0IHN0YXJ0RHJhZ2dpbmcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBzdGFydERyYWdnaW5nKCkge1xuICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAhKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3Qgc3RhcnQgZHJhZ2dpbmcgZnJvbSBwaGFzZSAke3BoYXNlLnR5cGV9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBhY3Rpb25zID0gcGhhc2UuYWN0aW9ucy5mbHVpZExpZnQocGhhc2UucG9pbnQpO1xuICAgIHNldFBoYXNlKHtcbiAgICAgIHR5cGU6ICdEUkFHR0lORycsXG4gICAgICBhY3Rpb25zLFxuICAgICAgaGFzTW92ZWQ6IGZhbHNlXG4gICAgfSk7XG4gIH0sIFtnZXRQaGFzZSwgc2V0UGhhc2VdKTtcbiAgY29uc3Qgc3RhcnRQZW5kaW5nRHJhZyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHN0YXJ0UGVuZGluZ0RyYWcoYWN0aW9ucywgcG9pbnQpIHtcbiAgICAhKGdldFBoYXNlKCkudHlwZSA9PT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIG1vdmUgZnJvbSBJRExFIHRvIFBFTkRJTkcgZHJhZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgbG9uZ1ByZXNzVGltZXJJZCA9IHNldFRpbWVvdXQoc3RhcnREcmFnZ2luZywgdGltZUZvckxvbmdQcmVzcyk7XG4gICAgc2V0UGhhc2Uoe1xuICAgICAgdHlwZTogJ1BFTkRJTkcnLFxuICAgICAgcG9pbnQsXG4gICAgICBhY3Rpb25zLFxuICAgICAgbG9uZ1ByZXNzVGltZXJJZFxuICAgIH0pO1xuICAgIGJpbmRDYXB0dXJpbmdFdmVudHMoKTtcbiAgfSwgW2JpbmRDYXB0dXJpbmdFdmVudHMsIGdldFBoYXNlLCBzZXRQaGFzZSwgc3RhcnREcmFnZ2luZ10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChwaGFzZS5sb25nUHJlc3NUaW1lcklkKTtcbiAgICAgICAgc2V0UGhhc2UoaWRsZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2dldFBoYXNlLCBsaXN0ZW5Gb3JDYXB0dXJlLCBzZXRQaGFzZV0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIHdlYmtpdEhhY2soKSB7XG4gICAgY29uc3QgdW5iaW5kID0gYmluZEV2ZW50cyh3aW5kb3csIFt7XG4gICAgICBldmVudE5hbWU6ICd0b3VjaG1vdmUnLFxuICAgICAgZm46ICgpID0+IHt9LFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIHVuYmluZDtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiB1c2VWYWxpZGF0ZVNlbnNvckhvb2tzKHNlbnNvckhvb2tzKSB7XG4gIHVzZURldigoKSA9PiB7XG4gICAgY29uc3QgcHJldmlvdXNSZWYgPSB1c2VQcmV2aW91cyhzZW5zb3JIb29rcyk7XG4gICAgdXNlRGV2U2V0dXBXYXJuaW5nKCgpID0+IHtcbiAgICAgICEocHJldmlvdXNSZWYuY3VycmVudC5sZW5ndGggPT09IHNlbnNvckhvb2tzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY2hhbmdlIHRoZSBhbW91bnQgb2Ygc2Vuc29yIGhvb2tzIGFmdGVyIG1vdW50aW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIH0pO1xuICB9KTtcbn1cblxuY29uc3QgaW50ZXJhY3RpdmVUYWdOYW1lcyA9IFsnaW5wdXQnLCAnYnV0dG9uJywgJ3RleHRhcmVhJywgJ3NlbGVjdCcsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAndmlkZW8nLCAnYXVkaW8nXTtcbmZ1bmN0aW9uIGlzQW5JbnRlcmFjdGl2ZUVsZW1lbnQocGFyZW50LCBjdXJyZW50KSB7XG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaGFzQW5JbnRlcmFjdGl2ZVRhZyA9IGludGVyYWN0aXZlVGFnTmFtZXMuaW5jbHVkZXMoY3VycmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICBpZiAoaGFzQW5JbnRlcmFjdGl2ZVRhZykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGF0dHJpYnV0ZSA9IGN1cnJlbnQuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKTtcbiAgaWYgKGF0dHJpYnV0ZSA9PT0gJ3RydWUnIHx8IGF0dHJpYnV0ZSA9PT0gJycpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoY3VycmVudCA9PT0gcGFyZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0FuSW50ZXJhY3RpdmVFbGVtZW50KHBhcmVudCwgY3VycmVudC5wYXJlbnRFbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGlzRXZlbnRJbkludGVyYWN0aXZlRWxlbWVudChkcmFnZ2FibGUsIGV2ZW50KSB7XG4gIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgaWYgKCFpc0h0bWxFbGVtZW50KHRhcmdldCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzQW5JbnRlcmFjdGl2ZUVsZW1lbnQoZHJhZ2dhYmxlLCB0YXJnZXQpO1xufVxuXG52YXIgZ2V0Qm9yZGVyQm94Q2VudGVyUG9zaXRpb24gPSBlbCA9PiBnZXRSZWN0KGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKS5jZW50ZXI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChlbCkge1xuICByZXR1cm4gZWwgaW5zdGFuY2VvZiBnZXRXaW5kb3dGcm9tRWwoZWwpLkVsZW1lbnQ7XG59XG5cbmNvbnN0IHN1cHBvcnRlZE1hdGNoZXNOYW1lID0gKCgpID0+IHtcbiAgY29uc3QgYmFzZSA9ICdtYXRjaGVzJztcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBjb25zdCBjYW5kaWRhdGVzID0gW2Jhc2UsICdtc01hdGNoZXNTZWxlY3RvcicsICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InXTtcbiAgY29uc3QgdmFsdWUgPSBjYW5kaWRhdGVzLmZpbmQobmFtZSA9PiBuYW1lIGluIEVsZW1lbnQucHJvdG90eXBlKTtcbiAgcmV0dXJuIHZhbHVlIHx8IGJhc2U7XG59KSgpO1xuZnVuY3Rpb24gY2xvc2VzdFBvbnlmaWxsKGVsLCBzZWxlY3Rvcikge1xuICBpZiAoZWwgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChlbFtzdXBwb3J0ZWRNYXRjaGVzTmFtZV0oc2VsZWN0b3IpKSB7XG4gICAgcmV0dXJuIGVsO1xuICB9XG4gIHJldHVybiBjbG9zZXN0UG9ueWZpbGwoZWwucGFyZW50RWxlbWVudCwgc2VsZWN0b3IpO1xufVxuZnVuY3Rpb24gY2xvc2VzdChlbCwgc2VsZWN0b3IpIHtcbiAgaWYgKGVsLmNsb3Nlc3QpIHtcbiAgICByZXR1cm4gZWwuY2xvc2VzdChzZWxlY3Rvcik7XG4gIH1cbiAgcmV0dXJuIGNsb3Nlc3RQb255ZmlsbChlbCwgc2VsZWN0b3IpO1xufVxuXG5mdW5jdGlvbiBnZXRTZWxlY3Rvcihjb250ZXh0SWQpIHtcbiAgcmV0dXJuIGBbJHtkcmFnSGFuZGxlLmNvbnRleHRJZH09XCIke2NvbnRleHRJZH1cIl1gO1xufVxuZnVuY3Rpb24gZmluZENsb3Nlc3REcmFnSGFuZGxlRnJvbUV2ZW50KGNvbnRleHRJZCwgZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICBpZiAoIWlzRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnZXZlbnQudGFyZ2V0IG11c3QgYmUgYSBFbGVtZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3Rvcihjb250ZXh0SWQpO1xuICBjb25zdCBoYW5kbGUgPSBjbG9zZXN0KHRhcmdldCwgc2VsZWN0b3IpO1xuICBpZiAoIWhhbmRsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghaXNIdG1sRWxlbWVudChoYW5kbGUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnZHJhZyBoYW5kbGUgbXVzdCBiZSBhIEhUTUxFbGVtZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZTtcbn1cbmZ1bmN0aW9uIHRyeUdldENsb3Nlc3REcmFnZ2FibGVJZEZyb21FdmVudChjb250ZXh0SWQsIGV2ZW50KSB7XG4gIGNvbnN0IGhhbmRsZSA9IGZpbmRDbG9zZXN0RHJhZ0hhbmRsZUZyb21FdmVudChjb250ZXh0SWQsIGV2ZW50KTtcbiAgaWYgKCFoYW5kbGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaGFuZGxlLmdldEF0dHJpYnV0ZShkcmFnSGFuZGxlLmRyYWdnYWJsZUlkKTtcbn1cblxuZnVuY3Rpb24gZmluZERyYWdnYWJsZShjb250ZXh0SWQsIGRyYWdnYWJsZUlkKSB7XG4gIGNvbnN0IHNlbGVjdG9yID0gYFske2RyYWdnYWJsZS5jb250ZXh0SWR9PVwiJHtjb250ZXh0SWR9XCJdYDtcbiAgY29uc3QgcG9zc2libGUgPSBxdWVyeVNlbGVjdG9yQWxsKGRvY3VtZW50LCBzZWxlY3Rvcik7XG4gIGNvbnN0IGRyYWdnYWJsZSQxID0gcG9zc2libGUuZmluZChlbCA9PiB7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShkcmFnZ2FibGUuaWQpID09PSBkcmFnZ2FibGVJZDtcbiAgfSk7XG4gIGlmICghZHJhZ2dhYmxlJDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIWlzSHRtbEVsZW1lbnQoZHJhZ2dhYmxlJDEpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnRHJhZ2dhYmxlIGVsZW1lbnQgaXMgbm90IGEgSFRNTEVsZW1lbnQnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZHJhZ2dhYmxlJDE7XG59XG5cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5mdW5jdGlvbiBpc0FjdGl2ZSh7XG4gIGV4cGVjdGVkLFxuICBwaGFzZSxcbiAgaXNMb2NrQWN0aXZlLFxuICBzaG91bGRXYXJuXG59KSB7XG4gIGlmICghaXNMb2NrQWN0aXZlKCkpIHtcbiAgICBpZiAoc2hvdWxkV2Fybikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICAgIENhbm5vdCBwZXJmb3JtIGFjdGlvbi5cbiAgICAgICAgVGhlIHNlbnNvciBubyBsb25nZXIgaGFzIGFuIGFjdGlvbiBsb2NrLlxuXG4gICAgICAgIFRpcHM6XG5cbiAgICAgICAgLSBUaHJvdyBhd2F5IHlvdXIgYWN0aW9uIGhhbmRsZXJzIHdoZW4gZm9yY2VTdG9wKCkgaXMgY2FsbGVkXG4gICAgICAgIC0gQ2hlY2sgYWN0aW9ucy5pc0FjdGl2ZSgpIGlmIHlvdSByZWFsbHkgbmVlZCB0b1xuICAgICAgYCkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZXhwZWN0ZWQgIT09IHBoYXNlKSB7XG4gICAgaWYgKHNob3VsZFdhcm4pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgICBDYW5ub3QgcGVyZm9ybSBhY3Rpb24uXG4gICAgICAgIFRoZSBhY3Rpb25zIHlvdSB1c2VkIGJlbG9uZyB0byBhbiBvdXRkYXRlZCBwaGFzZVxuXG4gICAgICAgIEN1cnJlbnQgcGhhc2U6ICR7ZXhwZWN0ZWR9XG4gICAgICAgIFlvdSBjYWxsZWQgYW4gYWN0aW9uIGZyb20gb3V0ZGF0ZWQgcGhhc2U6ICR7cGhhc2V9XG5cbiAgICAgICAgVGlwczpcblxuICAgICAgICAtIERvIG5vdCB1c2UgcHJlRHJhZ0FjdGlvbnMgYWN0aW9ucyBhZnRlciBjYWxsaW5nIHByZURyYWdBY3Rpb25zLmxpZnQoKVxuICAgICAgYCkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNhblN0YXJ0KHtcbiAgbG9ja0FQSSxcbiAgc3RvcmUsXG4gIHJlZ2lzdHJ5LFxuICBkcmFnZ2FibGVJZFxufSkge1xuICBpZiAobG9ja0FQSS5pc0NsYWltZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBlbnRyeSA9IHJlZ2lzdHJ5LmRyYWdnYWJsZS5maW5kQnlJZChkcmFnZ2FibGVJZCk7XG4gIGlmICghZW50cnkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBVbmFibGUgdG8gZmluZCBkcmFnZ2FibGUgd2l0aCBpZDogJHtkcmFnZ2FibGVJZH1gKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFlbnRyeS5vcHRpb25zLmlzRW5hYmxlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWNhblN0YXJ0RHJhZyhzdG9yZS5nZXRTdGF0ZSgpLCBkcmFnZ2FibGVJZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB0cnlTdGFydCh7XG4gIGxvY2tBUEksXG4gIGNvbnRleHRJZCxcbiAgc3RvcmUsXG4gIHJlZ2lzdHJ5LFxuICBkcmFnZ2FibGVJZCxcbiAgZm9yY2VTZW5zb3JTdG9wLFxuICBzb3VyY2VFdmVudFxufSkge1xuICBjb25zdCBzaG91bGRTdGFydCA9IGNhblN0YXJ0KHtcbiAgICBsb2NrQVBJLFxuICAgIHN0b3JlLFxuICAgIHJlZ2lzdHJ5LFxuICAgIGRyYWdnYWJsZUlkXG4gIH0pO1xuICBpZiAoIXNob3VsZFN0YXJ0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZW50cnkgPSByZWdpc3RyeS5kcmFnZ2FibGUuZ2V0QnlJZChkcmFnZ2FibGVJZCk7XG4gIGNvbnN0IGVsID0gZmluZERyYWdnYWJsZShjb250ZXh0SWQsIGVudHJ5LmRlc2NyaXB0b3IuaWQpO1xuICBpZiAoIWVsKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgVW5hYmxlIHRvIGZpbmQgZHJhZ2dhYmxlIGVsZW1lbnQgd2l0aCBpZDogJHtkcmFnZ2FibGVJZH1gKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoc291cmNlRXZlbnQgJiYgIWVudHJ5Lm9wdGlvbnMuY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMgJiYgaXNFdmVudEluSW50ZXJhY3RpdmVFbGVtZW50KGVsLCBzb3VyY2VFdmVudCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBsb2NrID0gbG9ja0FQSS5jbGFpbShmb3JjZVNlbnNvclN0b3AgfHwgbm9vcCQyKTtcbiAgbGV0IHBoYXNlID0gJ1BSRV9EUkFHJztcbiAgZnVuY3Rpb24gZ2V0U2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MoKSB7XG4gICAgcmV0dXJuIGVudHJ5Lm9wdGlvbnMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M7XG4gIH1cbiAgZnVuY3Rpb24gaXNMb2NrQWN0aXZlKCkge1xuICAgIHJldHVybiBsb2NrQVBJLmlzQWN0aXZlKGxvY2spO1xuICB9XG4gIGZ1bmN0aW9uIHRyeURpc3BhdGNoKGV4cGVjdGVkLCBnZXRBY3Rpb24pIHtcbiAgICBpZiAoaXNBY3RpdmUoe1xuICAgICAgZXhwZWN0ZWQsXG4gICAgICBwaGFzZSxcbiAgICAgIGlzTG9ja0FjdGl2ZSxcbiAgICAgIHNob3VsZFdhcm46IHRydWVcbiAgICB9KSkge1xuICAgICAgc3RvcmUuZGlzcGF0Y2goZ2V0QWN0aW9uKCkpO1xuICAgIH1cbiAgfVxuICBjb25zdCB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyA9IHRyeURpc3BhdGNoLmJpbmQobnVsbCwgJ0RSQUdHSU5HJyk7XG4gIGZ1bmN0aW9uIGxpZnQoYXJncykge1xuICAgIGZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcbiAgICAgIGxvY2tBUEkucmVsZWFzZSgpO1xuICAgICAgcGhhc2UgPSAnQ09NUExFVEVEJztcbiAgICB9XG4gICAgaWYgKHBoYXNlICE9PSAnUFJFX0RSQUcnKSB7XG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBsaWZ0IGluIHBoYXNlICR7cGhhc2V9YCkgOiBpbnZhcmlhbnQoKSA7XG4gICAgfVxuICAgIHN0b3JlLmRpc3BhdGNoKGxpZnQkMShhcmdzLmxpZnRBY3Rpb25BcmdzKSk7XG4gICAgcGhhc2UgPSAnRFJBR0dJTkcnO1xuICAgIGZ1bmN0aW9uIGZpbmlzaChyZWFzb24sIG9wdGlvbnMgPSB7XG4gICAgICBzaG91bGRCbG9ja05leHRDbGljazogZmFsc2VcbiAgICB9KSB7XG4gICAgICBhcmdzLmNsZWFudXAoKTtcbiAgICAgIGlmIChvcHRpb25zLnNob3VsZEJsb2NrTmV4dENsaWNrKSB7XG4gICAgICAgIGNvbnN0IHVuYmluZCA9IGJpbmRFdmVudHMod2luZG93LCBbe1xuICAgICAgICAgIGV2ZW50TmFtZTogJ2NsaWNrJyxcbiAgICAgICAgICBmbjogcHJldmVudERlZmF1bHQsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgICBzZXRUaW1lb3V0KHVuYmluZCk7XG4gICAgICB9XG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKGRyb3Aoe1xuICAgICAgICByZWFzb25cbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQWN0aXZlOiAoKSA9PiBpc0FjdGl2ZSh7XG4gICAgICAgIGV4cGVjdGVkOiAnRFJBR0dJTkcnLFxuICAgICAgICBwaGFzZSxcbiAgICAgICAgaXNMb2NrQWN0aXZlLFxuICAgICAgICBzaG91bGRXYXJuOiBmYWxzZVxuICAgICAgfSksXG4gICAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzczogZ2V0U2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsXG4gICAgICBkcm9wOiBvcHRpb25zID0+IGZpbmlzaCgnRFJPUCcsIG9wdGlvbnMpLFxuICAgICAgY2FuY2VsOiBvcHRpb25zID0+IGZpbmlzaCgnQ0FOQ0VMJywgb3B0aW9ucyksXG4gICAgICAuLi5hcmdzLmFjdGlvbnNcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGZsdWlkTGlmdChjbGllbnRTZWxlY3Rpb24pIHtcbiAgICBjb25zdCBtb3ZlJDEgPSByYWZTY2hkKGNsaWVudCA9PiB7XG4gICAgICB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZygoKSA9PiBtb3ZlKHtcbiAgICAgICAgY2xpZW50XG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgY29uc3QgYXBpID0gbGlmdCh7XG4gICAgICBsaWZ0QWN0aW9uQXJnczoge1xuICAgICAgICBpZDogZHJhZ2dhYmxlSWQsXG4gICAgICAgIGNsaWVudFNlbGVjdGlvbixcbiAgICAgICAgbW92ZW1lbnRNb2RlOiAnRkxVSUQnXG4gICAgICB9LFxuICAgICAgY2xlYW51cDogKCkgPT4gbW92ZSQxLmNhbmNlbCgpLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICBtb3ZlOiBtb3ZlJDFcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uYXBpLFxuICAgICAgbW92ZTogbW92ZSQxXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzbmFwTGlmdCgpIHtcbiAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgbW92ZVVwOiAoKSA9PiB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyhtb3ZlVXApLFxuICAgICAgbW92ZVJpZ2h0OiAoKSA9PiB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyhtb3ZlUmlnaHQpLFxuICAgICAgbW92ZURvd246ICgpID0+IHRyeURpc3BhdGNoV2hlbkRyYWdnaW5nKG1vdmVEb3duKSxcbiAgICAgIG1vdmVMZWZ0OiAoKSA9PiB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyhtb3ZlTGVmdClcbiAgICB9O1xuICAgIHJldHVybiBsaWZ0KHtcbiAgICAgIGxpZnRBY3Rpb25BcmdzOiB7XG4gICAgICAgIGlkOiBkcmFnZ2FibGVJZCxcbiAgICAgICAgY2xpZW50U2VsZWN0aW9uOiBnZXRCb3JkZXJCb3hDZW50ZXJQb3NpdGlvbihlbCksXG4gICAgICAgIG1vdmVtZW50TW9kZTogJ1NOQVAnXG4gICAgICB9LFxuICAgICAgY2xlYW51cDogbm9vcCQyLFxuICAgICAgYWN0aW9uc1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFib3J0UHJlRHJhZygpIHtcbiAgICBjb25zdCBzaG91bGRSZWxlYXNlID0gaXNBY3RpdmUoe1xuICAgICAgZXhwZWN0ZWQ6ICdQUkVfRFJBRycsXG4gICAgICBwaGFzZSxcbiAgICAgIGlzTG9ja0FjdGl2ZSxcbiAgICAgIHNob3VsZFdhcm46IHRydWVcbiAgICB9KTtcbiAgICBpZiAoc2hvdWxkUmVsZWFzZSkge1xuICAgICAgbG9ja0FQSS5yZWxlYXNlKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHByZURyYWcgPSB7XG4gICAgaXNBY3RpdmU6ICgpID0+IGlzQWN0aXZlKHtcbiAgICAgIGV4cGVjdGVkOiAnUFJFX0RSQUcnLFxuICAgICAgcGhhc2UsXG4gICAgICBpc0xvY2tBY3RpdmUsXG4gICAgICBzaG91bGRXYXJuOiBmYWxzZVxuICAgIH0pLFxuICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzOiBnZXRTaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICBmbHVpZExpZnQsXG4gICAgc25hcExpZnQsXG4gICAgYWJvcnQ6IGFib3J0UHJlRHJhZ1xuICB9O1xuICByZXR1cm4gcHJlRHJhZztcbn1cbmNvbnN0IGRlZmF1bHRTZW5zb3JzID0gW3VzZU1vdXNlU2Vuc29yLCB1c2VLZXlib2FyZFNlbnNvciwgdXNlVG91Y2hTZW5zb3JdO1xuZnVuY3Rpb24gdXNlU2Vuc29yTWFyc2hhbCh7XG4gIGNvbnRleHRJZCxcbiAgc3RvcmUsXG4gIHJlZ2lzdHJ5LFxuICBjdXN0b21TZW5zb3JzLFxuICBlbmFibGVEZWZhdWx0U2Vuc29yc1xufSkge1xuICBjb25zdCB1c2VTZW5zb3JzID0gWy4uLihlbmFibGVEZWZhdWx0U2Vuc29ycyA/IGRlZmF1bHRTZW5zb3JzIDogW10pLCAuLi4oY3VzdG9tU2Vuc29ycyB8fCBbXSldO1xuICBjb25zdCBsb2NrQVBJID0gdXNlU3RhdGUoKCkgPT4gY3JlYXRlKCkpWzBdO1xuICBjb25zdCB0cnlBYmFuZG9uTG9jayA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeUFiYW5kb25Mb2NrKHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgaWYgKGlzRHJhZ2dpbmcocHJldmlvdXMpICYmICFpc0RyYWdnaW5nKGN1cnJlbnQpKSB7XG4gICAgICBsb2NrQVBJLnRyeUFiYW5kb24oKTtcbiAgICB9XG4gIH0sIFtsb2NrQVBJXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gbGlzdGVuVG9TdG9yZSgpIHtcbiAgICBsZXQgcHJldmlvdXMgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gc3RvcmUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgdHJ5QWJhbmRvbkxvY2socHJldmlvdXMsIGN1cnJlbnQpO1xuICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIH0pO1xuICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgfSwgW2xvY2tBUEksIHN0b3JlLCB0cnlBYmFuZG9uTG9ja10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gbG9ja0FQSS50cnlBYmFuZG9uO1xuICB9LCBbbG9ja0FQSS50cnlBYmFuZG9uXSk7XG4gIGNvbnN0IGNhbkdldExvY2sgPSB1c2VDYWxsYmFjayhkcmFnZ2FibGVJZCA9PiB7XG4gICAgcmV0dXJuIGNhblN0YXJ0KHtcbiAgICAgIGxvY2tBUEksXG4gICAgICByZWdpc3RyeSxcbiAgICAgIHN0b3JlLFxuICAgICAgZHJhZ2dhYmxlSWRcbiAgICB9KTtcbiAgfSwgW2xvY2tBUEksIHJlZ2lzdHJ5LCBzdG9yZV0pO1xuICBjb25zdCB0cnlHZXRMb2NrID0gdXNlQ2FsbGJhY2soKGRyYWdnYWJsZUlkLCBmb3JjZVN0b3AsIG9wdGlvbnMpID0+IHRyeVN0YXJ0KHtcbiAgICBsb2NrQVBJLFxuICAgIHJlZ2lzdHJ5LFxuICAgIGNvbnRleHRJZCxcbiAgICBzdG9yZSxcbiAgICBkcmFnZ2FibGVJZCxcbiAgICBmb3JjZVNlbnNvclN0b3A6IGZvcmNlU3RvcCB8fCBudWxsLFxuICAgIHNvdXJjZUV2ZW50OiBvcHRpb25zICYmIG9wdGlvbnMuc291cmNlRXZlbnQgPyBvcHRpb25zLnNvdXJjZUV2ZW50IDogbnVsbFxuICB9KSwgW2NvbnRleHRJZCwgbG9ja0FQSSwgcmVnaXN0cnksIHN0b3JlXSk7XG4gIGNvbnN0IGZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQgPSB1c2VDYWxsYmFjayhldmVudCA9PiB0cnlHZXRDbG9zZXN0RHJhZ2dhYmxlSWRGcm9tRXZlbnQoY29udGV4dElkLCBldmVudCksIFtjb250ZXh0SWRdKTtcbiAgY29uc3QgZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUgPSB1c2VDYWxsYmFjayhpZCA9PiB7XG4gICAgY29uc3QgZW50cnkgPSByZWdpc3RyeS5kcmFnZ2FibGUuZmluZEJ5SWQoaWQpO1xuICAgIHJldHVybiBlbnRyeSA/IGVudHJ5Lm9wdGlvbnMgOiBudWxsO1xuICB9LCBbcmVnaXN0cnkuZHJhZ2dhYmxlXSk7XG4gIGNvbnN0IHRyeVJlbGVhc2VMb2NrID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5UmVsZWFzZUxvY2soKSB7XG4gICAgaWYgKCFsb2NrQVBJLmlzQ2xhaW1lZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvY2tBUEkudHJ5QWJhbmRvbigpO1xuICAgIGlmIChzdG9yZS5nZXRTdGF0ZSgpLnBoYXNlICE9PSAnSURMRScpIHtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKGZsdXNoKCkpO1xuICAgIH1cbiAgfSwgW2xvY2tBUEksIHN0b3JlXSk7XG4gIGNvbnN0IGlzTG9ja0NsYWltZWQgPSB1c2VDYWxsYmFjaygoKSA9PiBsb2NrQVBJLmlzQ2xhaW1lZCgpLCBbbG9ja0FQSV0pO1xuICBjb25zdCBhcGkgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgY2FuR2V0TG9jayxcbiAgICB0cnlHZXRMb2NrLFxuICAgIGZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQsXG4gICAgZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUsXG4gICAgdHJ5UmVsZWFzZUxvY2ssXG4gICAgaXNMb2NrQ2xhaW1lZFxuICB9KSwgW2NhbkdldExvY2ssIHRyeUdldExvY2ssIGZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQsIGZpbmRPcHRpb25zRm9yRHJhZ2dhYmxlLCB0cnlSZWxlYXNlTG9jaywgaXNMb2NrQ2xhaW1lZF0pO1xuICB1c2VWYWxpZGF0ZVNlbnNvckhvb2tzKHVzZVNlbnNvcnMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHVzZVNlbnNvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB1c2VTZW5zb3JzW2ldKGFwaSk7XG4gIH1cbn1cblxuY29uc3QgY3JlYXRlUmVzcG9uZGVycyA9IHByb3BzID0+ICh7XG4gIG9uQmVmb3JlQ2FwdHVyZTogdCA9PiB7XG4gICAgY29uc3Qgb25CZWZvcmVDYXB1cmVDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGlmIChwcm9wcy5vbkJlZm9yZUNhcHR1cmUpIHtcbiAgICAgICAgcHJvcHMub25CZWZvcmVDYXB0dXJlKHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgZmx1c2hTeW5jKG9uQmVmb3JlQ2FwdXJlQ2FsbGJhY2spO1xuICB9LFxuICBvbkJlZm9yZURyYWdTdGFydDogcHJvcHMub25CZWZvcmVEcmFnU3RhcnQsXG4gIG9uRHJhZ1N0YXJ0OiBwcm9wcy5vbkRyYWdTdGFydCxcbiAgb25EcmFnRW5kOiBwcm9wcy5vbkRyYWdFbmQsXG4gIG9uRHJhZ1VwZGF0ZTogcHJvcHMub25EcmFnVXBkYXRlXG59KTtcbmNvbnN0IGNyZWF0ZUF1dG9TY3JvbGxlck9wdGlvbnMgPSBwcm9wcyA9PiAoe1xuICAuLi5kZWZhdWx0QXV0b1Njcm9sbGVyT3B0aW9ucyxcbiAgLi4ucHJvcHMuYXV0b1Njcm9sbGVyT3B0aW9ucyxcbiAgZHVyYXRpb25EYW1wZW5pbmc6IHtcbiAgICAuLi5kZWZhdWx0QXV0b1Njcm9sbGVyT3B0aW9ucy5kdXJhdGlvbkRhbXBlbmluZyxcbiAgICAuLi5wcm9wcy5hdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH1cbn0pO1xuZnVuY3Rpb24gZ2V0U3RvcmUobGF6eVJlZikge1xuICAhbGF6eVJlZi5jdXJyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgc3RvcmUgZnJvbSBsYXp5IHJlZicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIHJldHVybiBsYXp5UmVmLmN1cnJlbnQ7XG59XG5mdW5jdGlvbiBBcHAocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNvbnRleHRJZCxcbiAgICBzZXRDYWxsYmFja3MsXG4gICAgc2Vuc29ycyxcbiAgICBub25jZSxcbiAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBsYXp5U3RvcmVSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHVzZVN0YXJ0dXBWYWxpZGF0aW9uKCk7XG4gIGNvbnN0IGxhc3RQcm9wc1JlZiA9IHVzZVByZXZpb3VzKHByb3BzKTtcbiAgY29uc3QgZ2V0UmVzcG9uZGVycyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlUmVzcG9uZGVycyhsYXN0UHJvcHNSZWYuY3VycmVudCk7XG4gIH0sIFtsYXN0UHJvcHNSZWZdKTtcbiAgY29uc3QgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlQXV0b1Njcm9sbGVyT3B0aW9ucyhsYXN0UHJvcHNSZWYuY3VycmVudCk7XG4gIH0sIFtsYXN0UHJvcHNSZWZdKTtcbiAgY29uc3QgYW5ub3VuY2UgPSB1c2VBbm5vdW5jZXIoY29udGV4dElkKTtcbiAgY29uc3QgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQgPSB1c2VIaWRkZW5UZXh0RWxlbWVudCh7XG4gICAgY29udGV4dElkLFxuICAgIHRleHQ6IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc1xuICB9KTtcbiAgY29uc3Qgc3R5bGVNYXJzaGFsID0gdXNlU3R5bGVNYXJzaGFsKGNvbnRleHRJZCwgbm9uY2UpO1xuICBjb25zdCBsYXp5RGlzcGF0Y2ggPSB1c2VDYWxsYmFjayhhY3Rpb24gPT4ge1xuICAgIGdldFN0b3JlKGxhenlTdG9yZVJlZikuZGlzcGF0Y2goYWN0aW9uKTtcbiAgfSwgW10pO1xuICBjb25zdCBtYXJzaGFsQ2FsbGJhY2tzID0gdXNlTWVtbygoKSA9PiBiaW5kQWN0aW9uQ3JlYXRvcnMoe1xuICAgIHB1Ymxpc2hXaGlsZURyYWdnaW5nLFxuICAgIHVwZGF0ZURyb3BwYWJsZVNjcm9sbCxcbiAgICB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQsXG4gICAgdXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCxcbiAgICBjb2xsZWN0aW9uU3RhcnRpbmdcbiAgfSwgbGF6eURpc3BhdGNoKSwgW2xhenlEaXNwYXRjaF0pO1xuICBjb25zdCByZWdpc3RyeSA9IHVzZVJlZ2lzdHJ5KCk7XG4gIGNvbnN0IGRpbWVuc2lvbk1hcnNoYWwgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlRGltZW5zaW9uTWFyc2hhbChyZWdpc3RyeSwgbWFyc2hhbENhbGxiYWNrcyk7XG4gIH0sIFtyZWdpc3RyeSwgbWFyc2hhbENhbGxiYWNrc10pO1xuICBjb25zdCBhdXRvU2Nyb2xsZXIgPSB1c2VNZW1vKCgpID0+IGNyZWF0ZUF1dG9TY3JvbGxlcih7XG4gICAgc2Nyb2xsV2luZG93LFxuICAgIHNjcm9sbERyb3BwYWJsZTogZGltZW5zaW9uTWFyc2hhbC5zY3JvbGxEcm9wcGFibGUsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyxcbiAgICAuLi5iaW5kQWN0aW9uQ3JlYXRvcnMoe1xuICAgICAgbW92ZVxuICAgIH0sIGxhenlEaXNwYXRjaClcbiAgfSksIFtkaW1lbnNpb25NYXJzaGFsLnNjcm9sbERyb3BwYWJsZSwgbGF6eURpc3BhdGNoLCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXSk7XG4gIGNvbnN0IGZvY3VzTWFyc2hhbCA9IHVzZUZvY3VzTWFyc2hhbChjb250ZXh0SWQpO1xuICBjb25zdCBzdG9yZSA9IHVzZU1lbW8oKCkgPT4gY3JlYXRlU3RvcmUoe1xuICAgIGFubm91bmNlLFxuICAgIGF1dG9TY3JvbGxlcixcbiAgICBkaW1lbnNpb25NYXJzaGFsLFxuICAgIGZvY3VzTWFyc2hhbCxcbiAgICBnZXRSZXNwb25kZXJzLFxuICAgIHN0eWxlTWFyc2hhbFxuICB9KSwgW2Fubm91bmNlLCBhdXRvU2Nyb2xsZXIsIGRpbWVuc2lvbk1hcnNoYWwsIGZvY3VzTWFyc2hhbCwgZ2V0UmVzcG9uZGVycywgc3R5bGVNYXJzaGFsXSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGxhenlTdG9yZVJlZi5jdXJyZW50ICYmIGxhenlTdG9yZVJlZi5jdXJyZW50ICE9PSBzdG9yZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygndW5leHBlY3RlZCBzdG9yZSBjaGFuZ2UnKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgbGF6eVN0b3JlUmVmLmN1cnJlbnQgPSBzdG9yZTtcbiAgY29uc3QgdHJ5UmVzZXRTdG9yZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50ID0gZ2V0U3RvcmUobGF6eVN0b3JlUmVmKTtcbiAgICBjb25zdCBzdGF0ZSA9IGN1cnJlbnQuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUucGhhc2UgIT09ICdJRExFJykge1xuICAgICAgY3VycmVudC5kaXNwYXRjaChmbHVzaCgpKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgaXNEcmFnZ2luZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0b3JlKGxhenlTdG9yZVJlZikuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuaXNEcmFnZ2luZztcbiAgfSwgW10pO1xuICBjb25zdCBhcHBDYWxsYmFja3MgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgaXNEcmFnZ2luZyxcbiAgICB0cnlBYm9ydDogdHJ5UmVzZXRTdG9yZVxuICB9KSwgW2lzRHJhZ2dpbmcsIHRyeVJlc2V0U3RvcmVdKTtcbiAgc2V0Q2FsbGJhY2tzKGFwcENhbGxiYWNrcyk7XG4gIGNvbnN0IGdldENhbkxpZnQgPSB1c2VDYWxsYmFjayhpZCA9PiBjYW5TdGFydERyYWcoZ2V0U3RvcmUobGF6eVN0b3JlUmVmKS5nZXRTdGF0ZSgpLCBpZCksIFtdKTtcbiAgY29uc3QgZ2V0SXNNb3ZlbWVudEFsbG93ZWQgPSB1c2VDYWxsYmFjaygoKSA9PiBpc01vdmVtZW50QWxsb3dlZChnZXRTdG9yZShsYXp5U3RvcmVSZWYpLmdldFN0YXRlKCkpLCBbXSk7XG4gIGNvbnN0IGFwcENvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgbWFyc2hhbDogZGltZW5zaW9uTWFyc2hhbCxcbiAgICBmb2N1czogZm9jdXNNYXJzaGFsLFxuICAgIGNvbnRleHRJZCxcbiAgICBjYW5MaWZ0OiBnZXRDYW5MaWZ0LFxuICAgIGlzTW92ZW1lbnRBbGxvd2VkOiBnZXRJc01vdmVtZW50QWxsb3dlZCxcbiAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCxcbiAgICByZWdpc3RyeVxuICB9KSwgW2NvbnRleHRJZCwgZGltZW5zaW9uTWFyc2hhbCwgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQsIGZvY3VzTWFyc2hhbCwgZ2V0Q2FuTGlmdCwgZ2V0SXNNb3ZlbWVudEFsbG93ZWQsIHJlZ2lzdHJ5XSk7XG4gIHVzZVNlbnNvck1hcnNoYWwoe1xuICAgIGNvbnRleHRJZCxcbiAgICBzdG9yZSxcbiAgICByZWdpc3RyeSxcbiAgICBjdXN0b21TZW5zb3JzOiBzZW5zb3JzIHx8IG51bGwsXG4gICAgZW5hYmxlRGVmYXVsdFNlbnNvcnM6IHByb3BzLmVuYWJsZURlZmF1bHRTZW5zb3JzICE9PSBmYWxzZVxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gdHJ5UmVzZXRTdG9yZTtcbiAgfSwgW3RyeVJlc2V0U3RvcmVdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXBwQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBhcHBDb250ZXh0XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJvdmlkZXIsIHtcbiAgICBjb250ZXh0OiBTdG9yZUNvbnRleHQsXG4gICAgc3RvcmU6IHN0b3JlXG4gIH0sIHByb3BzLmNoaWxkcmVuKSk7XG59XG5cbmZ1bmN0aW9uIHVzZVVuaXF1ZUNvbnRleHRJZCgpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUlkKCk7XG59XG5cbmZ1bmN0aW9uIERyYWdEcm9wQ29udGV4dChwcm9wcykge1xuICBjb25zdCBjb250ZXh0SWQgPSB1c2VVbmlxdWVDb250ZXh0SWQoKTtcbiAgY29uc3QgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zID0gcHJvcHMuZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zIHx8IHByZXNldC5kcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnM7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIG51bGwsIHNldENhbGxiYWNrcyA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KEFwcCwge1xuICAgIG5vbmNlOiBwcm9wcy5ub25jZSxcbiAgICBjb250ZXh0SWQ6IGNvbnRleHRJZCxcbiAgICBzZXRDYWxsYmFja3M6IHNldENhbGxiYWNrcyxcbiAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnM6IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyxcbiAgICBlbmFibGVEZWZhdWx0U2Vuc29yczogcHJvcHMuZW5hYmxlRGVmYXVsdFNlbnNvcnMsXG4gICAgc2Vuc29yczogcHJvcHMuc2Vuc29ycyxcbiAgICBvbkJlZm9yZUNhcHR1cmU6IHByb3BzLm9uQmVmb3JlQ2FwdHVyZSxcbiAgICBvbkJlZm9yZURyYWdTdGFydDogcHJvcHMub25CZWZvcmVEcmFnU3RhcnQsXG4gICAgb25EcmFnU3RhcnQ6IHByb3BzLm9uRHJhZ1N0YXJ0LFxuICAgIG9uRHJhZ1VwZGF0ZTogcHJvcHMub25EcmFnVXBkYXRlLFxuICAgIG9uRHJhZ0VuZDogcHJvcHMub25EcmFnRW5kLFxuICAgIGF1dG9TY3JvbGxlck9wdGlvbnM6IHByb3BzLmF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSwgcHJvcHMuY2hpbGRyZW4pKTtcbn1cblxuY29uc3QgekluZGV4T3B0aW9ucyA9IHtcbiAgZHJhZ2dpbmc6IDUwMDAsXG4gIGRyb3BBbmltYXRpbmc6IDQ1MDBcbn07XG5jb25zdCBnZXREcmFnZ2luZ1RyYW5zaXRpb24gPSAoc2hvdWxkQW5pbWF0ZURyYWdNb3ZlbWVudCwgZHJvcHBpbmcpID0+IHtcbiAgaWYgKGRyb3BwaW5nKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25zLmRyb3AoZHJvcHBpbmcuZHVyYXRpb24pO1xuICB9XG4gIGlmIChzaG91bGRBbmltYXRlRHJhZ01vdmVtZW50KSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25zLnNuYXA7XG4gIH1cbiAgcmV0dXJuIHRyYW5zaXRpb25zLmZsdWlkO1xufTtcbmNvbnN0IGdldERyYWdnaW5nT3BhY2l0eSA9IChpc0NvbWJpbmluZywgaXNEcm9wQW5pbWF0aW5nKSA9PiB7XG4gIGlmICghaXNDb21iaW5pbmcpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBpc0Ryb3BBbmltYXRpbmcgPyBjb21iaW5lLm9wYWNpdHkuZHJvcCA6IGNvbWJpbmUub3BhY2l0eS5jb21iaW5pbmc7XG59O1xuY29uc3QgZ2V0U2hvdWxkRHJhZ2dpbmdBbmltYXRlID0gZHJhZ2dpbmcgPT4ge1xuICBpZiAoZHJhZ2dpbmcuZm9yY2VTaG91bGRBbmltYXRlICE9IG51bGwpIHtcbiAgICByZXR1cm4gZHJhZ2dpbmcuZm9yY2VTaG91bGRBbmltYXRlO1xuICB9XG4gIHJldHVybiBkcmFnZ2luZy5tb2RlID09PSAnU05BUCc7XG59O1xuZnVuY3Rpb24gZ2V0RHJhZ2dpbmdTdHlsZShkcmFnZ2luZykge1xuICBjb25zdCBkaW1lbnNpb24gPSBkcmFnZ2luZy5kaW1lbnNpb247XG4gIGNvbnN0IGJveCA9IGRpbWVuc2lvbi5jbGllbnQ7XG4gIGNvbnN0IHtcbiAgICBvZmZzZXQsXG4gICAgY29tYmluZVdpdGgsXG4gICAgZHJvcHBpbmdcbiAgfSA9IGRyYWdnaW5nO1xuICBjb25zdCBpc0NvbWJpbmluZyA9IEJvb2xlYW4oY29tYmluZVdpdGgpO1xuICBjb25zdCBzaG91bGRBbmltYXRlID0gZ2V0U2hvdWxkRHJhZ2dpbmdBbmltYXRlKGRyYWdnaW5nKTtcbiAgY29uc3QgaXNEcm9wQW5pbWF0aW5nID0gQm9vbGVhbihkcm9wcGluZyk7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IGlzRHJvcEFuaW1hdGluZyA/IHRyYW5zZm9ybXMuZHJvcChvZmZzZXQsIGlzQ29tYmluaW5nKSA6IHRyYW5zZm9ybXMubW92ZVRvKG9mZnNldCk7XG4gIGNvbnN0IHN0eWxlID0ge1xuICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgIHRvcDogYm94Lm1hcmdpbkJveC50b3AsXG4gICAgbGVmdDogYm94Lm1hcmdpbkJveC5sZWZ0LFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIHdpZHRoOiBib3guYm9yZGVyQm94LndpZHRoLFxuICAgIGhlaWdodDogYm94LmJvcmRlckJveC5oZWlnaHQsXG4gICAgdHJhbnNpdGlvbjogZ2V0RHJhZ2dpbmdUcmFuc2l0aW9uKHNob3VsZEFuaW1hdGUsIGRyb3BwaW5nKSxcbiAgICB0cmFuc2Zvcm0sXG4gICAgb3BhY2l0eTogZ2V0RHJhZ2dpbmdPcGFjaXR5KGlzQ29tYmluaW5nLCBpc0Ryb3BBbmltYXRpbmcpLFxuICAgIHpJbmRleDogaXNEcm9wQW5pbWF0aW5nID8gekluZGV4T3B0aW9ucy5kcm9wQW5pbWF0aW5nIDogekluZGV4T3B0aW9ucy5kcmFnZ2luZyxcbiAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgfTtcbiAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gZ2V0U2Vjb25kYXJ5U3R5bGUoc2Vjb25kYXJ5KSB7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1zLm1vdmVUbyhzZWNvbmRhcnkub2Zmc2V0KSxcbiAgICB0cmFuc2l0aW9uOiBzZWNvbmRhcnkuc2hvdWxkQW5pbWF0ZURpc3BsYWNlbWVudCA/IHVuZGVmaW5lZCA6ICdub25lJ1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0U3R5bGUkMShtYXBwZWQpIHtcbiAgcmV0dXJuIG1hcHBlZC50eXBlID09PSAnRFJBR0dJTkcnID8gZ2V0RHJhZ2dpbmdTdHlsZShtYXBwZWQpIDogZ2V0U2Vjb25kYXJ5U3R5bGUobWFwcGVkKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9uJDEoZGVzY3JpcHRvciwgZWwsIHdpbmRvd1Njcm9sbCA9IG9yaWdpbikge1xuICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgY29uc3QgYm9yZGVyQm94ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGNsaWVudCA9IGNhbGN1bGF0ZUJveChib3JkZXJCb3gsIGNvbXB1dGVkU3R5bGVzKTtcbiAgY29uc3QgcGFnZSA9IHdpdGhTY3JvbGwoY2xpZW50LCB3aW5kb3dTY3JvbGwpO1xuICBjb25zdCBwbGFjZWhvbGRlciA9IHtcbiAgICBjbGllbnQsXG4gICAgdGFnTmFtZTogZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgIGRpc3BsYXk6IGNvbXB1dGVkU3R5bGVzLmRpc3BsYXlcbiAgfTtcbiAgY29uc3QgZGlzcGxhY2VCeSA9IHtcbiAgICB4OiBjbGllbnQubWFyZ2luQm94LndpZHRoLFxuICAgIHk6IGNsaWVudC5tYXJnaW5Cb3guaGVpZ2h0XG4gIH07XG4gIGNvbnN0IGRpbWVuc2lvbiA9IHtcbiAgICBkZXNjcmlwdG9yLFxuICAgIHBsYWNlaG9sZGVyLFxuICAgIGRpc3BsYWNlQnksXG4gICAgY2xpZW50LFxuICAgIHBhZ2VcbiAgfTtcbiAgcmV0dXJuIGRpbWVuc2lvbjtcbn1cblxuZnVuY3Rpb24gdXNlRHJhZ2dhYmxlUHVibGlzaGVyKGFyZ3MpIHtcbiAgY29uc3QgdW5pcXVlSWQgPSB1c2VVbmlxdWVJZCgnZHJhZ2dhYmxlJyk7XG4gIGNvbnN0IHtcbiAgICBkZXNjcmlwdG9yLFxuICAgIHJlZ2lzdHJ5LFxuICAgIGdldERyYWdnYWJsZVJlZixcbiAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICBpc0VuYWJsZWRcbiAgfSA9IGFyZ3M7XG4gIGNvbnN0IG9wdGlvbnMgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsXG4gICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsXG4gICAgaXNFbmFibGVkXG4gIH0pLCBbY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsIGlzRW5hYmxlZCwgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3NdKTtcbiAgY29uc3QgZ2V0RGltZW5zaW9uID0gdXNlQ2FsbGJhY2sod2luZG93U2Nyb2xsID0+IHtcbiAgICBjb25zdCBlbCA9IGdldERyYWdnYWJsZVJlZigpO1xuICAgICFlbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBnZXQgZGltZW5zaW9uIHdoZW4gbm8gcmVmIGlzIHNldCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGdldERpbWVuc2lvbiQxKGRlc2NyaXB0b3IsIGVsLCB3aW5kb3dTY3JvbGwpO1xuICB9LCBbZGVzY3JpcHRvciwgZ2V0RHJhZ2dhYmxlUmVmXSk7XG4gIGNvbnN0IGVudHJ5ID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIHVuaXF1ZUlkLFxuICAgIGRlc2NyaXB0b3IsXG4gICAgb3B0aW9ucyxcbiAgICBnZXREaW1lbnNpb25cbiAgfSksIFtkZXNjcmlwdG9yLCBnZXREaW1lbnNpb24sIG9wdGlvbnMsIHVuaXF1ZUlkXSk7XG4gIGNvbnN0IHB1Ymxpc2hlZFJlZiA9IHVzZVJlZihlbnRyeSk7XG4gIGNvbnN0IGlzRmlyc3RQdWJsaXNoUmVmID0gdXNlUmVmKHRydWUpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZWdpc3RyeS5kcmFnZ2FibGUucmVnaXN0ZXIocHVibGlzaGVkUmVmLmN1cnJlbnQpO1xuICAgIHJldHVybiAoKSA9PiByZWdpc3RyeS5kcmFnZ2FibGUudW5yZWdpc3RlcihwdWJsaXNoZWRSZWYuY3VycmVudCk7XG4gIH0sIFtyZWdpc3RyeS5kcmFnZ2FibGVdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzRmlyc3RQdWJsaXNoUmVmLmN1cnJlbnQpIHtcbiAgICAgIGlzRmlyc3RQdWJsaXNoUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdCA9IHB1Ymxpc2hlZFJlZi5jdXJyZW50O1xuICAgIHB1Ymxpc2hlZFJlZi5jdXJyZW50ID0gZW50cnk7XG4gICAgcmVnaXN0cnkuZHJhZ2dhYmxlLnVwZGF0ZShlbnRyeSwgbGFzdCk7XG4gIH0sIFtlbnRyeSwgcmVnaXN0cnkuZHJhZ2dhYmxlXSk7XG59XG5cbnZhciBEcm9wcGFibGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuZnVuY3Rpb24gY2hlY2tJc1ZhbGlkSW5uZXJSZWYoZWwpIHtcbiAgIShlbCAmJiBpc0h0bWxFbGVtZW50KGVsKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBcbiAgICBwcm92aWRlZC5pbm5lclJlZiBoYXMgbm90IGJlZW4gcHJvdmlkZWQgd2l0aCBhIEhUTUxFbGVtZW50LlxuXG4gICAgWW91IGNhbiBmaW5kIGEgZ3VpZGUgb24gdXNpbmcgdGhlIGlubmVyUmVmIGNhbGxiYWNrIGZ1bmN0aW9ucyBhdDpcbiAgICBodHRwczovL2dpdGh1Yi5jb20vaGVsbG8tcGFuZ2VhL2RuZC9ibG9iL21haW4vZG9jcy9ndWlkZXMvdXNpbmctaW5uZXItcmVmLm1kXG4gIGApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIHVzZVZhbGlkYXRpb24kMShwcm9wcywgY29udGV4dElkLCBnZXRSZWYpIHtcbiAgdXNlRGV2U2V0dXBXYXJuaW5nKCgpID0+IHtcbiAgICBmdW5jdGlvbiBwcmVmaXgoaWQpIHtcbiAgICAgIHJldHVybiBgRHJhZ2dhYmxlW2lkOiAke2lkfV06IGA7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gcHJvcHMuZHJhZ2dhYmxlSWQ7XG4gICAgIWlkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRHJhZ2dhYmxlIHJlcXVpcmVzIGEgZHJhZ2dhYmxlSWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYERyYWdnYWJsZSByZXF1aXJlcyBhIFtzdHJpbmddIGRyYWdnYWJsZUlkLlxuICAgICAgUHJvdmlkZWQ6IFt0eXBlOiAke3R5cGVvZiBpZH1dICh2YWx1ZTogJHtpZH0pYCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICFOdW1iZXIuaXNJbnRlZ2VyKHByb3BzLmluZGV4KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYCR7cHJlZml4KGlkKX0gcmVxdWlyZXMgYW4gaW50ZWdlciBpbmRleCBwcm9wYCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGlmIChwcm9wcy5tYXBwZWQudHlwZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjaGVja0lzVmFsaWRJbm5lclJlZihnZXRSZWYoKSk7XG4gICAgaWYgKHByb3BzLmlzRW5hYmxlZCkge1xuICAgICAgIWZpbmREcmFnSGFuZGxlKGNvbnRleHRJZCwgaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgJHtwcmVmaXgoaWQpfSBVbmFibGUgdG8gZmluZCBkcmFnIGhhbmRsZWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdXNlQ2xvbmVQcm9wVmFsaWRhdGlvbihpc0Nsb25lKSB7XG4gIHVzZURldigoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbFJlZiA9IHVzZVJlZihpc0Nsb25lKTtcbiAgICB1c2VEZXZTZXR1cFdhcm5pbmcoKCkgPT4ge1xuICAgICAgIShpc0Nsb25lID09PSBpbml0aWFsUmVmLmN1cnJlbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRHJhZ2dhYmxlIGlzQ2xvbmUgcHJvcCB2YWx1ZSBjaGFuZ2VkIGR1cmluZyBjb21wb25lbnQgbGlmZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB9LCBbaXNDbG9uZV0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlUmVxdWlyZWRDb250ZXh0KENvbnRleHQpIHtcbiAgY29uc3QgcmVzdWx0ID0gdXNlQ29udGV4dChDb250ZXh0KTtcbiAgIXJlc3VsdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIHJlcXVpcmVkIGNvbnRleHQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwcmV2ZW50SHRtbDVEbmQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cbmNvbnN0IERyYWdnYWJsZSA9IHByb3BzID0+IHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBzZXRSZWYgPSB1c2VDYWxsYmFjaygoZWwgPSBudWxsKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSBlbDtcbiAgfSwgW10pO1xuICBjb25zdCBnZXRSZWYgPSB1c2VDYWxsYmFjaygoKSA9PiByZWYuY3VycmVudCwgW10pO1xuICBjb25zdCB7XG4gICAgY29udGV4dElkLFxuICAgIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkLFxuICAgIHJlZ2lzdHJ5XG4gIH0gPSB1c2VSZXF1aXJlZENvbnRleHQoQXBwQ29udGV4dCk7XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIGRyb3BwYWJsZUlkXG4gIH0gPSB1c2VSZXF1aXJlZENvbnRleHQoRHJvcHBhYmxlQ29udGV4dCk7XG4gIGNvbnN0IGRlc2NyaXB0b3IgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgaWQ6IHByb3BzLmRyYWdnYWJsZUlkLFxuICAgIGluZGV4OiBwcm9wcy5pbmRleCxcbiAgICB0eXBlLFxuICAgIGRyb3BwYWJsZUlkXG4gIH0pLCBbcHJvcHMuZHJhZ2dhYmxlSWQsIHByb3BzLmluZGV4LCB0eXBlLCBkcm9wcGFibGVJZF0pO1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZHJhZ2dhYmxlSWQsXG4gICAgaXNFbmFibGVkLFxuICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgIGlzQ2xvbmUsXG4gICAgbWFwcGVkLFxuICAgIGRyb3BBbmltYXRpb25GaW5pc2hlZDogZHJvcEFuaW1hdGlvbkZpbmlzaGVkQWN0aW9uXG4gIH0gPSBwcm9wcztcbiAgdXNlVmFsaWRhdGlvbiQxKHByb3BzLCBjb250ZXh0SWQsIGdldFJlZik7XG4gIHVzZUNsb25lUHJvcFZhbGlkYXRpb24oaXNDbG9uZSk7XG4gIGlmICghaXNDbG9uZSkge1xuICAgIGNvbnN0IGZvclB1Ymxpc2hlciA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIGRlc2NyaXB0b3IsXG4gICAgICByZWdpc3RyeSxcbiAgICAgIGdldERyYWdnYWJsZVJlZjogZ2V0UmVmLFxuICAgICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsXG4gICAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICAgIGlzRW5hYmxlZFxuICAgIH0pLCBbZGVzY3JpcHRvciwgcmVnaXN0cnksIGdldFJlZiwgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzLCBpc0VuYWJsZWRdKTtcbiAgICB1c2VEcmFnZ2FibGVQdWJsaXNoZXIoZm9yUHVibGlzaGVyKTtcbiAgfVxuICBjb25zdCBkcmFnSGFuZGxlUHJvcHMgPSB1c2VNZW1vKCgpID0+IGlzRW5hYmxlZCA/IHtcbiAgICB0YWJJbmRleDogMCxcbiAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAnYXJpYS1kZXNjcmliZWRieSc6IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkLFxuICAgICdkYXRhLXJmZC1kcmFnLWhhbmRsZS1kcmFnZ2FibGUtaWQnOiBkcmFnZ2FibGVJZCxcbiAgICAnZGF0YS1yZmQtZHJhZy1oYW5kbGUtY29udGV4dC1pZCc6IGNvbnRleHRJZCxcbiAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgIG9uRHJhZ1N0YXJ0OiBwcmV2ZW50SHRtbDVEbmRcbiAgfSA6IG51bGwsIFtjb250ZXh0SWQsIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkLCBkcmFnZ2FibGVJZCwgaXNFbmFibGVkXSk7XG4gIGNvbnN0IG9uTW92ZUVuZCA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICBpZiAobWFwcGVkLnR5cGUgIT09ICdEUkFHR0lORycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFtYXBwZWQuZHJvcHBpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3RyYW5zZm9ybScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmx1c2hTeW5jKGRyb3BBbmltYXRpb25GaW5pc2hlZEFjdGlvbik7XG4gIH0sIFtkcm9wQW5pbWF0aW9uRmluaXNoZWRBY3Rpb24sIG1hcHBlZF0pO1xuICBjb25zdCBwcm92aWRlZCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0U3R5bGUkMShtYXBwZWQpO1xuICAgIGNvbnN0IG9uVHJhbnNpdGlvbkVuZCA9IG1hcHBlZC50eXBlID09PSAnRFJBR0dJTkcnICYmIG1hcHBlZC5kcm9wcGluZyA/IG9uTW92ZUVuZCA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBpbm5lclJlZjogc2V0UmVmLFxuICAgICAgZHJhZ2dhYmxlUHJvcHM6IHtcbiAgICAgICAgJ2RhdGEtcmZkLWRyYWdnYWJsZS1jb250ZXh0LWlkJzogY29udGV4dElkLFxuICAgICAgICAnZGF0YS1yZmQtZHJhZ2dhYmxlLWlkJzogZHJhZ2dhYmxlSWQsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICBvblRyYW5zaXRpb25FbmRcbiAgICAgIH0sXG4gICAgICBkcmFnSGFuZGxlUHJvcHNcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIFtjb250ZXh0SWQsIGRyYWdIYW5kbGVQcm9wcywgZHJhZ2dhYmxlSWQsIG1hcHBlZCwgb25Nb3ZlRW5kLCBzZXRSZWZdKTtcbiAgY29uc3QgcnVicmljID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGRyYWdnYWJsZUlkOiBkZXNjcmlwdG9yLmlkLFxuICAgIHR5cGU6IGRlc2NyaXB0b3IudHlwZSxcbiAgICBzb3VyY2U6IHtcbiAgICAgIGluZGV4OiBkZXNjcmlwdG9yLmluZGV4LFxuICAgICAgZHJvcHBhYmxlSWQ6IGRlc2NyaXB0b3IuZHJvcHBhYmxlSWRcbiAgICB9XG4gIH0pLCBbZGVzY3JpcHRvci5kcm9wcGFibGVJZCwgZGVzY3JpcHRvci5pZCwgZGVzY3JpcHRvci5pbmRleCwgZGVzY3JpcHRvci50eXBlXSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbihwcm92aWRlZCwgbWFwcGVkLnNuYXBzaG90LCBydWJyaWMpKTtcbn07XG5cbnZhciBpc1N0cmljdEVxdWFsID0gKGEsIGIpID0+IGEgPT09IGI7XG5cbnZhciB3aGF0SXNEcmFnZ2VkT3ZlckZyb21SZXN1bHQgPSByZXN1bHQgPT4ge1xuICBjb25zdCB7XG4gICAgY29tYmluZSxcbiAgICBkZXN0aW5hdGlvblxuICB9ID0gcmVzdWx0O1xuICBpZiAoZGVzdGluYXRpb24pIHtcbiAgICByZXR1cm4gZGVzdGluYXRpb24uZHJvcHBhYmxlSWQ7XG4gIH1cbiAgaWYgKGNvbWJpbmUpIHtcbiAgICByZXR1cm4gY29tYmluZS5kcm9wcGFibGVJZDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IGdldENvbWJpbmVXaXRoRnJvbVJlc3VsdCA9IHJlc3VsdCA9PiB7XG4gIHJldHVybiByZXN1bHQuY29tYmluZSA/IHJlc3VsdC5jb21iaW5lLmRyYWdnYWJsZUlkIDogbnVsbDtcbn07XG5jb25zdCBnZXRDb21iaW5lV2l0aEZyb21JbXBhY3QgPSBpbXBhY3QgPT4ge1xuICByZXR1cm4gaW1wYWN0LmF0ICYmIGltcGFjdC5hdC50eXBlID09PSAnQ09NQklORScgPyBpbXBhY3QuYXQuY29tYmluZS5kcmFnZ2FibGVJZCA6IG51bGw7XG59O1xuZnVuY3Rpb24gZ2V0RHJhZ2dhYmxlU2VsZWN0b3IoKSB7XG4gIGNvbnN0IG1lbW9pemVkT2Zmc2V0ID0gbWVtb2l6ZU9uZSgoeCwgeSkgPT4gKHtcbiAgICB4LFxuICAgIHlcbiAgfSkpO1xuICBjb25zdCBnZXRNZW1vaXplZFNuYXBzaG90ID0gbWVtb2l6ZU9uZSgobW9kZSwgaXNDbG9uZSwgZHJhZ2dpbmdPdmVyID0gbnVsbCwgY29tYmluZVdpdGggPSBudWxsLCBkcm9wcGluZyA9IG51bGwpID0+ICh7XG4gICAgaXNEcmFnZ2luZzogdHJ1ZSxcbiAgICBpc0Nsb25lLFxuICAgIGlzRHJvcEFuaW1hdGluZzogQm9vbGVhbihkcm9wcGluZyksXG4gICAgZHJvcEFuaW1hdGlvbjogZHJvcHBpbmcsXG4gICAgbW9kZSxcbiAgICBkcmFnZ2luZ092ZXIsXG4gICAgY29tYmluZVdpdGgsXG4gICAgY29tYmluZVRhcmdldEZvcjogbnVsbFxuICB9KSk7XG4gIGNvbnN0IGdldE1lbW9pemVkUHJvcHMgPSBtZW1vaXplT25lKChvZmZzZXQsIG1vZGUsIGRpbWVuc2lvbiwgaXNDbG9uZSwgZHJhZ2dpbmdPdmVyID0gbnVsbCwgY29tYmluZVdpdGggPSBudWxsLCBmb3JjZVNob3VsZEFuaW1hdGUgPSBudWxsKSA9PiAoe1xuICAgIG1hcHBlZDoge1xuICAgICAgdHlwZTogJ0RSQUdHSU5HJyxcbiAgICAgIGRyb3BwaW5nOiBudWxsLFxuICAgICAgZHJhZ2dpbmdPdmVyLFxuICAgICAgY29tYmluZVdpdGgsXG4gICAgICBtb2RlLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZGltZW5zaW9uLFxuICAgICAgZm9yY2VTaG91bGRBbmltYXRlLFxuICAgICAgc25hcHNob3Q6IGdldE1lbW9pemVkU25hcHNob3QobW9kZSwgaXNDbG9uZSwgZHJhZ2dpbmdPdmVyLCBjb21iaW5lV2l0aCwgbnVsbClcbiAgICB9XG4gIH0pKTtcbiAgY29uc3Qgc2VsZWN0b3IgPSAoc3RhdGUsIG93blByb3BzKSA9PiB7XG4gICAgaWYgKGlzRHJhZ2dpbmcoc3RhdGUpKSB7XG4gICAgICBpZiAoc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkICE9PSBvd25Qcm9wcy5kcmFnZ2FibGVJZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9mZnNldCA9IHN0YXRlLmN1cnJlbnQuY2xpZW50Lm9mZnNldDtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tvd25Qcm9wcy5kcmFnZ2FibGVJZF07XG4gICAgICBjb25zdCBkcmFnZ2luZ092ZXIgPSB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpO1xuICAgICAgY29uc3QgY29tYmluZVdpdGggPSBnZXRDb21iaW5lV2l0aEZyb21JbXBhY3Qoc3RhdGUuaW1wYWN0KTtcbiAgICAgIGNvbnN0IGZvcmNlU2hvdWxkQW5pbWF0ZSA9IHN0YXRlLmZvcmNlU2hvdWxkQW5pbWF0ZTtcbiAgICAgIHJldHVybiBnZXRNZW1vaXplZFByb3BzKG1lbW9pemVkT2Zmc2V0KG9mZnNldC54LCBvZmZzZXQueSksIHN0YXRlLm1vdmVtZW50TW9kZSwgZGltZW5zaW9uLCBvd25Qcm9wcy5pc0Nsb25lLCBkcmFnZ2luZ092ZXIsIGNvbWJpbmVXaXRoLCBmb3JjZVNob3VsZEFuaW1hdGUpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICAgIGNvbnN0IGNvbXBsZXRlZCA9IHN0YXRlLmNvbXBsZXRlZDtcbiAgICAgIGlmIChjb21wbGV0ZWQucmVzdWx0LmRyYWdnYWJsZUlkICE9PSBvd25Qcm9wcy5kcmFnZ2FibGVJZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzQ2xvbmUgPSBvd25Qcm9wcy5pc0Nsb25lO1xuICAgICAgY29uc3QgZGltZW5zaW9uID0gc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzW293blByb3BzLmRyYWdnYWJsZUlkXTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBsZXRlZC5yZXN1bHQ7XG4gICAgICBjb25zdCBtb2RlID0gcmVzdWx0Lm1vZGU7XG4gICAgICBjb25zdCBkcmFnZ2luZ092ZXIgPSB3aGF0SXNEcmFnZ2VkT3ZlckZyb21SZXN1bHQocmVzdWx0KTtcbiAgICAgIGNvbnN0IGNvbWJpbmVXaXRoID0gZ2V0Q29tYmluZVdpdGhGcm9tUmVzdWx0KHJlc3VsdCk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHN0YXRlLmRyb3BEdXJhdGlvbjtcbiAgICAgIGNvbnN0IGRyb3BwaW5nID0ge1xuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgY3VydmU6IGN1cnZlcy5kcm9wLFxuICAgICAgICBtb3ZlVG86IHN0YXRlLm5ld0hvbWVDbGllbnRPZmZzZXQsXG4gICAgICAgIG9wYWNpdHk6IGNvbWJpbmVXaXRoID8gY29tYmluZS5vcGFjaXR5LmRyb3AgOiBudWxsLFxuICAgICAgICBzY2FsZTogY29tYmluZVdpdGggPyBjb21iaW5lLnNjYWxlLmRyb3AgOiBudWxsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWFwcGVkOiB7XG4gICAgICAgICAgdHlwZTogJ0RSQUdHSU5HJyxcbiAgICAgICAgICBvZmZzZXQ6IHN0YXRlLm5ld0hvbWVDbGllbnRPZmZzZXQsXG4gICAgICAgICAgZGltZW5zaW9uLFxuICAgICAgICAgIGRyb3BwaW5nLFxuICAgICAgICAgIGRyYWdnaW5nT3ZlcixcbiAgICAgICAgICBjb21iaW5lV2l0aCxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogbnVsbCxcbiAgICAgICAgICBzbmFwc2hvdDogZ2V0TWVtb2l6ZWRTbmFwc2hvdChtb2RlLCBpc0Nsb25lLCBkcmFnZ2luZ092ZXIsIGNvbWJpbmVXaXRoLCBkcm9wcGluZylcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIHJldHVybiBzZWxlY3Rvcjtcbn1cbmZ1bmN0aW9uIGdldFNlY29uZGFyeVNuYXBzaG90KGNvbWJpbmVUYXJnZXRGb3IgPSBudWxsKSB7XG4gIHJldHVybiB7XG4gICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgaXNEcm9wQW5pbWF0aW5nOiBmYWxzZSxcbiAgICBpc0Nsb25lOiBmYWxzZSxcbiAgICBkcm9wQW5pbWF0aW9uOiBudWxsLFxuICAgIG1vZGU6IG51bGwsXG4gICAgZHJhZ2dpbmdPdmVyOiBudWxsLFxuICAgIGNvbWJpbmVUYXJnZXRGb3IsXG4gICAgY29tYmluZVdpdGg6IG51bGxcbiAgfTtcbn1cbmNvbnN0IGF0UmVzdCA9IHtcbiAgbWFwcGVkOiB7XG4gICAgdHlwZTogJ1NFQ09OREFSWScsXG4gICAgb2Zmc2V0OiBvcmlnaW4sXG4gICAgY29tYmluZVRhcmdldEZvcjogbnVsbCxcbiAgICBzaG91bGRBbmltYXRlRGlzcGxhY2VtZW50OiB0cnVlLFxuICAgIHNuYXBzaG90OiBnZXRTZWNvbmRhcnlTbmFwc2hvdChudWxsKVxuICB9XG59O1xuZnVuY3Rpb24gZ2V0U2Vjb25kYXJ5U2VsZWN0b3IoKSB7XG4gIGNvbnN0IG1lbW9pemVkT2Zmc2V0ID0gbWVtb2l6ZU9uZSgoeCwgeSkgPT4gKHtcbiAgICB4LFxuICAgIHlcbiAgfSkpO1xuICBjb25zdCBnZXRNZW1vaXplZFNuYXBzaG90ID0gbWVtb2l6ZU9uZShnZXRTZWNvbmRhcnlTbmFwc2hvdCk7XG4gIGNvbnN0IGdldE1lbW9pemVkUHJvcHMgPSBtZW1vaXplT25lKChvZmZzZXQsIGNvbWJpbmVUYXJnZXRGb3IgPSBudWxsLCBzaG91bGRBbmltYXRlRGlzcGxhY2VtZW50KSA9PiAoe1xuICAgIG1hcHBlZDoge1xuICAgICAgdHlwZTogJ1NFQ09OREFSWScsXG4gICAgICBvZmZzZXQsXG4gICAgICBjb21iaW5lVGFyZ2V0Rm9yLFxuICAgICAgc2hvdWxkQW5pbWF0ZURpc3BsYWNlbWVudCxcbiAgICAgIHNuYXBzaG90OiBnZXRNZW1vaXplZFNuYXBzaG90KGNvbWJpbmVUYXJnZXRGb3IpXG4gICAgfVxuICB9KSk7XG4gIGNvbnN0IGdldEZhbGxiYWNrID0gY29tYmluZVRhcmdldEZvciA9PiB7XG4gICAgcmV0dXJuIGNvbWJpbmVUYXJnZXRGb3IgPyBnZXRNZW1vaXplZFByb3BzKG9yaWdpbiwgY29tYmluZVRhcmdldEZvciwgdHJ1ZSkgOiBudWxsO1xuICB9O1xuICBjb25zdCBnZXRQcm9wcyA9IChvd25JZCwgZHJhZ2dpbmdJZCwgaW1wYWN0LCBhZnRlckNyaXRpY2FsKSA9PiB7XG4gICAgY29uc3QgdmlzdWFsRGlzcGxhY2VtZW50ID0gaW1wYWN0LmRpc3BsYWNlZC52aXNpYmxlW293bklkXTtcbiAgICBjb25zdCBpc0FmdGVyQ3JpdGljYWxJblZpcnR1YWxMaXN0ID0gQm9vbGVhbihhZnRlckNyaXRpY2FsLmluVmlydHVhbExpc3QgJiYgYWZ0ZXJDcml0aWNhbC5lZmZlY3RlZFtvd25JZF0pO1xuICAgIGNvbnN0IGNvbWJpbmUgPSB0cnlHZXRDb21iaW5lKGltcGFjdCk7XG4gICAgY29uc3QgY29tYmluZVRhcmdldEZvciA9IGNvbWJpbmUgJiYgY29tYmluZS5kcmFnZ2FibGVJZCA9PT0gb3duSWQgPyBkcmFnZ2luZ0lkIDogbnVsbDtcbiAgICBpZiAoIXZpc3VhbERpc3BsYWNlbWVudCkge1xuICAgICAgaWYgKCFpc0FmdGVyQ3JpdGljYWxJblZpcnR1YWxMaXN0KSB7XG4gICAgICAgIHJldHVybiBnZXRGYWxsYmFjayhjb21iaW5lVGFyZ2V0Rm9yKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbXBhY3QuZGlzcGxhY2VkLmludmlzaWJsZVtvd25JZF0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFuZ2UgPSBuZWdhdGUoYWZ0ZXJDcml0aWNhbC5kaXNwbGFjZWRCeS5wb2ludCk7XG4gICAgICBjb25zdCBvZmZzZXQgPSBtZW1vaXplZE9mZnNldChjaGFuZ2UueCwgY2hhbmdlLnkpO1xuICAgICAgcmV0dXJuIGdldE1lbW9pemVkUHJvcHMob2Zmc2V0LCBjb21iaW5lVGFyZ2V0Rm9yLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGlzQWZ0ZXJDcml0aWNhbEluVmlydHVhbExpc3QpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFjayhjb21iaW5lVGFyZ2V0Rm9yKTtcbiAgICB9XG4gICAgY29uc3QgZGlzcGxhY2VCeSA9IGltcGFjdC5kaXNwbGFjZWRCeS5wb2ludDtcbiAgICBjb25zdCBvZmZzZXQgPSBtZW1vaXplZE9mZnNldChkaXNwbGFjZUJ5LngsIGRpc3BsYWNlQnkueSk7XG4gICAgcmV0dXJuIGdldE1lbW9pemVkUHJvcHMob2Zmc2V0LCBjb21iaW5lVGFyZ2V0Rm9yLCB2aXN1YWxEaXNwbGFjZW1lbnQuc2hvdWxkQW5pbWF0ZSk7XG4gIH07XG4gIGNvbnN0IHNlbGVjdG9yID0gKHN0YXRlLCBvd25Qcm9wcykgPT4ge1xuICAgIGlmIChpc0RyYWdnaW5nKHN0YXRlKSkge1xuICAgICAgaWYgKHN0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZCA9PT0gb3duUHJvcHMuZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0UHJvcHMob3duUHJvcHMuZHJhZ2dhYmxlSWQsIHN0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZCwgc3RhdGUuaW1wYWN0LCBzdGF0ZS5hZnRlckNyaXRpY2FsKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICBjb25zdCBjb21wbGV0ZWQgPSBzdGF0ZS5jb21wbGV0ZWQ7XG4gICAgICBpZiAoY29tcGxldGVkLnJlc3VsdC5kcmFnZ2FibGVJZCA9PT0gb3duUHJvcHMuZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0UHJvcHMob3duUHJvcHMuZHJhZ2dhYmxlSWQsIGNvbXBsZXRlZC5yZXN1bHQuZHJhZ2dhYmxlSWQsIGNvbXBsZXRlZC5pbXBhY3QsIGNvbXBsZXRlZC5hZnRlckNyaXRpY2FsKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIHJldHVybiBzZWxlY3Rvcjtcbn1cbmNvbnN0IG1ha2VNYXBTdGF0ZVRvUHJvcHMkMSA9ICgpID0+IHtcbiAgY29uc3QgZHJhZ2dpbmdTZWxlY3RvciA9IGdldERyYWdnYWJsZVNlbGVjdG9yKCk7XG4gIGNvbnN0IHNlY29uZGFyeVNlbGVjdG9yID0gZ2V0U2Vjb25kYXJ5U2VsZWN0b3IoKTtcbiAgY29uc3Qgc2VsZWN0b3IgPSAoc3RhdGUsIG93blByb3BzKSA9PiBkcmFnZ2luZ1NlbGVjdG9yKHN0YXRlLCBvd25Qcm9wcykgfHwgc2Vjb25kYXJ5U2VsZWN0b3Ioc3RhdGUsIG93blByb3BzKSB8fCBhdFJlc3Q7XG4gIHJldHVybiBzZWxlY3Rvcjtcbn07XG5jb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMkMSA9IHtcbiAgZHJvcEFuaW1hdGlvbkZpbmlzaGVkOiBkcm9wQW5pbWF0aW9uRmluaXNoZWRcbn07XG5jb25zdCBDb25uZWN0ZWREcmFnZ2FibGUgPSBjb25uZWN0KG1ha2VNYXBTdGF0ZVRvUHJvcHMkMSwgbWFwRGlzcGF0Y2hUb1Byb3BzJDEsIG51bGwsIHtcbiAgY29udGV4dDogU3RvcmVDb250ZXh0LFxuICBhcmVTdGF0ZVByb3BzRXF1YWw6IGlzU3RyaWN0RXF1YWxcbn0pKERyYWdnYWJsZSk7XG5cbmZ1bmN0aW9uIFByaXZhdGVEcmFnZ2FibGUocHJvcHMpIHtcbiAgY29uc3QgZHJvcHBhYmxlQ29udGV4dCA9IHVzZVJlcXVpcmVkQ29udGV4dChEcm9wcGFibGVDb250ZXh0KTtcbiAgY29uc3QgaXNVc2luZ0Nsb25lRm9yID0gZHJvcHBhYmxlQ29udGV4dC5pc1VzaW5nQ2xvbmVGb3I7XG4gIGlmIChpc1VzaW5nQ2xvbmVGb3IgPT09IHByb3BzLmRyYWdnYWJsZUlkICYmICFwcm9wcy5pc0Nsb25lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29ubmVjdGVkRHJhZ2dhYmxlLCBwcm9wcyk7XG59XG5mdW5jdGlvbiBQdWJsaWNEcmFnZ2FibGUocHJvcHMpIHtcbiAgY29uc3QgaXNFbmFibGVkID0gdHlwZW9mIHByb3BzLmlzRHJhZ0Rpc2FibGVkID09PSAnYm9vbGVhbicgPyAhcHJvcHMuaXNEcmFnRGlzYWJsZWQgOiB0cnVlO1xuICBjb25zdCBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyA9IEJvb2xlYW4ocHJvcHMuZGlzYWJsZUludGVyYWN0aXZlRWxlbWVudEJsb2NraW5nKTtcbiAgY29uc3Qgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MgPSBCb29sZWFuKHByb3BzLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJpdmF0ZURyYWdnYWJsZSwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgaXNDbG9uZTogZmFsc2UsXG4gICAgaXNFbmFibGVkOiBpc0VuYWJsZWQsXG4gICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHM6IGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzOiBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzc1xuICB9KSk7XG59XG5cbmNvbnN0IGlzRXF1YWwgPSBiYXNlID0+IHZhbHVlID0+IGJhc2UgPT09IHZhbHVlO1xuY29uc3QgaXNTY3JvbGwgPSBpc0VxdWFsKCdzY3JvbGwnKTtcbmNvbnN0IGlzQXV0byA9IGlzRXF1YWwoJ2F1dG8nKTtcbmNvbnN0IGlzVmlzaWJsZSA9IGlzRXF1YWwoJ3Zpc2libGUnKTtcbmNvbnN0IGlzRWl0aGVyID0gKG92ZXJmbG93LCBmbikgPT4gZm4ob3ZlcmZsb3cub3ZlcmZsb3dYKSB8fCBmbihvdmVyZmxvdy5vdmVyZmxvd1kpO1xuY29uc3QgaXNCb3RoID0gKG92ZXJmbG93LCBmbikgPT4gZm4ob3ZlcmZsb3cub3ZlcmZsb3dYKSAmJiBmbihvdmVyZmxvdy5vdmVyZmxvd1kpO1xuY29uc3QgaXNFbGVtZW50U2Nyb2xsYWJsZSA9IGVsID0+IHtcbiAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIGNvbnN0IG92ZXJmbG93ID0ge1xuICAgIG92ZXJmbG93WDogc3R5bGUub3ZlcmZsb3dYLFxuICAgIG92ZXJmbG93WTogc3R5bGUub3ZlcmZsb3dZXG4gIH07XG4gIHJldHVybiBpc0VpdGhlcihvdmVyZmxvdywgaXNTY3JvbGwpIHx8IGlzRWl0aGVyKG92ZXJmbG93LCBpc0F1dG8pO1xufTtcbmNvbnN0IGlzQm9keVNjcm9sbGFibGUgPSAoKSA9PiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGJvZHkgPSBnZXRCb2R5RWxlbWVudCgpO1xuICBjb25zdCBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAhaHRtbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudCgpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGlmICghaXNFbGVtZW50U2Nyb2xsYWJsZShib2R5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBodG1sU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShodG1sKTtcbiAgY29uc3QgaHRtbE92ZXJmbG93ID0ge1xuICAgIG92ZXJmbG93WDogaHRtbFN0eWxlLm92ZXJmbG93WCxcbiAgICBvdmVyZmxvd1k6IGh0bWxTdHlsZS5vdmVyZmxvd1lcbiAgfTtcbiAgaWYgKGlzQm90aChodG1sT3ZlcmZsb3csIGlzVmlzaWJsZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgV2UgaGF2ZSBkZXRlY3RlZCB0aGF0IHlvdXIgPGJvZHk+IGVsZW1lbnQgbWlnaHQgYmUgYSBzY3JvbGwgY29udGFpbmVyLlxuICAgIFdlIGhhdmUgZm91bmQgbm8gcmVsaWFibGUgd2F5IG9mIGRldGVjdGluZyB3aGV0aGVyIHRoZSA8Ym9keT4gZWxlbWVudCBpcyBhIHNjcm9sbCBjb250YWluZXIuXG4gICAgVW5kZXIgbW9zdCBjaXJjdW1zdGFuY2VzIGEgPGJvZHk+IHNjcm9sbCBiYXIgd2lsbCBiZSBvbiB0aGUgPGh0bWw+IGVsZW1lbnQgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudClcblxuICAgIEJlY2F1c2Ugd2UgY2Fubm90IGRldGVybWluZSBpZiB0aGUgPGJvZHk+IGlzIGEgc2Nyb2xsIGNvbnRhaW5lciwgYW5kIGdlbmVyYWxseSBpdCBpcyBub3Qgb25lLFxuICAgIHdlIHdpbGwgYmUgdHJlYXRpbmcgdGhlIDxib2R5PiBhcyAqbm90KiBhIHNjcm9sbCBjb250YWluZXJcblxuICAgIE1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9oZWxsby1wYW5nZWEvZG5kL2Jsb2IvbWFpbi9kb2NzL2d1aWRlcy9ob3ctd2UtZGV0ZWN0LXNjcm9sbC1jb250YWluZXJzLm1kXG4gIGApIDogdm9pZCAwO1xuICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgZ2V0Q2xvc2VzdFNjcm9sbGFibGUgPSBlbCA9PiB7XG4gIGlmIChlbCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgcmV0dXJuIGlzQm9keVNjcm9sbGFibGUoKSA/IGVsIDogbnVsbDtcbiAgfVxuICBpZiAoZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghaXNFbGVtZW50U2Nyb2xsYWJsZShlbCkpIHtcbiAgICByZXR1cm4gZ2V0Q2xvc2VzdFNjcm9sbGFibGUoZWwucGFyZW50RWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIGVsO1xufTtcblxudmFyIGNoZWNrRm9yTmVzdGVkU2Nyb2xsQ29udGFpbmVycyA9IHNjcm9sbGFibGUgPT4ge1xuICBpZiAoIXNjcm9sbGFibGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYW5vdGhlclNjcm9sbFBhcmVudCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlKHNjcm9sbGFibGUucGFyZW50RWxlbWVudCk7XG4gIGlmICghYW5vdGhlclNjcm9sbFBhcmVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICBEcm9wcGFibGU6IHVuc3VwcG9ydGVkIG5lc3RlZCBzY3JvbGwgY29udGFpbmVyIGRldGVjdGVkLlxuICAgIEEgRHJvcHBhYmxlIGNhbiBvbmx5IGhhdmUgb25lIHNjcm9sbCBwYXJlbnQgKHdoaWNoIGNhbiBiZSBpdHNlbGYpXG4gICAgTmVzdGVkIHNjcm9sbCBjb250YWluZXJzIGFyZSBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC5cblxuICAgIFdlIGhvcGUgdG8gc3VwcG9ydCBuZXN0ZWQgc2Nyb2xsIGNvbnRhaW5lcnMgc29vbjogaHR0cHM6Ly9naXRodWIuY29tL2F0bGFzc2lhbi9yZWFjdC1iZWF1dGlmdWwtZG5kL2lzc3Vlcy8xMzFcbiAgYCkgOiB2b2lkIDA7XG59O1xuXG52YXIgZ2V0U2Nyb2xsID0gZWwgPT4gKHtcbiAgeDogZWwuc2Nyb2xsTGVmdCxcbiAgeTogZWwuc2Nyb2xsVG9wXG59KTtcblxuY29uc3QgZ2V0SXNGaXhlZCA9IGVsID0+IHtcbiAgaWYgKCFlbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgaWYgKHN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGdldElzRml4ZWQoZWwucGFyZW50RWxlbWVudCk7XG59O1xudmFyIGdldEVudiA9IHN0YXJ0ID0+IHtcbiAgY29uc3QgY2xvc2VzdFNjcm9sbGFibGUgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZShzdGFydCk7XG4gIGNvbnN0IGlzRml4ZWRPblBhZ2UgPSBnZXRJc0ZpeGVkKHN0YXJ0KTtcbiAgcmV0dXJuIHtcbiAgICBjbG9zZXN0U2Nyb2xsYWJsZSxcbiAgICBpc0ZpeGVkT25QYWdlXG4gIH07XG59O1xuXG52YXIgZ2V0RHJvcHBhYmxlRGltZW5zaW9uID0gKHtcbiAgZGVzY3JpcHRvcixcbiAgaXNFbmFibGVkLFxuICBpc0NvbWJpbmVFbmFibGVkLFxuICBpc0ZpeGVkT25QYWdlLFxuICBkaXJlY3Rpb24sXG4gIGNsaWVudCxcbiAgcGFnZSxcbiAgY2xvc2VzdFxufSkgPT4ge1xuICBjb25zdCBmcmFtZSA9ICgoKSA9PiB7XG4gICAgaWYgKCFjbG9zZXN0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc2Nyb2xsU2l6ZSxcbiAgICAgIGNsaWVudDogZnJhbWVDbGllbnRcbiAgICB9ID0gY2xvc2VzdDtcbiAgICBjb25zdCBtYXhTY3JvbGwgPSBnZXRNYXhTY3JvbGwoe1xuICAgICAgc2Nyb2xsSGVpZ2h0OiBzY3JvbGxTaXplLnNjcm9sbEhlaWdodCxcbiAgICAgIHNjcm9sbFdpZHRoOiBzY3JvbGxTaXplLnNjcm9sbFdpZHRoLFxuICAgICAgaGVpZ2h0OiBmcmFtZUNsaWVudC5wYWRkaW5nQm94LmhlaWdodCxcbiAgICAgIHdpZHRoOiBmcmFtZUNsaWVudC5wYWRkaW5nQm94LndpZHRoXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2VNYXJnaW5Cb3g6IGNsb3Nlc3QucGFnZS5tYXJnaW5Cb3gsXG4gICAgICBmcmFtZUNsaWVudCxcbiAgICAgIHNjcm9sbFNpemUsXG4gICAgICBzaG91bGRDbGlwU3ViamVjdDogY2xvc2VzdC5zaG91bGRDbGlwU3ViamVjdCxcbiAgICAgIHNjcm9sbDoge1xuICAgICAgICBpbml0aWFsOiBjbG9zZXN0LnNjcm9sbCxcbiAgICAgICAgY3VycmVudDogY2xvc2VzdC5zY3JvbGwsXG4gICAgICAgIG1heDogbWF4U2Nyb2xsLFxuICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgdmFsdWU6IG9yaWdpbixcbiAgICAgICAgICBkaXNwbGFjZW1lbnQ6IG9yaWdpblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbiAgY29uc3QgYXhpcyA9IGRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IHZlcnRpY2FsIDogaG9yaXpvbnRhbDtcbiAgY29uc3Qgc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgIHBhZ2UsXG4gICAgd2l0aFBsYWNlaG9sZGVyOiBudWxsLFxuICAgIGF4aXMsXG4gICAgZnJhbWVcbiAgfSk7XG4gIGNvbnN0IGRpbWVuc2lvbiA9IHtcbiAgICBkZXNjcmlwdG9yLFxuICAgIGlzQ29tYmluZUVuYWJsZWQsXG4gICAgaXNGaXhlZE9uUGFnZSxcbiAgICBheGlzLFxuICAgIGlzRW5hYmxlZCxcbiAgICBjbGllbnQsXG4gICAgcGFnZSxcbiAgICBmcmFtZSxcbiAgICBzdWJqZWN0XG4gIH07XG4gIHJldHVybiBkaW1lbnNpb247XG59O1xuXG5jb25zdCBnZXRDbGllbnQgPSAodGFyZ2V0UmVmLCBjbG9zZXN0U2Nyb2xsYWJsZSkgPT4ge1xuICBjb25zdCBiYXNlID0gZ2V0Qm94KHRhcmdldFJlZik7XG4gIGlmICghY2xvc2VzdFNjcm9sbGFibGUpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBpZiAodGFyZ2V0UmVmICE9PSBjbG9zZXN0U2Nyb2xsYWJsZSkge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGNvbnN0IHRvcCA9IGJhc2UucGFkZGluZ0JveC50b3AgLSBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxUb3A7XG4gIGNvbnN0IGxlZnQgPSBiYXNlLnBhZGRpbmdCb3gubGVmdCAtIGNsb3Nlc3RTY3JvbGxhYmxlLnNjcm9sbExlZnQ7XG4gIGNvbnN0IGJvdHRvbSA9IHRvcCArIGNsb3Nlc3RTY3JvbGxhYmxlLnNjcm9sbEhlaWdodDtcbiAgY29uc3QgcmlnaHQgPSBsZWZ0ICsgY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsV2lkdGg7XG4gIGNvbnN0IHBhZGRpbmdCb3ggPSB7XG4gICAgdG9wLFxuICAgIHJpZ2h0LFxuICAgIGJvdHRvbSxcbiAgICBsZWZ0XG4gIH07XG4gIGNvbnN0IGJvcmRlckJveCA9IGV4cGFuZChwYWRkaW5nQm94LCBiYXNlLmJvcmRlcik7XG4gIGNvbnN0IGNsaWVudCA9IGNyZWF0ZUJveCh7XG4gICAgYm9yZGVyQm94LFxuICAgIG1hcmdpbjogYmFzZS5tYXJnaW4sXG4gICAgYm9yZGVyOiBiYXNlLmJvcmRlcixcbiAgICBwYWRkaW5nOiBiYXNlLnBhZGRpbmdcbiAgfSk7XG4gIHJldHVybiBjbGllbnQ7XG59O1xudmFyIGdldERpbWVuc2lvbiA9ICh7XG4gIHJlZixcbiAgZGVzY3JpcHRvcixcbiAgZW52LFxuICB3aW5kb3dTY3JvbGwsXG4gIGRpcmVjdGlvbixcbiAgaXNEcm9wRGlzYWJsZWQsXG4gIGlzQ29tYmluZUVuYWJsZWQsXG4gIHNob3VsZENsaXBTdWJqZWN0XG59KSA9PiB7XG4gIGNvbnN0IGNsb3Nlc3RTY3JvbGxhYmxlID0gZW52LmNsb3Nlc3RTY3JvbGxhYmxlO1xuICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnQocmVmLCBjbG9zZXN0U2Nyb2xsYWJsZSk7XG4gIGNvbnN0IHBhZ2UgPSB3aXRoU2Nyb2xsKGNsaWVudCwgd2luZG93U2Nyb2xsKTtcbiAgY29uc3QgY2xvc2VzdCA9ICgoKSA9PiB7XG4gICAgaWYgKCFjbG9zZXN0U2Nyb2xsYWJsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGZyYW1lQ2xpZW50ID0gZ2V0Qm94KGNsb3Nlc3RTY3JvbGxhYmxlKTtcbiAgICBjb25zdCBzY3JvbGxTaXplID0ge1xuICAgICAgc2Nyb2xsSGVpZ2h0OiBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxIZWlnaHQsXG4gICAgICBzY3JvbGxXaWR0aDogY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsV2lkdGhcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBjbGllbnQ6IGZyYW1lQ2xpZW50LFxuICAgICAgcGFnZTogd2l0aFNjcm9sbChmcmFtZUNsaWVudCwgd2luZG93U2Nyb2xsKSxcbiAgICAgIHNjcm9sbDogZ2V0U2Nyb2xsKGNsb3Nlc3RTY3JvbGxhYmxlKSxcbiAgICAgIHNjcm9sbFNpemUsXG4gICAgICBzaG91bGRDbGlwU3ViamVjdFxuICAgIH07XG4gIH0pKCk7XG4gIGNvbnN0IGRpbWVuc2lvbiA9IGdldERyb3BwYWJsZURpbWVuc2lvbih7XG4gICAgZGVzY3JpcHRvcixcbiAgICBpc0VuYWJsZWQ6ICFpc0Ryb3BEaXNhYmxlZCxcbiAgICBpc0NvbWJpbmVFbmFibGVkLFxuICAgIGlzRml4ZWRPblBhZ2U6IGVudi5pc0ZpeGVkT25QYWdlLFxuICAgIGRpcmVjdGlvbixcbiAgICBjbGllbnQsXG4gICAgcGFnZSxcbiAgICBjbG9zZXN0XG4gIH0pO1xuICByZXR1cm4gZGltZW5zaW9uO1xufTtcblxuY29uc3QgaW1tZWRpYXRlID0ge1xuICBwYXNzaXZlOiBmYWxzZVxufTtcbmNvbnN0IGRlbGF5ZWQgPSB7XG4gIHBhc3NpdmU6IHRydWVcbn07XG52YXIgZ2V0TGlzdGVuZXJPcHRpb25zID0gb3B0aW9ucyA9PiBvcHRpb25zLnNob3VsZFB1Ymxpc2hJbW1lZGlhdGVseSA/IGltbWVkaWF0ZSA6IGRlbGF5ZWQ7XG5cbmNvbnN0IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcgPSBkcmFnZ2luZyA9PiBkcmFnZ2luZyAmJiBkcmFnZ2luZy5lbnYuY2xvc2VzdFNjcm9sbGFibGUgfHwgbnVsbDtcbmZ1bmN0aW9uIHVzZURyb3BwYWJsZVB1Ymxpc2hlcihhcmdzKSB7XG4gIGNvbnN0IHdoaWxlRHJhZ2dpbmdSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGFwcENvbnRleHQgPSB1c2VSZXF1aXJlZENvbnRleHQoQXBwQ29udGV4dCk7XG4gIGNvbnN0IHVuaXF1ZUlkID0gdXNlVW5pcXVlSWQoJ2Ryb3BwYWJsZScpO1xuICBjb25zdCB7XG4gICAgcmVnaXN0cnksXG4gICAgbWFyc2hhbFxuICB9ID0gYXBwQ29udGV4dDtcbiAgY29uc3QgcHJldmlvdXNSZWYgPSB1c2VQcmV2aW91cyhhcmdzKTtcbiAgY29uc3QgZGVzY3JpcHRvciA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBpZDogYXJncy5kcm9wcGFibGVJZCxcbiAgICB0eXBlOiBhcmdzLnR5cGUsXG4gICAgbW9kZTogYXJncy5tb2RlXG4gIH0pLCBbYXJncy5kcm9wcGFibGVJZCwgYXJncy5tb2RlLCBhcmdzLnR5cGVdKTtcbiAgY29uc3QgcHVibGlzaGVkRGVzY3JpcHRvclJlZiA9IHVzZVJlZihkZXNjcmlwdG9yKTtcbiAgY29uc3QgbWVtb2l6ZWRVcGRhdGVTY3JvbGwgPSB1c2VNZW1vKCgpID0+IG1lbW9pemVPbmUoKHgsIHkpID0+IHtcbiAgICAhd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgdXBkYXRlIHNjcm9sbCB3aGVuIGRyYWdnaW5nJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBzY3JvbGwgPSB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gICAgbWFyc2hhbC51cGRhdGVEcm9wcGFibGVTY3JvbGwoZGVzY3JpcHRvci5pZCwgc2Nyb2xsKTtcbiAgfSksIFtkZXNjcmlwdG9yLmlkLCBtYXJzaGFsXSk7XG4gIGNvbnN0IGdldENsb3Nlc3RTY3JvbGwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFkcmFnZ2luZyB8fCAhZHJhZ2dpbmcuZW52LmNsb3Nlc3RTY3JvbGxhYmxlKSB7XG4gICAgICByZXR1cm4gb3JpZ2luO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0U2Nyb2xsKGRyYWdnaW5nLmVudi5jbG9zZXN0U2Nyb2xsYWJsZSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgdXBkYXRlU2Nyb2xsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHNjcm9sbCA9IGdldENsb3Nlc3RTY3JvbGwoKTtcbiAgICBtZW1vaXplZFVwZGF0ZVNjcm9sbChzY3JvbGwueCwgc2Nyb2xsLnkpO1xuICB9LCBbZ2V0Q2xvc2VzdFNjcm9sbCwgbWVtb2l6ZWRVcGRhdGVTY3JvbGxdKTtcbiAgY29uc3Qgc2NoZWR1bGVTY3JvbGxVcGRhdGUgPSB1c2VNZW1vKCgpID0+IHJhZlNjaGQodXBkYXRlU2Nyb2xsKSwgW3VwZGF0ZVNjcm9sbF0pO1xuICBjb25zdCBvbkNsb3Nlc3RTY3JvbGwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgY2xvc2VzdCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcoZHJhZ2dpbmcpO1xuICAgICEoZHJhZ2dpbmcgJiYgY2xvc2VzdCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCBzY3JvbGwgb3B0aW9ucyB3aGlsZSBzY3JvbGxpbmcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBkcmFnZ2luZy5zY3JvbGxPcHRpb25zO1xuICAgIGlmIChvcHRpb25zLnNob3VsZFB1Ymxpc2hJbW1lZGlhdGVseSkge1xuICAgICAgdXBkYXRlU2Nyb2xsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVkdWxlU2Nyb2xsVXBkYXRlKCk7XG4gIH0sIFtzY2hlZHVsZVNjcm9sbFVwZGF0ZSwgdXBkYXRlU2Nyb2xsXSk7XG4gIGNvbnN0IGdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsID0gdXNlQ2FsbGJhY2soKHdpbmRvd1Njcm9sbCwgb3B0aW9ucykgPT4ge1xuICAgICEhd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNvbGxlY3QgYSBkcm9wcGFibGUgd2hpbGUgYSBkcmFnIGlzIG9jY3VycmluZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgcHJldmlvdXMgPSBwcmV2aW91c1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHJlZiA9IHByZXZpb3VzLmdldERyb3BwYWJsZVJlZigpO1xuICAgICFyZWYgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29sbGVjdCB3aXRob3V0IGEgZHJvcHBhYmxlIHJlZicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgZW52ID0gZ2V0RW52KHJlZik7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSB7XG4gICAgICByZWYsXG4gICAgICBkZXNjcmlwdG9yLFxuICAgICAgZW52LFxuICAgICAgc2Nyb2xsT3B0aW9uczogb3B0aW9uc1xuICAgIH07XG4gICAgd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50ID0gZHJhZ2dpbmc7XG4gICAgY29uc3QgZGltZW5zaW9uID0gZ2V0RGltZW5zaW9uKHtcbiAgICAgIHJlZixcbiAgICAgIGRlc2NyaXB0b3IsXG4gICAgICBlbnYsXG4gICAgICB3aW5kb3dTY3JvbGwsXG4gICAgICBkaXJlY3Rpb246IHByZXZpb3VzLmRpcmVjdGlvbixcbiAgICAgIGlzRHJvcERpc2FibGVkOiBwcmV2aW91cy5pc0Ryb3BEaXNhYmxlZCxcbiAgICAgIGlzQ29tYmluZUVuYWJsZWQ6IHByZXZpb3VzLmlzQ29tYmluZUVuYWJsZWQsXG4gICAgICBzaG91bGRDbGlwU3ViamVjdDogIXByZXZpb3VzLmlnbm9yZUNvbnRhaW5lckNsaXBwaW5nXG4gICAgfSk7XG4gICAgY29uc3Qgc2Nyb2xsYWJsZSA9IGVudi5jbG9zZXN0U2Nyb2xsYWJsZTtcbiAgICBpZiAoc2Nyb2xsYWJsZSkge1xuICAgICAgc2Nyb2xsYWJsZS5zZXRBdHRyaWJ1dGUoc2Nyb2xsQ29udGFpbmVyLmNvbnRleHRJZCwgYXBwQ29udGV4dC5jb250ZXh0SWQpO1xuICAgICAgc2Nyb2xsYWJsZS5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvbkNsb3Nlc3RTY3JvbGwsIGdldExpc3RlbmVyT3B0aW9ucyhkcmFnZ2luZy5zY3JvbGxPcHRpb25zKSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja0Zvck5lc3RlZFNjcm9sbENvbnRhaW5lcnMoc2Nyb2xsYWJsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaW1lbnNpb247XG4gIH0sIFthcHBDb250ZXh0LmNvbnRleHRJZCwgZGVzY3JpcHRvciwgb25DbG9zZXN0U2Nyb2xsLCBwcmV2aW91c1JlZl0pO1xuICBjb25zdCBnZXRTY3JvbGxXaGlsZURyYWdnaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGRyYWdnaW5nID0gd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IGNsb3Nlc3QgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnKGRyYWdnaW5nKTtcbiAgICAhKGRyYWdnaW5nICYmIGNsb3Nlc3QpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgcmVjb2xsZWN0IERyb3BwYWJsZSBjbGllbnQgZm9yIERyb3BwYWJsZXMgdGhhdCBoYXZlIGEgc2Nyb2xsIGNvbnRhaW5lcicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGdldFNjcm9sbChjbG9zZXN0KTtcbiAgfSwgW10pO1xuICBjb25zdCBkcmFnU3RvcHBlZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICAhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RvcCBkcmFnIHdoZW4gbm8gYWN0aXZlIGRyYWcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IGNsb3Nlc3QgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnKGRyYWdnaW5nKTtcbiAgICB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIGlmICghY2xvc2VzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzY2hlZHVsZVNjcm9sbFVwZGF0ZS5jYW5jZWwoKTtcbiAgICBjbG9zZXN0LnJlbW92ZUF0dHJpYnV0ZShzY3JvbGxDb250YWluZXIuY29udGV4dElkKTtcbiAgICBjbG9zZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uQ2xvc2VzdFNjcm9sbCwgZ2V0TGlzdGVuZXJPcHRpb25zKGRyYWdnaW5nLnNjcm9sbE9wdGlvbnMpKTtcbiAgfSwgW29uQ2xvc2VzdFNjcm9sbCwgc2NoZWR1bGVTY3JvbGxVcGRhdGVdKTtcbiAgY29uc3Qgc2Nyb2xsID0gdXNlQ2FsbGJhY2soY2hhbmdlID0+IHtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICAhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc2Nyb2xsIHdoZW4gdGhlcmUgaXMgbm8gZHJhZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgY2xvc2VzdCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcoZHJhZ2dpbmcpO1xuICAgICFjbG9zZXN0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHNjcm9sbCBhIGRyb3BwYWJsZSB3aXRoIG5vIGNsb3Nlc3Qgc2Nyb2xsYWJsZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY2xvc2VzdC5zY3JvbGxUb3AgKz0gY2hhbmdlLnk7XG4gICAgY2xvc2VzdC5zY3JvbGxMZWZ0ICs9IGNoYW5nZS54O1xuICB9LCBbXSk7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBnZXREaW1lbnNpb25BbmRXYXRjaFNjcm9sbCxcbiAgICAgIGdldFNjcm9sbFdoaWxlRHJhZ2dpbmcsXG4gICAgICBkcmFnU3RvcHBlZCxcbiAgICAgIHNjcm9sbFxuICAgIH07XG4gIH0sIFtkcmFnU3RvcHBlZCwgZ2V0RGltZW5zaW9uQW5kV2F0Y2hTY3JvbGwsIGdldFNjcm9sbFdoaWxlRHJhZ2dpbmcsIHNjcm9sbF0pO1xuICBjb25zdCBlbnRyeSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICB1bmlxdWVJZCxcbiAgICBkZXNjcmlwdG9yLFxuICAgIGNhbGxiYWNrc1xuICB9KSwgW2NhbGxiYWNrcywgZGVzY3JpcHRvciwgdW5pcXVlSWRdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcHVibGlzaGVkRGVzY3JpcHRvclJlZi5jdXJyZW50ID0gZW50cnkuZGVzY3JpcHRvcjtcbiAgICByZWdpc3RyeS5kcm9wcGFibGUucmVnaXN0ZXIoZW50cnkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAod2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50KSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ1Vuc3VwcG9ydGVkOiBjaGFuZ2luZyB0aGUgZHJvcHBhYmxlSWQgb3IgdHlwZSBvZiBhIERyb3BwYWJsZSBkdXJpbmcgYSBkcmFnJykgOiB2b2lkIDA7XG4gICAgICAgIGRyYWdTdG9wcGVkKCk7XG4gICAgICB9XG4gICAgICByZWdpc3RyeS5kcm9wcGFibGUudW5yZWdpc3RlcihlbnRyeSk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrcywgZGVzY3JpcHRvciwgZHJhZ1N0b3BwZWQsIGVudHJ5LCBtYXJzaGFsLCByZWdpc3RyeS5kcm9wcGFibGVdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWFyc2hhbC51cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQocHVibGlzaGVkRGVzY3JpcHRvclJlZi5jdXJyZW50LmlkLCAhYXJncy5pc0Ryb3BEaXNhYmxlZCk7XG4gIH0sIFthcmdzLmlzRHJvcERpc2FibGVkLCBtYXJzaGFsXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hcnNoYWwudXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZChwdWJsaXNoZWREZXNjcmlwdG9yUmVmLmN1cnJlbnQuaWQsIGFyZ3MuaXNDb21iaW5lRW5hYmxlZCk7XG4gIH0sIFthcmdzLmlzQ29tYmluZUVuYWJsZWQsIG1hcnNoYWxdKTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5jb25zdCBlbXB0eSA9IHtcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcbiAgbWFyZ2luOiBub1NwYWNpbmdcbn07XG5jb25zdCBnZXRTaXplID0gKHtcbiAgaXNBbmltYXRpbmdPcGVuT25Nb3VudCxcbiAgcGxhY2Vob2xkZXIsXG4gIGFuaW1hdGVcbn0pID0+IHtcbiAgaWYgKGlzQW5pbWF0aW5nT3Blbk9uTW91bnQpIHtcbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cbiAgaWYgKGFuaW1hdGUgPT09ICdjbG9zZScpIHtcbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IHBsYWNlaG9sZGVyLmNsaWVudC5ib3JkZXJCb3guaGVpZ2h0LFxuICAgIHdpZHRoOiBwbGFjZWhvbGRlci5jbGllbnQuYm9yZGVyQm94LndpZHRoLFxuICAgIG1hcmdpbjogcGxhY2Vob2xkZXIuY2xpZW50Lm1hcmdpblxuICB9O1xufTtcbmNvbnN0IGdldFN0eWxlID0gKHtcbiAgaXNBbmltYXRpbmdPcGVuT25Nb3VudCxcbiAgcGxhY2Vob2xkZXIsXG4gIGFuaW1hdGVcbn0pID0+IHtcbiAgY29uc3Qgc2l6ZSA9IGdldFNpemUoe1xuICAgIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgYW5pbWF0ZVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBkaXNwbGF5OiBwbGFjZWhvbGRlci5kaXNwbGF5LFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgbWFyZ2luVG9wOiBzaXplLm1hcmdpbi50b3AsXG4gICAgbWFyZ2luUmlnaHQ6IHNpemUubWFyZ2luLnJpZ2h0LFxuICAgIG1hcmdpbkJvdHRvbTogc2l6ZS5tYXJnaW4uYm90dG9tLFxuICAgIG1hcmdpbkxlZnQ6IHNpemUubWFyZ2luLmxlZnQsXG4gICAgZmxleFNocmluazogJzAnLFxuICAgIGZsZXhHcm93OiAnMCcsXG4gICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgIHRyYW5zaXRpb246IGFuaW1hdGUgIT09ICdub25lJyA/IHRyYW5zaXRpb25zLnBsYWNlaG9sZGVyIDogbnVsbFxuICB9O1xufTtcbmNvbnN0IFBsYWNlaG9sZGVyID0gcHJvcHMgPT4ge1xuICBjb25zdCBhbmltYXRlT3BlblRpbWVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCB0cnlDbGVhckFuaW1hdGVPcGVuVGltZXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFhbmltYXRlT3BlblRpbWVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCk7XG4gICAgYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgfSwgW10pO1xuICBjb25zdCB7XG4gICAgYW5pbWF0ZSxcbiAgICBvblRyYW5zaXRpb25FbmQsXG4gICAgb25DbG9zZSxcbiAgICBjb250ZXh0SWRcbiAgfSA9IHByb3BzO1xuICBjb25zdCBbaXNBbmltYXRpbmdPcGVuT25Nb3VudCwgc2V0SXNBbmltYXRpbmdPcGVuT25Nb3VudF0gPSB1c2VTdGF0ZShwcm9wcy5hbmltYXRlID09PSAnb3BlbicpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNBbmltYXRpbmdPcGVuT25Nb3VudCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIGlmIChhbmltYXRlICE9PSAnb3BlbicpIHtcbiAgICAgIHRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lcigpO1xuICAgICAgc2V0SXNBbmltYXRpbmdPcGVuT25Nb3VudChmYWxzZSk7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gICAgaWYgKGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHNldElzQW5pbWF0aW5nT3Blbk9uTW91bnQoZmFsc2UpO1xuICAgIH0pO1xuICAgIHJldHVybiB0cnlDbGVhckFuaW1hdGVPcGVuVGltZXI7XG4gIH0sIFthbmltYXRlLCBpc0FuaW1hdGluZ09wZW5Pbk1vdW50LCB0cnlDbGVhckFuaW1hdGVPcGVuVGltZXJdKTtcbiAgY29uc3Qgb25TaXplQ2hhbmdlRW5kID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgIGlmIChldmVudC5wcm9wZXJ0eU5hbWUgIT09ICdoZWlnaHQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9uVHJhbnNpdGlvbkVuZCgpO1xuICAgIGlmIChhbmltYXRlID09PSAnY2xvc2UnKSB7XG4gICAgICBvbkNsb3NlKCk7XG4gICAgfVxuICB9LCBbYW5pbWF0ZSwgb25DbG9zZSwgb25UcmFuc2l0aW9uRW5kXSk7XG4gIGNvbnN0IHN0eWxlID0gZ2V0U3R5bGUoe1xuICAgIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQsXG4gICAgYW5pbWF0ZTogcHJvcHMuYW5pbWF0ZSxcbiAgICBwbGFjZWhvbGRlcjogcHJvcHMucGxhY2Vob2xkZXJcbiAgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHByb3BzLnBsYWNlaG9sZGVyLnRhZ05hbWUsIHtcbiAgICBzdHlsZSxcbiAgICAnZGF0YS1yZmQtcGxhY2Vob2xkZXItY29udGV4dC1pZCc6IGNvbnRleHRJZCxcbiAgICBvblRyYW5zaXRpb25FbmQ6IG9uU2l6ZUNoYW5nZUVuZCxcbiAgICByZWY6IHByb3BzLmlubmVyUmVmXG4gIH0pO1xufTtcbnZhciBQbGFjZWhvbGRlciQxID0gUmVhY3QubWVtbyhQbGFjZWhvbGRlcik7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG59XG5mdW5jdGlvbiBydW5DaGVja3MoYXJncywgY2hlY2tzKSB7XG4gIGNoZWNrcy5mb3JFYWNoKGNoZWNrID0+IGNoZWNrKGFyZ3MpKTtcbn1cbmNvbnN0IHNoYXJlZCA9IFtmdW5jdGlvbiByZXF1aXJlZCh7XG4gIHByb3BzXG59KSB7XG4gICFwcm9wcy5kcm9wcGFibGVJZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0EgRHJvcHBhYmxlIHJlcXVpcmVzIGEgZHJvcHBhYmxlSWQgcHJvcCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICEodHlwZW9mIHByb3BzLmRyb3BwYWJsZUlkID09PSAnc3RyaW5nJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBBIERyb3BwYWJsZSByZXF1aXJlcyBhIFtzdHJpbmddIGRyb3BwYWJsZUlkLiBQcm92aWRlZDogWyR7dHlwZW9mIHByb3BzLmRyb3BwYWJsZUlkfV1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xufSwgZnVuY3Rpb24gYm9vbGVhbih7XG4gIHByb3BzXG59KSB7XG4gICFpc0Jvb2xlYW4ocHJvcHMuaXNEcm9wRGlzYWJsZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnaXNEcm9wRGlzYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4nKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAhaXNCb29sZWFuKHByb3BzLmlzQ29tYmluZUVuYWJsZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnaXNDb21iaW5lRW5hYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICFpc0Jvb2xlYW4ocHJvcHMuaWdub3JlQ29udGFpbmVyQ2xpcHBpbmcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnaWdub3JlQ29udGFpbmVyQ2xpcHBpbmcgbXVzdCBiZSBhIGJvb2xlYW4nKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xufSwgZnVuY3Rpb24gcmVmKHtcbiAgZ2V0RHJvcHBhYmxlUmVmXG59KSB7XG4gIGNoZWNrSXNWYWxpZElubmVyUmVmKGdldERyb3BwYWJsZVJlZigpKTtcbn1dO1xuY29uc3Qgc3RhbmRhcmQgPSBbZnVuY3Rpb24gcGxhY2Vob2xkZXIoe1xuICBwcm9wcyxcbiAgZ2V0UGxhY2Vob2xkZXJSZWZcbn0pIHtcbiAgaWYgKCFwcm9wcy5wbGFjZWhvbGRlcikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZWYgPSBnZXRQbGFjZWhvbGRlclJlZigpO1xuICBpZiAocmVmKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgRHJvcHBhYmxlIHNldHVwIGlzc3VlIFtkcm9wcGFibGVJZDogXCIke3Byb3BzLmRyb3BwYWJsZUlkfVwiXTpcbiAgICAgIERyb3BwYWJsZVByb3ZpZGVkID4gcGxhY2Vob2xkZXIgY291bGQgbm90IGJlIGZvdW5kLlxuXG4gICAgICBQbGVhc2UgYmUgc3VyZSB0byBhZGQgdGhlIHtwcm92aWRlZC5wbGFjZWhvbGRlcn0gUmVhY3QgTm9kZSBhcyBhIGNoaWxkIG9mIHlvdXIgRHJvcHBhYmxlLlxuICAgICAgTW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL2hlbGxvLXBhbmdlYS9kbmQvYmxvYi9tYWluL2RvY3MvYXBpL2Ryb3BwYWJsZS5tZFxuICAgIGApIDogdm9pZCAwO1xufV07XG5jb25zdCB2aXJ0dWFsID0gW2Z1bmN0aW9uIGhhc0Nsb25lKHtcbiAgcHJvcHNcbn0pIHtcbiAgIXByb3BzLnJlbmRlckNsb25lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnTXVzdCBwcm92aWRlIGEgY2xvbmUgcmVuZGVyIGZ1bmN0aW9uIChyZW5kZXJDbG9uZSkgZm9yIHZpcnR1YWwgbGlzdHMnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xufSwgZnVuY3Rpb24gaGFzTm9QbGFjZWhvbGRlcih7XG4gIGdldFBsYWNlaG9sZGVyUmVmXG59KSB7XG4gICEhZ2V0UGxhY2Vob2xkZXJSZWYoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHZpcnR1YWwgbGlzdCB0byBub3QgaGF2ZSBhIHBsYWNlaG9sZGVyJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbn1dO1xuZnVuY3Rpb24gdXNlVmFsaWRhdGlvbihhcmdzKSB7XG4gIHVzZURldlNldHVwV2FybmluZygoKSA9PiB7XG4gICAgcnVuQ2hlY2tzKGFyZ3MsIHNoYXJlZCk7XG4gICAgaWYgKGFyZ3MucHJvcHMubW9kZSA9PT0gJ3N0YW5kYXJkJykge1xuICAgICAgcnVuQ2hlY2tzKGFyZ3MsIHN0YW5kYXJkKTtcbiAgICB9XG4gICAgaWYgKGFyZ3MucHJvcHMubW9kZSA9PT0gJ3ZpcnR1YWwnKSB7XG4gICAgICBydW5DaGVja3MoYXJncywgdmlydHVhbCk7XG4gICAgfVxuICB9KTtcbn1cblxuY2xhc3MgQW5pbWF0ZUluT3V0IGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaXNWaXNpYmxlOiBCb29sZWFuKHRoaXMucHJvcHMub24pLFxuICAgICAgZGF0YTogdGhpcy5wcm9wcy5vbixcbiAgICAgIGFuaW1hdGU6IHRoaXMucHJvcHMuc2hvdWxkQW5pbWF0ZSAmJiB0aGlzLnByb3BzLm9uID8gJ29wZW4nIDogJ25vbmUnXG4gICAgfTtcbiAgICB0aGlzLm9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5hbmltYXRlICE9PSAnY2xvc2UnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc1Zpc2libGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgaWYgKCFwcm9wcy5zaG91bGRBbmltYXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1Zpc2libGU6IEJvb2xlYW4ocHJvcHMub24pLFxuICAgICAgICBkYXRhOiBwcm9wcy5vbixcbiAgICAgICAgYW5pbWF0ZTogJ25vbmUnXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAocHJvcHMub24pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgZGF0YTogcHJvcHMub24sXG4gICAgICAgIGFuaW1hdGU6ICdvcGVuJ1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICBkYXRhOiBzdGF0ZS5kYXRhLFxuICAgICAgICBhbmltYXRlOiAnY2xvc2UnXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgIGFuaW1hdGU6ICdjbG9zZScsXG4gICAgICBkYXRhOiBudWxsXG4gICAgfTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHByb3ZpZGVkID0ge1xuICAgICAgb25DbG9zZTogdGhpcy5vbkNsb3NlLFxuICAgICAgZGF0YTogdGhpcy5zdGF0ZS5kYXRhLFxuICAgICAgYW5pbWF0ZTogdGhpcy5zdGF0ZS5hbmltYXRlXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbihwcm92aWRlZCk7XG4gIH1cbn1cblxuY29uc3QgRHJvcHBhYmxlID0gcHJvcHMgPT4ge1xuICBjb25zdCBhcHBDb250ZXh0ID0gdXNlQ29udGV4dChBcHBDb250ZXh0KTtcbiAgIWFwcENvbnRleHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCBhcHAgY29udGV4dCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IHtcbiAgICBjb250ZXh0SWQsXG4gICAgaXNNb3ZlbWVudEFsbG93ZWRcbiAgfSA9IGFwcENvbnRleHQ7XG4gIGNvbnN0IGRyb3BwYWJsZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgcGxhY2Vob2xkZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBkcm9wcGFibGVJZCxcbiAgICB0eXBlLFxuICAgIG1vZGUsXG4gICAgZGlyZWN0aW9uLFxuICAgIGlnbm9yZUNvbnRhaW5lckNsaXBwaW5nLFxuICAgIGlzRHJvcERpc2FibGVkLFxuICAgIGlzQ29tYmluZUVuYWJsZWQsXG4gICAgc25hcHNob3QsXG4gICAgdXNlQ2xvbmUsXG4gICAgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGwsXG4gICAgZ2V0Q29udGFpbmVyRm9yQ2xvbmVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBnZXREcm9wcGFibGVSZWYgPSB1c2VDYWxsYmFjaygoKSA9PiBkcm9wcGFibGVSZWYuY3VycmVudCwgW10pO1xuICBjb25zdCBzZXREcm9wcGFibGVSZWYgPSB1c2VDYWxsYmFjaygodmFsdWUgPSBudWxsKSA9PiB7XG4gICAgZHJvcHBhYmxlUmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW10pO1xuICBjb25zdCBnZXRQbGFjZWhvbGRlclJlZiA9IHVzZUNhbGxiYWNrKCgpID0+IHBsYWNlaG9sZGVyUmVmLmN1cnJlbnQsIFtdKTtcbiAgY29uc3Qgc2V0UGxhY2Vob2xkZXJSZWYgPSB1c2VDYWxsYmFjaygodmFsdWUgPSBudWxsKSA9PiB7XG4gICAgcGxhY2Vob2xkZXJSZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbXSk7XG4gIHVzZVZhbGlkYXRpb24oe1xuICAgIHByb3BzLFxuICAgIGdldERyb3BwYWJsZVJlZixcbiAgICBnZXRQbGFjZWhvbGRlclJlZlxuICB9KTtcbiAgY29uc3Qgb25QbGFjZWhvbGRlclRyYW5zaXRpb25FbmQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGlzTW92ZW1lbnRBbGxvd2VkKCkpIHtcbiAgICAgIHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsKHtcbiAgICAgICAgbWF4U2Nyb2xsOiBnZXRNYXhXaW5kb3dTY3JvbGwoKVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbaXNNb3ZlbWVudEFsbG93ZWQsIHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsXSk7XG4gIHVzZURyb3BwYWJsZVB1Ymxpc2hlcih7XG4gICAgZHJvcHBhYmxlSWQsXG4gICAgdHlwZSxcbiAgICBtb2RlLFxuICAgIGRpcmVjdGlvbixcbiAgICBpc0Ryb3BEaXNhYmxlZCxcbiAgICBpc0NvbWJpbmVFbmFibGVkLFxuICAgIGlnbm9yZUNvbnRhaW5lckNsaXBwaW5nLFxuICAgIGdldERyb3BwYWJsZVJlZlxuICB9KTtcbiAgY29uc3QgcGxhY2Vob2xkZXIgPSB1c2VNZW1vKCgpID0+IFJlYWN0LmNyZWF0ZUVsZW1lbnQoQW5pbWF0ZUluT3V0LCB7XG4gICAgb246IHByb3BzLnBsYWNlaG9sZGVyLFxuICAgIHNob3VsZEFuaW1hdGU6IHByb3BzLnNob3VsZEFuaW1hdGVQbGFjZWhvbGRlclxuICB9LCAoe1xuICAgIG9uQ2xvc2UsXG4gICAgZGF0YSxcbiAgICBhbmltYXRlXG4gIH0pID0+IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGxhY2Vob2xkZXIkMSwge1xuICAgIHBsYWNlaG9sZGVyOiBkYXRhLFxuICAgIG9uQ2xvc2U6IG9uQ2xvc2UsXG4gICAgaW5uZXJSZWY6IHNldFBsYWNlaG9sZGVyUmVmLFxuICAgIGFuaW1hdGU6IGFuaW1hdGUsXG4gICAgY29udGV4dElkOiBjb250ZXh0SWQsXG4gICAgb25UcmFuc2l0aW9uRW5kOiBvblBsYWNlaG9sZGVyVHJhbnNpdGlvbkVuZFxuICB9KSksIFtjb250ZXh0SWQsIG9uUGxhY2Vob2xkZXJUcmFuc2l0aW9uRW5kLCBwcm9wcy5wbGFjZWhvbGRlciwgcHJvcHMuc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyLCBzZXRQbGFjZWhvbGRlclJlZl0pO1xuICBjb25zdCBwcm92aWRlZCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBpbm5lclJlZjogc2V0RHJvcHBhYmxlUmVmLFxuICAgIHBsYWNlaG9sZGVyLFxuICAgIGRyb3BwYWJsZVByb3BzOiB7XG4gICAgICAnZGF0YS1yZmQtZHJvcHBhYmxlLWlkJzogZHJvcHBhYmxlSWQsXG4gICAgICAnZGF0YS1yZmQtZHJvcHBhYmxlLWNvbnRleHQtaWQnOiBjb250ZXh0SWRcbiAgICB9XG4gIH0pLCBbY29udGV4dElkLCBkcm9wcGFibGVJZCwgcGxhY2Vob2xkZXIsIHNldERyb3BwYWJsZVJlZl0pO1xuICBjb25zdCBpc1VzaW5nQ2xvbmVGb3IgPSB1c2VDbG9uZSA/IHVzZUNsb25lLmRyYWdnaW5nLmRyYWdnYWJsZUlkIDogbnVsbDtcbiAgY29uc3QgZHJvcHBhYmxlQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBkcm9wcGFibGVJZCxcbiAgICB0eXBlLFxuICAgIGlzVXNpbmdDbG9uZUZvclxuICB9KSwgW2Ryb3BwYWJsZUlkLCBpc1VzaW5nQ2xvbmVGb3IsIHR5cGVdKTtcbiAgZnVuY3Rpb24gZ2V0Q2xvbmUoKSB7XG4gICAgaWYgKCF1c2VDbG9uZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRyYWdnaW5nLFxuICAgICAgcmVuZGVyXG4gICAgfSA9IHVzZUNsb25lO1xuICAgIGNvbnN0IG5vZGUgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFByaXZhdGVEcmFnZ2FibGUsIHtcbiAgICAgIGRyYWdnYWJsZUlkOiBkcmFnZ2luZy5kcmFnZ2FibGVJZCxcbiAgICAgIGluZGV4OiBkcmFnZ2luZy5zb3VyY2UuaW5kZXgsXG4gICAgICBpc0Nsb25lOiB0cnVlLFxuICAgICAgaXNFbmFibGVkOiB0cnVlLFxuICAgICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M6IGZhbHNlLFxuICAgICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHM6IHRydWVcbiAgICB9LCAoZHJhZ2dhYmxlUHJvdmlkZWQsIGRyYWdnYWJsZVNuYXBzaG90KSA9PiByZW5kZXIoZHJhZ2dhYmxlUHJvdmlkZWQsIGRyYWdnYWJsZVNuYXBzaG90LCBkcmFnZ2luZykpO1xuICAgIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwobm9kZSwgZ2V0Q29udGFpbmVyRm9yQ2xvbmUoKSk7XG4gIH1cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRHJvcHBhYmxlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBkcm9wcGFibGVDb250ZXh0XG4gIH0sIGNoaWxkcmVuKHByb3ZpZGVkLCBzbmFwc2hvdCksIGdldENsb25lKCkpO1xufTtcblxuZnVuY3Rpb24gZ2V0Qm9keSgpIHtcbiAgIWRvY3VtZW50LmJvZHkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdkb2N1bWVudC5ib2R5IGlzIG5vdCByZWFkeScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIHJldHVybiBkb2N1bWVudC5ib2R5O1xufVxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBtb2RlOiAnc3RhbmRhcmQnLFxuICB0eXBlOiAnREVGQVVMVCcsXG4gIGRpcmVjdGlvbjogJ3ZlcnRpY2FsJyxcbiAgaXNEcm9wRGlzYWJsZWQ6IGZhbHNlLFxuICBpc0NvbWJpbmVFbmFibGVkOiBmYWxzZSxcbiAgaWdub3JlQ29udGFpbmVyQ2xpcHBpbmc6IGZhbHNlLFxuICByZW5kZXJDbG9uZTogbnVsbCxcbiAgZ2V0Q29udGFpbmVyRm9yQ2xvbmU6IGdldEJvZHlcbn07XG5jb25zdCBhdHRhY2hEZWZhdWx0UHJvcHNUb093blByb3BzID0gb3duUHJvcHMgPT4ge1xuICBsZXQgbWVyZ2VkUHJvcHMgPSB7XG4gICAgLi4ub3duUHJvcHNcbiAgfTtcbiAgbGV0IGRlZmF1bHRQcm9wS2V5O1xuICBmb3IgKGRlZmF1bHRQcm9wS2V5IGluIGRlZmF1bHRQcm9wcykge1xuICAgIGlmIChvd25Qcm9wc1tkZWZhdWx0UHJvcEtleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgbWVyZ2VkUHJvcHMgPSB7XG4gICAgICAgIC4uLm1lcmdlZFByb3BzLFxuICAgICAgICBbZGVmYXVsdFByb3BLZXldOiBkZWZhdWx0UHJvcHNbZGVmYXVsdFByb3BLZXldXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VkUHJvcHM7XG59O1xuY29uc3QgaXNNYXRjaGluZ1R5cGUgPSAodHlwZSwgY3JpdGljYWwpID0+IHR5cGUgPT09IGNyaXRpY2FsLmRyb3BwYWJsZS50eXBlO1xuY29uc3QgZ2V0RHJhZ2dhYmxlID0gKGNyaXRpY2FsLCBkaW1lbnNpb25zKSA9PiBkaW1lbnNpb25zLmRyYWdnYWJsZXNbY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbmNvbnN0IG1ha2VNYXBTdGF0ZVRvUHJvcHMgPSAoKSA9PiB7XG4gIGNvbnN0IGlkbGVXaXRoQW5pbWF0aW9uID0ge1xuICAgIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgIHNob3VsZEFuaW1hdGVQbGFjZWhvbGRlcjogdHJ1ZSxcbiAgICBzbmFwc2hvdDoge1xuICAgICAgaXNEcmFnZ2luZ092ZXI6IGZhbHNlLFxuICAgICAgZHJhZ2dpbmdPdmVyV2l0aDogbnVsbCxcbiAgICAgIGRyYWdnaW5nRnJvbVRoaXNXaXRoOiBudWxsLFxuICAgICAgaXNVc2luZ1BsYWNlaG9sZGVyOiBmYWxzZVxuICAgIH0sXG4gICAgdXNlQ2xvbmU6IG51bGxcbiAgfTtcbiAgY29uc3QgaWRsZVdpdGhvdXRBbmltYXRpb24gPSB7XG4gICAgLi4uaWRsZVdpdGhBbmltYXRpb24sXG4gICAgc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyOiBmYWxzZVxuICB9O1xuICBjb25zdCBnZXREcmFnZ2FibGVSdWJyaWMgPSBtZW1vaXplT25lKGRlc2NyaXB0b3IgPT4gKHtcbiAgICBkcmFnZ2FibGVJZDogZGVzY3JpcHRvci5pZCxcbiAgICB0eXBlOiBkZXNjcmlwdG9yLnR5cGUsXG4gICAgc291cmNlOiB7XG4gICAgICBpbmRleDogZGVzY3JpcHRvci5pbmRleCxcbiAgICAgIGRyb3BwYWJsZUlkOiBkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXG4gICAgfVxuICB9KSk7XG4gIGNvbnN0IGdldE1hcFByb3BzID0gbWVtb2l6ZU9uZSgoaWQsIGlzRW5hYmxlZCwgaXNEcmFnZ2luZ092ZXJGb3JDb25zdW1lciwgaXNEcmFnZ2luZ092ZXJGb3JJbXBhY3QsIGRyYWdnaW5nLCByZW5kZXJDbG9uZSkgPT4ge1xuICAgIGNvbnN0IGRyYWdnYWJsZUlkID0gZHJhZ2dpbmcuZGVzY3JpcHRvci5pZDtcbiAgICBjb25zdCBpc0hvbWUgPSBkcmFnZ2luZy5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkID09PSBpZDtcbiAgICBpZiAoaXNIb21lKSB7XG4gICAgICBjb25zdCB1c2VDbG9uZSA9IHJlbmRlckNsb25lID8ge1xuICAgICAgICByZW5kZXI6IHJlbmRlckNsb25lLFxuICAgICAgICBkcmFnZ2luZzogZ2V0RHJhZ2dhYmxlUnVicmljKGRyYWdnaW5nLmRlc2NyaXB0b3IpXG4gICAgICB9IDogbnVsbDtcbiAgICAgIGNvbnN0IHNuYXBzaG90ID0ge1xuICAgICAgICBpc0RyYWdnaW5nT3ZlcjogaXNEcmFnZ2luZ092ZXJGb3JDb25zdW1lcixcbiAgICAgICAgZHJhZ2dpbmdPdmVyV2l0aDogaXNEcmFnZ2luZ092ZXJGb3JDb25zdW1lciA/IGRyYWdnYWJsZUlkIDogbnVsbCxcbiAgICAgICAgZHJhZ2dpbmdGcm9tVGhpc1dpdGg6IGRyYWdnYWJsZUlkLFxuICAgICAgICBpc1VzaW5nUGxhY2Vob2xkZXI6IHRydWVcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwbGFjZWhvbGRlcjogZHJhZ2dpbmcucGxhY2Vob2xkZXIsXG4gICAgICAgIHNob3VsZEFuaW1hdGVQbGFjZWhvbGRlcjogZmFsc2UsXG4gICAgICAgIHNuYXBzaG90LFxuICAgICAgICB1c2VDbG9uZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFpc0VuYWJsZWQpIHtcbiAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0RyYWdnaW5nT3ZlckZvckltcGFjdCkge1xuICAgICAgcmV0dXJuIGlkbGVXaXRoQW5pbWF0aW9uO1xuICAgIH1cbiAgICBjb25zdCBzbmFwc2hvdCA9IHtcbiAgICAgIGlzRHJhZ2dpbmdPdmVyOiBpc0RyYWdnaW5nT3ZlckZvckNvbnN1bWVyLFxuICAgICAgZHJhZ2dpbmdPdmVyV2l0aDogZHJhZ2dhYmxlSWQsXG4gICAgICBkcmFnZ2luZ0Zyb21UaGlzV2l0aDogbnVsbCxcbiAgICAgIGlzVXNpbmdQbGFjZWhvbGRlcjogdHJ1ZVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHBsYWNlaG9sZGVyOiBkcmFnZ2luZy5wbGFjZWhvbGRlcixcbiAgICAgIHNob3VsZEFuaW1hdGVQbGFjZWhvbGRlcjogdHJ1ZSxcbiAgICAgIHNuYXBzaG90LFxuICAgICAgdXNlQ2xvbmU6IG51bGxcbiAgICB9O1xuICB9KTtcbiAgY29uc3Qgc2VsZWN0b3IgPSAoc3RhdGUsIG93blByb3BzKSA9PiB7XG4gICAgY29uc3Qgb3duUHJvcHNXaXRoRGVmYXVsdFByb3BzID0gYXR0YWNoRGVmYXVsdFByb3BzVG9Pd25Qcm9wcyhvd25Qcm9wcyk7XG4gICAgY29uc3QgaWQgPSBvd25Qcm9wc1dpdGhEZWZhdWx0UHJvcHMuZHJvcHBhYmxlSWQ7XG4gICAgY29uc3QgdHlwZSA9IG93blByb3BzV2l0aERlZmF1bHRQcm9wcy50eXBlO1xuICAgIGNvbnN0IGlzRW5hYmxlZCA9ICFvd25Qcm9wc1dpdGhEZWZhdWx0UHJvcHMuaXNEcm9wRGlzYWJsZWQ7XG4gICAgY29uc3QgcmVuZGVyQ2xvbmUgPSBvd25Qcm9wc1dpdGhEZWZhdWx0UHJvcHMucmVuZGVyQ2xvbmU7XG4gICAgaWYgKGlzRHJhZ2dpbmcoc3RhdGUpKSB7XG4gICAgICBjb25zdCBjcml0aWNhbCA9IHN0YXRlLmNyaXRpY2FsO1xuICAgICAgaWYgKCFpc01hdGNoaW5nVHlwZSh0eXBlLCBjcml0aWNhbCkpIHtcbiAgICAgICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZ2dpbmcgPSBnZXREcmFnZ2FibGUoY3JpdGljYWwsIHN0YXRlLmRpbWVuc2lvbnMpO1xuICAgICAgY29uc3QgaXNEcmFnZ2luZ092ZXIgPSB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpID09PSBpZDtcbiAgICAgIHJldHVybiBnZXRNYXBQcm9wcyhpZCwgaXNFbmFibGVkLCBpc0RyYWdnaW5nT3ZlciwgaXNEcmFnZ2luZ092ZXIsIGRyYWdnaW5nLCByZW5kZXJDbG9uZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgY29uc3QgY29tcGxldGVkID0gc3RhdGUuY29tcGxldGVkO1xuICAgICAgaWYgKCFpc01hdGNoaW5nVHlwZSh0eXBlLCBjb21wbGV0ZWQuY3JpdGljYWwpKSB7XG4gICAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRyYWdnaW5nID0gZ2V0RHJhZ2dhYmxlKGNvbXBsZXRlZC5jcml0aWNhbCwgc3RhdGUuZGltZW5zaW9ucyk7XG4gICAgICByZXR1cm4gZ2V0TWFwUHJvcHMoaWQsIGlzRW5hYmxlZCwgd2hhdElzRHJhZ2dlZE92ZXJGcm9tUmVzdWx0KGNvbXBsZXRlZC5yZXN1bHQpID09PSBpZCwgd2hhdElzRHJhZ2dlZE92ZXIoY29tcGxldGVkLmltcGFjdCkgPT09IGlkLCBkcmFnZ2luZywgcmVuZGVyQ2xvbmUpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJyAmJiBzdGF0ZS5jb21wbGV0ZWQgJiYgIXN0YXRlLnNob3VsZEZsdXNoKSB7XG4gICAgICBjb25zdCBjb21wbGV0ZWQgPSBzdGF0ZS5jb21wbGV0ZWQ7XG4gICAgICBpZiAoIWlzTWF0Y2hpbmdUeXBlKHR5cGUsIGNvbXBsZXRlZC5jcml0aWNhbCkpIHtcbiAgICAgICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2FzT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKGNvbXBsZXRlZC5pbXBhY3QpID09PSBpZDtcbiAgICAgIGNvbnN0IHdhc0NvbWJpbmluZyA9IEJvb2xlYW4oY29tcGxldGVkLmltcGFjdC5hdCAmJiBjb21wbGV0ZWQuaW1wYWN0LmF0LnR5cGUgPT09ICdDT01CSU5FJyk7XG4gICAgICBjb25zdCBpc0hvbWUgPSBjb21wbGV0ZWQuY3JpdGljYWwuZHJvcHBhYmxlLmlkID09PSBpZDtcbiAgICAgIGlmICh3YXNPdmVyKSB7XG4gICAgICAgIHJldHVybiB3YXNDb21iaW5pbmcgPyBpZGxlV2l0aEFuaW1hdGlvbiA6IGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKGlzSG9tZSkge1xuICAgICAgICByZXR1cm4gaWRsZVdpdGhBbmltYXRpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgfVxuICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgfTtcbiAgcmV0dXJuIHNlbGVjdG9yO1xufTtcbmNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IHtcbiAgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGw6IHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsXG59O1xuY29uc3QgQ29ubmVjdGVkRHJvcHBhYmxlID0gY29ubmVjdChtYWtlTWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIChzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLmF0dGFjaERlZmF1bHRQcm9wc1RvT3duUHJvcHMob3duUHJvcHMpLFxuICAgIC4uLnN0YXRlUHJvcHMsXG4gICAgLi4uZGlzcGF0Y2hQcm9wc1xuICB9O1xufSwge1xuICBjb250ZXh0OiBTdG9yZUNvbnRleHQsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbDogaXNTdHJpY3RFcXVhbFxufSkoRHJvcHBhYmxlKTtcblxuZXhwb3J0IHsgRHJhZ0Ryb3BDb250ZXh0LCBQdWJsaWNEcmFnZ2FibGUgYXMgRHJhZ2dhYmxlLCBDb25uZWN0ZWREcm9wcGFibGUgYXMgRHJvcHBhYmxlLCB1c2VLZXlib2FyZFNlbnNvciwgdXNlTW91c2VTZW5zb3IsIHVzZVRvdWNoU2Vuc29yIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@hello-pangea/dnd/dist/dnd.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/css-box-model/dist/css-box-model.esm.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-box-model/dist/css-box-model.esm.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateBox: () => (/* binding */ calculateBox),\n/* harmony export */   createBox: () => (/* binding */ createBox),\n/* harmony export */   expand: () => (/* binding */ expand),\n/* harmony export */   getBox: () => (/* binding */ getBox),\n/* harmony export */   getRect: () => (/* binding */ getRect),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   shrink: () => (/* binding */ shrink),\n/* harmony export */   withScroll: () => (/* binding */ withScroll)\n/* harmony export */ });\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-invariant */ \"(app-pages-browser)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n\n\nvar getRect = function getRect(_ref) {\n  var top = _ref.top,\n      right = _ref.right,\n      bottom = _ref.bottom,\n      left = _ref.left;\n  var width = right - left;\n  var height = bottom - top;\n  var rect = {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left,\n    width: width,\n    height: height,\n    x: left,\n    y: top,\n    center: {\n      x: (right + left) / 2,\n      y: (bottom + top) / 2\n    }\n  };\n  return rect;\n};\nvar expand = function expand(target, expandBy) {\n  return {\n    top: target.top - expandBy.top,\n    left: target.left - expandBy.left,\n    bottom: target.bottom + expandBy.bottom,\n    right: target.right + expandBy.right\n  };\n};\nvar shrink = function shrink(target, shrinkBy) {\n  return {\n    top: target.top + shrinkBy.top,\n    left: target.left + shrinkBy.left,\n    bottom: target.bottom - shrinkBy.bottom,\n    right: target.right - shrinkBy.right\n  };\n};\n\nvar shift = function shift(target, shiftBy) {\n  return {\n    top: target.top + shiftBy.y,\n    left: target.left + shiftBy.x,\n    bottom: target.bottom + shiftBy.y,\n    right: target.right + shiftBy.x\n  };\n};\n\nvar noSpacing = {\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0\n};\nvar createBox = function createBox(_ref2) {\n  var borderBox = _ref2.borderBox,\n      _ref2$margin = _ref2.margin,\n      margin = _ref2$margin === void 0 ? noSpacing : _ref2$margin,\n      _ref2$border = _ref2.border,\n      border = _ref2$border === void 0 ? noSpacing : _ref2$border,\n      _ref2$padding = _ref2.padding,\n      padding = _ref2$padding === void 0 ? noSpacing : _ref2$padding;\n  var marginBox = getRect(expand(borderBox, margin));\n  var paddingBox = getRect(shrink(borderBox, border));\n  var contentBox = getRect(shrink(paddingBox, padding));\n  return {\n    marginBox: marginBox,\n    borderBox: getRect(borderBox),\n    paddingBox: paddingBox,\n    contentBox: contentBox,\n    margin: margin,\n    border: border,\n    padding: padding\n  };\n};\n\nvar parse = function parse(raw) {\n  var value = raw.slice(0, -2);\n  var suffix = raw.slice(-2);\n\n  if (suffix !== 'px') {\n    return 0;\n  }\n\n  var result = Number(value);\n  !!isNaN(result) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(false, \"Could not parse value [raw: \" + raw + \", without suffix: \" + value + \"]\") : 0 : void 0;\n  return result;\n};\n\nvar getWindowScroll = function getWindowScroll() {\n  return {\n    x: window.pageXOffset,\n    y: window.pageYOffset\n  };\n};\n\nvar offset = function offset(original, change) {\n  var borderBox = original.borderBox,\n      border = original.border,\n      margin = original.margin,\n      padding = original.padding;\n  var shifted = shift(borderBox, change);\n  return createBox({\n    borderBox: shifted,\n    border: border,\n    margin: margin,\n    padding: padding\n  });\n};\nvar withScroll = function withScroll(original, scroll) {\n  if (scroll === void 0) {\n    scroll = getWindowScroll();\n  }\n\n  return offset(original, scroll);\n};\nvar calculateBox = function calculateBox(borderBox, styles) {\n  var margin = {\n    top: parse(styles.marginTop),\n    right: parse(styles.marginRight),\n    bottom: parse(styles.marginBottom),\n    left: parse(styles.marginLeft)\n  };\n  var padding = {\n    top: parse(styles.paddingTop),\n    right: parse(styles.paddingRight),\n    bottom: parse(styles.paddingBottom),\n    left: parse(styles.paddingLeft)\n  };\n  var border = {\n    top: parse(styles.borderTopWidth),\n    right: parse(styles.borderRightWidth),\n    bottom: parse(styles.borderBottomWidth),\n    left: parse(styles.borderLeftWidth)\n  };\n  return createBox({\n    borderBox: borderBox,\n    margin: margin,\n    padding: padding,\n    border: border\n  });\n};\nvar getBox = function getBox(el) {\n  var borderBox = el.getBoundingClientRect();\n  var styles = window.getComputedStyle(el);\n  return calculateBox(borderBox, styles);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jc3MtYm94LW1vZGVsL2Rpc3QvY3NzLWJveC1tb2RlbC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixLQUFxQyxHQUFHLDBEQUFTLHFGQUFxRixDQUFnQjtBQUMxSztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXdGIiwic291cmNlcyI6WyIvYXBwL25vZGVfbW9kdWxlcy9jc3MtYm94LW1vZGVsL2Rpc3QvY3NzLWJveC1tb2RlbC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LWludmFyaWFudCc7XG5cbnZhciBnZXRSZWN0ID0gZnVuY3Rpb24gZ2V0UmVjdChfcmVmKSB7XG4gIHZhciB0b3AgPSBfcmVmLnRvcCxcbiAgICAgIHJpZ2h0ID0gX3JlZi5yaWdodCxcbiAgICAgIGJvdHRvbSA9IF9yZWYuYm90dG9tLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdDtcbiAgdmFyIHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICB2YXIgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICB2YXIgcmVjdCA9IHtcbiAgICB0b3A6IHRvcCxcbiAgICByaWdodDogcmlnaHQsXG4gICAgYm90dG9tOiBib3R0b20sXG4gICAgbGVmdDogbGVmdCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogbGVmdCxcbiAgICB5OiB0b3AsXG4gICAgY2VudGVyOiB7XG4gICAgICB4OiAocmlnaHQgKyBsZWZ0KSAvIDIsXG4gICAgICB5OiAoYm90dG9tICsgdG9wKSAvIDJcbiAgICB9XG4gIH07XG4gIHJldHVybiByZWN0O1xufTtcbnZhciBleHBhbmQgPSBmdW5jdGlvbiBleHBhbmQodGFyZ2V0LCBleHBhbmRCeSkge1xuICByZXR1cm4ge1xuICAgIHRvcDogdGFyZ2V0LnRvcCAtIGV4cGFuZEJ5LnRvcCxcbiAgICBsZWZ0OiB0YXJnZXQubGVmdCAtIGV4cGFuZEJ5LmxlZnQsXG4gICAgYm90dG9tOiB0YXJnZXQuYm90dG9tICsgZXhwYW5kQnkuYm90dG9tLFxuICAgIHJpZ2h0OiB0YXJnZXQucmlnaHQgKyBleHBhbmRCeS5yaWdodFxuICB9O1xufTtcbnZhciBzaHJpbmsgPSBmdW5jdGlvbiBzaHJpbmsodGFyZ2V0LCBzaHJpbmtCeSkge1xuICByZXR1cm4ge1xuICAgIHRvcDogdGFyZ2V0LnRvcCArIHNocmlua0J5LnRvcCxcbiAgICBsZWZ0OiB0YXJnZXQubGVmdCArIHNocmlua0J5LmxlZnQsXG4gICAgYm90dG9tOiB0YXJnZXQuYm90dG9tIC0gc2hyaW5rQnkuYm90dG9tLFxuICAgIHJpZ2h0OiB0YXJnZXQucmlnaHQgLSBzaHJpbmtCeS5yaWdodFxuICB9O1xufTtcblxudmFyIHNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQodGFyZ2V0LCBzaGlmdEJ5KSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiB0YXJnZXQudG9wICsgc2hpZnRCeS55LFxuICAgIGxlZnQ6IHRhcmdldC5sZWZ0ICsgc2hpZnRCeS54LFxuICAgIGJvdHRvbTogdGFyZ2V0LmJvdHRvbSArIHNoaWZ0QnkueSxcbiAgICByaWdodDogdGFyZ2V0LnJpZ2h0ICsgc2hpZnRCeS54XG4gIH07XG59O1xuXG52YXIgbm9TcGFjaW5nID0ge1xuICB0b3A6IDAsXG4gIHJpZ2h0OiAwLFxuICBib3R0b206IDAsXG4gIGxlZnQ6IDBcbn07XG52YXIgY3JlYXRlQm94ID0gZnVuY3Rpb24gY3JlYXRlQm94KF9yZWYyKSB7XG4gIHZhciBib3JkZXJCb3ggPSBfcmVmMi5ib3JkZXJCb3gsXG4gICAgICBfcmVmMiRtYXJnaW4gPSBfcmVmMi5tYXJnaW4sXG4gICAgICBtYXJnaW4gPSBfcmVmMiRtYXJnaW4gPT09IHZvaWQgMCA/IG5vU3BhY2luZyA6IF9yZWYyJG1hcmdpbixcbiAgICAgIF9yZWYyJGJvcmRlciA9IF9yZWYyLmJvcmRlcixcbiAgICAgIGJvcmRlciA9IF9yZWYyJGJvcmRlciA9PT0gdm9pZCAwID8gbm9TcGFjaW5nIDogX3JlZjIkYm9yZGVyLFxuICAgICAgX3JlZjIkcGFkZGluZyA9IF9yZWYyLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nID0gX3JlZjIkcGFkZGluZyA9PT0gdm9pZCAwID8gbm9TcGFjaW5nIDogX3JlZjIkcGFkZGluZztcbiAgdmFyIG1hcmdpbkJveCA9IGdldFJlY3QoZXhwYW5kKGJvcmRlckJveCwgbWFyZ2luKSk7XG4gIHZhciBwYWRkaW5nQm94ID0gZ2V0UmVjdChzaHJpbmsoYm9yZGVyQm94LCBib3JkZXIpKTtcbiAgdmFyIGNvbnRlbnRCb3ggPSBnZXRSZWN0KHNocmluayhwYWRkaW5nQm94LCBwYWRkaW5nKSk7XG4gIHJldHVybiB7XG4gICAgbWFyZ2luQm94OiBtYXJnaW5Cb3gsXG4gICAgYm9yZGVyQm94OiBnZXRSZWN0KGJvcmRlckJveCksXG4gICAgcGFkZGluZ0JveDogcGFkZGluZ0JveCxcbiAgICBjb250ZW50Qm94OiBjb250ZW50Qm94LFxuICAgIG1hcmdpbjogbWFyZ2luLFxuICAgIGJvcmRlcjogYm9yZGVyLFxuICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgfTtcbn07XG5cbnZhciBwYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHJhdykge1xuICB2YXIgdmFsdWUgPSByYXcuc2xpY2UoMCwgLTIpO1xuICB2YXIgc3VmZml4ID0gcmF3LnNsaWNlKC0yKTtcblxuICBpZiAoc3VmZml4ICE9PSAncHgnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gTnVtYmVyKHZhbHVlKTtcbiAgISFpc05hTihyZXN1bHQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkNvdWxkIG5vdCBwYXJzZSB2YWx1ZSBbcmF3OiBcIiArIHJhdyArIFwiLCB3aXRob3V0IHN1ZmZpeDogXCIgKyB2YWx1ZSArIFwiXVwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgZ2V0V2luZG93U2Nyb2xsID0gZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKCkge1xuICByZXR1cm4ge1xuICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgfTtcbn07XG5cbnZhciBvZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQob3JpZ2luYWwsIGNoYW5nZSkge1xuICB2YXIgYm9yZGVyQm94ID0gb3JpZ2luYWwuYm9yZGVyQm94LFxuICAgICAgYm9yZGVyID0gb3JpZ2luYWwuYm9yZGVyLFxuICAgICAgbWFyZ2luID0gb3JpZ2luYWwubWFyZ2luLFxuICAgICAgcGFkZGluZyA9IG9yaWdpbmFsLnBhZGRpbmc7XG4gIHZhciBzaGlmdGVkID0gc2hpZnQoYm9yZGVyQm94LCBjaGFuZ2UpO1xuICByZXR1cm4gY3JlYXRlQm94KHtcbiAgICBib3JkZXJCb3g6IHNoaWZ0ZWQsXG4gICAgYm9yZGVyOiBib3JkZXIsXG4gICAgbWFyZ2luOiBtYXJnaW4sXG4gICAgcGFkZGluZzogcGFkZGluZ1xuICB9KTtcbn07XG52YXIgd2l0aFNjcm9sbCA9IGZ1bmN0aW9uIHdpdGhTY3JvbGwob3JpZ2luYWwsIHNjcm9sbCkge1xuICBpZiAoc2Nyb2xsID09PSB2b2lkIDApIHtcbiAgICBzY3JvbGwgPSBnZXRXaW5kb3dTY3JvbGwoKTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQob3JpZ2luYWwsIHNjcm9sbCk7XG59O1xudmFyIGNhbGN1bGF0ZUJveCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUJveChib3JkZXJCb3gsIHN0eWxlcykge1xuICB2YXIgbWFyZ2luID0ge1xuICAgIHRvcDogcGFyc2Uoc3R5bGVzLm1hcmdpblRvcCksXG4gICAgcmlnaHQ6IHBhcnNlKHN0eWxlcy5tYXJnaW5SaWdodCksXG4gICAgYm90dG9tOiBwYXJzZShzdHlsZXMubWFyZ2luQm90dG9tKSxcbiAgICBsZWZ0OiBwYXJzZShzdHlsZXMubWFyZ2luTGVmdClcbiAgfTtcbiAgdmFyIHBhZGRpbmcgPSB7XG4gICAgdG9wOiBwYXJzZShzdHlsZXMucGFkZGluZ1RvcCksXG4gICAgcmlnaHQ6IHBhcnNlKHN0eWxlcy5wYWRkaW5nUmlnaHQpLFxuICAgIGJvdHRvbTogcGFyc2Uoc3R5bGVzLnBhZGRpbmdCb3R0b20pLFxuICAgIGxlZnQ6IHBhcnNlKHN0eWxlcy5wYWRkaW5nTGVmdClcbiAgfTtcbiAgdmFyIGJvcmRlciA9IHtcbiAgICB0b3A6IHBhcnNlKHN0eWxlcy5ib3JkZXJUb3BXaWR0aCksXG4gICAgcmlnaHQ6IHBhcnNlKHN0eWxlcy5ib3JkZXJSaWdodFdpZHRoKSxcbiAgICBib3R0b206IHBhcnNlKHN0eWxlcy5ib3JkZXJCb3R0b21XaWR0aCksXG4gICAgbGVmdDogcGFyc2Uoc3R5bGVzLmJvcmRlckxlZnRXaWR0aClcbiAgfTtcbiAgcmV0dXJuIGNyZWF0ZUJveCh7XG4gICAgYm9yZGVyQm94OiBib3JkZXJCb3gsXG4gICAgbWFyZ2luOiBtYXJnaW4sXG4gICAgcGFkZGluZzogcGFkZGluZyxcbiAgICBib3JkZXI6IGJvcmRlclxuICB9KTtcbn07XG52YXIgZ2V0Qm94ID0gZnVuY3Rpb24gZ2V0Qm94KGVsKSB7XG4gIHZhciBib3JkZXJCb3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgcmV0dXJuIGNhbGN1bGF0ZUJveChib3JkZXJCb3gsIHN0eWxlcyk7XG59O1xuXG5leHBvcnQgeyBjYWxjdWxhdGVCb3gsIGNyZWF0ZUJveCwgZXhwYW5kLCBnZXRCb3gsIGdldFJlY3QsIG9mZnNldCwgc2hyaW5rLCB3aXRoU2Nyb2xsIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/css-box-model/dist/css-box-model.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/raf-schd/dist/raf-schd.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/raf-schd/dist/raf-schd.esm.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar rafSchd = function rafSchd(fn) {\n  var lastArgs = [];\n  var frameId = null;\n\n  var wrapperFn = function wrapperFn() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    lastArgs = args;\n\n    if (frameId) {\n      return;\n    }\n\n    frameId = requestAnimationFrame(function () {\n      frameId = null;\n      fn.apply(void 0, lastArgs);\n    });\n  };\n\n  wrapperFn.cancel = function () {\n    if (!frameId) {\n      return;\n    }\n\n    cancelAnimationFrame(frameId);\n    frameId = null;\n  };\n\n  return wrapperFn;\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (rafSchd);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yYWYtc2NoZC9kaXN0L3JhZi1zY2hkLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlFQUFlLE9BQU8sRUFBQyIsInNvdXJjZXMiOlsiL2FwcC9ub2RlX21vZHVsZXMvcmFmLXNjaGQvZGlzdC9yYWYtc2NoZC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHJhZlNjaGQgPSBmdW5jdGlvbiByYWZTY2hkKGZuKSB7XG4gIHZhciBsYXN0QXJncyA9IFtdO1xuICB2YXIgZnJhbWVJZCA9IG51bGw7XG5cbiAgdmFyIHdyYXBwZXJGbiA9IGZ1bmN0aW9uIHdyYXBwZXJGbigpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgbGFzdEFyZ3MgPSBhcmdzO1xuXG4gICAgaWYgKGZyYW1lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZyYW1lSWQgPSBudWxsO1xuICAgICAgZm4uYXBwbHkodm9pZCAwLCBsYXN0QXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgd3JhcHBlckZuLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWZyYW1lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICBmcmFtZUlkID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gd3JhcHBlckZuO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgcmFmU2NoZDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/raf-schd/dist/raf-schd.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/dist/react-redux.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/react-redux/dist/react-redux.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider_default),\n/* harmony export */   ReactReduxContext: () => (/* binding */ ReactReduxContext),\n/* harmony export */   batch: () => (/* binding */ batch),\n/* harmony export */   connect: () => (/* binding */ connect_default),\n/* harmony export */   createDispatchHook: () => (/* binding */ createDispatchHook),\n/* harmony export */   createSelectorHook: () => (/* binding */ createSelectorHook),\n/* harmony export */   createStoreHook: () => (/* binding */ createStoreHook),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual),\n/* harmony export */   useDispatch: () => (/* binding */ useDispatch),\n/* harmony export */   useSelector: () => (/* binding */ useSelector),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/with-selector.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/with-selector.js\");\n// src/utils/react.ts\n\n\n// src/utils/react-is.ts\nvar IS_REACT_19 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.version.startsWith(\"19\");\nvar REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for(\n  IS_REACT_19 ? \"react.transitional.element\" : \"react.element\"\n);\nvar REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for(\"react.portal\");\nvar REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for(\"react.fragment\");\nvar REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for(\"react.strict_mode\");\nvar REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for(\"react.profiler\");\nvar REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for(\"react.consumer\");\nvar REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for(\"react.context\");\nvar REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for(\"react.forward_ref\");\nvar REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for(\"react.suspense\");\nvar REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for(\n  \"react.suspense_list\"\n);\nvar REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for(\"react.memo\");\nvar REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for(\"react.lazy\");\nvar REACT_OFFSCREEN_TYPE = /* @__PURE__ */ Symbol.for(\"react.offscreen\");\nvar REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for(\n  \"react.client.reference\"\n);\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nfunction isValidElementType(type) {\n  return typeof type === \"string\" || typeof type === \"function\" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || typeof type === \"object\" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) ? true : false;\n}\nfunction typeOf(object) {\n  if (typeof object === \"object\" && object !== null) {\n    const { $$typeof } = object;\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        switch (object = object.type, object) {\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n          case REACT_SUSPENSE_LIST_TYPE:\n            return object;\n          default:\n            switch (object = object && object.$$typeof, object) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n                return object;\n              case REACT_CONSUMER_TYPE:\n                return object;\n              default:\n                return $$typeof;\n            }\n        }\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n}\nfunction isContextConsumer(object) {\n  return IS_REACT_19 ? typeOf(object) === REACT_CONSUMER_TYPE : typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\n\n// src/utils/warning.ts\nfunction warning(message) {\n  if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n    console.error(message);\n  }\n  try {\n    throw new Error(message);\n  } catch (e) {\n  }\n}\n\n// src/connect/verifySubselectors.ts\nfunction verify(selector, methodName) {\n  if (!selector) {\n    throw new Error(`Unexpected value for ${methodName} in connect.`);\n  } else if (methodName === \"mapStateToProps\" || methodName === \"mapDispatchToProps\") {\n    if (!Object.prototype.hasOwnProperty.call(selector, \"dependsOnOwnProps\")) {\n      warning(\n        `The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`\n      );\n    }\n  }\n}\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\n  verify(mapStateToProps, \"mapStateToProps\");\n  verify(mapDispatchToProps, \"mapDispatchToProps\");\n  verify(mergeProps, \"mergeProps\");\n}\n\n// src/connect/selectorFactory.ts\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, {\n  areStatesEqual,\n  areOwnPropsEqual,\n  areStatePropsEqual\n}) {\n  let hasRunAtLeastOnce = false;\n  let state;\n  let ownProps;\n  let stateProps;\n  let dispatchProps;\n  let mergedProps;\n  function handleFirstCall(firstState, firstOwnProps) {\n    state = firstState;\n    ownProps = firstOwnProps;\n    stateProps = mapStateToProps(state, ownProps);\n    dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    hasRunAtLeastOnce = true;\n    return mergedProps;\n  }\n  function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps)\n      dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps)\n      stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps)\n      dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleNewState() {\n    const nextStateProps = mapStateToProps(state, ownProps);\n    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n    stateProps = nextStateProps;\n    if (statePropsChanged)\n      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleSubsequentCalls(nextState, nextOwnProps) {\n    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n    const stateChanged = !areStatesEqual(\n      nextState,\n      state,\n      nextOwnProps,\n      ownProps\n    );\n    state = nextState;\n    ownProps = nextOwnProps;\n    if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n    if (propsChanged) return handleNewProps();\n    if (stateChanged) return handleNewState();\n    return mergedProps;\n  }\n  return function pureFinalPropsSelector(nextState, nextOwnProps) {\n    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n  };\n}\nfunction finalPropsSelectorFactory(dispatch, {\n  initMapStateToProps,\n  initMapDispatchToProps,\n  initMergeProps,\n  ...options\n}) {\n  const mapStateToProps = initMapStateToProps(dispatch, options);\n  const mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n  const mergeProps = initMergeProps(dispatch, options);\n  if (true) {\n    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);\n  }\n  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n\n// src/utils/bindActionCreators.ts\nfunction bindActionCreators(actionCreators, dispatch) {\n  const boundActionCreators = {};\n  for (const key in actionCreators) {\n    const actionCreator = actionCreators[key];\n    if (typeof actionCreator === \"function\") {\n      boundActionCreators[key] = (...args) => dispatch(actionCreator(...args));\n    }\n  }\n  return boundActionCreators;\n}\n\n// src/utils/isPlainObject.ts\nfunction isPlainObject(obj) {\n  if (typeof obj !== \"object\" || obj === null) return false;\n  const proto = Object.getPrototypeOf(obj);\n  if (proto === null) return true;\n  let baseProto = proto;\n  while (Object.getPrototypeOf(baseProto) !== null) {\n    baseProto = Object.getPrototypeOf(baseProto);\n  }\n  return proto === baseProto;\n}\n\n// src/utils/verifyPlainObject.ts\nfunction verifyPlainObject(value, displayName, methodName) {\n  if (!isPlainObject(value)) {\n    warning(\n      `${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`\n    );\n  }\n}\n\n// src/connect/wrapMapToProps.ts\nfunction wrapMapToPropsConstant(getConstant) {\n  return function initConstantSelector(dispatch) {\n    const constant = getConstant(dispatch);\n    function constantSelector() {\n      return constant;\n    }\n    constantSelector.dependsOnOwnProps = false;\n    return constantSelector;\n  };\n}\nfunction getDependsOnOwnProps(mapToProps) {\n  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n}\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n  return function initProxySelector(dispatch, { displayName }) {\n    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);\n    };\n    proxy.dependsOnOwnProps = true;\n    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n      proxy.mapToProps = mapToProps;\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n      let props = proxy(stateOrDispatch, ownProps);\n      if (typeof props === \"function\") {\n        proxy.mapToProps = props;\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n        props = proxy(stateOrDispatch, ownProps);\n      }\n      if (true)\n        verifyPlainObject(props, displayName, methodName);\n      return props;\n    };\n    return proxy;\n  };\n}\n\n// src/connect/invalidArgFactory.ts\nfunction createInvalidArgFactory(arg, name) {\n  return (dispatch, options) => {\n    throw new Error(\n      `Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`\n    );\n  };\n}\n\n// src/connect/mapDispatchToProps.ts\nfunction mapDispatchToPropsFactory(mapDispatchToProps) {\n  return mapDispatchToProps && typeof mapDispatchToProps === \"object\" ? wrapMapToPropsConstant(\n    (dispatch) => (\n      // @ts-ignore\n      bindActionCreators(mapDispatchToProps, dispatch)\n    )\n  ) : !mapDispatchToProps ? wrapMapToPropsConstant((dispatch) => ({\n    dispatch\n  })) : typeof mapDispatchToProps === \"function\" ? (\n    // @ts-ignore\n    wrapMapToPropsFunc(mapDispatchToProps, \"mapDispatchToProps\")\n  ) : createInvalidArgFactory(mapDispatchToProps, \"mapDispatchToProps\");\n}\n\n// src/connect/mapStateToProps.ts\nfunction mapStateToPropsFactory(mapStateToProps) {\n  return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps === \"function\" ? (\n    // @ts-ignore\n    wrapMapToPropsFunc(mapStateToProps, \"mapStateToProps\")\n  ) : createInvalidArgFactory(mapStateToProps, \"mapStateToProps\");\n}\n\n// src/connect/mergeProps.ts\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n  return { ...ownProps, ...stateProps, ...dispatchProps };\n}\nfunction wrapMergePropsFunc(mergeProps) {\n  return function initMergePropsProxy(dispatch, { displayName, areMergedPropsEqual }) {\n    let hasRunOnce = false;\n    let mergedProps;\n    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n      if (hasRunOnce) {\n        if (!areMergedPropsEqual(nextMergedProps, mergedProps))\n          mergedProps = nextMergedProps;\n      } else {\n        hasRunOnce = true;\n        mergedProps = nextMergedProps;\n        if (true)\n          verifyPlainObject(mergedProps, displayName, \"mergeProps\");\n      }\n      return mergedProps;\n    };\n  };\n}\nfunction mergePropsFactory(mergeProps) {\n  return !mergeProps ? () => defaultMergeProps : typeof mergeProps === \"function\" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, \"mergeProps\");\n}\n\n// src/utils/batch.ts\nfunction defaultNoopBatch(callback) {\n  callback();\n}\n\n// src/utils/Subscription.ts\nfunction createListenerCollection() {\n  let first = null;\n  let last = null;\n  return {\n    clear() {\n      first = null;\n      last = null;\n    },\n    notify() {\n      defaultNoopBatch(() => {\n        let listener = first;\n        while (listener) {\n          listener.callback();\n          listener = listener.next;\n        }\n      });\n    },\n    get() {\n      const listeners = [];\n      let listener = first;\n      while (listener) {\n        listeners.push(listener);\n        listener = listener.next;\n      }\n      return listeners;\n    },\n    subscribe(callback) {\n      let isSubscribed = true;\n      const listener = last = {\n        callback,\n        next: null,\n        prev: last\n      };\n      if (listener.prev) {\n        listener.prev.next = listener;\n      } else {\n        first = listener;\n      }\n      return function unsubscribe() {\n        if (!isSubscribed || first === null) return;\n        isSubscribed = false;\n        if (listener.next) {\n          listener.next.prev = listener.prev;\n        } else {\n          last = listener.prev;\n        }\n        if (listener.prev) {\n          listener.prev.next = listener.next;\n        } else {\n          first = listener.next;\n        }\n      };\n    }\n  };\n}\nvar nullListeners = {\n  notify() {\n  },\n  get: () => []\n};\nfunction createSubscription(store, parentSub) {\n  let unsubscribe;\n  let listeners = nullListeners;\n  let subscriptionsAmount = 0;\n  let selfSubscribed = false;\n  function addNestedSub(listener) {\n    trySubscribe();\n    const cleanupListener = listeners.subscribe(listener);\n    let removed = false;\n    return () => {\n      if (!removed) {\n        removed = true;\n        cleanupListener();\n        tryUnsubscribe();\n      }\n    };\n  }\n  function notifyNestedSubs() {\n    listeners.notify();\n  }\n  function handleChangeWrapper() {\n    if (subscription.onStateChange) {\n      subscription.onStateChange();\n    }\n  }\n  function isSubscribed() {\n    return selfSubscribed;\n  }\n  function trySubscribe() {\n    subscriptionsAmount++;\n    if (!unsubscribe) {\n      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n      listeners = createListenerCollection();\n    }\n  }\n  function tryUnsubscribe() {\n    subscriptionsAmount--;\n    if (unsubscribe && subscriptionsAmount === 0) {\n      unsubscribe();\n      unsubscribe = void 0;\n      listeners.clear();\n      listeners = nullListeners;\n    }\n  }\n  function trySubscribeSelf() {\n    if (!selfSubscribed) {\n      selfSubscribed = true;\n      trySubscribe();\n    }\n  }\n  function tryUnsubscribeSelf() {\n    if (selfSubscribed) {\n      selfSubscribed = false;\n      tryUnsubscribe();\n    }\n  }\n  const subscription = {\n    addNestedSub,\n    notifyNestedSubs,\n    handleChangeWrapper,\n    isSubscribed,\n    trySubscribe: trySubscribeSelf,\n    tryUnsubscribe: tryUnsubscribeSelf,\n    getListeners: () => listeners\n  };\n  return subscription;\n}\n\n// src/utils/useIsomorphicLayoutEffect.ts\nvar canUseDOM = () => !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\nvar isDOM = /* @__PURE__ */ canUseDOM();\nvar isRunningInReactNative = () => typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\";\nvar isReactNative = /* @__PURE__ */ isRunningInReactNative();\nvar getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();\n\n// src/utils/shallowEqual.ts\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) return true;\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return false;\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// src/utils/hoistStatics.ts\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  $$typeof: true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  $$typeof: true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = {\n  [ForwardRef]: FORWARD_REF_STATICS,\n  [Memo]: MEMO_STATICS\n};\nfunction getStatics(component) {\n  if (isMemo(component)) {\n    return MEMO_STATICS;\n  }\n  return TYPE_STATICS[component[\"$$typeof\"]] || REACT_STATICS;\n}\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent) {\n  if (typeof sourceComponent !== \"string\") {\n    if (objectPrototype) {\n      const inheritedComponent = getPrototypeOf(sourceComponent);\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent);\n      }\n    }\n    let keys = getOwnPropertyNames(sourceComponent);\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n    const targetStatics = getStatics(targetComponent);\n    const sourceStatics = getStatics(sourceComponent);\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        const descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n        try {\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {\n        }\n      }\n    }\n  }\n  return targetComponent;\n}\n\n// src/components/Context.ts\nvar ContextKey = /* @__PURE__ */ Symbol.for(`react-redux-context`);\nvar gT = typeof globalThis !== \"undefined\" ? globalThis : (\n  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */\n  {}\n);\nfunction getContext() {\n  if (!react__WEBPACK_IMPORTED_MODULE_0__.createContext) return {};\n  const contextMap = gT[ContextKey] ??= /* @__PURE__ */ new Map();\n  let realContext = contextMap.get(react__WEBPACK_IMPORTED_MODULE_0__.createContext);\n  if (!realContext) {\n    realContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(\n      null\n    );\n    if (true) {\n      realContext.displayName = \"ReactRedux\";\n    }\n    contextMap.set(react__WEBPACK_IMPORTED_MODULE_0__.createContext, realContext);\n  }\n  return realContext;\n}\nvar ReactReduxContext = /* @__PURE__ */ getContext();\n\n// src/components/connect.tsx\nvar NO_SUBSCRIPTION_ARRAY = [null, null];\nvar stringifyComponent = (Comp) => {\n  try {\n    return JSON.stringify(Comp);\n  } catch (err) {\n    return String(Comp);\n  }\n};\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n  useIsomorphicLayoutEffect(() => effectFunc(...effectArgs), dependencies);\n}\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {\n  lastWrapperProps.current = wrapperProps;\n  renderIsScheduled.current = false;\n  if (childPropsFromStoreUpdate.current) {\n    childPropsFromStoreUpdate.current = null;\n    notifyNestedSubs();\n  }\n}\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {\n  if (!shouldHandleStateChanges) return () => {\n  };\n  let didUnsubscribe = false;\n  let lastThrownError = null;\n  const checkForUpdates = () => {\n    if (didUnsubscribe || !isMounted.current) {\n      return;\n    }\n    const latestStoreState = store.getState();\n    let newChildProps, error;\n    try {\n      newChildProps = childPropsSelector(\n        latestStoreState,\n        lastWrapperProps.current\n      );\n    } catch (e) {\n      error = e;\n      lastThrownError = e;\n    }\n    if (!error) {\n      lastThrownError = null;\n    }\n    if (newChildProps === lastChildProps.current) {\n      if (!renderIsScheduled.current) {\n        notifyNestedSubs();\n      }\n    } else {\n      lastChildProps.current = newChildProps;\n      childPropsFromStoreUpdate.current = newChildProps;\n      renderIsScheduled.current = true;\n      additionalSubscribeListener();\n    }\n  };\n  subscription.onStateChange = checkForUpdates;\n  subscription.trySubscribe();\n  checkForUpdates();\n  const unsubscribeWrapper = () => {\n    didUnsubscribe = true;\n    subscription.tryUnsubscribe();\n    subscription.onStateChange = null;\n    if (lastThrownError) {\n      throw lastThrownError;\n    }\n  };\n  return unsubscribeWrapper;\n}\nfunction strictEqual(a, b) {\n  return a === b;\n}\nvar hasWarnedAboutDeprecatedPureOption = false;\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps, {\n  // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\n  // @ts-ignore\n  pure,\n  areStatesEqual = strictEqual,\n  areOwnPropsEqual = shallowEqual,\n  areStatePropsEqual = shallowEqual,\n  areMergedPropsEqual = shallowEqual,\n  // use React's forwardRef to expose a ref of the wrapped component\n  forwardRef = false,\n  // the context consumer to use\n  context = ReactReduxContext\n} = {}) {\n  if (true) {\n    if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {\n      hasWarnedAboutDeprecatedPureOption = true;\n      warning(\n        'The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component'\n      );\n    }\n  }\n  const Context = context;\n  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\n  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\n  const initMergeProps = mergePropsFactory(mergeProps);\n  const shouldHandleStateChanges = Boolean(mapStateToProps);\n  const wrapWithConnect = (WrappedComponent) => {\n    if (true) {\n      const isValid = /* @__PURE__ */ isValidElementType(WrappedComponent);\n      if (!isValid)\n        throw new Error(\n          `You must pass a component to the function returned by connect. Instead received ${stringifyComponent(\n            WrappedComponent\n          )}`\n        );\n    }\n    const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n    const displayName = `Connect(${wrappedComponentName})`;\n    const selectorFactoryOptions = {\n      shouldHandleStateChanges,\n      displayName,\n      wrappedComponentName,\n      WrappedComponent,\n      // @ts-ignore\n      initMapStateToProps,\n      initMapDispatchToProps,\n      initMergeProps,\n      areStatesEqual,\n      areStatePropsEqual,\n      areOwnPropsEqual,\n      areMergedPropsEqual\n    };\n    function ConnectFunction(props) {\n      const [propsContext, reactReduxForwardedRef, wrapperProps] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        const { reactReduxForwardedRef: reactReduxForwardedRef2, ...wrapperProps2 } = props;\n        return [props.context, reactReduxForwardedRef2, wrapperProps2];\n      }, [props]);\n      const ContextToUse = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        let ResultContext = Context;\n        if (propsContext?.Consumer) {\n          if (true) {\n            const isValid = /* @__PURE__ */ isContextConsumer(\n              // @ts-ignore\n              /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(propsContext.Consumer, null)\n            );\n            if (!isValid) {\n              throw new Error(\n                \"You must pass a valid React context consumer as `props.context`\"\n              );\n            }\n            ResultContext = propsContext;\n          }\n        }\n        return ResultContext;\n      }, [propsContext, Context]);\n      const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ContextToUse);\n      const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n      const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n      if ( true && !didStoreComeFromProps && !didStoreComeFromContext) {\n        throw new Error(\n          `Could not find \"store\" in the context of \"${displayName}\". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`\n        );\n      }\n      const store = didStoreComeFromProps ? props.store : contextValue.store;\n      const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n      const childPropsSelector = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);\n      }, [store]);\n      const [subscription, notifyNestedSubs] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;\n        const subscription2 = createSubscription(\n          store,\n          didStoreComeFromProps ? void 0 : contextValue.subscription\n        );\n        const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);\n        return [subscription2, notifyNestedSubs2];\n      }, [store, didStoreComeFromProps, contextValue]);\n      const overriddenContextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        if (didStoreComeFromProps) {\n          return contextValue;\n        }\n        return {\n          ...contextValue,\n          subscription\n        };\n      }, [didStoreComeFromProps, contextValue, subscription]);\n      const lastChildProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n      const lastWrapperProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(wrapperProps);\n      const childPropsFromStoreUpdate = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n      const renderIsScheduled = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n      const isMounted = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n      const latestSubscriptionCallbackError = react__WEBPACK_IMPORTED_MODULE_0__.useRef(\n        void 0\n      );\n      useIsomorphicLayoutEffect(() => {\n        isMounted.current = true;\n        return () => {\n          isMounted.current = false;\n        };\n      }, []);\n      const actualChildPropsSelector = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        const selector = () => {\n          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n            return childPropsFromStoreUpdate.current;\n          }\n          return childPropsSelector(store.getState(), wrapperProps);\n        };\n        return selector;\n      }, [store, wrapperProps]);\n      const subscribeForReact = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        const subscribe = (reactListener) => {\n          if (!subscription) {\n            return () => {\n            };\n          }\n          return subscribeUpdates(\n            shouldHandleStateChanges,\n            store,\n            subscription,\n            // @ts-ignore\n            childPropsSelector,\n            lastWrapperProps,\n            lastChildProps,\n            renderIsScheduled,\n            isMounted,\n            childPropsFromStoreUpdate,\n            notifyNestedSubs,\n            reactListener\n          );\n        };\n        return subscribe;\n      }, [subscription]);\n      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [\n        lastWrapperProps,\n        lastChildProps,\n        renderIsScheduled,\n        wrapperProps,\n        childPropsFromStoreUpdate,\n        notifyNestedSubs\n      ]);\n      let actualChildProps;\n      try {\n        actualChildProps = react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore(\n          // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n          subscribeForReact,\n          // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n          // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n          actualChildPropsSelector,\n          getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector\n        );\n      } catch (err) {\n        if (latestSubscriptionCallbackError.current) {\n          ;\n          err.message += `\nThe error may be correlated with this previous error:\n${latestSubscriptionCallbackError.current.stack}\n\n`;\n        }\n        throw err;\n      }\n      useIsomorphicLayoutEffect(() => {\n        latestSubscriptionCallbackError.current = void 0;\n        childPropsFromStoreUpdate.current = void 0;\n        lastChildProps.current = actualChildProps;\n      });\n      const renderedWrappedComponent = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        return (\n          // @ts-ignore\n          /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n            WrappedComponent,\n            {\n              ...actualChildProps,\n              ref: reactReduxForwardedRef\n            }\n          )\n        );\n      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);\n      const renderedChild = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        if (shouldHandleStateChanges) {\n          return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextToUse.Provider, { value: overriddenContextValue }, renderedWrappedComponent);\n        }\n        return renderedWrappedComponent;\n      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);\n      return renderedChild;\n    }\n    const _Connect = react__WEBPACK_IMPORTED_MODULE_0__.memo(ConnectFunction);\n    const Connect = _Connect;\n    Connect.WrappedComponent = WrappedComponent;\n    Connect.displayName = ConnectFunction.displayName = displayName;\n    if (forwardRef) {\n      const _forwarded = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n        function forwardConnectRef(props, ref) {\n          return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Connect, { ...props, reactReduxForwardedRef: ref });\n        }\n      );\n      const forwarded = _forwarded;\n      forwarded.displayName = displayName;\n      forwarded.WrappedComponent = WrappedComponent;\n      return /* @__PURE__ */ hoistNonReactStatics(forwarded, WrappedComponent);\n    }\n    return /* @__PURE__ */ hoistNonReactStatics(Connect, WrappedComponent);\n  };\n  return wrapWithConnect;\n}\nvar connect_default = connect;\n\n// src/components/Provider.tsx\nfunction Provider(providerProps) {\n  const { children, context, serverState, store } = providerProps;\n  const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const subscription = createSubscription(store);\n    const baseContextValue = {\n      store,\n      subscription,\n      getServerState: serverState ? () => serverState : void 0\n    };\n    if (false) {} else {\n      const { identityFunctionCheck = \"once\", stabilityCheck = \"once\" } = providerProps;\n      return /* @__PURE__ */ Object.assign(baseContextValue, {\n        stabilityCheck,\n        identityFunctionCheck\n      });\n    }\n  }, [store, serverState]);\n  const previousState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => store.getState(), [store]);\n  useIsomorphicLayoutEffect(() => {\n    const { subscription } = contextValue;\n    subscription.onStateChange = subscription.notifyNestedSubs;\n    subscription.trySubscribe();\n    if (previousState !== store.getState()) {\n      subscription.notifyNestedSubs();\n    }\n    return () => {\n      subscription.tryUnsubscribe();\n      subscription.onStateChange = void 0;\n    };\n  }, [contextValue, previousState]);\n  const Context = context || ReactReduxContext;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Context.Provider, { value: contextValue }, children);\n}\nvar Provider_default = Provider;\n\n// src/hooks/useReduxContext.ts\nfunction createReduxContextHook(context = ReactReduxContext) {\n  return function useReduxContext2() {\n    const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if ( true && !contextValue) {\n      throw new Error(\n        \"could not find react-redux context value; please ensure the component is wrapped in a <Provider>\"\n      );\n    }\n    return contextValue;\n  };\n}\nvar useReduxContext = /* @__PURE__ */ createReduxContextHook();\n\n// src/hooks/useStore.ts\nfunction createStoreHook(context = ReactReduxContext) {\n  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : (\n    // @ts-ignore\n    createReduxContextHook(context)\n  );\n  const useStore2 = () => {\n    const { store } = useReduxContext2();\n    return store;\n  };\n  Object.assign(useStore2, {\n    withTypes: () => useStore2\n  });\n  return useStore2;\n}\nvar useStore = /* @__PURE__ */ createStoreHook();\n\n// src/hooks/useDispatch.ts\nfunction createDispatchHook(context = ReactReduxContext) {\n  const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);\n  const useDispatch2 = () => {\n    const store = useStore2();\n    return store.dispatch;\n  };\n  Object.assign(useDispatch2, {\n    withTypes: () => useDispatch2\n  });\n  return useDispatch2;\n}\nvar useDispatch = /* @__PURE__ */ createDispatchHook();\n\n// src/hooks/useSelector.ts\n\nvar refEquality = (a, b) => a === b;\nfunction createSelectorHook(context = ReactReduxContext) {\n  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);\n  const useSelector2 = (selector, equalityFnOrOptions = {}) => {\n    const { equalityFn = refEquality } = typeof equalityFnOrOptions === \"function\" ? { equalityFn: equalityFnOrOptions } : equalityFnOrOptions;\n    if (true) {\n      if (!selector) {\n        throw new Error(`You must pass a selector to useSelector`);\n      }\n      if (typeof selector !== \"function\") {\n        throw new Error(`You must pass a function as a selector to useSelector`);\n      }\n      if (typeof equalityFn !== \"function\") {\n        throw new Error(\n          `You must pass a function as an equality function to useSelector`\n        );\n      }\n    }\n    const reduxContext = useReduxContext2();\n    const { store, subscription, getServerState } = reduxContext;\n    const firstRun = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n      {\n        [selector.name](state) {\n          const selected = selector(state);\n          if (true) {\n            const { devModeChecks = {} } = typeof equalityFnOrOptions === \"function\" ? {} : equalityFnOrOptions;\n            const { identityFunctionCheck, stabilityCheck } = reduxContext;\n            const {\n              identityFunctionCheck: finalIdentityFunctionCheck,\n              stabilityCheck: finalStabilityCheck\n            } = {\n              stabilityCheck,\n              identityFunctionCheck,\n              ...devModeChecks\n            };\n            if (finalStabilityCheck === \"always\" || finalStabilityCheck === \"once\" && firstRun.current) {\n              const toCompare = selector(state);\n              if (!equalityFn(selected, toCompare)) {\n                let stack = void 0;\n                try {\n                  throw new Error();\n                } catch (e) {\n                  ;\n                  ({ stack } = e);\n                }\n                console.warn(\n                  \"Selector \" + (selector.name || \"unknown\") + \" returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization\",\n                  {\n                    state,\n                    selected,\n                    selected2: toCompare,\n                    stack\n                  }\n                );\n              }\n            }\n            if (finalIdentityFunctionCheck === \"always\" || finalIdentityFunctionCheck === \"once\" && firstRun.current) {\n              if (selected === state) {\n                let stack = void 0;\n                try {\n                  throw new Error();\n                } catch (e) {\n                  ;\n                  ({ stack } = e);\n                }\n                console.warn(\n                  \"Selector \" + (selector.name || \"unknown\") + \" returned the root state when called. This can lead to unnecessary rerenders.\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.\",\n                  { stack }\n                );\n              }\n            }\n            if (firstRun.current) firstRun.current = false;\n          }\n          return selected;\n        }\n      }[selector.name],\n      [selector]\n    );\n    const selectedState = (0,use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(\n      subscription.addNestedSub,\n      store.getState,\n      getServerState || store.getState,\n      wrappedSelector,\n      equalityFn\n    );\n    react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue(selectedState);\n    return selectedState;\n  };\n  Object.assign(useSelector2, {\n    withTypes: () => useSelector2\n  });\n  return useSelector2;\n}\nvar useSelector = /* @__PURE__ */ createSelectorHook();\n\n// src/exports.ts\nvar batch = defaultNoopBatch;\n\n//# sourceMappingURL=react-redux.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9kaXN0L3JlYWN0LXJlZHV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDK0I7O0FBRS9CO0FBQ0Esa0NBQWtDLDBDQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RCxJQUFJO0FBQ0o7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxnREFBbUI7QUFDMUI7QUFDQSxtQ0FBbUMsZ0RBQW1CO0FBQ3REO0FBQ0Esa0JBQWtCLGdEQUFtQjtBQUNyQztBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0EsbUJBQW1CLGdEQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ04sTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxQkFBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLDBDQUFhO0FBQ2hGLGdCQUFnQixvRUFBb0U7QUFDcEY7QUFDQSxPQUFPO0FBQ1AsMkJBQTJCLDBDQUFhO0FBQ3hDO0FBQ0E7QUFDQSxjQUFjLElBQXFDO0FBQ25EO0FBQ0E7QUFDQSw4QkFBOEIsZ0RBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDJCQUEyQiw2Q0FBZ0I7QUFDM0M7QUFDQTtBQUNBLFVBQVUsS0FBcUM7QUFDL0M7QUFDQSx1REFBdUQsWUFBWSwySkFBMkosYUFBYTtBQUMzTztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQ0FBYTtBQUM5QztBQUNBLE9BQU87QUFDUCwrQ0FBK0MsMENBQWE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AscUNBQXFDLDBDQUFhO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2Qix5Q0FBWTtBQUN6QywrQkFBK0IseUNBQVk7QUFDM0Msd0NBQXdDLHlDQUFZO0FBQ3BELGdDQUFnQyx5Q0FBWTtBQUM1Qyx3QkFBd0IseUNBQVk7QUFDcEMsOENBQThDLHlDQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHVDQUF1QywwQ0FBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxnQ0FBZ0MsMENBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVEQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx1Q0FBdUMsMENBQWE7QUFDcEQ7QUFDQTtBQUNBLDBCQUEwQixnREFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNEJBQTRCLDBDQUFhO0FBQ3pDO0FBQ0EsaUNBQWlDLGdEQUFtQiwwQkFBMEIsK0JBQStCO0FBQzdHO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHFCQUFxQix1Q0FBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2Q0FBZ0I7QUFDekM7QUFDQSxpQ0FBaUMsZ0RBQW1CLFlBQVksdUNBQXVDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx3Q0FBd0M7QUFDbEQsdUJBQXVCLDBDQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ04sY0FBYywwREFBMEQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILHdCQUF3QiwwQ0FBYTtBQUNyQztBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx5QkFBeUIsZ0RBQW1CLHFCQUFxQixxQkFBcUI7QUFDdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkNBQWdCO0FBQ3pDLFFBQVEsS0FBcUM7QUFDN0M7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQzRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxZQUFZLDJCQUEyQixnREFBZ0Qsa0NBQWtDO0FBQ3pILFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNDQUFzQztBQUNsRCxxQkFBcUIseUNBQVk7QUFDakMsNEJBQTRCLDhDQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQXFDO0FBQ25ELG9CQUFvQixxQkFBcUIsaURBQWlEO0FBQzFGLG9CQUFvQix3Q0FBd0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMEJBQTBCLDBHQUFnQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdEQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQWFFO0FBQ0YiLCJzb3VyY2VzIjpbIi9hcHAvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2Rpc3QvcmVhY3QtcmVkdXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91dGlscy9yZWFjdC50c1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy91dGlscy9yZWFjdC1pcy50c1xudmFyIElTX1JFQUNUXzE5ID0gLyogQF9fUFVSRV9fICovIFJlYWN0LnZlcnNpb24uc3RhcnRzV2l0aChcIjE5XCIpO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFxuICBJU19SRUFDVF8xOSA/IFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiA6IFwicmVhY3QuZWxlbWVudFwiXG4pO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIik7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIik7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIik7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIik7XG52YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIik7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFxuICBcInJlYWN0LnN1c3BlbnNlX2xpc3RcIlxuKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIik7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIik7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFxuICBcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIlxuKTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdm9pZCAwKSA/IHRydWUgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwib2JqZWN0XCIgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgY29uc3QgeyAkJHR5cGVvZiB9ID0gb2JqZWN0O1xuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICBzd2l0Y2ggKG9iamVjdCA9IG9iamVjdC50eXBlLCBvYmplY3QpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzd2l0Y2ggKG9iamVjdCA9IG9iamVjdCAmJiBvYmplY3QuJCR0eXBlb2YsIG9iamVjdCkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIElTX1JFQUNUXzE5ID8gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlNVTUVSX1RZUEUgOiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX01FTU9fVFlQRTtcbn1cblxuLy8gc3JjL3V0aWxzL3dhcm5pbmcudHNcbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgdHJ5IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxuXG4vLyBzcmMvY29ubmVjdC92ZXJpZnlTdWJzZWxlY3RvcnMudHNcbmZ1bmN0aW9uIHZlcmlmeShzZWxlY3RvciwgbWV0aG9kTmFtZSkge1xuICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHZhbHVlIGZvciAke21ldGhvZE5hbWV9IGluIGNvbm5lY3QuYCk7XG4gIH0gZWxzZSBpZiAobWV0aG9kTmFtZSA9PT0gXCJtYXBTdGF0ZVRvUHJvcHNcIiB8fCBtZXRob2ROYW1lID09PSBcIm1hcERpc3BhdGNoVG9Qcm9wc1wiKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2VsZWN0b3IsIFwiZGVwZW5kc09uT3duUHJvcHNcIikpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGBUaGUgc2VsZWN0b3IgZm9yICR7bWV0aG9kTmFtZX0gb2YgY29ubmVjdCBkaWQgbm90IHNwZWNpZnkgYSB2YWx1ZSBmb3IgZGVwZW5kc09uT3duUHJvcHMuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHZlcmlmeVN1YnNlbGVjdG9ycyhtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcykge1xuICB2ZXJpZnkobWFwU3RhdGVUb1Byb3BzLCBcIm1hcFN0YXRlVG9Qcm9wc1wiKTtcbiAgdmVyaWZ5KG1hcERpc3BhdGNoVG9Qcm9wcywgXCJtYXBEaXNwYXRjaFRvUHJvcHNcIik7XG4gIHZlcmlmeShtZXJnZVByb3BzLCBcIm1lcmdlUHJvcHNcIik7XG59XG5cbi8vIHNyYy9jb25uZWN0L3NlbGVjdG9yRmFjdG9yeS50c1xuZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCB7XG4gIGFyZVN0YXRlc0VxdWFsLFxuICBhcmVPd25Qcm9wc0VxdWFsLFxuICBhcmVTdGF0ZVByb3BzRXF1YWxcbn0pIHtcbiAgbGV0IGhhc1J1bkF0TGVhc3RPbmNlID0gZmFsc2U7XG4gIGxldCBzdGF0ZTtcbiAgbGV0IG93blByb3BzO1xuICBsZXQgc3RhdGVQcm9wcztcbiAgbGV0IGRpc3BhdGNoUHJvcHM7XG4gIGxldCBtZXJnZWRQcm9wcztcbiAgZnVuY3Rpb24gaGFuZGxlRmlyc3RDYWxsKGZpcnN0U3RhdGUsIGZpcnN0T3duUHJvcHMpIHtcbiAgICBzdGF0ZSA9IGZpcnN0U3RhdGU7XG4gICAgb3duUHJvcHMgPSBmaXJzdE93blByb3BzO1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICBoYXNSdW5BdExlYXN0T25jZSA9IHRydWU7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKSB7XG4gICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpXG4gICAgICBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHMoKSB7XG4gICAgaWYgKG1hcFN0YXRlVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBpZiAobWFwRGlzcGF0Y2hUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKVxuICAgICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1N0YXRlKCkge1xuICAgIGNvbnN0IG5leHRTdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgY29uc3Qgc3RhdGVQcm9wc0NoYW5nZWQgPSAhYXJlU3RhdGVQcm9wc0VxdWFsKG5leHRTdGF0ZVByb3BzLCBzdGF0ZVByb3BzKTtcbiAgICBzdGF0ZVByb3BzID0gbmV4dFN0YXRlUHJvcHM7XG4gICAgaWYgKHN0YXRlUHJvcHNDaGFuZ2VkKVxuICAgICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlU3Vic2VxdWVudENhbGxzKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSB7XG4gICAgY29uc3QgcHJvcHNDaGFuZ2VkID0gIWFyZU93blByb3BzRXF1YWwobmV4dE93blByb3BzLCBvd25Qcm9wcyk7XG4gICAgY29uc3Qgc3RhdGVDaGFuZ2VkID0gIWFyZVN0YXRlc0VxdWFsKFxuICAgICAgbmV4dFN0YXRlLFxuICAgICAgc3RhdGUsXG4gICAgICBuZXh0T3duUHJvcHMsXG4gICAgICBvd25Qcm9wc1xuICAgICk7XG4gICAgc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgb3duUHJvcHMgPSBuZXh0T3duUHJvcHM7XG4gICAgaWYgKHByb3BzQ2hhbmdlZCAmJiBzdGF0ZUNoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCk7XG4gICAgaWYgKHByb3BzQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1Byb3BzKCk7XG4gICAgaWYgKHN0YXRlQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1N0YXRlKCk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSB7XG4gICAgcmV0dXJuIGhhc1J1bkF0TGVhc3RPbmNlID8gaGFuZGxlU3Vic2VxdWVudENhbGxzKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSA6IGhhbmRsZUZpcnN0Q2FsbChuZXh0U3RhdGUsIG5leHRPd25Qcm9wcyk7XG4gIH07XG59XG5mdW5jdGlvbiBmaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KGRpc3BhdGNoLCB7XG4gIGluaXRNYXBTdGF0ZVRvUHJvcHMsXG4gIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMsXG4gIGluaXRNZXJnZVByb3BzLFxuICAuLi5vcHRpb25zXG59KSB7XG4gIGNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IGluaXRNYXBTdGF0ZVRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICBjb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgY29uc3QgbWVyZ2VQcm9wcyA9IGluaXRNZXJnZVByb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZlcmlmeVN1YnNlbGVjdG9ycyhtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcyk7XG4gIH1cbiAgcmV0dXJuIHB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwYXRjaCwgb3B0aW9ucyk7XG59XG5cbi8vIHNyYy91dGlscy9iaW5kQWN0aW9uQ3JlYXRvcnMudHNcbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgY29uc3QgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBhY3Rpb25DcmVhdG9ycykge1xuICAgIGNvbnN0IGFjdGlvbkNyZWF0b3IgPSBhY3Rpb25DcmVhdG9yc1trZXldO1xuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSAoLi4uYXJncykgPT4gZGlzcGF0Y2goYWN0aW9uQ3JlYXRvciguLi5hcmdzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG4vLyBzcmMvdXRpbHMvaXNQbGFpbk9iamVjdC50c1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgfHwgb2JqID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gIGlmIChwcm90byA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIGxldCBiYXNlUHJvdG8gPSBwcm90bztcbiAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlUHJvdG8pICE9PSBudWxsKSB7XG4gICAgYmFzZVByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90byk7XG4gIH1cbiAgcmV0dXJuIHByb3RvID09PSBiYXNlUHJvdG87XG59XG5cbi8vIHNyYy91dGlscy92ZXJpZnlQbGFpbk9iamVjdC50c1xuZnVuY3Rpb24gdmVyaWZ5UGxhaW5PYmplY3QodmFsdWUsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgYCR7bWV0aG9kTmFtZX0oKSBpbiAke2Rpc3BsYXlOYW1lfSBtdXN0IHJldHVybiBhIHBsYWluIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZCAke3ZhbHVlfS5gXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzcmMvY29ubmVjdC93cmFwTWFwVG9Qcm9wcy50c1xuZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNDb25zdGFudChnZXRDb25zdGFudCkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdENvbnN0YW50U2VsZWN0b3IoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCBjb25zdGFudCA9IGdldENvbnN0YW50KGRpc3BhdGNoKTtcbiAgICBmdW5jdGlvbiBjb25zdGFudFNlbGVjdG9yKCkge1xuICAgICAgcmV0dXJuIGNvbnN0YW50O1xuICAgIH1cbiAgICBjb25zdGFudFNlbGVjdG9yLmRlcGVuZHNPbk93blByb3BzID0gZmFsc2U7XG4gICAgcmV0dXJuIGNvbnN0YW50U2VsZWN0b3I7XG4gIH07XG59XG5mdW5jdGlvbiBnZXREZXBlbmRzT25Pd25Qcm9wcyhtYXBUb1Byb3BzKSB7XG4gIHJldHVybiBtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzID8gQm9vbGVhbihtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSA6IG1hcFRvUHJvcHMubGVuZ3RoICE9PSAxO1xufVxuZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFRvUHJvcHMsIG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRQcm94eVNlbGVjdG9yKGRpc3BhdGNoLCB7IGRpc3BsYXlOYW1lIH0pIHtcbiAgICBjb25zdCBwcm94eSA9IGZ1bmN0aW9uIG1hcFRvUHJvcHNQcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICByZXR1cm4gcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPyBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIDogcHJveHkubWFwVG9Qcm9wcyhzdGF0ZU9yRGlzcGF0Y2gsIHZvaWQgMCk7XG4gICAgfTtcbiAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IHRydWU7XG4gICAgcHJveHkubWFwVG9Qcm9wcyA9IGZ1bmN0aW9uIGRldGVjdEZhY3RvcnlBbmRWZXJpZnkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykge1xuICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IG1hcFRvUHJvcHM7XG4gICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpO1xuICAgICAgbGV0IHByb3BzID0gcHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgICBpZiAodHlwZW9mIHByb3BzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IHByb3BzO1xuICAgICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKHByb3BzKTtcbiAgICAgICAgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgICAgIHZlcmlmeVBsYWluT2JqZWN0KHByb3BzLCBkaXNwbGF5TmFtZSwgbWV0aG9kTmFtZSk7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG59XG5cbi8vIHNyYy9jb25uZWN0L2ludmFsaWRBcmdGYWN0b3J5LnRzXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShhcmcsIG5hbWUpIHtcbiAgcmV0dXJuIChkaXNwYXRjaCwgb3B0aW9ucykgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgYXJnfSBmb3IgJHtuYW1lfSBhcmd1bWVudCB3aGVuIGNvbm5lY3RpbmcgY29tcG9uZW50ICR7b3B0aW9ucy53cmFwcGVkQ29tcG9uZW50TmFtZX0uYFxuICAgICk7XG4gIH07XG59XG5cbi8vIHNyYy9jb25uZWN0L21hcERpc3BhdGNoVG9Qcm9wcy50c1xuZnVuY3Rpb24gbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeShtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcERpc3BhdGNoVG9Qcm9wcyAmJiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSBcIm9iamVjdFwiID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChcbiAgICAoZGlzcGF0Y2gpID0+IChcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGJpbmRBY3Rpb25DcmVhdG9ycyhtYXBEaXNwYXRjaFRvUHJvcHMsIGRpc3BhdGNoKVxuICAgIClcbiAgKSA6ICFtYXBEaXNwYXRjaFRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KChkaXNwYXRjaCkgPT4gKHtcbiAgICBkaXNwYXRjaFxuICB9KSkgOiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSBcImZ1bmN0aW9uXCIgPyAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBEaXNwYXRjaFRvUHJvcHMsIFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpXG4gICkgOiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShtYXBEaXNwYXRjaFRvUHJvcHMsIFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpO1xufVxuXG4vLyBzcmMvY29ubmVjdC9tYXBTdGF0ZVRvUHJvcHMudHNcbmZ1bmN0aW9uIG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzKSB7XG4gIHJldHVybiAhbWFwU3RhdGVUb1Byb3BzID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudCgoKSA9PiAoe30pKSA6IHR5cGVvZiBtYXBTdGF0ZVRvUHJvcHMgPT09IFwiZnVuY3Rpb25cIiA/IChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFN0YXRlVG9Qcm9wcywgXCJtYXBTdGF0ZVRvUHJvcHNcIilcbiAgKSA6IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgXCJtYXBTdGF0ZVRvUHJvcHNcIik7XG59XG5cbi8vIHNyYy9jb25uZWN0L21lcmdlUHJvcHMudHNcbmZ1bmN0aW9uIGRlZmF1bHRNZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gIHJldHVybiB7IC4uLm93blByb3BzLCAuLi5zdGF0ZVByb3BzLCAuLi5kaXNwYXRjaFByb3BzIH07XG59XG5mdW5jdGlvbiB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdE1lcmdlUHJvcHNQcm94eShkaXNwYXRjaCwgeyBkaXNwbGF5TmFtZSwgYXJlTWVyZ2VkUHJvcHNFcXVhbCB9KSB7XG4gICAgbGV0IGhhc1J1bk9uY2UgPSBmYWxzZTtcbiAgICBsZXQgbWVyZ2VkUHJvcHM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlUHJvcHNQcm94eShzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykge1xuICAgICAgY29uc3QgbmV4dE1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgICBpZiAoaGFzUnVuT25jZSkge1xuICAgICAgICBpZiAoIWFyZU1lcmdlZFByb3BzRXF1YWwobmV4dE1lcmdlZFByb3BzLCBtZXJnZWRQcm9wcykpXG4gICAgICAgICAgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNSdW5PbmNlID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgICAgICAgdmVyaWZ5UGxhaW5PYmplY3QobWVyZ2VkUHJvcHMsIGRpc3BsYXlOYW1lLCBcIm1lcmdlUHJvcHNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlUHJvcHNGYWN0b3J5KG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuICFtZXJnZVByb3BzID8gKCkgPT4gZGVmYXVsdE1lcmdlUHJvcHMgOiB0eXBlb2YgbWVyZ2VQcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWVyZ2VQcm9wcywgXCJtZXJnZVByb3BzXCIpO1xufVxuXG4vLyBzcmMvdXRpbHMvYmF0Y2gudHNcbmZ1bmN0aW9uIGRlZmF1bHROb29wQmF0Y2goY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soKTtcbn1cblxuLy8gc3JjL3V0aWxzL1N1YnNjcmlwdGlvbi50c1xuZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCkge1xuICBsZXQgZmlyc3QgPSBudWxsO1xuICBsZXQgbGFzdCA9IG51bGw7XG4gIHJldHVybiB7XG4gICAgY2xlYXIoKSB7XG4gICAgICBmaXJzdCA9IG51bGw7XG4gICAgICBsYXN0ID0gbnVsbDtcbiAgICB9LFxuICAgIG5vdGlmeSgpIHtcbiAgICAgIGRlZmF1bHROb29wQmF0Y2goKCkgPT4ge1xuICAgICAgICBsZXQgbGlzdGVuZXIgPSBmaXJzdDtcbiAgICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2soKTtcbiAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0KCkge1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gW107XG4gICAgICBsZXQgbGlzdGVuZXIgPSBmaXJzdDtcbiAgICAgIHdoaWxlIChsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0ZW5lcnM7XG4gICAgfSxcbiAgICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgIGxldCBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSBsYXN0ID0ge1xuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgcHJldjogbGFzdFxuICAgICAgfTtcbiAgICAgIGlmIChsaXN0ZW5lci5wcmV2KSB7XG4gICAgICAgIGxpc3RlbmVyLnByZXYubmV4dCA9IGxpc3RlbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3QgPSBsaXN0ZW5lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKCFpc1N1YnNjcmliZWQgfHwgZmlyc3QgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChsaXN0ZW5lci5uZXh0KSB7XG4gICAgICAgICAgbGlzdGVuZXIubmV4dC5wcmV2ID0gbGlzdGVuZXIucHJldjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0ID0gbGlzdGVuZXIucHJldjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIucHJldikge1xuICAgICAgICAgIGxpc3RlbmVyLnByZXYubmV4dCA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlyc3QgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbnZhciBudWxsTGlzdGVuZXJzID0ge1xuICBub3RpZnkoKSB7XG4gIH0sXG4gIGdldDogKCkgPT4gW11cbn07XG5mdW5jdGlvbiBjcmVhdGVTdWJzY3JpcHRpb24oc3RvcmUsIHBhcmVudFN1Yikge1xuICBsZXQgdW5zdWJzY3JpYmU7XG4gIGxldCBsaXN0ZW5lcnMgPSBudWxsTGlzdGVuZXJzO1xuICBsZXQgc3Vic2NyaXB0aW9uc0Ftb3VudCA9IDA7XG4gIGxldCBzZWxmU3Vic2NyaWJlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBhZGROZXN0ZWRTdWIobGlzdGVuZXIpIHtcbiAgICB0cnlTdWJzY3JpYmUoKTtcbiAgICBjb25zdCBjbGVhbnVwTGlzdGVuZXIgPSBsaXN0ZW5lcnMuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgICBsZXQgcmVtb3ZlZCA9IGZhbHNlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoIXJlbW92ZWQpIHtcbiAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXBMaXN0ZW5lcigpO1xuICAgICAgICB0cnlVbnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5TmVzdGVkU3VicygpIHtcbiAgICBsaXN0ZW5lcnMubm90aWZ5KCk7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlV3JhcHBlcigpIHtcbiAgICBpZiAoc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UpIHtcbiAgICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzU3Vic2NyaWJlZCgpIHtcbiAgICByZXR1cm4gc2VsZlN1YnNjcmliZWQ7XG4gIH1cbiAgZnVuY3Rpb24gdHJ5U3Vic2NyaWJlKCkge1xuICAgIHN1YnNjcmlwdGlvbnNBbW91bnQrKztcbiAgICBpZiAoIXVuc3Vic2NyaWJlKSB7XG4gICAgICB1bnN1YnNjcmliZSA9IHBhcmVudFN1YiA/IHBhcmVudFN1Yi5hZGROZXN0ZWRTdWIoaGFuZGxlQ2hhbmdlV3JhcHBlcikgOiBzdG9yZS5zdWJzY3JpYmUoaGFuZGxlQ2hhbmdlV3JhcHBlcik7XG4gICAgICBsaXN0ZW5lcnMgPSBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJ5VW5zdWJzY3JpYmUoKSB7XG4gICAgc3Vic2NyaXB0aW9uc0Ftb3VudC0tO1xuICAgIGlmICh1bnN1YnNjcmliZSAmJiBzdWJzY3JpcHRpb25zQW1vdW50ID09PSAwKSB7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgdW5zdWJzY3JpYmUgPSB2b2lkIDA7XG4gICAgICBsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgIGxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyeVN1YnNjcmliZVNlbGYoKSB7XG4gICAgaWYgKCFzZWxmU3Vic2NyaWJlZCkge1xuICAgICAgc2VsZlN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgdHJ5U3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlU2VsZigpIHtcbiAgICBpZiAoc2VsZlN1YnNjcmliZWQpIHtcbiAgICAgIHNlbGZTdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICB0cnlVbnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBzdWJzY3JpcHRpb24gPSB7XG4gICAgYWRkTmVzdGVkU3ViLFxuICAgIG5vdGlmeU5lc3RlZFN1YnMsXG4gICAgaGFuZGxlQ2hhbmdlV3JhcHBlcixcbiAgICBpc1N1YnNjcmliZWQsXG4gICAgdHJ5U3Vic2NyaWJlOiB0cnlTdWJzY3JpYmVTZWxmLFxuICAgIHRyeVVuc3Vic2NyaWJlOiB0cnlVbnN1YnNjcmliZVNlbGYsXG4gICAgZ2V0TGlzdGVuZXJzOiAoKSA9PiBsaXN0ZW5lcnNcbiAgfTtcbiAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbn1cblxuLy8gc3JjL3V0aWxzL3VzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QudHNcbnZhciBjYW5Vc2VET00gPSAoKSA9PiAhISh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiKTtcbnZhciBpc0RPTSA9IC8qIEBfX1BVUkVfXyAqLyBjYW5Vc2VET00oKTtcbnZhciBpc1J1bm5pbmdJblJlYWN0TmF0aXZlID0gKCkgPT4gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJSZWFjdE5hdGl2ZVwiO1xudmFyIGlzUmVhY3ROYXRpdmUgPSAvKiBAX19QVVJFX18gKi8gaXNSdW5uaW5nSW5SZWFjdE5hdGl2ZSgpO1xudmFyIGdldFVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSAoKSA9PiBpc0RPTSB8fCBpc1JlYWN0TmF0aXZlID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSAvKiBAX19QVVJFX18gKi8gZ2V0VXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgpO1xuXG4vLyBzcmMvdXRpbHMvc2hhbGxvd0VxdWFsLnRzXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSB7XG4gICAgcmV0dXJuIHggIT09IDAgfHwgeSAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHR5cGVvZiBvYmpBICE9PSBcIm9iamVjdFwiIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09IFwib2JqZWN0XCIgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICBjb25zdCBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gc3JjL3V0aWxzL2hvaXN0U3RhdGljcy50c1xudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICBjb250ZXh0VHlwZTogdHJ1ZSxcbiAgY29udGV4dFR5cGVzOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB0cnVlLFxuICBtaXhpbnM6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWVcbn07XG52YXIgRk9SV0FSRF9SRUZfU1RBVElDUyA9IHtcbiAgJCR0eXBlb2Y6IHRydWUsXG4gIHJlbmRlcjogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlXG59O1xudmFyIE1FTU9fU1RBVElDUyA9IHtcbiAgJCR0eXBlb2Y6IHRydWUsXG4gIGNvbXBhcmU6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBUWVBFX1NUQVRJQ1MgPSB7XG4gIFtGb3J3YXJkUmVmXTogRk9SV0FSRF9SRUZfU1RBVElDUyxcbiAgW01lbW9dOiBNRU1PX1NUQVRJQ1Ncbn07XG5mdW5jdGlvbiBnZXRTdGF0aWNzKGNvbXBvbmVudCkge1xuICBpZiAoaXNNZW1vKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gTUVNT19TVEFUSUNTO1xuICB9XG4gIHJldHVybiBUWVBFX1NUQVRJQ1NbY29tcG9uZW50W1wiJCR0eXBlb2ZcIl1dIHx8IFJFQUNUX1NUQVRJQ1M7XG59XG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQpIHtcbiAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAob2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICBjb25zdCBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFN0YXRpY3MgPSBnZXRTdGF0aWNzKHRhcmdldENvbXBvbmVudCk7XG4gICAgY29uc3Qgc291cmNlU3RhdGljcyA9IGdldFN0YXRpY3Moc291cmNlQ29tcG9uZW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoIUtOT1dOX1NUQVRJQ1Nba2V5XSAmJiAhKHNvdXJjZVN0YXRpY3MgJiYgc291cmNlU3RhdGljc1trZXldKSAmJiAhKHRhcmdldFN0YXRpY3MgJiYgdGFyZ2V0U3RhdGljc1trZXldKSkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9Db250ZXh0LnRzXG52YXIgQ29udGV4dEtleSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKGByZWFjdC1yZWR1eC1jb250ZXh0YCk7XG52YXIgZ1QgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiAoXG4gIC8qIGZhbGwgYmFjayB0byBhIHBlci1tb2R1bGUgc2NvcGUgKHByZS04LjEgYmVoYXZpb3VyKSBpZiBgZ2xvYmFsVGhpc2AgaXMgbm90IGF2YWlsYWJsZSAqL1xuICB7fVxuKTtcbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIGlmICghUmVhY3QuY3JlYXRlQ29udGV4dCkgcmV0dXJuIHt9O1xuICBjb25zdCBjb250ZXh0TWFwID0gZ1RbQ29udGV4dEtleV0gPz89IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCByZWFsQ29udGV4dCA9IGNvbnRleHRNYXAuZ2V0KFJlYWN0LmNyZWF0ZUNvbnRleHQpO1xuICBpZiAoIXJlYWxDb250ZXh0KSB7XG4gICAgcmVhbENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICAgICAgbnVsbFxuICAgICk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmVhbENvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJlYWN0UmVkdXhcIjtcbiAgICB9XG4gICAgY29udGV4dE1hcC5zZXQoUmVhY3QuY3JlYXRlQ29udGV4dCwgcmVhbENvbnRleHQpO1xuICB9XG4gIHJldHVybiByZWFsQ29udGV4dDtcbn1cbnZhciBSZWFjdFJlZHV4Q29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBnZXRDb250ZXh0KCk7XG5cbi8vIHNyYy9jb21wb25lbnRzL2Nvbm5lY3QudHN4XG52YXIgTk9fU1VCU0NSSVBUSU9OX0FSUkFZID0gW251bGwsIG51bGxdO1xudmFyIHN0cmluZ2lmeUNvbXBvbmVudCA9IChDb21wKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KENvbXApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nKENvbXApO1xuICB9XG59O1xuZnVuY3Rpb24gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKGVmZmVjdEZ1bmMsIGVmZmVjdEFyZ3MsIGRlcGVuZGVuY2llcykge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IGVmZmVjdEZ1bmMoLi4uZWZmZWN0QXJncyksIGRlcGVuZGVuY2llcyk7XG59XG5mdW5jdGlvbiBjYXB0dXJlV3JhcHBlclByb3BzKGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgd3JhcHBlclByb3BzLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzKSB7XG4gIGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudCA9IHdyYXBwZXJQcm9wcztcbiAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IGZhbHNlO1xuICBpZiAoY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50KSB7XG4gICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gbnVsbDtcbiAgICBub3RpZnlOZXN0ZWRTdWJzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHN1YnNjcmliZVVwZGF0ZXMoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLCBzdG9yZSwgc3Vic2NyaXB0aW9uLCBjaGlsZFByb3BzU2VsZWN0b3IsIGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgaXNNb3VudGVkLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzLCBhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIpIHtcbiAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHJldHVybiAoKSA9PiB7XG4gIH07XG4gIGxldCBkaWRVbnN1YnNjcmliZSA9IGZhbHNlO1xuICBsZXQgbGFzdFRocm93bkVycm9yID0gbnVsbDtcbiAgY29uc3QgY2hlY2tGb3JVcGRhdGVzID0gKCkgPT4ge1xuICAgIGlmIChkaWRVbnN1YnNjcmliZSB8fCAhaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGF0ZXN0U3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgbGV0IG5ld0NoaWxkUHJvcHMsIGVycm9yO1xuICAgIHRyeSB7XG4gICAgICBuZXdDaGlsZFByb3BzID0gY2hpbGRQcm9wc1NlbGVjdG9yKFxuICAgICAgICBsYXRlc3RTdG9yZVN0YXRlLFxuICAgICAgICBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnRcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IgPSBlO1xuICAgICAgbGFzdFRocm93bkVycm9yID0gZTtcbiAgICB9XG4gICAgaWYgKCFlcnJvcikge1xuICAgICAgbGFzdFRocm93bkVycm9yID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG5ld0NoaWxkUHJvcHMgPT09IGxhc3RDaGlsZFByb3BzLmN1cnJlbnQpIHtcbiAgICAgIGlmICghcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCkge1xuICAgICAgICBub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RDaGlsZFByb3BzLmN1cnJlbnQgPSBuZXdDaGlsZFByb3BzO1xuICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gbmV3Q2hpbGRQcm9wcztcbiAgICAgIHJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgYWRkaXRpb25hbFN1YnNjcmliZUxpc3RlbmVyKCk7XG4gICAgfVxuICB9O1xuICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IGNoZWNrRm9yVXBkYXRlcztcbiAgc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpO1xuICBjaGVja0ZvclVwZGF0ZXMoKTtcbiAgY29uc3QgdW5zdWJzY3JpYmVXcmFwcGVyID0gKCkgPT4ge1xuICAgIGRpZFVuc3Vic2NyaWJlID0gdHJ1ZTtcbiAgICBzdWJzY3JpcHRpb24udHJ5VW5zdWJzY3JpYmUoKTtcbiAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IG51bGw7XG4gICAgaWYgKGxhc3RUaHJvd25FcnJvcikge1xuICAgICAgdGhyb3cgbGFzdFRocm93bkVycm9yO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHVuc3Vic2NyaWJlV3JhcHBlcjtcbn1cbmZ1bmN0aW9uIHN0cmljdEVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbiA9IGZhbHNlO1xuZnVuY3Rpb24gY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywge1xuICAvLyBUaGUgYHB1cmVgIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkLCBzbyBUUyBkb2Vzbid0IGxpa2UgdXMgZGVzdHJ1Y3R1cmluZyB0aGlzIHRvIGNoZWNrIGl0cyBleGlzdGVuY2UuXG4gIC8vIEB0cy1pZ25vcmVcbiAgcHVyZSxcbiAgYXJlU3RhdGVzRXF1YWwgPSBzdHJpY3RFcXVhbCxcbiAgYXJlT3duUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgYXJlU3RhdGVQcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxuICBhcmVNZXJnZWRQcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxuICAvLyB1c2UgUmVhY3QncyBmb3J3YXJkUmVmIHRvIGV4cG9zZSBhIHJlZiBvZiB0aGUgd3JhcHBlZCBjb21wb25lbnRcbiAgZm9yd2FyZFJlZiA9IGZhbHNlLFxuICAvLyB0aGUgY29udGV4dCBjb25zdW1lciB0byB1c2VcbiAgY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0XG59ID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChwdXJlICE9PSB2b2lkIDAgJiYgIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24pIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24gPSB0cnVlO1xuICAgICAgd2FybmluZyhcbiAgICAgICAgJ1RoZSBgcHVyZWAgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQuIGBjb25uZWN0YCBpcyBub3cgYWx3YXlzIGEgXCJwdXJlL21lbW9pemVkXCIgY29tcG9uZW50J1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgQ29udGV4dCA9IGNvbnRleHQ7XG4gIGNvbnN0IGluaXRNYXBTdGF0ZVRvUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcyk7XG4gIGNvbnN0IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcyk7XG4gIGNvbnN0IGluaXRNZXJnZVByb3BzID0gbWVyZ2VQcm9wc0ZhY3RvcnkobWVyZ2VQcm9wcyk7XG4gIGNvbnN0IHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyA9IEJvb2xlYW4obWFwU3RhdGVUb1Byb3BzKTtcbiAgY29uc3Qgd3JhcFdpdGhDb25uZWN0ID0gKFdyYXBwZWRDb21wb25lbnQpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zdCBpc1ZhbGlkID0gLyogQF9fUFVSRV9fICovIGlzVmFsaWRFbGVtZW50VHlwZShXcmFwcGVkQ29tcG9uZW50KTtcbiAgICAgIGlmICghaXNWYWxpZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBZb3UgbXVzdCBwYXNzIGEgY29tcG9uZW50IHRvIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSBjb25uZWN0LiBJbnN0ZWFkIHJlY2VpdmVkICR7c3RyaW5naWZ5Q29tcG9uZW50KFxuICAgICAgICAgICAgV3JhcHBlZENvbXBvbmVudFxuICAgICAgICAgICl9YFxuICAgICAgICApO1xuICAgIH1cbiAgICBjb25zdCB3cmFwcGVkQ29tcG9uZW50TmFtZSA9IFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgY29uc3QgZGlzcGxheU5hbWUgPSBgQ29ubmVjdCgke3dyYXBwZWRDb21wb25lbnROYW1lfSlgO1xuICAgIGNvbnN0IHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMgPSB7XG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICBkaXNwbGF5TmFtZSxcbiAgICAgIHdyYXBwZWRDb21wb25lbnROYW1lLFxuICAgICAgV3JhcHBlZENvbXBvbmVudCxcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGluaXRNYXBTdGF0ZVRvUHJvcHMsXG4gICAgICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICAgICAgaW5pdE1lcmdlUHJvcHMsXG4gICAgICBhcmVTdGF0ZXNFcXVhbCxcbiAgICAgIGFyZVN0YXRlUHJvcHNFcXVhbCxcbiAgICAgIGFyZU93blByb3BzRXF1YWwsXG4gICAgICBhcmVNZXJnZWRQcm9wc0VxdWFsXG4gICAgfTtcbiAgICBmdW5jdGlvbiBDb25uZWN0RnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgIGNvbnN0IFtwcm9wc0NvbnRleHQsIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIHdyYXBwZXJQcm9wc10gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgeyByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmOiByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmMiwgLi4ud3JhcHBlclByb3BzMiB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiBbcHJvcHMuY29udGV4dCwgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjIsIHdyYXBwZXJQcm9wczJdO1xuICAgICAgfSwgW3Byb3BzXSk7XG4gICAgICBjb25zdCBDb250ZXh0VG9Vc2UgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgbGV0IFJlc3VsdENvbnRleHQgPSBDb250ZXh0O1xuICAgICAgICBpZiAocHJvcHNDb250ZXh0Py5Db25zdW1lcikge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSAvKiBAX19QVVJFX18gKi8gaXNDb250ZXh0Q29uc3VtZXIoXG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQocHJvcHNDb250ZXh0LkNvbnN1bWVyLCBudWxsKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJZb3UgbXVzdCBwYXNzIGEgdmFsaWQgUmVhY3QgY29udGV4dCBjb25zdW1lciBhcyBgcHJvcHMuY29udGV4dGBcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVzdWx0Q29udGV4dCA9IHByb3BzQ29udGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlc3VsdENvbnRleHQ7XG4gICAgICB9LCBbcHJvcHNDb250ZXh0LCBDb250ZXh0XSk7XG4gICAgICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KENvbnRleHRUb1VzZSk7XG4gICAgICBjb25zdCBkaWRTdG9yZUNvbWVGcm9tUHJvcHMgPSBCb29sZWFuKHByb3BzLnN0b3JlKSAmJiBCb29sZWFuKHByb3BzLnN0b3JlLmdldFN0YXRlKSAmJiBCb29sZWFuKHByb3BzLnN0b3JlLmRpc3BhdGNoKTtcbiAgICAgIGNvbnN0IGRpZFN0b3JlQ29tZUZyb21Db250ZXh0ID0gQm9vbGVhbihjb250ZXh0VmFsdWUpICYmIEJvb2xlYW4oY29udGV4dFZhbHVlLnN0b3JlKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWRpZFN0b3JlQ29tZUZyb21Qcm9wcyAmJiAhZGlkU3RvcmVDb21lRnJvbUNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDb3VsZCBub3QgZmluZCBcInN0b3JlXCIgaW4gdGhlIGNvbnRleHQgb2YgXCIke2Rpc3BsYXlOYW1lfVwiLiBFaXRoZXIgd3JhcCB0aGUgcm9vdCBjb21wb25lbnQgaW4gYSA8UHJvdmlkZXI+LCBvciBwYXNzIGEgY3VzdG9tIFJlYWN0IGNvbnRleHQgcHJvdmlkZXIgdG8gPFByb3ZpZGVyPiBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgUmVhY3QgY29udGV4dCBjb25zdW1lciB0byAke2Rpc3BsYXlOYW1lfSBpbiBjb25uZWN0IG9wdGlvbnMuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RvcmUgPSBkaWRTdG9yZUNvbWVGcm9tUHJvcHMgPyBwcm9wcy5zdG9yZSA6IGNvbnRleHRWYWx1ZS5zdG9yZTtcbiAgICAgIGNvbnN0IGdldFNlcnZlclN0YXRlID0gZGlkU3RvcmVDb21lRnJvbUNvbnRleHQgPyBjb250ZXh0VmFsdWUuZ2V0U2VydmVyU3RhdGUgOiBzdG9yZS5nZXRTdGF0ZTtcbiAgICAgIGNvbnN0IGNoaWxkUHJvcHNTZWxlY3RvciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShzdG9yZS5kaXNwYXRjaCwgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyk7XG4gICAgICB9LCBbc3RvcmVdKTtcbiAgICAgIGNvbnN0IFtzdWJzY3JpcHRpb24sIG5vdGlmeU5lc3RlZFN1YnNdID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSByZXR1cm4gTk9fU1VCU0NSSVBUSU9OX0FSUkFZO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24yID0gY3JlYXRlU3Vic2NyaXB0aW9uKFxuICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgIGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA/IHZvaWQgMCA6IGNvbnRleHRWYWx1ZS5zdWJzY3JpcHRpb25cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgbm90aWZ5TmVzdGVkU3ViczIgPSBzdWJzY3JpcHRpb24yLm5vdGlmeU5lc3RlZFN1YnMuYmluZChzdWJzY3JpcHRpb24yKTtcbiAgICAgICAgcmV0dXJuIFtzdWJzY3JpcHRpb24yLCBub3RpZnlOZXN0ZWRTdWJzMl07XG4gICAgICB9LCBbc3RvcmUsIGRpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlXSk7XG4gICAgICBjb25zdCBvdmVycmlkZGVuQ29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChkaWRTdG9yZUNvbWVGcm9tUHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uY29udGV4dFZhbHVlLFxuICAgICAgICAgIHN1YnNjcmlwdGlvblxuICAgICAgICB9O1xuICAgICAgfSwgW2RpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlLCBzdWJzY3JpcHRpb25dKTtcbiAgICAgIGNvbnN0IGxhc3RDaGlsZFByb3BzID0gUmVhY3QudXNlUmVmKHZvaWQgMCk7XG4gICAgICBjb25zdCBsYXN0V3JhcHBlclByb3BzID0gUmVhY3QudXNlUmVmKHdyYXBwZXJQcm9wcyk7XG4gICAgICBjb25zdCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlID0gUmVhY3QudXNlUmVmKHZvaWQgMCk7XG4gICAgICBjb25zdCByZW5kZXJJc1NjaGVkdWxlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgICBjb25zdCBpc01vdW50ZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgICAgY29uc3QgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciA9IFJlYWN0LnVzZVJlZihcbiAgICAgICAgdm9pZCAwXG4gICAgICApO1xuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgfSwgW10pO1xuICAgICAgY29uc3QgYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgJiYgd3JhcHBlclByb3BzID09PSBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzU2VsZWN0b3Ioc3RvcmUuZ2V0U3RhdGUoKSwgd3JhcHBlclByb3BzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgfSwgW3N0b3JlLCB3cmFwcGVyUHJvcHNdKTtcbiAgICAgIGNvbnN0IHN1YnNjcmliZUZvclJlYWN0ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZSA9IChyZWFjdExpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlVXBkYXRlcyhcbiAgICAgICAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY2hpbGRQcm9wc1NlbGVjdG9yLFxuICAgICAgICAgICAgbGFzdFdyYXBwZXJQcm9wcyxcbiAgICAgICAgICAgIGxhc3RDaGlsZFByb3BzLFxuICAgICAgICAgICAgcmVuZGVySXNTY2hlZHVsZWQsXG4gICAgICAgICAgICBpc01vdW50ZWQsXG4gICAgICAgICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLFxuICAgICAgICAgICAgbm90aWZ5TmVzdGVkU3VicyxcbiAgICAgICAgICAgIHJlYWN0TGlzdGVuZXJcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlO1xuICAgICAgfSwgW3N1YnNjcmlwdGlvbl0pO1xuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKGNhcHR1cmVXcmFwcGVyUHJvcHMsIFtcbiAgICAgICAgbGFzdFdyYXBwZXJQcm9wcyxcbiAgICAgICAgbGFzdENoaWxkUHJvcHMsXG4gICAgICAgIHJlbmRlcklzU2NoZWR1bGVkLFxuICAgICAgICB3cmFwcGVyUHJvcHMsXG4gICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsXG4gICAgICAgIG5vdGlmeU5lc3RlZFN1YnNcbiAgICAgIF0pO1xuICAgICAgbGV0IGFjdHVhbENoaWxkUHJvcHM7XG4gICAgICB0cnkge1xuICAgICAgICBhY3R1YWxDaGlsZFByb3BzID0gUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgLy8gVE9ETyBXZSdyZSBwYXNzaW5nIHRocm91Z2ggYSBiaWcgd3JhcHBlciB0aGF0IGRvZXMgYSBidW5jaCBvZiBleHRyYSBzaWRlIGVmZmVjdHMgYmVzaWRlcyBzdWJzY3JpYmluZ1xuICAgICAgICAgIHN1YnNjcmliZUZvclJlYWN0LFxuICAgICAgICAgIC8vIFRPRE8gVGhpcyBpcyBpbmNyZWRpYmx5IGhhY2t5LiBXZSd2ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGUgc3RvcmUgdXBkYXRlIGFuZCBjYWxjdWxhdGVkIG5ldyBjaGlsZCBwcm9wcyxcbiAgICAgICAgICAvLyBUT0RPIGFuZCB3ZSdyZSBqdXN0IHBhc3NpbmcgdGhhdCB0aHJvdWdoIHNvIGl0IHRyaWdnZXJzIGEgcmUtcmVuZGVyIGZvciB1cyByYXRoZXIgdGhhbiByZWx5aW5nIG9uIGB1U0VTYC5cbiAgICAgICAgICBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IsXG4gICAgICAgICAgZ2V0U2VydmVyU3RhdGUgPyAoKSA9PiBjaGlsZFByb3BzU2VsZWN0b3IoZ2V0U2VydmVyU3RhdGUoKSwgd3JhcHBlclByb3BzKSA6IGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvclxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQpIHtcbiAgICAgICAgICA7XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgKz0gYFxuVGhlIGVycm9yIG1heSBiZSBjb3JyZWxhdGVkIHdpdGggdGhpcyBwcmV2aW91cyBlcnJvcjpcbiR7bGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50LnN0YWNrfVxuXG5gO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgbGFzdENoaWxkUHJvcHMuY3VycmVudCA9IGFjdHVhbENoaWxkUHJvcHM7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIFdyYXBwZWRDb21wb25lbnQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLmFjdHVhbENoaWxkUHJvcHMsXG4gICAgICAgICAgICAgIHJlZjogcmVhY3RSZWR1eEZvcndhcmRlZFJlZlxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0sIFtyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmLCBXcmFwcGVkQ29tcG9uZW50LCBhY3R1YWxDaGlsZFByb3BzXSk7XG4gICAgICBjb25zdCByZW5kZXJlZENoaWxkID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHtcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dFRvVXNlLlByb3ZpZGVyLCB7IHZhbHVlOiBvdmVycmlkZGVuQ29udGV4dFZhbHVlIH0sIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudDtcbiAgICAgIH0sIFtDb250ZXh0VG9Vc2UsIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCwgb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZV0pO1xuICAgICAgcmV0dXJuIHJlbmRlcmVkQ2hpbGQ7XG4gICAgfVxuICAgIGNvbnN0IF9Db25uZWN0ID0gUmVhY3QubWVtbyhDb25uZWN0RnVuY3Rpb24pO1xuICAgIGNvbnN0IENvbm5lY3QgPSBfQ29ubmVjdDtcbiAgICBDb25uZWN0LldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgIENvbm5lY3QuZGlzcGxheU5hbWUgPSBDb25uZWN0RnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICBpZiAoZm9yd2FyZFJlZikge1xuICAgICAgY29uc3QgX2ZvcndhcmRlZCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmRDb25uZWN0UmVmKHByb3BzLCByZWYpIHtcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29ubmVjdCwgeyAuLi5wcm9wcywgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjogcmVmIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgY29uc3QgZm9yd2FyZGVkID0gX2ZvcndhcmRlZDtcbiAgICAgIGZvcndhcmRlZC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgICAgZm9yd2FyZGVkLldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBob2lzdE5vblJlYWN0U3RhdGljcyhmb3J3YXJkZWQsIFdyYXBwZWRDb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKENvbm5lY3QsIFdyYXBwZWRDb21wb25lbnQpO1xuICB9O1xuICByZXR1cm4gd3JhcFdpdGhDb25uZWN0O1xufVxudmFyIGNvbm5lY3RfZGVmYXVsdCA9IGNvbm5lY3Q7XG5cbi8vIHNyYy9jb21wb25lbnRzL1Byb3ZpZGVyLnRzeFxuZnVuY3Rpb24gUHJvdmlkZXIocHJvdmlkZXJQcm9wcykge1xuICBjb25zdCB7IGNoaWxkcmVuLCBjb250ZXh0LCBzZXJ2ZXJTdGF0ZSwgc3RvcmUgfSA9IHByb3ZpZGVyUHJvcHM7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGNyZWF0ZVN1YnNjcmlwdGlvbihzdG9yZSk7XG4gICAgY29uc3QgYmFzZUNvbnRleHRWYWx1ZSA9IHtcbiAgICAgIHN0b3JlLFxuICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgZ2V0U2VydmVyU3RhdGU6IHNlcnZlclN0YXRlID8gKCkgPT4gc2VydmVyU3RhdGUgOiB2b2lkIDBcbiAgICB9O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBiYXNlQ29udGV4dFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IGlkZW50aXR5RnVuY3Rpb25DaGVjayA9IFwib25jZVwiLCBzdGFiaWxpdHlDaGVjayA9IFwib25jZVwiIH0gPSBwcm92aWRlclByb3BzO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuYXNzaWduKGJhc2VDb250ZXh0VmFsdWUsIHtcbiAgICAgICAgc3RhYmlsaXR5Q2hlY2ssXG4gICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVja1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbc3RvcmUsIHNlcnZlclN0YXRlXSk7XG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHN0b3JlLmdldFN0YXRlKCksIFtzdG9yZV0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7IHN1YnNjcmlwdGlvbiB9ID0gY29udGV4dFZhbHVlO1xuICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnM7XG4gICAgc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpO1xuICAgIGlmIChwcmV2aW91c1N0YXRlICE9PSBzdG9yZS5nZXRTdGF0ZSgpKSB7XG4gICAgICBzdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3VicygpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IHZvaWQgMDtcbiAgICB9O1xuICB9LCBbY29udGV4dFZhbHVlLCBwcmV2aW91c1N0YXRlXSk7XG4gIGNvbnN0IENvbnRleHQgPSBjb250ZXh0IHx8IFJlYWN0UmVkdXhDb250ZXh0O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dFZhbHVlIH0sIGNoaWxkcmVuKTtcbn1cbnZhciBQcm92aWRlcl9kZWZhdWx0ID0gUHJvdmlkZXI7XG5cbi8vIHNyYy9ob29rcy91c2VSZWR1eENvbnRleHQudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiB1c2VSZWR1eENvbnRleHQyKCkge1xuICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoY29udGV4dCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhY29udGV4dFZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiY291bGQgbm90IGZpbmQgcmVhY3QtcmVkdXggY29udGV4dCB2YWx1ZTsgcGxlYXNlIGVuc3VyZSB0aGUgY29tcG9uZW50IGlzIHdyYXBwZWQgaW4gYSA8UHJvdmlkZXI+XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0VmFsdWU7XG4gIH07XG59XG52YXIgdXNlUmVkdXhDb250ZXh0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soKTtcblxuLy8gc3JjL2hvb2tzL3VzZVN0b3JlLnRzXG5mdW5jdGlvbiBjcmVhdGVTdG9yZUhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIGNvbnN0IHVzZVJlZHV4Q29udGV4dDIgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZVJlZHV4Q29udGV4dCA6IChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY3JlYXRlUmVkdXhDb250ZXh0SG9vayhjb250ZXh0KVxuICApO1xuICBjb25zdCB1c2VTdG9yZTIgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBzdG9yZSB9ID0gdXNlUmVkdXhDb250ZXh0MigpO1xuICAgIHJldHVybiBzdG9yZTtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih1c2VTdG9yZTIsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHVzZVN0b3JlMlxuICB9KTtcbiAgcmV0dXJuIHVzZVN0b3JlMjtcbn1cbnZhciB1c2VTdG9yZSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTdG9yZUhvb2soKTtcblxuLy8gc3JjL2hvb2tzL3VzZURpc3BhdGNoLnRzXG5mdW5jdGlvbiBjcmVhdGVEaXNwYXRjaEhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIGNvbnN0IHVzZVN0b3JlMiA9IGNvbnRleHQgPT09IFJlYWN0UmVkdXhDb250ZXh0ID8gdXNlU3RvcmUgOiBjcmVhdGVTdG9yZUhvb2soY29udGV4dCk7XG4gIGNvbnN0IHVzZURpc3BhdGNoMiA9ICgpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlMigpO1xuICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaDtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih1c2VEaXNwYXRjaDIsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHVzZURpc3BhdGNoMlxuICB9KTtcbiAgcmV0dXJuIHVzZURpc3BhdGNoMjtcbn1cbnZhciB1c2VEaXNwYXRjaCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEaXNwYXRjaEhvb2soKTtcblxuLy8gc3JjL2hvb2tzL3VzZVNlbGVjdG9yLnRzXG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS93aXRoLXNlbGVjdG9yLmpzXCI7XG52YXIgcmVmRXF1YWxpdHkgPSAoYSwgYikgPT4gYSA9PT0gYjtcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9ySG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgY29uc3QgdXNlUmVkdXhDb250ZXh0MiA9IGNvbnRleHQgPT09IFJlYWN0UmVkdXhDb250ZXh0ID8gdXNlUmVkdXhDb250ZXh0IDogY3JlYXRlUmVkdXhDb250ZXh0SG9vayhjb250ZXh0KTtcbiAgY29uc3QgdXNlU2VsZWN0b3IyID0gKHNlbGVjdG9yLCBlcXVhbGl0eUZuT3JPcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCB7IGVxdWFsaXR5Rm4gPSByZWZFcXVhbGl0eSB9ID0gdHlwZW9mIGVxdWFsaXR5Rm5Pck9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IHsgZXF1YWxpdHlGbjogZXF1YWxpdHlGbk9yT3B0aW9ucyB9IDogZXF1YWxpdHlGbk9yT3B0aW9ucztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcGFzcyBhIHNlbGVjdG9yIHRvIHVzZVNlbGVjdG9yYCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgZnVuY3Rpb24gYXMgYSBzZWxlY3RvciB0byB1c2VTZWxlY3RvcmApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlcXVhbGl0eUZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBZb3UgbXVzdCBwYXNzIGEgZnVuY3Rpb24gYXMgYW4gZXF1YWxpdHkgZnVuY3Rpb24gdG8gdXNlU2VsZWN0b3JgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlZHV4Q29udGV4dCA9IHVzZVJlZHV4Q29udGV4dDIoKTtcbiAgICBjb25zdCB7IHN0b3JlLCBzdWJzY3JpcHRpb24sIGdldFNlcnZlclN0YXRlIH0gPSByZWR1eENvbnRleHQ7XG4gICAgY29uc3QgZmlyc3RSdW4gPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICB7XG4gICAgICAgIFtzZWxlY3Rvci5uYW1lXShzdGF0ZSkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGV2TW9kZUNoZWNrcyA9IHt9IH0gPSB0eXBlb2YgZXF1YWxpdHlGbk9yT3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8ge30gOiBlcXVhbGl0eUZuT3JPcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgeyBpZGVudGl0eUZ1bmN0aW9uQ2hlY2ssIHN0YWJpbGl0eUNoZWNrIH0gPSByZWR1eENvbnRleHQ7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVjazogZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2ssXG4gICAgICAgICAgICAgIHN0YWJpbGl0eUNoZWNrOiBmaW5hbFN0YWJpbGl0eUNoZWNrXG4gICAgICAgICAgICB9ID0ge1xuICAgICAgICAgICAgICBzdGFiaWxpdHlDaGVjayxcbiAgICAgICAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrLFxuICAgICAgICAgICAgICAuLi5kZXZNb2RlQ2hlY2tzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGZpbmFsU3RhYmlsaXR5Q2hlY2sgPT09IFwiYWx3YXlzXCIgfHwgZmluYWxTdGFiaWxpdHlDaGVjayA9PT0gXCJvbmNlXCIgJiYgZmlyc3RSdW4uY3VycmVudCkge1xuICAgICAgICAgICAgICBjb25zdCB0b0NvbXBhcmUgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgICAgICAgICAgIGlmICghZXF1YWxpdHlGbihzZWxlY3RlZCwgdG9Db21wYXJlKSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgKHsgc3RhY2sgfSA9IGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICBcIlNlbGVjdG9yIFwiICsgKHNlbGVjdG9yLm5hbWUgfHwgXCJ1bmtub3duXCIpICsgXCIgcmV0dXJuZWQgYSBkaWZmZXJlbnQgcmVzdWx0IHdoZW4gY2FsbGVkIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycy4gVGhpcyBjYW4gbGVhZCB0byB1bm5lY2Vzc2FyeSByZXJlbmRlcnMuXFxuU2VsZWN0b3JzIHRoYXQgcmV0dXJuIGEgbmV3IHJlZmVyZW5jZSAoc3VjaCBhcyBhbiBvYmplY3Qgb3IgYW4gYXJyYXkpIHNob3VsZCBiZSBtZW1vaXplZDogaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdXNhZ2UvZGVyaXZpbmctZGF0YS1zZWxlY3RvcnMjb3B0aW1pemluZy1zZWxlY3RvcnMtd2l0aC1tZW1vaXphdGlvblwiLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkMjogdG9Db21wYXJlLFxuICAgICAgICAgICAgICAgICAgICBzdGFja1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaW5hbElkZW50aXR5RnVuY3Rpb25DaGVjayA9PT0gXCJhbHdheXNcIiB8fCBmaW5hbElkZW50aXR5RnVuY3Rpb25DaGVjayA9PT0gXCJvbmNlXCIgJiYgZmlyc3RSdW4uY3VycmVudCkge1xuICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAoeyBzdGFjayB9ID0gZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgIFwiU2VsZWN0b3IgXCIgKyAoc2VsZWN0b3IubmFtZSB8fCBcInVua25vd25cIikgKyBcIiByZXR1cm5lZCB0aGUgcm9vdCBzdGF0ZSB3aGVuIGNhbGxlZC4gVGhpcyBjYW4gbGVhZCB0byB1bm5lY2Vzc2FyeSByZXJlbmRlcnMuXFxuU2VsZWN0b3JzIHRoYXQgcmV0dXJuIHRoZSBlbnRpcmUgc3RhdGUgYXJlIGFsbW9zdCBjZXJ0YWlubHkgYSBtaXN0YWtlLCBhcyB0aGV5IHdpbGwgY2F1c2UgYSByZXJlbmRlciB3aGVuZXZlciAqYW55dGhpbmcqIGluIHN0YXRlIGNoYW5nZXMuXCIsXG4gICAgICAgICAgICAgICAgICB7IHN0YWNrIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RSdW4uY3VycmVudCkgZmlyc3RSdW4uY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1bc2VsZWN0b3IubmFtZV0sXG4gICAgICBbc2VsZWN0b3JdXG4gICAgKTtcbiAgICBjb25zdCBzZWxlY3RlZFN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgICBzdWJzY3JpcHRpb24uYWRkTmVzdGVkU3ViLFxuICAgICAgc3RvcmUuZ2V0U3RhdGUsXG4gICAgICBnZXRTZXJ2ZXJTdGF0ZSB8fCBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgIHdyYXBwZWRTZWxlY3RvcixcbiAgICAgIGVxdWFsaXR5Rm5cbiAgICApO1xuICAgIFJlYWN0LnVzZURlYnVnVmFsdWUoc2VsZWN0ZWRTdGF0ZSk7XG4gICAgcmV0dXJuIHNlbGVjdGVkU3RhdGU7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odXNlU2VsZWN0b3IyLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiB1c2VTZWxlY3RvcjJcbiAgfSk7XG4gIHJldHVybiB1c2VTZWxlY3RvcjI7XG59XG52YXIgdXNlU2VsZWN0b3IgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU2VsZWN0b3JIb29rKCk7XG5cbi8vIHNyYy9leHBvcnRzLnRzXG52YXIgYmF0Y2ggPSBkZWZhdWx0Tm9vcEJhdGNoO1xuZXhwb3J0IHtcbiAgUHJvdmlkZXJfZGVmYXVsdCBhcyBQcm92aWRlcixcbiAgUmVhY3RSZWR1eENvbnRleHQsXG4gIGJhdGNoLFxuICBjb25uZWN0X2RlZmF1bHQgYXMgY29ubmVjdCxcbiAgY3JlYXRlRGlzcGF0Y2hIb29rLFxuICBjcmVhdGVTZWxlY3Rvckhvb2ssXG4gIGNyZWF0ZVN0b3JlSG9vayxcbiAgc2hhbGxvd0VxdWFsLFxuICB1c2VEaXNwYXRjaCxcbiAgdXNlU2VsZWN0b3IsXG4gIHVzZVN0b3JlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtcmVkdXgubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/dist/react-redux.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/redux/dist/redux.mjs":
/*!*******************************************!*\
  !*** ./node_modules/redux/dist/redux.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __DO_NOT_USE__ActionTypes: () => (/* binding */ actionTypes_default),\n/* harmony export */   applyMiddleware: () => (/* binding */ applyMiddleware),\n/* harmony export */   bindActionCreators: () => (/* binding */ bindActionCreators),\n/* harmony export */   combineReducers: () => (/* binding */ combineReducers),\n/* harmony export */   compose: () => (/* binding */ compose),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   isAction: () => (/* binding */ isAction),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   legacy_createStore: () => (/* binding */ legacy_createStore)\n/* harmony export */ });\n// src/utils/formatProdErrorMessage.ts\nfunction formatProdErrorMessage(code) {\n  return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\n}\n\n// src/utils/symbol-observable.ts\nvar $$observable = /* @__PURE__ */ (() => typeof Symbol === \"function\" && Symbol.observable || \"@@observable\")();\nvar symbol_observable_default = $$observable;\n\n// src/utils/actionTypes.ts\nvar randomString = () => Math.random().toString(36).substring(7).split(\"\").join(\".\");\nvar ActionTypes = {\n  INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,\n  REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,\n  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`\n};\nvar actionTypes_default = ActionTypes;\n\n// src/utils/isPlainObject.ts\nfunction isPlainObject(obj) {\n  if (typeof obj !== \"object\" || obj === null)\n    return false;\n  let proto = obj;\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n  return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;\n}\n\n// src/utils/kindOf.ts\nfunction miniKindOf(val) {\n  if (val === void 0)\n    return \"undefined\";\n  if (val === null)\n    return \"null\";\n  const type = typeof val;\n  switch (type) {\n    case \"boolean\":\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"function\": {\n      return type;\n    }\n  }\n  if (Array.isArray(val))\n    return \"array\";\n  if (isDate(val))\n    return \"date\";\n  if (isError(val))\n    return \"error\";\n  const constructorName = ctorName(val);\n  switch (constructorName) {\n    case \"Symbol\":\n    case \"Promise\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n    case \"Map\":\n    case \"Set\":\n      return constructorName;\n  }\n  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\\s/g, \"\");\n}\nfunction ctorName(val) {\n  return typeof val.constructor === \"function\" ? val.constructor.name : null;\n}\nfunction isError(val) {\n  return val instanceof Error || typeof val.message === \"string\" && val.constructor && typeof val.constructor.stackTraceLimit === \"number\";\n}\nfunction isDate(val) {\n  if (val instanceof Date)\n    return true;\n  return typeof val.toDateString === \"function\" && typeof val.getDate === \"function\" && typeof val.setDate === \"function\";\n}\nfunction kindOf(val) {\n  let typeOfVal = typeof val;\n  if (true) {\n    typeOfVal = miniKindOf(val);\n  }\n  return typeOfVal;\n}\n\n// src/createStore.ts\nfunction createStore(reducer, preloadedState, enhancer) {\n  if (typeof reducer !== \"function\") {\n    throw new Error( false ? 0 : `Expected the root reducer to be a function. Instead, received: '${kindOf(reducer)}'`);\n  }\n  if (typeof preloadedState === \"function\" && typeof enhancer === \"function\" || typeof enhancer === \"function\" && typeof arguments[3] === \"function\") {\n    throw new Error( false ? 0 : \"It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.\");\n  }\n  if (typeof preloadedState === \"function\" && typeof enhancer === \"undefined\") {\n    enhancer = preloadedState;\n    preloadedState = void 0;\n  }\n  if (typeof enhancer !== \"undefined\") {\n    if (typeof enhancer !== \"function\") {\n      throw new Error( false ? 0 : `Expected the enhancer to be a function. Instead, received: '${kindOf(enhancer)}'`);\n    }\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n  let currentReducer = reducer;\n  let currentState = preloadedState;\n  let currentListeners = /* @__PURE__ */ new Map();\n  let nextListeners = currentListeners;\n  let listenerIdCounter = 0;\n  let isDispatching = false;\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = /* @__PURE__ */ new Map();\n      currentListeners.forEach((listener, key) => {\n        nextListeners.set(key, listener);\n      });\n    }\n  }\n  function getState() {\n    if (isDispatching) {\n      throw new Error( false ? 0 : \"You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.\");\n    }\n    return currentState;\n  }\n  function subscribe(listener) {\n    if (typeof listener !== \"function\") {\n      throw new Error( false ? 0 : `Expected the listener to be a function. Instead, received: '${kindOf(listener)}'`);\n    }\n    if (isDispatching) {\n      throw new Error( false ? 0 : \"You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.\");\n    }\n    let isSubscribed = true;\n    ensureCanMutateNextListeners();\n    const listenerId = listenerIdCounter++;\n    nextListeners.set(listenerId, listener);\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n      if (isDispatching) {\n        throw new Error( false ? 0 : \"You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.\");\n      }\n      isSubscribed = false;\n      ensureCanMutateNextListeners();\n      nextListeners.delete(listenerId);\n      currentListeners = null;\n    };\n  }\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error( false ? 0 : `Actions must be plain objects. Instead, the actual type was: '${kindOf(action)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);\n    }\n    if (typeof action.type === \"undefined\") {\n      throw new Error( false ? 0 : 'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.');\n    }\n    if (typeof action.type !== \"string\") {\n      throw new Error( false ? 0 : `Action \"type\" property must be a string. Instead, the actual type was: '${kindOf(action.type)}'. Value was: '${action.type}' (stringified)`);\n    }\n    if (isDispatching) {\n      throw new Error( false ? 0 : \"Reducers may not dispatch actions.\");\n    }\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n    const listeners = currentListeners = nextListeners;\n    listeners.forEach((listener) => {\n      listener();\n    });\n    return action;\n  }\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== \"function\") {\n      throw new Error( false ? 0 : `Expected the nextReducer to be a function. Instead, received: '${kindOf(nextReducer)}`);\n    }\n    currentReducer = nextReducer;\n    dispatch({\n      type: actionTypes_default.REPLACE\n    });\n  }\n  function observable() {\n    const outerSubscribe = subscribe;\n    return {\n      /**\n       * The minimal observable subscription method.\n       * @param observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe(observer) {\n        if (typeof observer !== \"object\" || observer === null) {\n          throw new Error( false ? 0 : `Expected the observer to be an object. Instead, received: '${kindOf(observer)}'`);\n        }\n        function observeState() {\n          const observerAsObserver = observer;\n          if (observerAsObserver.next) {\n            observerAsObserver.next(getState());\n          }\n        }\n        observeState();\n        const unsubscribe = outerSubscribe(observeState);\n        return {\n          unsubscribe\n        };\n      },\n      [symbol_observable_default]() {\n        return this;\n      }\n    };\n  }\n  dispatch({\n    type: actionTypes_default.INIT\n  });\n  const store = {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer,\n    [symbol_observable_default]: observable\n  };\n  return store;\n}\nfunction legacy_createStore(reducer, preloadedState, enhancer) {\n  return createStore(reducer, preloadedState, enhancer);\n}\n\n// src/utils/warning.ts\nfunction warning(message) {\n  if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n    console.error(message);\n  }\n  try {\n    throw new Error(message);\n  } catch (e) {\n  }\n}\n\n// src/combineReducers.ts\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  const reducerKeys = Object.keys(reducers);\n  const argumentName = action && action.type === actionTypes_default.INIT ? \"preloadedState argument passed to createStore\" : \"previous state received by the reducer\";\n  if (reducerKeys.length === 0) {\n    return \"Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.\";\n  }\n  if (!isPlainObject(inputState)) {\n    return `The ${argumentName} has unexpected type of \"${kindOf(inputState)}\". Expected argument to be an object with the following keys: \"${reducerKeys.join('\", \"')}\"`;\n  }\n  const unexpectedKeys = Object.keys(inputState).filter((key) => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);\n  unexpectedKeys.forEach((key) => {\n    unexpectedKeyCache[key] = true;\n  });\n  if (action && action.type === actionTypes_default.REPLACE)\n    return;\n  if (unexpectedKeys.length > 0) {\n    return `Unexpected ${unexpectedKeys.length > 1 ? \"keys\" : \"key\"} \"${unexpectedKeys.join('\", \"')}\" found in ${argumentName}. Expected to find one of the known reducer keys instead: \"${reducerKeys.join('\", \"')}\". Unexpected keys will be ignored.`;\n  }\n}\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach((key) => {\n    const reducer = reducers[key];\n    const initialState = reducer(void 0, {\n      type: actionTypes_default.INIT\n    });\n    if (typeof initialState === \"undefined\") {\n      throw new Error( false ? 0 : `The slice reducer for key \"${key}\" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);\n    }\n    if (typeof reducer(void 0, {\n      type: actionTypes_default.PROBE_UNKNOWN_ACTION()\n    }) === \"undefined\") {\n      throw new Error( false ? 0 : `The slice reducer for key \"${key}\" returned undefined when probed with a random type. Don't try to handle '${actionTypes_default.INIT}' or other actions in \"redux/*\" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);\n    }\n  });\n}\nfunction combineReducers(reducers) {\n  const reducerKeys = Object.keys(reducers);\n  const finalReducers = {};\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i];\n    if (true) {\n      if (typeof reducers[key] === \"undefined\") {\n        warning(`No reducer provided for key \"${key}\"`);\n      }\n    }\n    if (typeof reducers[key] === \"function\") {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers);\n  let unexpectedKeyCache;\n  if (true) {\n    unexpectedKeyCache = {};\n  }\n  let shapeAssertionError;\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n  return function combination(state = {}, action) {\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n    if (true) {\n      const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n      if (warningMessage) {\n        warning(warningMessage);\n      }\n    }\n    let hasChanged = false;\n    const nextState = {};\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i];\n      const reducer = finalReducers[key];\n      const previousStateForKey = state[key];\n      const nextStateForKey = reducer(previousStateForKey, action);\n      if (typeof nextStateForKey === \"undefined\") {\n        const actionType = action && action.type;\n        throw new Error( false ? 0 : `When called with an action of type ${actionType ? `\"${String(actionType)}\"` : \"(unknown type)\"}, the slice reducer for key \"${key}\" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);\n      }\n      nextState[key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n    return hasChanged ? nextState : state;\n  };\n}\n\n// src/bindActionCreators.ts\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function(...args) {\n    return dispatch(actionCreator.apply(this, args));\n  };\n}\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === \"function\") {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n  if (typeof actionCreators !== \"object\" || actionCreators === null) {\n    throw new Error( false ? 0 : `bindActionCreators expected an object or a function, but instead received: '${kindOf(actionCreators)}'. Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?`);\n  }\n  const boundActionCreators = {};\n  for (const key in actionCreators) {\n    const actionCreator = actionCreators[key];\n    if (typeof actionCreator === \"function\") {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n  return boundActionCreators;\n}\n\n// src/compose.ts\nfunction compose(...funcs) {\n  if (funcs.length === 0) {\n    return (arg) => arg;\n  }\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}\n\n// src/applyMiddleware.ts\nfunction applyMiddleware(...middlewares) {\n  return (createStore2) => (reducer, preloadedState) => {\n    const store = createStore2(reducer, preloadedState);\n    let dispatch = () => {\n      throw new Error( false ? 0 : \"Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.\");\n    };\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (action, ...args) => dispatch(action, ...args)\n    };\n    const chain = middlewares.map((middleware) => middleware(middlewareAPI));\n    dispatch = compose(...chain)(store.dispatch);\n    return {\n      ...store,\n      dispatch\n    };\n  };\n}\n\n// src/utils/isAction.ts\nfunction isAction(action) {\n  return isPlainObject(action) && \"type\" in action && typeof action.type === \"string\";\n}\n\n//# sourceMappingURL=redux.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWR1eC9kaXN0L3JlZHV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU8seUNBQXlDLE1BQU07QUFDeEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQsNkJBQTZCLCtCQUErQjtBQUM1RCw2REFBNkQsZUFBZTtBQUM1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFxQyxHQUFHLENBQXlCLHNFQUFzRSxnQkFBZ0I7QUFDM0s7QUFDQTtBQUNBLG9CQUFvQixNQUFxQyxHQUFHLENBQXlCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQXFDLEdBQUcsQ0FBeUIsa0VBQWtFLGlCQUFpQjtBQUMxSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQXFDLEdBQUcsQ0FBeUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7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LHVCQUF1QjtBQUMvTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQXFDLEdBQUcsQ0FBMEI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFXRTtBQUNGIiwic291cmNlcyI6WyIvYXBwL25vZGVfbW9kdWxlcy9yZWR1eC9kaXN0L3JlZHV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZS50c1xuZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlKSB7XG4gIHJldHVybiBgTWluaWZpZWQgUmVkdXggZXJyb3IgIyR7Y29kZX07IHZpc2l0IGh0dHBzOi8vcmVkdXguanMub3JnL0Vycm9ycz9jb2RlPSR7Y29kZX0gZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycy4gYDtcbn1cblxuLy8gc3JjL3V0aWxzL3N5bWJvbC1vYnNlcnZhYmxlLnRzXG52YXIgJCRvYnNlcnZhYmxlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLm9ic2VydmFibGUgfHwgXCJAQG9ic2VydmFibGVcIikoKTtcbnZhciBzeW1ib2xfb2JzZXJ2YWJsZV9kZWZhdWx0ID0gJCRvYnNlcnZhYmxlO1xuXG4vLyBzcmMvdXRpbHMvYWN0aW9uVHlwZXMudHNcbnZhciByYW5kb21TdHJpbmcgPSAoKSA9PiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoXCJcIikuam9pbihcIi5cIik7XG52YXIgQWN0aW9uVHlwZXMgPSB7XG4gIElOSVQ6IGBAQHJlZHV4L0lOSVQkey8qIEBfX1BVUkVfXyAqLyByYW5kb21TdHJpbmcoKX1gLFxuICBSRVBMQUNFOiBgQEByZWR1eC9SRVBMQUNFJHsvKiBAX19QVVJFX18gKi8gcmFuZG9tU3RyaW5nKCl9YCxcbiAgUFJPQkVfVU5LTk9XTl9BQ1RJT046ICgpID0+IGBAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OJHtyYW5kb21TdHJpbmcoKX1gXG59O1xudmFyIGFjdGlvblR5cGVzX2RlZmF1bHQgPSBBY3Rpb25UeXBlcztcblxuLy8gc3JjL3V0aWxzL2lzUGxhaW5PYmplY3QudHNcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGxldCBwcm90byA9IG9iajtcbiAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgIT09IG51bGwpIHtcbiAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBwcm90byB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gbnVsbDtcbn1cblxuLy8gc3JjL3V0aWxzL2tpbmRPZi50c1xuZnVuY3Rpb24gbWluaUtpbmRPZih2YWwpIHtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwKVxuICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICBpZiAodmFsID09PSBudWxsKVxuICAgIHJldHVybiBcIm51bGxcIjtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgY2FzZSBcImZ1bmN0aW9uXCI6IHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKVxuICAgIHJldHVybiBcImFycmF5XCI7XG4gIGlmIChpc0RhdGUodmFsKSlcbiAgICByZXR1cm4gXCJkYXRlXCI7XG4gIGlmIChpc0Vycm9yKHZhbCkpXG4gICAgcmV0dXJuIFwiZXJyb3JcIjtcbiAgY29uc3QgY29uc3RydWN0b3JOYW1lID0gY3Rvck5hbWUodmFsKTtcbiAgc3dpdGNoIChjb25zdHJ1Y3Rvck5hbWUpIHtcbiAgICBjYXNlIFwiU3ltYm9sXCI6XG4gICAgY2FzZSBcIlByb21pc2VcIjpcbiAgICBjYXNlIFwiV2Vha01hcFwiOlxuICAgIGNhc2UgXCJXZWFrU2V0XCI6XG4gICAgY2FzZSBcIk1hcFwiOlxuICAgIGNhc2UgXCJTZXRcIjpcbiAgICAgIHJldHVybiBjb25zdHJ1Y3Rvck5hbWU7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccy9nLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGN0b3JOYW1lKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbC5jb25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiID8gdmFsLmNvbnN0cnVjdG9yLm5hbWUgOiBudWxsO1xufVxuZnVuY3Rpb24gaXNFcnJvcih2YWwpIHtcbiAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIEVycm9yIHx8IHR5cGVvZiB2YWwubWVzc2FnZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWwuY29uc3RydWN0b3IgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5zdGFja1RyYWNlTGltaXQgPT09IFwibnVtYmVyXCI7XG59XG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKVxuICAgIHJldHVybiB0cnVlO1xuICByZXR1cm4gdHlwZW9mIHZhbC50b0RhdGVTdHJpbmcgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdmFsLmdldERhdGUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdmFsLnNldERhdGUgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGtpbmRPZih2YWwpIHtcbiAgbGV0IHR5cGVPZlZhbCA9IHR5cGVvZiB2YWw7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB0eXBlT2ZWYWwgPSBtaW5pS2luZE9mKHZhbCk7XG4gIH1cbiAgcmV0dXJuIHR5cGVPZlZhbDtcbn1cblxuLy8gc3JjL2NyZWF0ZVN0b3JlLnRzXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgaWYgKHR5cGVvZiByZWR1Y2VyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyKSA6IGBFeHBlY3RlZCB0aGUgcm9vdCByZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQsIHJlY2VpdmVkOiAnJHtraW5kT2YocmVkdWNlcil9J2ApO1xuICB9XG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZW5oYW5jZXIgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgZW5oYW5jZXIgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgYXJndW1lbnRzWzNdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgwKSA6IFwiSXQgbG9va3MgbGlrZSB5b3UgYXJlIHBhc3Npbmcgc2V2ZXJhbCBzdG9yZSBlbmhhbmNlcnMgdG8gY3JlYXRlU3RvcmUoKS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBJbnN0ZWFkLCBjb21wb3NlIHRoZW0gdG9nZXRoZXIgdG8gYSBzaW5nbGUgZnVuY3Rpb24uIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNC1zdG9yZSNjcmVhdGluZy1hLXN0b3JlLXdpdGgtZW5oYW5jZXJzIGZvciBhbiBleGFtcGxlLlwiKTtcbiAgfVxuICBpZiAodHlwZW9mIHByZWxvYWRlZFN0YXRlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGVuaGFuY2VyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZW5oYW5jZXIgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHZvaWQgMDtcbiAgfVxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxKSA6IGBFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICcke2tpbmRPZihlbmhhbmNlcil9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgfVxuICBsZXQgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyO1xuICBsZXQgY3VycmVudFN0YXRlID0gcHJlbG9hZGVkU3RhdGU7XG4gIGxldCBjdXJyZW50TGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xuICBsZXQgbGlzdGVuZXJJZENvdW50ZXIgPSAwO1xuICBsZXQgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICBmdW5jdGlvbiBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCkge1xuICAgIGlmIChuZXh0TGlzdGVuZXJzID09PSBjdXJyZW50TGlzdGVuZXJzKSB7XG4gICAgICBuZXh0TGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGN1cnJlbnRMaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIsIGtleSkgPT4ge1xuICAgICAgICBuZXh0TGlzdGVuZXJzLnNldChrZXksIGxpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMykgOiBcIllvdSBtYXkgbm90IGNhbGwgc3RvcmUuZ2V0U3RhdGUoKSB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuIFRoZSByZWR1Y2VyIGhhcyBhbHJlYWR5IHJlY2VpdmVkIHRoZSBzdGF0ZSBhcyBhbiBhcmd1bWVudC4gUGFzcyBpdCBkb3duIGZyb20gdGhlIHRvcCByZWR1Y2VyIGluc3RlYWQgb2YgcmVhZGluZyBpdCBmcm9tIHRoZSBzdG9yZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0KSA6IGBFeHBlY3RlZCB0aGUgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICcke2tpbmRPZihsaXN0ZW5lcil9J2ApO1xuICAgIH1cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNSkgOiBcIllvdSBtYXkgbm90IGNhbGwgc3RvcmUuc3Vic2NyaWJlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiBJZiB5b3Ugd291bGQgbGlrZSB0byBiZSBub3RpZmllZCBhZnRlciB0aGUgc3RvcmUgaGFzIGJlZW4gdXBkYXRlZCwgc3Vic2NyaWJlIGZyb20gYSBjb21wb25lbnQgYW5kIGludm9rZSBzdG9yZS5nZXRTdGF0ZSgpIGluIHRoZSBjYWxsYmFjayB0byBhY2Nlc3MgdGhlIGxhdGVzdCBzdGF0ZS4gU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2FwaS9zdG9yZSNzdWJzY3JpYmVsaXN0ZW5lciBmb3IgbW9yZSBkZXRhaWxzLlwiKTtcbiAgICB9XG4gICAgbGV0IGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIGNvbnN0IGxpc3RlbmVySWQgPSBsaXN0ZW5lcklkQ291bnRlcisrO1xuICAgIG5leHRMaXN0ZW5lcnMuc2V0KGxpc3RlbmVySWQsIGxpc3RlbmVyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoIWlzU3Vic2NyaWJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg2KSA6IFwiWW91IG1heSBub3QgdW5zdWJzY3JpYmUgZnJvbSBhIHN0b3JlIGxpc3RlbmVyIHdoaWxlIHRoZSByZWR1Y2VyIGlzIGV4ZWN1dGluZy4gU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2FwaS9zdG9yZSNzdWJzY3JpYmVsaXN0ZW5lciBmb3IgbW9yZSBkZXRhaWxzLlwiKTtcbiAgICAgIH1cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgICAgbmV4dExpc3RlbmVycy5kZWxldGUobGlzdGVuZXJJZCk7XG4gICAgICBjdXJyZW50TGlzdGVuZXJzID0gbnVsbDtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg3KSA6IGBBY3Rpb25zIG11c3QgYmUgcGxhaW4gb2JqZWN0cy4gSW5zdGVhZCwgdGhlIGFjdHVhbCB0eXBlIHdhczogJyR7a2luZE9mKGFjdGlvbil9Jy4gWW91IG1heSBuZWVkIHRvIGFkZCBtaWRkbGV3YXJlIHRvIHlvdXIgc3RvcmUgc2V0dXAgdG8gaGFuZGxlIGRpc3BhdGNoaW5nIG90aGVyIHZhbHVlcywgc3VjaCBhcyAncmVkdXgtdGh1bmsnIHRvIGhhbmRsZSBkaXNwYXRjaGluZyBmdW5jdGlvbnMuIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNC1zdG9yZSNtaWRkbGV3YXJlIGFuZCBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNi1hc3luYy1sb2dpYyN1c2luZy10aGUtcmVkdXgtdGh1bmstbWlkZGxld2FyZSBmb3IgZXhhbXBsZXMuYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDgpIDogJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gWW91IG1heSBoYXZlIG1pc3NwZWxsZWQgYW4gYWN0aW9uIHR5cGUgc3RyaW5nIGNvbnN0YW50LicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNykgOiBgQWN0aW9uIFwidHlwZVwiIHByb3BlcnR5IG11c3QgYmUgYSBzdHJpbmcuIEluc3RlYWQsIHRoZSBhY3R1YWwgdHlwZSB3YXM6ICcke2tpbmRPZihhY3Rpb24udHlwZSl9Jy4gVmFsdWUgd2FzOiAnJHthY3Rpb24udHlwZX0nIChzdHJpbmdpZmllZClgKTtcbiAgICB9XG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDkpIDogXCJSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IHRydWU7XG4gICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50UmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycyA9IG5leHRMaXN0ZW5lcnM7XG4gICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY3Rpb247XG4gIH1cbiAgZnVuY3Rpb24gcmVwbGFjZVJlZHVjZXIobmV4dFJlZHVjZXIpIHtcbiAgICBpZiAodHlwZW9mIG5leHRSZWR1Y2VyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEwKSA6IGBFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICcke2tpbmRPZihuZXh0UmVkdWNlcil9YCk7XG4gICAgfVxuICAgIGN1cnJlbnRSZWR1Y2VyID0gbmV4dFJlZHVjZXI7XG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogYWN0aW9uVHlwZXNfZGVmYXVsdC5SRVBMQUNFXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZSgpIHtcbiAgICBjb25zdCBvdXRlclN1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWluaW1hbCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXG4gICAgICAgKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBhbiBgdW5zdWJzY3JpYmVgIG1ldGhvZCB0aGF0IGNhblxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICAgKi9cbiAgICAgIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgICAgICBpZiAodHlwZW9mIG9ic2VydmVyICE9PSBcIm9iamVjdFwiIHx8IG9ic2VydmVyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTEpIDogYEV4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuIEluc3RlYWQsIHJlY2VpdmVkOiAnJHtraW5kT2Yob2JzZXJ2ZXIpfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvYnNlcnZlU3RhdGUoKSB7XG4gICAgICAgICAgY29uc3Qgb2JzZXJ2ZXJBc09ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICAgICAgaWYgKG9ic2VydmVyQXNPYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICBvYnNlcnZlckFzT2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JzZXJ2ZVN0YXRlKCk7XG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1bnN1YnNjcmliZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIFtzeW1ib2xfb2JzZXJ2YWJsZV9kZWZhdWx0XSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkaXNwYXRjaCh7XG4gICAgdHlwZTogYWN0aW9uVHlwZXNfZGVmYXVsdC5JTklUXG4gIH0pO1xuICBjb25zdCBzdG9yZSA9IHtcbiAgICBkaXNwYXRjaCxcbiAgICBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGUsXG4gICAgcmVwbGFjZVJlZHVjZXIsXG4gICAgW3N5bWJvbF9vYnNlcnZhYmxlX2RlZmF1bHRdOiBvYnNlcnZhYmxlXG4gIH07XG4gIHJldHVybiBzdG9yZTtcbn1cbmZ1bmN0aW9uIGxlZ2FjeV9jcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgcmV0dXJuIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcik7XG59XG5cbi8vIHNyYy91dGlscy93YXJuaW5nLnRzXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIHRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxuLy8gc3JjL2NvbWJpbmVSZWR1Y2Vycy50c1xuZnVuY3Rpb24gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShpbnB1dFN0YXRlLCByZWR1Y2VycywgYWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGUpIHtcbiAgY29uc3QgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIGNvbnN0IGFyZ3VtZW50TmFtZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gYWN0aW9uVHlwZXNfZGVmYXVsdC5JTklUID8gXCJwcmVsb2FkZWRTdGF0ZSBhcmd1bWVudCBwYXNzZWQgdG8gY3JlYXRlU3RvcmVcIiA6IFwicHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXJcIjtcbiAgaWYgKHJlZHVjZXJLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIlN0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCB0byBjb21iaW5lUmVkdWNlcnMgaXMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgcmVkdWNlcnMuXCI7XG4gIH1cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuIGBUaGUgJHthcmd1bWVudE5hbWV9IGhhcyB1bmV4cGVjdGVkIHR5cGUgb2YgXCIke2tpbmRPZihpbnB1dFN0YXRlKX1cIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBrZXlzOiBcIiR7cmVkdWNlcktleXMuam9pbignXCIsIFwiJyl9XCJgO1xuICB9XG4gIGNvbnN0IHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKChrZXkpID0+ICFyZWR1Y2Vycy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICF1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XSk7XG4gIHVuZXhwZWN0ZWRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldID0gdHJ1ZTtcbiAgfSk7XG4gIGlmIChhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IGFjdGlvblR5cGVzX2RlZmF1bHQuUkVQTEFDRSlcbiAgICByZXR1cm47XG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGBVbmV4cGVjdGVkICR7dW5leHBlY3RlZEtleXMubGVuZ3RoID4gMSA/IFwia2V5c1wiIDogXCJrZXlcIn0gXCIke3VuZXhwZWN0ZWRLZXlzLmpvaW4oJ1wiLCBcIicpfVwiIGZvdW5kIGluICR7YXJndW1lbnROYW1lfS4gRXhwZWN0ZWQgdG8gZmluZCBvbmUgb2YgdGhlIGtub3duIHJlZHVjZXIga2V5cyBpbnN0ZWFkOiBcIiR7cmVkdWNlcktleXMuam9pbignXCIsIFwiJyl9XCIuIFVuZXhwZWN0ZWQga2V5cyB3aWxsIGJlIGlnbm9yZWQuYDtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNoYXBlKHJlZHVjZXJzKSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCByZWR1Y2VyID0gcmVkdWNlcnNba2V5XTtcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSByZWR1Y2VyKHZvaWQgMCwge1xuICAgICAgdHlwZTogYWN0aW9uVHlwZXNfZGVmYXVsdC5JTklUXG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEyKSA6IGBUaGUgc2xpY2UgcmVkdWNlciBmb3Iga2V5IFwiJHtrZXl9XCIgcmV0dXJuZWQgdW5kZWZpbmVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgeW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZWR1Y2VyKHZvaWQgMCwge1xuICAgICAgdHlwZTogYWN0aW9uVHlwZXNfZGVmYXVsdC5QUk9CRV9VTktOT1dOX0FDVElPTigpXG4gICAgfSkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEzKSA6IGBUaGUgc2xpY2UgcmVkdWNlciBmb3Iga2V5IFwiJHtrZXl9XCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gcHJvYmVkIHdpdGggYSByYW5kb20gdHlwZS4gRG9uJ3QgdHJ5IHRvIGhhbmRsZSAnJHthY3Rpb25UeXBlc19kZWZhdWx0LklOSVR9JyBvciBvdGhlciBhY3Rpb25zIGluIFwicmVkdXgvKlwiIG5hbWVzcGFjZS4gVGhleSBhcmUgY29uc2lkZXJlZCBwcml2YXRlLiBJbnN0ZWFkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUgZm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHVubGVzcyBpdCBpcyB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2UgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLCByZWdhcmRsZXNzIG9mIHRoZSBhY3Rpb24gdHlwZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQsIGJ1dCBjYW4gYmUgbnVsbC5gKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY29tYmluZVJlZHVjZXJzKHJlZHVjZXJzKSB7XG4gIGNvbnN0IHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICBjb25zdCBmaW5hbFJlZHVjZXJzID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSByZWR1Y2VyS2V5c1tpXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgd2FybmluZyhgTm8gcmVkdWNlciBwcm92aWRlZCBmb3Iga2V5IFwiJHtrZXl9XCJgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZpbmFsUmVkdWNlcnNba2V5XSA9IHJlZHVjZXJzW2tleV07XG4gICAgfVxuICB9XG4gIGNvbnN0IGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcbiAgbGV0IHVuZXhwZWN0ZWRLZXlDYWNoZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZSA9IHt9O1xuICB9XG4gIGxldCBzaGFwZUFzc2VydGlvbkVycm9yO1xuICB0cnkge1xuICAgIGFzc2VydFJlZHVjZXJTaGFwZShmaW5hbFJlZHVjZXJzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNoYXBlQXNzZXJ0aW9uRXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiBjb21iaW5hdGlvbihzdGF0ZSA9IHt9LCBhY3Rpb24pIHtcbiAgICBpZiAoc2hhcGVBc3NlcnRpb25FcnJvcikge1xuICAgICAgdGhyb3cgc2hhcGVBc3NlcnRpb25FcnJvcjtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc3Qgd2FybmluZ01lc3NhZ2UgPSBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKHN0YXRlLCBmaW5hbFJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSk7XG4gICAgICBpZiAod2FybmluZ01lc3NhZ2UpIHtcbiAgICAgICAgd2FybmluZyh3YXJuaW5nTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgY29uc3QgbmV4dFN0YXRlID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBmaW5hbFJlZHVjZXJLZXlzW2ldO1xuICAgICAgY29uc3QgcmVkdWNlciA9IGZpbmFsUmVkdWNlcnNba2V5XTtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGVGb3JLZXkgPSBzdGF0ZVtrZXldO1xuICAgICAgY29uc3QgbmV4dFN0YXRlRm9yS2V5ID0gcmVkdWNlcihwcmV2aW91c1N0YXRlRm9yS2V5LCBhY3Rpb24pO1xuICAgICAgaWYgKHR5cGVvZiBuZXh0U3RhdGVGb3JLZXkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTQpIDogYFdoZW4gY2FsbGVkIHdpdGggYW4gYWN0aW9uIG9mIHR5cGUgJHthY3Rpb25UeXBlID8gYFwiJHtTdHJpbmcoYWN0aW9uVHlwZSl9XCJgIDogXCIodW5rbm93biB0eXBlKVwifSwgdGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7a2V5fVwiIHJldHVybmVkIHVuZGVmaW5lZC4gVG8gaWdub3JlIGFuIGFjdGlvbiwgeW91IG11c3QgZXhwbGljaXRseSByZXR1cm4gdGhlIHByZXZpb3VzIHN0YXRlLiBJZiB5b3Ugd2FudCB0aGlzIHJlZHVjZXIgdG8gaG9sZCBubyB2YWx1ZSwgeW91IGNhbiByZXR1cm4gbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5gKTtcbiAgICAgIH1cbiAgICAgIG5leHRTdGF0ZVtrZXldID0gbmV4dFN0YXRlRm9yS2V5O1xuICAgICAgaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQgfHwgbmV4dFN0YXRlRm9yS2V5ICE9PSBwcmV2aW91c1N0YXRlRm9yS2V5O1xuICAgIH1cbiAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoc3RhdGUpLmxlbmd0aDtcbiAgICByZXR1cm4gaGFzQ2hhbmdlZCA/IG5leHRTdGF0ZSA6IHN0YXRlO1xuICB9O1xufVxuXG4vLyBzcmMvYmluZEFjdGlvbkNyZWF0b3JzLnRzXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHJldHVybiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyAhPT0gXCJvYmplY3RcIiB8fCBhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2KSA6IGBiaW5kQWN0aW9uQ3JlYXRvcnMgZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGJ1dCBpbnN0ZWFkIHJlY2VpdmVkOiAnJHtraW5kT2YoYWN0aW9uQ3JlYXRvcnMpfScuIERpZCB5b3Ugd3JpdGUgXCJpbXBvcnQgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiIGluc3RlYWQgb2YgXCJpbXBvcnQgKiBhcyBBY3Rpb25DcmVhdG9ycyBmcm9tXCI/YCk7XG4gIH1cbiAgY29uc3QgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBhY3Rpb25DcmVhdG9ycykge1xuICAgIGNvbnN0IGFjdGlvbkNyZWF0b3IgPSBhY3Rpb25DcmVhdG9yc1trZXldO1xuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG4vLyBzcmMvY29tcG9zZS50c1xuZnVuY3Rpb24gY29tcG9zZSguLi5mdW5jcykge1xuICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhcmcpID0+IGFyZztcbiAgfVxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZ1bmNzWzBdO1xuICB9XG4gIHJldHVybiBmdW5jcy5yZWR1Y2UoKGEsIGIpID0+ICguLi5hcmdzKSA9PiBhKGIoLi4uYXJncykpKTtcbn1cblxuLy8gc3JjL2FwcGx5TWlkZGxld2FyZS50c1xuZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmVzKSB7XG4gIHJldHVybiAoY3JlYXRlU3RvcmUyKSA9PiAocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IGNyZWF0ZVN0b3JlMihyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSk7XG4gICAgbGV0IGRpc3BhdGNoID0gKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTUpIDogXCJEaXNwYXRjaGluZyB3aGlsZSBjb25zdHJ1Y3RpbmcgeW91ciBtaWRkbGV3YXJlIGlzIG5vdCBhbGxvd2VkLiBPdGhlciBtaWRkbGV3YXJlIHdvdWxkIG5vdCBiZSBhcHBsaWVkIHRvIHRoaXMgZGlzcGF0Y2guXCIpO1xuICAgIH07XG4gICAgY29uc3QgbWlkZGxld2FyZUFQSSA9IHtcbiAgICAgIGdldFN0YXRlOiBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgIGRpc3BhdGNoOiAoYWN0aW9uLCAuLi5hcmdzKSA9PiBkaXNwYXRjaChhY3Rpb24sIC4uLmFyZ3MpXG4gICAgfTtcbiAgICBjb25zdCBjaGFpbiA9IG1pZGRsZXdhcmVzLm1hcCgobWlkZGxld2FyZSkgPT4gbWlkZGxld2FyZShtaWRkbGV3YXJlQVBJKSk7XG4gICAgZGlzcGF0Y2ggPSBjb21wb3NlKC4uLmNoYWluKShzdG9yZS5kaXNwYXRjaCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0b3JlLFxuICAgICAgZGlzcGF0Y2hcbiAgICB9O1xuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMvaXNBY3Rpb24udHNcbmZ1bmN0aW9uIGlzQWN0aW9uKGFjdGlvbikge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdChhY3Rpb24pICYmIFwidHlwZVwiIGluIGFjdGlvbiAmJiB0eXBlb2YgYWN0aW9uLnR5cGUgPT09IFwic3RyaW5nXCI7XG59XG5leHBvcnQge1xuICBhY3Rpb25UeXBlc19kZWZhdWx0IGFzIF9fRE9fTk9UX1VTRV9fQWN0aW9uVHlwZXMsXG4gIGFwcGx5TWlkZGxld2FyZSxcbiAgYmluZEFjdGlvbkNyZWF0b3JzLFxuICBjb21iaW5lUmVkdWNlcnMsXG4gIGNvbXBvc2UsXG4gIGNyZWF0ZVN0b3JlLFxuICBpc0FjdGlvbixcbiAgaXNQbGFpbk9iamVjdCxcbiAgbGVnYWN5X2NyZWF0ZVN0b3JlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdXgubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/redux/dist/redux.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js":
/*!****************************************************************!*\
  !*** ./node_modules/tiny-invariant/dist/esm/tiny-invariant.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ invariant)\n/* harmony export */ });\nvar isProduction = \"development\" === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    var provided = typeof message === 'function' ? message() : message;\n    var value = provided ? \"\".concat(prefix, \": \").concat(provided) : prefix;\n    throw new Error(value);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aW55LWludmFyaWFudC9kaXN0L2VzbS90aW55LWludmFyaWFudC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsbUJBQW1CLGFBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0MiLCJzb3VyY2VzIjpbIi9hcHAvbm9kZV9tb2R1bGVzL3RpbnktaW52YXJpYW50L2Rpc3QvZXNtL3RpbnktaW52YXJpYW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBpc1Byb2R1Y3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xudmFyIHByZWZpeCA9ICdJbnZhcmlhbnQgZmFpbGVkJztcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJlZml4KTtcbiAgICB9XG4gICAgdmFyIHByb3ZpZGVkID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdmdW5jdGlvbicgPyBtZXNzYWdlKCkgOiBtZXNzYWdlO1xuICAgIHZhciB2YWx1ZSA9IHByb3ZpZGVkID8gXCJcIi5jb25jYXQocHJlZml4LCBcIjogXCIpLmNvbmNhdChwcm92aWRlZCkgOiBwcmVmaXg7XG4gICAgdGhyb3cgbmV3IEVycm9yKHZhbHVlKTtcbn1cblxuZXhwb3J0IHsgaW52YXJpYW50IGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-with-selector.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useSyncExternalStore = React.useSyncExternalStore,\n      useRef = React.useRef,\n      useEffect = React.useEffect,\n      useMemo = React.useMemo,\n      useDebugValue = React.useDebugValue;\n    exports.useSyncExternalStoreWithSelector = function (\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      selector,\n      isEqual\n    ) {\n      var instRef = useRef(null);\n      if (null === instRef.current) {\n        var inst = { hasValue: !1, value: null };\n        instRef.current = inst;\n      } else inst = instRef.current;\n      instRef = useMemo(\n        function () {\n          function memoizedSelector(nextSnapshot) {\n            if (!hasMemo) {\n              hasMemo = !0;\n              memoizedSnapshot = nextSnapshot;\n              nextSnapshot = selector(nextSnapshot);\n              if (void 0 !== isEqual && inst.hasValue) {\n                var currentSelection = inst.value;\n                if (isEqual(currentSelection, nextSnapshot))\n                  return (memoizedSelection = currentSelection);\n              }\n              return (memoizedSelection = nextSnapshot);\n            }\n            currentSelection = memoizedSelection;\n            if (objectIs(memoizedSnapshot, nextSnapshot))\n              return currentSelection;\n            var nextSelection = selector(nextSnapshot);\n            if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))\n              return (memoizedSnapshot = nextSnapshot), currentSelection;\n            memoizedSnapshot = nextSnapshot;\n            return (memoizedSelection = nextSelection);\n          }\n          var hasMemo = !1,\n            memoizedSnapshot,\n            memoizedSelection,\n            maybeGetServerSnapshot =\n              void 0 === getServerSnapshot ? null : getServerSnapshot;\n          return [\n            function () {\n              return memoizedSelector(getSnapshot());\n            },\n            null === maybeGetServerSnapshot\n              ? void 0\n              : function () {\n                  return memoizedSelector(maybeGetServerSnapshot());\n                }\n          ];\n        },\n        [getSnapshot, getServerSnapshot, selector, isEqual]\n      );\n      var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n      useEffect(\n        function () {\n          inst.hasValue = !0;\n          inst.value = value;\n        },\n        [value]\n      );\n      useDebugValue(value);\n      return value;\n    };\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3Q0FBd0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL2FwcC9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXdpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgICByZXR1cm4gKHggPT09IHkgJiYgKDAgIT09IHggfHwgMSAvIHggPT09IDEgLyB5KSkgfHwgKHggIT09IHggJiYgeSAhPT0geSk7XG4gICAgfVxuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgJiZcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQoRXJyb3IoKSk7XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpLFxuICAgICAgb2JqZWN0SXMgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiBpcyxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUsXG4gICAgICB1c2VSZWYgPSBSZWFjdC51c2VSZWYsXG4gICAgICB1c2VFZmZlY3QgPSBSZWFjdC51c2VFZmZlY3QsXG4gICAgICB1c2VNZW1vID0gUmVhY3QudXNlTWVtbyxcbiAgICAgIHVzZURlYnVnVmFsdWUgPSBSZWFjdC51c2VEZWJ1Z1ZhbHVlO1xuICAgIGV4cG9ydHMudXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSBmdW5jdGlvbiAoXG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBnZXRTbmFwc2hvdCxcbiAgICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgICAgc2VsZWN0b3IsXG4gICAgICBpc0VxdWFsXG4gICAgKSB7XG4gICAgICB2YXIgaW5zdFJlZiA9IHVzZVJlZihudWxsKTtcbiAgICAgIGlmIChudWxsID09PSBpbnN0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgdmFyIGluc3QgPSB7IGhhc1ZhbHVlOiAhMSwgdmFsdWU6IG51bGwgfTtcbiAgICAgICAgaW5zdFJlZi5jdXJyZW50ID0gaW5zdDtcbiAgICAgIH0gZWxzZSBpbnN0ID0gaW5zdFJlZi5jdXJyZW50O1xuICAgICAgaW5zdFJlZiA9IHVzZU1lbW8oXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmdW5jdGlvbiBtZW1vaXplZFNlbGVjdG9yKG5leHRTbmFwc2hvdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNNZW1vKSB7XG4gICAgICAgICAgICAgIGhhc01lbW8gPSAhMDtcbiAgICAgICAgICAgICAgbWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcbiAgICAgICAgICAgICAgbmV4dFNuYXBzaG90ID0gc2VsZWN0b3IobmV4dFNuYXBzaG90KTtcbiAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gaXNFcXVhbCAmJiBpbnN0Lmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBpbnN0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpc0VxdWFsKGN1cnJlbnRTZWxlY3Rpb24sIG5leHRTbmFwc2hvdCkpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gKG1lbW9pemVkU2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIChtZW1vaXplZFNlbGVjdGlvbiA9IG5leHRTbmFwc2hvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50U2VsZWN0aW9uID0gbWVtb2l6ZWRTZWxlY3Rpb247XG4gICAgICAgICAgICBpZiAob2JqZWN0SXMobWVtb2l6ZWRTbmFwc2hvdCwgbmV4dFNuYXBzaG90KSlcbiAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgICAgICB2YXIgbmV4dFNlbGVjdGlvbiA9IHNlbGVjdG9yKG5leHRTbmFwc2hvdCk7XG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBpc0VxdWFsICYmIGlzRXF1YWwoY3VycmVudFNlbGVjdGlvbiwgbmV4dFNlbGVjdGlvbikpXG4gICAgICAgICAgICAgIHJldHVybiAobWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdCksIGN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgICAgICBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuICAgICAgICAgICAgcmV0dXJuIChtZW1vaXplZFNlbGVjdGlvbiA9IG5leHRTZWxlY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaGFzTWVtbyA9ICExLFxuICAgICAgICAgICAgbWVtb2l6ZWRTbmFwc2hvdCxcbiAgICAgICAgICAgIG1lbW9pemVkU2VsZWN0aW9uLFxuICAgICAgICAgICAgbWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCA9XG4gICAgICAgICAgICAgIHZvaWQgMCA9PT0gZ2V0U2VydmVyU25hcHNob3QgPyBudWxsIDogZ2V0U2VydmVyU25hcHNob3Q7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1lbW9pemVkU2VsZWN0b3IoZ2V0U25hcHNob3QoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbnVsbCA9PT0gbWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICAgICAgICA/IHZvaWQgMFxuICAgICAgICAgICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1vaXplZFNlbGVjdG9yKG1heWJlR2V0U2VydmVyU25hcHNob3QoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgIF07XG4gICAgICAgIH0sXG4gICAgICAgIFtnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QsIHNlbGVjdG9yLCBpc0VxdWFsXVxuICAgICAgKTtcbiAgICAgIHZhciB2YWx1ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgaW5zdFJlZlswXSwgaW5zdFJlZlsxXSk7XG4gICAgICB1c2VFZmZlY3QoXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpbnN0Lmhhc1ZhbHVlID0gITA7XG4gICAgICAgICAgaW5zdC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBbdmFsdWVdXG4gICAgICApO1xuICAgICAgdXNlRGVidWdWYWx1ZSh2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgJiZcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChFcnJvcigpKTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/with-selector.js":
/*!***************************************************************!*\
  !*** ./node_modules/use-sync-external-store/with-selector.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/use-sync-external-store-with-selector.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS93aXRoLXNlbGVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw2TkFBc0Y7QUFDeEYiLCJzb3VyY2VzIjpbIi9hcHAvbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3dpdGgtc2VsZWN0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXdpdGgtc2VsZWN0b3IucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS13aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/with-selector.js\n"));

/***/ })

});