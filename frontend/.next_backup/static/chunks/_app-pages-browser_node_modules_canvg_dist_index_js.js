/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_canvg_dist_index_js"],{

/***/ "(app-pages-browser)/./node_modules/canvg/dist/index.js":
/*!******************************************!*\
  !*** ./node_modules/canvg/dist/index.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AElement: () => (/* binding */ AElement),\n/* harmony export */   AnimateColorElement: () => (/* binding */ AnimateColorElement),\n/* harmony export */   AnimateElement: () => (/* binding */ AnimateElement),\n/* harmony export */   AnimateTransformElement: () => (/* binding */ AnimateTransformElement),\n/* harmony export */   BoundingBox: () => (/* binding */ BoundingBox),\n/* harmony export */   CB1: () => (/* binding */ CB1),\n/* harmony export */   CB2: () => (/* binding */ CB2),\n/* harmony export */   CB3: () => (/* binding */ CB3),\n/* harmony export */   CB4: () => (/* binding */ CB4),\n/* harmony export */   Canvg: () => (/* binding */ Canvg),\n/* harmony export */   CircleElement: () => (/* binding */ CircleElement),\n/* harmony export */   ClipPathElement: () => (/* binding */ ClipPathElement),\n/* harmony export */   DefsElement: () => (/* binding */ DefsElement),\n/* harmony export */   DescElement: () => (/* binding */ DescElement),\n/* harmony export */   Document: () => (/* binding */ Document),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   EllipseElement: () => (/* binding */ EllipseElement),\n/* harmony export */   FeColorMatrixElement: () => (/* binding */ FeColorMatrixElement),\n/* harmony export */   FeCompositeElement: () => (/* binding */ FeCompositeElement),\n/* harmony export */   FeDropShadowElement: () => (/* binding */ FeDropShadowElement),\n/* harmony export */   FeGaussianBlurElement: () => (/* binding */ FeGaussianBlurElement),\n/* harmony export */   FeMorphologyElement: () => (/* binding */ FeMorphologyElement),\n/* harmony export */   FilterElement: () => (/* binding */ FilterElement),\n/* harmony export */   Font: () => (/* binding */ Font),\n/* harmony export */   FontElement: () => (/* binding */ FontElement),\n/* harmony export */   FontFaceElement: () => (/* binding */ FontFaceElement),\n/* harmony export */   GElement: () => (/* binding */ GElement),\n/* harmony export */   GlyphElement: () => (/* binding */ GlyphElement),\n/* harmony export */   GradientElement: () => (/* binding */ GradientElement),\n/* harmony export */   ImageElement: () => (/* binding */ ImageElement),\n/* harmony export */   LineElement: () => (/* binding */ LineElement),\n/* harmony export */   LinearGradientElement: () => (/* binding */ LinearGradientElement),\n/* harmony export */   MarkerElement: () => (/* binding */ MarkerElement),\n/* harmony export */   MaskElement: () => (/* binding */ MaskElement),\n/* harmony export */   Matrix: () => (/* binding */ Matrix),\n/* harmony export */   MissingGlyphElement: () => (/* binding */ MissingGlyphElement),\n/* harmony export */   Mouse: () => (/* binding */ Mouse),\n/* harmony export */   PSEUDO_ZERO: () => (/* binding */ PSEUDO_ZERO),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   PathElement: () => (/* binding */ PathElement),\n/* harmony export */   PathParser: () => (/* binding */ PathParser),\n/* harmony export */   PatternElement: () => (/* binding */ PatternElement),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   PolygonElement: () => (/* binding */ PolygonElement),\n/* harmony export */   PolylineElement: () => (/* binding */ PolylineElement),\n/* harmony export */   Property: () => (/* binding */ Property),\n/* harmony export */   QB1: () => (/* binding */ QB1),\n/* harmony export */   QB2: () => (/* binding */ QB2),\n/* harmony export */   QB3: () => (/* binding */ QB3),\n/* harmony export */   RadialGradientElement: () => (/* binding */ RadialGradientElement),\n/* harmony export */   RectElement: () => (/* binding */ RectElement),\n/* harmony export */   RenderedElement: () => (/* binding */ RenderedElement),\n/* harmony export */   Rotate: () => (/* binding */ Rotate),\n/* harmony export */   SVGElement: () => (/* binding */ SVGElement),\n/* harmony export */   SVGFontLoader: () => (/* binding */ SVGFontLoader),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   Screen: () => (/* binding */ Screen),\n/* harmony export */   Skew: () => (/* binding */ Skew),\n/* harmony export */   SkewX: () => (/* binding */ SkewX),\n/* harmony export */   SkewY: () => (/* binding */ SkewY),\n/* harmony export */   StopElement: () => (/* binding */ StopElement),\n/* harmony export */   StyleElement: () => (/* binding */ StyleElement),\n/* harmony export */   SymbolElement: () => (/* binding */ SymbolElement),\n/* harmony export */   TRefElement: () => (/* binding */ TRefElement),\n/* harmony export */   TSpanElement: () => (/* binding */ TSpanElement),\n/* harmony export */   TextElement: () => (/* binding */ TextElement),\n/* harmony export */   TextPathElement: () => (/* binding */ TextPathElement),\n/* harmony export */   TitleElement: () => (/* binding */ TitleElement),\n/* harmony export */   Transform: () => (/* binding */ Transform),\n/* harmony export */   Translate: () => (/* binding */ Translate),\n/* harmony export */   UnknownElement: () => (/* binding */ UnknownElement),\n/* harmony export */   UseElement: () => (/* binding */ UseElement),\n/* harmony export */   ViewPort: () => (/* binding */ ViewPort),\n/* harmony export */   compressSpaces: () => (/* binding */ compressSpaces),\n/* harmony export */   elements: () => (/* binding */ elements),\n/* harmony export */   getSelectorSpecificity: () => (/* binding */ getSelectorSpecificity),\n/* harmony export */   normalizeAttributeName: () => (/* binding */ normalizeAttributeName),\n/* harmony export */   normalizeColor: () => (/* binding */ normalizeColor),\n/* harmony export */   parseExternalUrl: () => (/* binding */ parseExternalUrl),\n/* harmony export */   presets: () => (/* binding */ index),\n/* harmony export */   toMatrixValue: () => (/* binding */ toMatrixValue),\n/* harmony export */   toNumbers: () => (/* binding */ toNumbers),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   vectorMagnitude: () => (/* binding */ vectorMagnitude),\n/* harmony export */   vectorsAngle: () => (/* binding */ vectorsAngle),\n/* harmony export */   vectorsRatio: () => (/* binding */ vectorsRatio)\n/* harmony export */ });\n/* harmony import */ var raf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! raf */ \"(app-pages-browser)/./node_modules/raf/index.js\");\n/* harmony import */ var rgbcolor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rgbcolor */ \"(app-pages-browser)/./node_modules/rgbcolor/index.js\");\n/* harmony import */ var svg_pathdata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svg-pathdata */ \"(app-pages-browser)/./node_modules/svg-pathdata/lib/SVGPathData.module.js\");\n/* harmony import */ var stackblur_canvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! stackblur-canvas */ \"(app-pages-browser)/./node_modules/stackblur-canvas/dist/stackblur-es.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\n\n\n/**\n * Options preset for `OffscreenCanvas`.\n * @param config - Preset requirements.\n * @param config.DOMParser - XML/HTML parser from string into DOM Document.\n * @returns Preset object.\n */ function offscreen() {\n    let { DOMParser: DOMParserFallback  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const preset = {\n        window: null,\n        ignoreAnimation: true,\n        ignoreMouse: true,\n        DOMParser: DOMParserFallback,\n        createCanvas (width, height) {\n            return new OffscreenCanvas(width, height);\n        },\n        async createImage (url) {\n            const response = await fetch(url);\n            const blob = await response.blob();\n            const img = await createImageBitmap(blob);\n            return img;\n        }\n    };\n    if (typeof globalThis.DOMParser !== 'undefined' || typeof DOMParserFallback === 'undefined') {\n        Reflect.deleteProperty(preset, 'DOMParser');\n    }\n    return preset;\n}\n\n/**\n * Options preset for `node-canvas`.\n * @param config - Preset requirements.\n * @param config.DOMParser - XML/HTML parser from string into DOM Document.\n * @param config.canvas - `node-canvas` exports.\n * @param config.fetch - WHATWG-compatible `fetch` function.\n * @returns Preset object.\n */ function node(param) {\n    let { DOMParser , canvas , fetch  } = param;\n    return {\n        window: null,\n        ignoreAnimation: true,\n        ignoreMouse: true,\n        DOMParser,\n        fetch,\n        createCanvas: canvas.createCanvas,\n        createImage: canvas.loadImage\n    };\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  offscreen: offscreen,\n  node: node\n});\n\n/**\n * HTML-safe compress white-spaces.\n * @param str - String to compress.\n * @returns String.\n */ function compressSpaces(str) {\n    return str.replace(/(?!\\u3000)\\s+/gm, ' ');\n}\n/**\n * HTML-safe left trim.\n * @param str - String to trim.\n * @returns String.\n */ function trimLeft(str) {\n    return str.replace(/^[\\n \\t]+/, '');\n}\n/**\n * HTML-safe right trim.\n * @param str - String to trim.\n * @returns String.\n */ function trimRight(str) {\n    return str.replace(/[\\n \\t]+$/, '');\n}\n/**\n * String to numbers array.\n * @param str - Numbers string.\n * @returns Numbers array.\n */ function toNumbers(str) {\n    const matches = str.match(/-?(\\d+(?:\\.\\d*(?:[eE][+-]?\\d+)?)?|\\.\\d+)(?=\\D|$)/gm);\n    return matches ? matches.map(parseFloat) : [];\n}\n/**\n * String to matrix value.\n * @param str - Numbers string.\n * @returns Matrix value.\n */ function toMatrixValue(str) {\n    const numbers = toNumbers(str);\n    const matrix = [\n        numbers[0] || 0,\n        numbers[1] || 0,\n        numbers[2] || 0,\n        numbers[3] || 0,\n        numbers[4] || 0,\n        numbers[5] || 0\n    ];\n    return matrix;\n}\n// Microsoft Edge fix\nconst allUppercase = /^[A-Z-]+$/;\n/**\n * Normalize attribute name.\n * @param name - Attribute name.\n * @returns Normalized attribute name.\n */ function normalizeAttributeName(name) {\n    if (allUppercase.test(name)) {\n        return name.toLowerCase();\n    }\n    return name;\n}\n/**\n * Parse external URL.\n * @param url - CSS url string.\n * @returns Parsed URL.\n */ function parseExternalUrl(url) {\n    //                      single quotes [2]\n    //                      v         double quotes [3]\n    //                      v         v         no quotes [4]\n    //                      v         v         v\n    const urlMatch = /url\\(('([^']+)'|\"([^\"]+)\"|([^'\")]+))\\)/.exec(url);\n    if (!urlMatch) {\n        return '';\n    }\n    return urlMatch[2] || urlMatch[3] || urlMatch[4] || '';\n}\n/**\n * Transform floats to integers in rgb colors.\n * @param color - Color to normalize.\n * @returns Normalized color.\n */ function normalizeColor(color) {\n    if (!color.startsWith('rgb')) {\n        return color;\n    }\n    let rgbParts = 3;\n    const normalizedColor = color.replace(/\\d+(\\.\\d+)?/g, (num, isFloat)=>(rgbParts--) && isFloat ? String(Math.round(parseFloat(num))) : num\n    );\n    return normalizedColor;\n}\n\n// slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js\nconst attributeRegex = /(\\[[^\\]]+\\])/g;\nconst idRegex = /(#[^\\s+>~.[:]+)/g;\nconst classRegex = /(\\.[^\\s+>~.[:]+)/g;\nconst pseudoElementRegex = /(::[^\\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;\nconst pseudoClassWithBracketsRegex = /(:[\\w-]+\\([^)]*\\))/gi;\nconst pseudoClassRegex = /(:[^\\s+>~.[:]+)/g;\nconst elementRegex = /([^\\s+>~.[:]+)/g;\nfunction findSelectorMatch(selector, regex) {\n    const matches = regex.exec(selector);\n    if (!matches) {\n        return [\n            selector,\n            0\n        ];\n    }\n    return [\n        selector.replace(regex, ' '),\n        matches.length\n    ];\n}\n/**\n * Measure selector specificity.\n * @param selector - Selector to measure.\n * @returns Specificity.\n */ function getSelectorSpecificity(selector) {\n    const specificity = [\n        0,\n        0,\n        0\n    ];\n    let currentSelector = selector.replace(/:not\\(([^)]*)\\)/g, '     $1 ').replace(/{[\\s\\S]*/gm, ' ');\n    let delta = 0;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);\n    specificity[0] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);\n    specificity[2] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);\n    specificity[1] += delta;\n    currentSelector = currentSelector.replace(/[*\\s+>~]/g, ' ').replace(/[#.]/g, ' ');\n    [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex) // lgtm [js/useless-assignment-to-local]\n    ;\n    specificity[2] += delta;\n    return specificity.join('');\n}\n\nconst PSEUDO_ZERO = 0.00000001;\n/**\n * Vector magnitude.\n * @param v\n * @returns Number result.\n */ function vectorMagnitude(v) {\n    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));\n}\n/**\n * Ratio between two vectors.\n * @param u\n * @param v\n * @returns Number result.\n */ function vectorsRatio(u, v) {\n    return (u[0] * v[0] + u[1] * v[1]) / (vectorMagnitude(u) * vectorMagnitude(v));\n}\n/**\n * Angle between two vectors.\n * @param u\n * @param v\n * @returns Number result.\n */ function vectorsAngle(u, v) {\n    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vectorsRatio(u, v));\n}\nfunction CB1(t) {\n    return t * t * t;\n}\nfunction CB2(t) {\n    return 3 * t * t * (1 - t);\n}\nfunction CB3(t) {\n    return 3 * t * (1 - t) * (1 - t);\n}\nfunction CB4(t) {\n    return (1 - t) * (1 - t) * (1 - t);\n}\nfunction QB1(t) {\n    return t * t;\n}\nfunction QB2(t) {\n    return 2 * t * (1 - t);\n}\nfunction QB3(t) {\n    return (1 - t) * (1 - t);\n}\n\nclass Property {\n    static empty(document) {\n        return new Property(document, 'EMPTY', '');\n    }\n    split() {\n        let separator = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ' ';\n        const { document , name  } = this;\n        return compressSpaces(this.getString()).trim().split(separator).map((value)=>new Property(document, name, value)\n        );\n    }\n    hasValue(zeroIsValue) {\n        const value = this.value;\n        return value !== null && value !== '' && (zeroIsValue || value !== 0) && typeof value !== 'undefined';\n    }\n    isString(regexp) {\n        const { value  } = this;\n        const result = typeof value === 'string';\n        if (!result || !regexp) {\n            return result;\n        }\n        return regexp.test(value);\n    }\n    isUrlDefinition() {\n        return this.isString(/^url\\(/);\n    }\n    isPixels() {\n        if (!this.hasValue()) {\n            return false;\n        }\n        const asString = this.getString();\n        switch(true){\n            case asString.endsWith('px'):\n            case /^[0-9]+$/.test(asString):\n                return true;\n            default:\n                return false;\n        }\n    }\n    setValue(value) {\n        this.value = value;\n        return this;\n    }\n    getValue(def) {\n        if (typeof def === 'undefined' || this.hasValue()) {\n            return this.value;\n        }\n        return def;\n    }\n    getNumber(def) {\n        if (!this.hasValue()) {\n            if (typeof def === 'undefined') {\n                return 0;\n            }\n            // @ts-expect-error Parse unknown value.\n            return parseFloat(def);\n        }\n        const { value  } = this;\n        // @ts-expect-error Parse unknown value.\n        let n = parseFloat(value);\n        if (this.isString(/%$/)) {\n            n /= 100;\n        }\n        return n;\n    }\n    getString(def) {\n        if (typeof def === 'undefined' || this.hasValue()) {\n            return typeof this.value === 'undefined' ? '' : String(this.value);\n        }\n        return String(def);\n    }\n    getColor(def) {\n        let color = this.getString(def);\n        if (this.isNormalizedColor) {\n            return color;\n        }\n        this.isNormalizedColor = true;\n        color = normalizeColor(color);\n        this.value = color;\n        return color;\n    }\n    getDpi() {\n        return 96 // TODO: compute?\n        ;\n    }\n    getRem() {\n        return this.document.rootEmSize;\n    }\n    getEm() {\n        return this.document.emSize;\n    }\n    getUnits() {\n        return this.getString().replace(/[0-9.-]/g, '');\n    }\n    getPixels(axisOrIsFontSize) {\n        let processPercent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        if (!this.hasValue()) {\n            return 0;\n        }\n        const [axis, isFontSize] = typeof axisOrIsFontSize === 'boolean' ? [\n            undefined,\n            axisOrIsFontSize\n        ] : [\n            axisOrIsFontSize\n        ];\n        const { viewPort  } = this.document.screen;\n        switch(true){\n            case this.isString(/vmin$/):\n                return this.getNumber() / 100 * Math.min(viewPort.computeSize('x'), viewPort.computeSize('y'));\n            case this.isString(/vmax$/):\n                return this.getNumber() / 100 * Math.max(viewPort.computeSize('x'), viewPort.computeSize('y'));\n            case this.isString(/vw$/):\n                return this.getNumber() / 100 * viewPort.computeSize('x');\n            case this.isString(/vh$/):\n                return this.getNumber() / 100 * viewPort.computeSize('y');\n            case this.isString(/rem$/):\n                return this.getNumber() * this.getRem();\n            case this.isString(/em$/):\n                return this.getNumber() * this.getEm();\n            case this.isString(/ex$/):\n                return this.getNumber() * this.getEm() / 2;\n            case this.isString(/px$/):\n                return this.getNumber();\n            case this.isString(/pt$/):\n                return this.getNumber() * this.getDpi() * (1 / 72);\n            case this.isString(/pc$/):\n                return this.getNumber() * 15;\n            case this.isString(/cm$/):\n                return this.getNumber() * this.getDpi() / 2.54;\n            case this.isString(/mm$/):\n                return this.getNumber() * this.getDpi() / 25.4;\n            case this.isString(/in$/):\n                return this.getNumber() * this.getDpi();\n            case this.isString(/%$/) && isFontSize:\n                return this.getNumber() * this.getEm();\n            case this.isString(/%$/):\n                return this.getNumber() * viewPort.computeSize(axis);\n            default:\n                {\n                    const n = this.getNumber();\n                    if (processPercent && n < 1) {\n                        return n * viewPort.computeSize(axis);\n                    }\n                    return n;\n                }\n        }\n    }\n    getMilliseconds() {\n        if (!this.hasValue()) {\n            return 0;\n        }\n        if (this.isString(/ms$/)) {\n            return this.getNumber();\n        }\n        return this.getNumber() * 1000;\n    }\n    getRadians() {\n        if (!this.hasValue()) {\n            return 0;\n        }\n        switch(true){\n            case this.isString(/deg$/):\n                return this.getNumber() * (Math.PI / 180);\n            case this.isString(/grad$/):\n                return this.getNumber() * (Math.PI / 200);\n            case this.isString(/rad$/):\n                return this.getNumber();\n            default:\n                return this.getNumber() * (Math.PI / 180);\n        }\n    }\n    getDefinition() {\n        const asString = this.getString();\n        const match = /#([^)'\"]+)/.exec(asString);\n        const name = (match === null || match === void 0 ? void 0 : match[1]) || asString;\n        return this.document.definitions.get(name);\n    }\n    getFillStyleDefinition(element, opacity) {\n        let def = this.getDefinition();\n        if (!def) {\n            return null;\n        }\n        // gradient\n        if (typeof def.createGradient === 'function' && 'getBoundingBox' in element) {\n            return def.createGradient(this.document.ctx, element, opacity);\n        }\n        // pattern\n        if (typeof def.createPattern === 'function') {\n            if (def.getHrefAttribute().hasValue()) {\n                const patternTransform = def.getAttribute('patternTransform');\n                def = def.getHrefAttribute().getDefinition();\n                if (def && patternTransform.hasValue()) {\n                    def.getAttribute('patternTransform', true).setValue(patternTransform.value);\n                }\n            }\n            if (def) {\n                return def.createPattern(this.document.ctx, element, opacity);\n            }\n        }\n        return null;\n    }\n    getTextBaseline() {\n        if (!this.hasValue()) {\n            return null;\n        }\n        const key = this.getString();\n        return Property.textBaselineMapping[key] || null;\n    }\n    addOpacity(opacity) {\n        let value = this.getColor();\n        const len = value.length;\n        let commas = 0;\n        // Simulate old RGBColor version, which can't parse rgba.\n        for(let i = 0; i < len; i++){\n            if (value[i] === ',') {\n                commas++;\n            }\n            if (commas === 3) {\n                break;\n            }\n        }\n        if (opacity.hasValue() && this.isString() && commas !== 3) {\n            const color = new rgbcolor__WEBPACK_IMPORTED_MODULE_1__(value);\n            if (color.ok) {\n                color.alpha = opacity.getNumber();\n                value = color.toRGBA();\n            }\n        }\n        return new Property(this.document, this.name, value);\n    }\n    constructor(document, name, value){\n        this.document = document;\n        this.name = name;\n        this.value = value;\n        this.isNormalizedColor = false;\n    }\n}\nProperty.textBaselineMapping = {\n    'baseline': 'alphabetic',\n    'before-edge': 'top',\n    'text-before-edge': 'top',\n    'middle': 'middle',\n    'central': 'middle',\n    'after-edge': 'bottom',\n    'text-after-edge': 'bottom',\n    'ideographic': 'ideographic',\n    'alphabetic': 'alphabetic',\n    'hanging': 'hanging',\n    'mathematical': 'alphabetic'\n};\n\nclass ViewPort {\n    clear() {\n        this.viewPorts = [];\n    }\n    setCurrent(width, height) {\n        this.viewPorts.push({\n            width,\n            height\n        });\n    }\n    removeCurrent() {\n        this.viewPorts.pop();\n    }\n    getRoot() {\n        const [root] = this.viewPorts;\n        if (!root) {\n            return getDefault();\n        }\n        return root;\n    }\n    getCurrent() {\n        const { viewPorts  } = this;\n        const current = viewPorts[viewPorts.length - 1];\n        if (!current) {\n            return getDefault();\n        }\n        return current;\n    }\n    get width() {\n        return this.getCurrent().width;\n    }\n    get height() {\n        return this.getCurrent().height;\n    }\n    computeSize(d) {\n        if (typeof d === 'number') {\n            return d;\n        }\n        if (d === 'x') {\n            return this.width;\n        }\n        if (d === 'y') {\n            return this.height;\n        }\n        return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);\n    }\n    constructor(){\n        this.viewPorts = [];\n    }\n}\nViewPort.DEFAULT_VIEWPORT_WIDTH = 800;\nViewPort.DEFAULT_VIEWPORT_HEIGHT = 600;\nfunction getDefault() {\n    return {\n        width: ViewPort.DEFAULT_VIEWPORT_WIDTH,\n        height: ViewPort.DEFAULT_VIEWPORT_HEIGHT\n    };\n}\n\nclass Point {\n    static parse(point) {\n        let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        const [x = defaultValue, y = defaultValue] = toNumbers(point);\n        return new Point(x, y);\n    }\n    static parseScale(scale) {\n        let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        const [x = defaultValue, y = x] = toNumbers(scale);\n        return new Point(x, y);\n    }\n    static parsePath(path) {\n        const points = toNumbers(path);\n        const len = points.length;\n        const pathPoints = [];\n        for(let i = 0; i < len; i += 2){\n            pathPoints.push(new Point(points[i], points[i + 1]));\n        }\n        return pathPoints;\n    }\n    angleTo(point) {\n        return Math.atan2(point.y - this.y, point.x - this.x);\n    }\n    applyTransform(transform) {\n        const { x , y  } = this;\n        const xp = x * transform[0] + y * transform[2] + transform[4];\n        const yp = x * transform[1] + y * transform[3] + transform[5];\n        this.x = xp;\n        this.y = yp;\n    }\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Mouse {\n    isWorking() {\n        return this.working;\n    }\n    start() {\n        if (this.working) {\n            return;\n        }\n        const { screen , onClick , onMouseMove  } = this;\n        const canvas = screen.ctx.canvas;\n        canvas.onclick = onClick;\n        canvas.onmousemove = onMouseMove;\n        this.working = true;\n    }\n    stop() {\n        if (!this.working) {\n            return;\n        }\n        const canvas = this.screen.ctx.canvas;\n        this.working = false;\n        canvas.onclick = null;\n        canvas.onmousemove = null;\n    }\n    hasEvents() {\n        return this.working && this.events.length > 0;\n    }\n    runEvents() {\n        if (!this.working) {\n            return;\n        }\n        const { screen: document , events , eventElements  } = this;\n        const { style  } = document.ctx.canvas;\n        let element;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (style) {\n            style.cursor = '';\n        }\n        events.forEach((param, i)=>{\n            let { run  } = param;\n            element = eventElements[i];\n            while(element){\n                run(element);\n                element = element.parent;\n            }\n        });\n        // done running, clear\n        this.events = [];\n        this.eventElements = [];\n    }\n    checkPath(element, ctx) {\n        if (!this.working || !ctx) {\n            return;\n        }\n        const { events , eventElements  } = this;\n        events.forEach((param, i)=>{\n            let { x , y  } = param;\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (!eventElements[i] && ctx.isPointInPath && ctx.isPointInPath(x, y)) {\n                eventElements[i] = element;\n            }\n        });\n    }\n    checkBoundingBox(element, boundingBox) {\n        if (!this.working || !boundingBox) {\n            return;\n        }\n        const { events , eventElements  } = this;\n        events.forEach((param, i)=>{\n            let { x , y  } = param;\n            if (!eventElements[i] && boundingBox.isPointInBox(x, y)) {\n                eventElements[i] = element;\n            }\n        });\n    }\n    mapXY(x, y) {\n        const { window , ctx  } = this.screen;\n        const point = new Point(x, y);\n        let element = ctx.canvas;\n        while(element){\n            point.x -= element.offsetLeft;\n            point.y -= element.offsetTop;\n            element = element.offsetParent;\n        }\n        if (window === null || window === void 0 ? void 0 : window.scrollX) {\n            point.x += window.scrollX;\n        }\n        if (window === null || window === void 0 ? void 0 : window.scrollY) {\n            point.y += window.scrollY;\n        }\n        return point;\n    }\n    onClick(event) {\n        const { x , y  } = this.mapXY(event.clientX, event.clientY);\n        this.events.push({\n            type: 'onclick',\n            x,\n            y,\n            run (eventTarget) {\n                if (eventTarget.onClick) {\n                    eventTarget.onClick();\n                }\n            }\n        });\n    }\n    onMouseMove(event) {\n        const { x , y  } = this.mapXY(event.clientX, event.clientY);\n        this.events.push({\n            type: 'onmousemove',\n            x,\n            y,\n            run (eventTarget) {\n                if (eventTarget.onMouseMove) {\n                    eventTarget.onMouseMove();\n                }\n            }\n        });\n    }\n    constructor(screen){\n        this.screen = screen;\n        this.working = false;\n        this.events = [];\n        this.eventElements = [];\n        this.onClick = this.onClick.bind(this);\n        this.onMouseMove = this.onMouseMove.bind(this);\n    }\n}\n\nconst defaultWindow = typeof window !== 'undefined' ? window : null;\nconst defaultFetch$1 = typeof fetch !== 'undefined' ? fetch.bind(undefined) // `fetch` depends on context: `someObject.fetch(...)` will throw error.\n : undefined;\nclass Screen {\n    wait(checker) {\n        this.waits.push(checker);\n    }\n    ready() {\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        if (!this.readyPromise) {\n            return Promise.resolve();\n        }\n        return this.readyPromise;\n    }\n    isReady() {\n        if (this.isReadyLock) {\n            return true;\n        }\n        const isReadyLock = this.waits.every((_)=>_()\n        );\n        if (isReadyLock) {\n            this.waits = [];\n            if (this.resolveReady) {\n                this.resolveReady();\n            }\n        }\n        this.isReadyLock = isReadyLock;\n        return isReadyLock;\n    }\n    setDefaults(ctx) {\n        // initial values and defaults\n        ctx.strokeStyle = 'rgba(0,0,0,0)';\n        ctx.lineCap = 'butt';\n        ctx.lineJoin = 'miter';\n        ctx.miterLimit = 4;\n    }\n    setViewBox(param) {\n        let { document , ctx , aspectRatio , width , desiredWidth , height , desiredHeight , minX =0 , minY =0 , refX , refY , clip =false , clipX =0 , clipY =0  } = param;\n        // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\n        const cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\\s/, '') // ignore defer\n        ;\n        const [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(' ');\n        const align = aspectRatioAlign || 'xMidYMid';\n        const meetOrSlice = aspectRatioMeetOrSlice || 'meet';\n        // calculate scale\n        const scaleX = width / desiredWidth;\n        const scaleY = height / desiredHeight;\n        const scaleMin = Math.min(scaleX, scaleY);\n        const scaleMax = Math.max(scaleX, scaleY);\n        let finalDesiredWidth = desiredWidth;\n        let finalDesiredHeight = desiredHeight;\n        if (meetOrSlice === 'meet') {\n            finalDesiredWidth *= scaleMin;\n            finalDesiredHeight *= scaleMin;\n        }\n        if (meetOrSlice === 'slice') {\n            finalDesiredWidth *= scaleMax;\n            finalDesiredHeight *= scaleMax;\n        }\n        const refXProp = new Property(document, 'refX', refX);\n        const refYProp = new Property(document, 'refY', refY);\n        const hasRefs = refXProp.hasValue() && refYProp.hasValue();\n        if (hasRefs) {\n            ctx.translate(-scaleMin * refXProp.getPixels('x'), -scaleMin * refYProp.getPixels('y'));\n        }\n        if (clip) {\n            const scaledClipX = scaleMin * clipX;\n            const scaledClipY = scaleMin * clipY;\n            ctx.beginPath();\n            ctx.moveTo(scaledClipX, scaledClipY);\n            ctx.lineTo(width, scaledClipY);\n            ctx.lineTo(width, height);\n            ctx.lineTo(scaledClipX, height);\n            ctx.closePath();\n            ctx.clip();\n        }\n        if (!hasRefs) {\n            const isMeetMinY = meetOrSlice === 'meet' && scaleMin === scaleY;\n            const isSliceMaxY = meetOrSlice === 'slice' && scaleMax === scaleY;\n            const isMeetMinX = meetOrSlice === 'meet' && scaleMin === scaleX;\n            const isSliceMaxX = meetOrSlice === 'slice' && scaleMax === scaleX;\n            if (align.startsWith('xMid') && (isMeetMinY || isSliceMaxY)) {\n                ctx.translate(width / 2 - finalDesiredWidth / 2, 0);\n            }\n            if (align.endsWith('YMid') && (isMeetMinX || isSliceMaxX)) {\n                ctx.translate(0, height / 2 - finalDesiredHeight / 2);\n            }\n            if (align.startsWith('xMax') && (isMeetMinY || isSliceMaxY)) {\n                ctx.translate(width - finalDesiredWidth, 0);\n            }\n            if (align.endsWith('YMax') && (isMeetMinX || isSliceMaxX)) {\n                ctx.translate(0, height - finalDesiredHeight);\n            }\n        }\n        // scale\n        switch(true){\n            case align === 'none':\n                ctx.scale(scaleX, scaleY);\n                break;\n            case meetOrSlice === 'meet':\n                ctx.scale(scaleMin, scaleMin);\n                break;\n            case meetOrSlice === 'slice':\n                ctx.scale(scaleMax, scaleMax);\n                break;\n        }\n        // translate\n        ctx.translate(-minX, -minY);\n    }\n    start(element) {\n        let { enableRedraw =false , ignoreMouse =false , ignoreAnimation =false , ignoreDimensions =false , ignoreClear =false , forceRedraw , scaleWidth , scaleHeight , offsetX , offsetY  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const { mouse  } = this;\n        const frameDuration = 1000 / Screen.FRAMERATE;\n        this.isReadyLock = false;\n        this.frameDuration = frameDuration;\n        this.readyPromise = new Promise((resolve)=>{\n            this.resolveReady = resolve;\n        });\n        if (this.isReady()) {\n            this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n        }\n        if (!enableRedraw) {\n            return;\n        }\n        let now = Date.now();\n        let then = now;\n        let delta = 0;\n        const tick = ()=>{\n            now = Date.now();\n            delta = now - then;\n            if (delta >= frameDuration) {\n                then = now - delta % frameDuration;\n                if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {\n                    this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n                    mouse.runEvents();\n                }\n            }\n            this.intervalId = raf__WEBPACK_IMPORTED_MODULE_0__(tick);\n        };\n        if (!ignoreMouse) {\n            mouse.start();\n        }\n        this.intervalId = raf__WEBPACK_IMPORTED_MODULE_0__(tick);\n    }\n    stop() {\n        if (this.intervalId) {\n            raf__WEBPACK_IMPORTED_MODULE_0__.cancel(this.intervalId);\n            this.intervalId = null;\n        }\n        this.mouse.stop();\n    }\n    shouldUpdate(ignoreAnimation, forceRedraw) {\n        // need update from animations?\n        if (!ignoreAnimation) {\n            const { frameDuration  } = this;\n            const shouldUpdate1 = this.animations.reduce((shouldUpdate, animation)=>animation.update(frameDuration) || shouldUpdate\n            , false);\n            if (shouldUpdate1) {\n                return true;\n            }\n        }\n        // need update from redraw?\n        if (typeof forceRedraw === 'function' && forceRedraw()) {\n            return true;\n        }\n        if (!this.isReadyLock && this.isReady()) {\n            return true;\n        }\n        // need update from mouse events?\n        if (this.mouse.hasEvents()) {\n            return true;\n        }\n        return false;\n    }\n    render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {\n        const { viewPort , ctx , isFirstRender  } = this;\n        const canvas = ctx.canvas;\n        viewPort.clear();\n        if (canvas.width && canvas.height) {\n            viewPort.setCurrent(canvas.width, canvas.height);\n        }\n        const widthStyle = element.getStyle('width');\n        const heightStyle = element.getStyle('height');\n        if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== 'number' && typeof scaleHeight !== 'number')) {\n            // set canvas size\n            if (widthStyle.hasValue()) {\n                canvas.width = widthStyle.getPixels('x');\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                if (canvas.style) {\n                    canvas.style.width = \"\".concat(canvas.width, \"px\");\n                }\n            }\n            if (heightStyle.hasValue()) {\n                canvas.height = heightStyle.getPixels('y');\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                if (canvas.style) {\n                    canvas.style.height = \"\".concat(canvas.height, \"px\");\n                }\n            }\n        }\n        let cWidth = canvas.clientWidth || canvas.width;\n        let cHeight = canvas.clientHeight || canvas.height;\n        if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {\n            cWidth = widthStyle.getPixels('x');\n            cHeight = heightStyle.getPixels('y');\n        }\n        viewPort.setCurrent(cWidth, cHeight);\n        if (typeof offsetX === 'number') {\n            element.getAttribute('x', true).setValue(offsetX);\n        }\n        if (typeof offsetY === 'number') {\n            element.getAttribute('y', true).setValue(offsetY);\n        }\n        if (typeof scaleWidth === 'number' || typeof scaleHeight === 'number') {\n            const viewBox = toNumbers(element.getAttribute('viewBox').getString());\n            let xRatio = 0;\n            let yRatio = 0;\n            if (typeof scaleWidth === 'number') {\n                const widthStyle = element.getStyle('width');\n                if (widthStyle.hasValue()) {\n                    xRatio = widthStyle.getPixels('x') / scaleWidth;\n                } else if (viewBox[2] && !isNaN(viewBox[2])) {\n                    xRatio = viewBox[2] / scaleWidth;\n                }\n            }\n            if (typeof scaleHeight === 'number') {\n                const heightStyle = element.getStyle('height');\n                if (heightStyle.hasValue()) {\n                    yRatio = heightStyle.getPixels('y') / scaleHeight;\n                } else if (viewBox[3] && !isNaN(viewBox[3])) {\n                    yRatio = viewBox[3] / scaleHeight;\n                }\n            }\n            if (!xRatio) {\n                xRatio = yRatio;\n            }\n            if (!yRatio) {\n                yRatio = xRatio;\n            }\n            element.getAttribute('width', true).setValue(scaleWidth);\n            element.getAttribute('height', true).setValue(scaleHeight);\n            const transformStyle = element.getStyle('transform', true, true);\n            transformStyle.setValue(\"\".concat(transformStyle.getString(), \" scale(\").concat(1 / xRatio, \", \").concat(1 / yRatio, \")\"));\n        }\n        // clear and render\n        if (!ignoreClear) {\n            ctx.clearRect(0, 0, cWidth, cHeight);\n        }\n        element.render(ctx);\n        if (isFirstRender) {\n            this.isFirstRender = false;\n        }\n    }\n    constructor(ctx, { fetch =defaultFetch$1 , window =defaultWindow  } = {}){\n        this.ctx = ctx;\n        this.viewPort = new ViewPort();\n        this.mouse = new Mouse(this);\n        this.animations = [];\n        this.waits = [];\n        this.frameDuration = 0;\n        this.isReadyLock = false;\n        this.isFirstRender = true;\n        this.intervalId = null;\n        this.window = window;\n        if (!fetch) {\n            throw new Error(\"Can't find 'fetch' in 'globalThis', please provide it via options\");\n        }\n        this.fetch = fetch;\n    }\n}\nScreen.defaultWindow = defaultWindow;\nScreen.defaultFetch = defaultFetch$1;\nScreen.FRAMERATE = 30;\nScreen.MAX_VIRTUAL_PIXELS = 30000;\n\nconst { defaultFetch  } = Screen;\nconst DefaultDOMParser = typeof DOMParser !== 'undefined' ? DOMParser : undefined;\nclass Parser {\n    async parse(resource) {\n        if (resource.startsWith('<')) {\n            return this.parseFromString(resource);\n        }\n        return this.load(resource);\n    }\n    parseFromString(xml) {\n        const parser = new this.DOMParser();\n        try {\n            return this.checkDocument(parser.parseFromString(xml, 'image/svg+xml'));\n        } catch (err) {\n            return this.checkDocument(parser.parseFromString(xml, 'text/xml'));\n        }\n    }\n    checkDocument(document) {\n        const parserError = document.getElementsByTagName('parsererror')[0];\n        if (parserError) {\n            throw new Error(parserError.textContent || 'Unknown parse error');\n        }\n        return document;\n    }\n    async load(url) {\n        const response = await this.fetch(url);\n        const xml = await response.text();\n        return this.parseFromString(xml);\n    }\n    constructor({ fetch =defaultFetch , DOMParser =DefaultDOMParser  } = {}){\n        if (!fetch) {\n            throw new Error(\"Can't find 'fetch' in 'globalThis', please provide it via options\");\n        }\n        if (!DOMParser) {\n            throw new Error(\"Can't find 'DOMParser' in 'globalThis', please provide it via options\");\n        }\n        this.fetch = fetch;\n        this.DOMParser = DOMParser;\n    }\n}\n\nclass Translate {\n    apply(ctx) {\n        const { x , y  } = this.point;\n        ctx.translate(x || 0, y || 0);\n    }\n    unapply(ctx) {\n        const { x , y  } = this.point;\n        ctx.translate(-1 * x || 0, -1 * y || 0);\n    }\n    applyToPoint(point) {\n        const { x , y  } = this.point;\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            x || 0,\n            y || 0\n        ]);\n    }\n    constructor(_, point){\n        this.type = 'translate';\n        this.point = Point.parse(point);\n    }\n}\n\nclass Rotate {\n    apply(ctx) {\n        const { cx , cy , originX , originY , angle  } = this;\n        const tx = cx + originX.getPixels('x');\n        const ty = cy + originY.getPixels('y');\n        ctx.translate(tx, ty);\n        ctx.rotate(angle.getRadians());\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        const { cx , cy , originX , originY , angle  } = this;\n        const tx = cx + originX.getPixels('x');\n        const ty = cy + originY.getPixels('y');\n        ctx.translate(tx, ty);\n        ctx.rotate(-1 * angle.getRadians());\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        const { cx , cy , angle  } = this;\n        const rad = angle.getRadians();\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            cx || 0,\n            cy || 0 // this.p.y\n        ]);\n        point.applyTransform([\n            Math.cos(rad),\n            Math.sin(rad),\n            -Math.sin(rad),\n            Math.cos(rad),\n            0,\n            0\n        ]);\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            -cx || 0,\n            -cy || 0 // -this.p.y\n        ]);\n    }\n    constructor(document, rotate, transformOrigin){\n        this.type = 'rotate';\n        const numbers = toNumbers(rotate);\n        this.angle = new Property(document, 'angle', numbers[0]);\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n        this.cx = numbers[1] || 0;\n        this.cy = numbers[2] || 0;\n    }\n}\n\nclass Scale {\n    apply(ctx) {\n        const { scale: { x , y  } , originX , originY  } = this;\n        const tx = originX.getPixels('x');\n        const ty = originY.getPixels('y');\n        ctx.translate(tx, ty);\n        ctx.scale(x, y || x);\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        const { scale: { x , y  } , originX , originY  } = this;\n        const tx = originX.getPixels('x');\n        const ty = originY.getPixels('y');\n        ctx.translate(tx, ty);\n        ctx.scale(1 / x, 1 / y || x);\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        const { x , y  } = this.scale;\n        point.applyTransform([\n            x || 0,\n            0,\n            0,\n            y || 0,\n            0,\n            0\n        ]);\n    }\n    constructor(_, scale, transformOrigin){\n        this.type = 'scale';\n        const scaleSize = Point.parseScale(scale);\n        // Workaround for node-canvas\n        if (scaleSize.x === 0 || scaleSize.y === 0) {\n            scaleSize.x = PSEUDO_ZERO;\n            scaleSize.y = PSEUDO_ZERO;\n        }\n        this.scale = scaleSize;\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n    }\n}\n\nclass Matrix {\n    apply(ctx) {\n        const { originX , originY , matrix  } = this;\n        const tx = originX.getPixels('x');\n        const ty = originY.getPixels('y');\n        ctx.translate(tx, ty);\n        ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        const { originX , originY , matrix  } = this;\n        const a = matrix[0];\n        const b = matrix[2];\n        const c = matrix[4];\n        const d = matrix[1];\n        const e = matrix[3];\n        const f = matrix[5];\n        const g = 0;\n        const h = 0;\n        const i = 1;\n        const det = 1 / (a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g));\n        const tx = originX.getPixels('x');\n        const ty = originY.getPixels('y');\n        ctx.translate(tx, ty);\n        ctx.transform(det * (e * i - f * h), det * (f * g - d * i), det * (c * h - b * i), det * (a * i - c * g), det * (b * f - c * e), det * (c * d - a * f));\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        point.applyTransform(this.matrix);\n    }\n    constructor(_, matrix, transformOrigin){\n        this.type = 'matrix';\n        this.matrix = toMatrixValue(matrix);\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n    }\n}\n\nclass Skew extends Matrix {\n    constructor(document, skew, transformOrigin){\n        super(document, skew, transformOrigin);\n        this.type = 'skew';\n        this.angle = new Property(document, 'angle', skew);\n    }\n}\n\nclass SkewX extends Skew {\n    constructor(document, skew, transformOrigin){\n        super(document, skew, transformOrigin);\n        this.type = 'skewX';\n        this.matrix = [\n            1,\n            0,\n            Math.tan(this.angle.getRadians()),\n            1,\n            0,\n            0\n        ];\n    }\n}\n\nclass SkewY extends Skew {\n    constructor(document, skew, transformOrigin){\n        super(document, skew, transformOrigin);\n        this.type = 'skewY';\n        this.matrix = [\n            1,\n            Math.tan(this.angle.getRadians()),\n            0,\n            1,\n            0,\n            0\n        ];\n    }\n}\n\nfunction parseTransforms(transform) {\n    return compressSpaces(transform).trim().replace(/\\)([a-zA-Z])/g, ') $1').replace(/\\)(\\s?,\\s?)/g, ') ').split(/\\s(?=[a-z])/);\n}\nfunction parseTransform(transform) {\n    const [type = '', value = ''] = transform.split('(');\n    return [\n        type.trim(),\n        value.trim().replace(')', '')\n    ];\n}\nclass Transform {\n    static fromElement(document, element) {\n        const transformStyle = element.getStyle('transform', false, true);\n        if (transformStyle.hasValue()) {\n            const [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle('transform-origin', false, true).split();\n            if (transformOriginXProperty && transformOriginYProperty) {\n                const transformOrigin = [\n                    transformOriginXProperty,\n                    transformOriginYProperty\n                ];\n                return new Transform(document, transformStyle.getString(), transformOrigin);\n            }\n        }\n        return null;\n    }\n    apply(ctx) {\n        this.transforms.forEach((transform)=>transform.apply(ctx)\n        );\n    }\n    unapply(ctx) {\n        this.transforms.forEach((transform)=>transform.unapply(ctx)\n        );\n    }\n    // TODO: applyToPoint unused ... remove?\n    applyToPoint(point) {\n        this.transforms.forEach((transform)=>transform.applyToPoint(point)\n        );\n    }\n    constructor(document, transform1, transformOrigin){\n        this.document = document;\n        this.transforms = [];\n        const data = parseTransforms(transform1);\n        data.forEach((transform)=>{\n            if (transform === 'none') {\n                return;\n            }\n            const [type, value] = parseTransform(transform);\n            const TransformType = Transform.transformTypes[type];\n            if (TransformType) {\n                this.transforms.push(new TransformType(this.document, value, transformOrigin));\n            }\n        });\n    }\n}\nTransform.transformTypes = {\n    translate: Translate,\n    rotate: Rotate,\n    scale: Scale,\n    matrix: Matrix,\n    skewX: SkewX,\n    skewY: SkewY\n};\n\nclass Element {\n    getAttribute(name) {\n        let createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        const attr = this.attributes.get(name);\n        if (!attr && createIfNotExists) {\n            const attr = new Property(this.document, name, '');\n            this.attributes.set(name, attr);\n            return attr;\n        }\n        return attr || Property.empty(this.document);\n    }\n    getHrefAttribute() {\n        let href;\n        for (const [key, value] of this.attributes){\n            if (key === 'href' || key.endsWith(':href')) {\n                href = value;\n                break;\n            }\n        }\n        return href || Property.empty(this.document);\n    }\n    getStyle(name) {\n        let createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, skipAncestors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        const style = this.styles.get(name);\n        if (style) {\n            return style;\n        }\n        const attr = this.getAttribute(name);\n        if (attr.hasValue()) {\n            this.styles.set(name, attr) // move up to me to cache\n            ;\n            return attr;\n        }\n        if (!skipAncestors) {\n            const { parent  } = this;\n            if (parent) {\n                const parentStyle = parent.getStyle(name);\n                if (parentStyle.hasValue()) {\n                    return parentStyle;\n                }\n            }\n        }\n        if (createIfNotExists) {\n            const style = new Property(this.document, name, '');\n            this.styles.set(name, style);\n            return style;\n        }\n        return Property.empty(this.document);\n    }\n    render(ctx) {\n        // don't render display=none\n        // don't render visibility=hidden\n        if (this.getStyle('display').getString() === 'none' || this.getStyle('visibility').getString() === 'hidden') {\n            return;\n        }\n        ctx.save();\n        if (this.getStyle('mask').hasValue()) {\n            const mask = this.getStyle('mask').getDefinition();\n            if (mask) {\n                this.applyEffects(ctx);\n                mask.apply(ctx, this);\n            }\n        } else if (this.getStyle('filter').getValue('none') !== 'none') {\n            const filter = this.getStyle('filter').getDefinition();\n            if (filter) {\n                this.applyEffects(ctx);\n                filter.apply(ctx, this);\n            }\n        } else {\n            this.setContext(ctx);\n            this.renderChildren(ctx);\n            this.clearContext(ctx);\n        }\n        ctx.restore();\n    }\n    setContext(_) {\n    // NO RENDER\n    }\n    applyEffects(ctx) {\n        // transform\n        const transform = Transform.fromElement(this.document, this);\n        if (transform) {\n            transform.apply(ctx);\n        }\n        // clip\n        const clipPathStyleProp = this.getStyle('clip-path', false, true);\n        if (clipPathStyleProp.hasValue()) {\n            const clip = clipPathStyleProp.getDefinition();\n            if (clip) {\n                clip.apply(ctx);\n            }\n        }\n    }\n    clearContext(_) {\n    // NO RENDER\n    }\n    renderChildren(ctx) {\n        this.children.forEach((child)=>{\n            child.render(ctx);\n        });\n    }\n    addChild(childNode) {\n        const child = childNode instanceof Element ? childNode : this.document.createElement(childNode);\n        child.parent = this;\n        if (!Element.ignoreChildTypes.includes(child.type)) {\n            this.children.push(child);\n        }\n    }\n    matchesSelector(selector) {\n        var ref;\n        const { node  } = this;\n        if (typeof node.matches === 'function') {\n            return node.matches(selector);\n        }\n        const styleClasses = (ref = node.getAttribute) === null || ref === void 0 ? void 0 : ref.call(node, 'class');\n        if (!styleClasses || styleClasses === '') {\n            return false;\n        }\n        return styleClasses.split(' ').some((styleClass)=>\".\".concat(styleClass) === selector\n        );\n    }\n    addStylesFromStyleDefinition() {\n        const { styles , stylesSpecificity  } = this.document;\n        for (const [selector, style] of styles){\n            if (!selector.startsWith('@') && this.matchesSelector(selector)) {\n                const specificity = stylesSpecificity.get(selector);\n                if (style) {\n                    for (const [name, styleProp] of style){\n                        let existingSpecificity = this.stylesSpecificity.get(name);\n                        if (typeof existingSpecificity === 'undefined') {\n                            existingSpecificity = '000';\n                        }\n                        if (specificity && specificity >= existingSpecificity) {\n                            if (styleProp) {\n                                this.styles.set(name, styleProp);\n                            }\n                            this.stylesSpecificity.set(name, specificity);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    removeStyles(element, ignoreStyles) {\n        const toRestore1 = ignoreStyles.reduce((toRestore, name)=>{\n            const styleProp = element.getStyle(name);\n            if (!styleProp.hasValue()) {\n                return toRestore;\n            }\n            const value = styleProp.getString();\n            styleProp.setValue('');\n            return [\n                ...toRestore,\n                [\n                    name,\n                    value\n                ]\n            ];\n        }, []);\n        return toRestore1;\n    }\n    restoreStyles(element, styles) {\n        styles.forEach((param)=>{\n            let [name, value] = param;\n            element.getStyle(name, true).setValue(value);\n        });\n    }\n    isFirstChild() {\n        var ref;\n        return ((ref = this.parent) === null || ref === void 0 ? void 0 : ref.children.indexOf(this)) === 0;\n    }\n    constructor(document, node, captureTextNodes = false){\n        this.document = document;\n        this.node = node;\n        this.captureTextNodes = captureTextNodes;\n        this.type = '';\n        this.attributes = new Map();\n        this.styles = new Map();\n        this.stylesSpecificity = new Map();\n        this.animationFrozen = false;\n        this.animationFrozenValue = '';\n        this.parent = null;\n        this.children = [];\n        if (!node || node.nodeType !== 1) {\n            return;\n        }\n        // add attributes\n        Array.from(node.attributes).forEach((attribute)=>{\n            const nodeName = normalizeAttributeName(attribute.nodeName);\n            this.attributes.set(nodeName, new Property(document, nodeName, attribute.value));\n        });\n        this.addStylesFromStyleDefinition();\n        // add inline styles\n        if (this.getAttribute('style').hasValue()) {\n            const styles = this.getAttribute('style').getString().split(';').map((_)=>_.trim()\n            );\n            styles.forEach((style)=>{\n                if (!style) {\n                    return;\n                }\n                const [name, value] = style.split(':').map((_)=>_.trim()\n                );\n                if (name) {\n                    this.styles.set(name, new Property(document, name, value));\n                }\n            });\n        }\n        const { definitions  } = document;\n        const id = this.getAttribute('id');\n        // add id\n        if (id.hasValue()) {\n            if (!definitions.has(id.getString())) {\n                definitions.set(id.getString(), this);\n            }\n        }\n        Array.from(node.childNodes).forEach((childNode)=>{\n            if (childNode.nodeType === 1) {\n                this.addChild(childNode) // ELEMENT_NODE\n                ;\n            } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {\n                const textNode = document.createTextNode(childNode);\n                if (textNode.getText().length > 0) {\n                    this.addChild(textNode) // TEXT_NODE\n                    ;\n                }\n            }\n        });\n    }\n}\nElement.ignoreChildTypes = [\n    'title'\n];\n\nclass UnknownElement extends Element {\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n    }\n}\n\nfunction wrapFontFamily(fontFamily) {\n    const trimmed = fontFamily.trim();\n    return /^('|\")/.test(trimmed) ? trimmed : \"\\\"\".concat(trimmed, \"\\\"\");\n}\nfunction prepareFontFamily(fontFamily) {\n    return typeof process === 'undefined' ? fontFamily : fontFamily.trim().split(',').map(wrapFontFamily).join(',');\n}\n/**\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-style\n * @param fontStyle\n * @returns CSS font style.\n */ function prepareFontStyle(fontStyle) {\n    if (!fontStyle) {\n        return '';\n    }\n    const targetFontStyle = fontStyle.trim().toLowerCase();\n    switch(targetFontStyle){\n        case 'normal':\n        case 'italic':\n        case 'oblique':\n        case 'inherit':\n        case 'initial':\n        case 'unset':\n            return targetFontStyle;\n        default:\n            if (/^oblique\\s+(-|)\\d+deg$/.test(targetFontStyle)) {\n                return targetFontStyle;\n            }\n            return '';\n    }\n}\n/**\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight\n * @param fontWeight\n * @returns CSS font weight.\n */ function prepareFontWeight(fontWeight) {\n    if (!fontWeight) {\n        return '';\n    }\n    const targetFontWeight = fontWeight.trim().toLowerCase();\n    switch(targetFontWeight){\n        case 'normal':\n        case 'bold':\n        case 'lighter':\n        case 'bolder':\n        case 'inherit':\n        case 'initial':\n        case 'unset':\n            return targetFontWeight;\n        default:\n            if (/^[\\d.]+$/.test(targetFontWeight)) {\n                return targetFontWeight;\n            }\n            return '';\n    }\n}\nclass Font {\n    static parse() {\n        let font = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : '', inherit = arguments.length > 1 ? arguments[1] : void 0;\n        let fontStyle = '';\n        let fontVariant = '';\n        let fontWeight = '';\n        let fontSize = '';\n        let fontFamily = '';\n        const parts = compressSpaces(font).trim().split(' ');\n        const set = {\n            fontSize: false,\n            fontStyle: false,\n            fontWeight: false,\n            fontVariant: false\n        };\n        parts.forEach((part)=>{\n            switch(true){\n                case !set.fontStyle && Font.styles.includes(part):\n                    if (part !== 'inherit') {\n                        fontStyle = part;\n                    }\n                    set.fontStyle = true;\n                    break;\n                case !set.fontVariant && Font.variants.includes(part):\n                    if (part !== 'inherit') {\n                        fontVariant = part;\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    break;\n                case !set.fontWeight && Font.weights.includes(part):\n                    if (part !== 'inherit') {\n                        fontWeight = part;\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    set.fontWeight = true;\n                    break;\n                case !set.fontSize:\n                    if (part !== 'inherit') {\n                        fontSize = part.split('/')[0] || '';\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    set.fontWeight = true;\n                    set.fontSize = true;\n                    break;\n                default:\n                    if (part !== 'inherit') {\n                        fontFamily += part;\n                    }\n            }\n        });\n        return new Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit);\n    }\n    toString() {\n        return [\n            prepareFontStyle(this.fontStyle),\n            this.fontVariant,\n            prepareFontWeight(this.fontWeight),\n            this.fontSize,\n            // Wrap fontFamily only on nodejs and only for canvas.ctx\n            prepareFontFamily(this.fontFamily)\n        ].join(' ').trim();\n    }\n    constructor(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit){\n        const inheritFont = inherit ? typeof inherit === 'string' ? Font.parse(inherit) : inherit : {};\n        this.fontFamily = fontFamily || inheritFont.fontFamily;\n        this.fontSize = fontSize || inheritFont.fontSize;\n        this.fontStyle = fontStyle || inheritFont.fontStyle;\n        this.fontWeight = fontWeight || inheritFont.fontWeight;\n        this.fontVariant = fontVariant || inheritFont.fontVariant;\n    }\n}\nFont.styles = 'normal|italic|oblique|inherit';\nFont.variants = 'normal|small-caps|inherit';\nFont.weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';\n\nclass BoundingBox {\n    get x() {\n        return this.x1;\n    }\n    get y() {\n        return this.y1;\n    }\n    get width() {\n        return this.x2 - this.x1;\n    }\n    get height() {\n        return this.y2 - this.y1;\n    }\n    addPoint(x, y) {\n        if (typeof x !== 'undefined') {\n            if (isNaN(this.x1) || isNaN(this.x2)) {\n                this.x1 = x;\n                this.x2 = x;\n            }\n            if (x < this.x1) {\n                this.x1 = x;\n            }\n            if (x > this.x2) {\n                this.x2 = x;\n            }\n        }\n        if (typeof y !== 'undefined') {\n            if (isNaN(this.y1) || isNaN(this.y2)) {\n                this.y1 = y;\n                this.y2 = y;\n            }\n            if (y < this.y1) {\n                this.y1 = y;\n            }\n            if (y > this.y2) {\n                this.y2 = y;\n            }\n        }\n    }\n    addX(x) {\n        this.addPoint(x, 0);\n    }\n    addY(y) {\n        this.addPoint(0, y);\n    }\n    addBoundingBox(boundingBox) {\n        if (!boundingBox) {\n            return;\n        }\n        const { x1 , y1 , x2 , y2  } = boundingBox;\n        this.addPoint(x1, y1);\n        this.addPoint(x2, y2);\n    }\n    sumCubic(t, p0, p1, p2, p3) {\n        return Math.pow(1 - t, 3) * p0 + 3 * Math.pow(1 - t, 2) * t * p1 + 3 * (1 - t) * Math.pow(t, 2) * p2 + Math.pow(t, 3) * p3;\n    }\n    bezierCurveAdd(forX, p0, p1, p2, p3) {\n        const b = 6 * p0 - 12 * p1 + 6 * p2;\n        const a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;\n        const c = 3 * p1 - 3 * p0;\n        if (a === 0) {\n            if (b === 0) {\n                return;\n            }\n            const t = -c / b;\n            if (0 < t && t < 1) {\n                if (forX) {\n                    this.addX(this.sumCubic(t, p0, p1, p2, p3));\n                } else {\n                    this.addY(this.sumCubic(t, p0, p1, p2, p3));\n                }\n            }\n            return;\n        }\n        const b2ac = Math.pow(b, 2) - 4 * c * a;\n        if (b2ac < 0) {\n            return;\n        }\n        const t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t1 && t1 < 1) {\n            if (forX) {\n                this.addX(this.sumCubic(t1, p0, p1, p2, p3));\n            } else {\n                this.addY(this.sumCubic(t1, p0, p1, p2, p3));\n            }\n        }\n        const t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t2 && t2 < 1) {\n            if (forX) {\n                this.addX(this.sumCubic(t2, p0, p1, p2, p3));\n            } else {\n                this.addY(this.sumCubic(t2, p0, p1, p2, p3));\n            }\n        }\n    }\n    // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n    addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {\n        this.addPoint(p0x, p0y);\n        this.addPoint(p3x, p3y);\n        this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);\n        this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);\n    }\n    addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {\n        const cp1x = p0x + 2 / 3 * (p1x - p0x) // CP1 = QP0 + 2/3 *(QP1-QP0)\n        ;\n        const cp1y = p0y + 2 / 3 * (p1y - p0y) // CP1 = QP0 + 2/3 *(QP1-QP0)\n        ;\n        const cp2x = cp1x + 1 / 3 * (p2x - p0x) // CP2 = CP1 + 1/3 *(QP2-QP0)\n        ;\n        const cp2y = cp1y + 1 / 3 * (p2y - p0y) // CP2 = CP1 + 1/3 *(QP2-QP0)\n        ;\n        this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);\n    }\n    isPointInBox(x, y) {\n        const { x1 , y1 , x2 , y2  } = this;\n        return x1 <= x && x <= x2 && y1 <= y && y <= y2;\n    }\n    constructor(x1 = Number.NaN, y1 = Number.NaN, x2 = Number.NaN, y2 = Number.NaN){\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n        this.addPoint(x1, y1);\n        this.addPoint(x2, y2);\n    }\n}\n\nclass RenderedElement extends Element {\n    calculateOpacity() {\n        let opacity = 1;\n        // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n        let element = this;\n        while(element){\n            const opacityStyle = element.getStyle('opacity', false, true) // no ancestors on style call\n            ;\n            if (opacityStyle.hasValue(true)) {\n                opacity *= opacityStyle.getNumber();\n            }\n            element = element.parent;\n        }\n        return opacity;\n    }\n    setContext(ctx) {\n        let fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        if (!fromMeasure) {\n            // fill\n            const fillStyleProp = this.getStyle('fill');\n            const fillOpacityStyleProp = this.getStyle('fill-opacity');\n            const strokeStyleProp = this.getStyle('stroke');\n            const strokeOpacityProp = this.getStyle('stroke-opacity');\n            if (fillStyleProp.isUrlDefinition()) {\n                const fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);\n                if (fillStyle) {\n                    ctx.fillStyle = fillStyle;\n                }\n            } else if (fillStyleProp.hasValue()) {\n                if (fillStyleProp.getString() === 'currentColor') {\n                    fillStyleProp.setValue(this.getStyle('color').getColor());\n                }\n                const fillStyle = fillStyleProp.getColor();\n                if (fillStyle !== 'inherit') {\n                    ctx.fillStyle = fillStyle === 'none' ? 'rgba(0,0,0,0)' : fillStyle;\n                }\n            }\n            if (fillOpacityStyleProp.hasValue()) {\n                const fillStyle = new Property(this.document, 'fill', ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();\n                ctx.fillStyle = fillStyle;\n            }\n            // stroke\n            if (strokeStyleProp.isUrlDefinition()) {\n                const strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);\n                if (strokeStyle) {\n                    ctx.strokeStyle = strokeStyle;\n                }\n            } else if (strokeStyleProp.hasValue()) {\n                if (strokeStyleProp.getString() === 'currentColor') {\n                    strokeStyleProp.setValue(this.getStyle('color').getColor());\n                }\n                const strokeStyle = strokeStyleProp.getString();\n                if (strokeStyle !== 'inherit') {\n                    ctx.strokeStyle = strokeStyle === 'none' ? 'rgba(0,0,0,0)' : strokeStyle;\n                }\n            }\n            if (strokeOpacityProp.hasValue()) {\n                const strokeStyle = new Property(this.document, 'stroke', ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();\n                ctx.strokeStyle = strokeStyle;\n            }\n            const strokeWidthStyleProp = this.getStyle('stroke-width');\n            if (strokeWidthStyleProp.hasValue()) {\n                const newLineWidth = strokeWidthStyleProp.getPixels();\n                ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO // browsers don't respect 0 (or node-canvas? :-)\n                 : newLineWidth;\n            }\n            const strokeLinecapStyleProp = this.getStyle('stroke-linecap');\n            const strokeLinejoinStyleProp = this.getStyle('stroke-linejoin');\n            const strokeMiterlimitProp = this.getStyle('stroke-miterlimit');\n            // NEED TEST\n            // const pointOrderStyleProp = this.getStyle('paint-order');\n            const strokeDasharrayStyleProp = this.getStyle('stroke-dasharray');\n            const strokeDashoffsetProp = this.getStyle('stroke-dashoffset');\n            if (strokeLinecapStyleProp.hasValue()) {\n                ctx.lineCap = strokeLinecapStyleProp.getString();\n            }\n            if (strokeLinejoinStyleProp.hasValue()) {\n                ctx.lineJoin = strokeLinejoinStyleProp.getString();\n            }\n            if (strokeMiterlimitProp.hasValue()) {\n                ctx.miterLimit = strokeMiterlimitProp.getNumber();\n            }\n            // NEED TEST\n            // if (pointOrderStyleProp.hasValue()) {\n            //   // ?\n            //   ctx.paintOrder = pointOrderStyleProp.getValue();\n            // }\n            if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== 'none') {\n                const gaps = toNumbers(strokeDasharrayStyleProp.getString());\n                if (typeof ctx.setLineDash !== 'undefined') {\n                    ctx.setLineDash(gaps);\n                } else // @ts-expect-error Handle browser prefix.\n                if (typeof ctx.webkitLineDash !== 'undefined') {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.webkitLineDash = gaps;\n                } else // @ts-expect-error Handle browser prefix.\n                if (typeof ctx.mozDash !== 'undefined' && !(gaps.length === 1 && gaps[0] === 0)) {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.mozDash = gaps;\n                }\n                const offset = strokeDashoffsetProp.getPixels();\n                if (typeof ctx.lineDashOffset !== 'undefined') {\n                    ctx.lineDashOffset = offset;\n                } else // @ts-expect-error Handle browser prefix.\n                if (typeof ctx.webkitLineDashOffset !== 'undefined') {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.webkitLineDashOffset = offset;\n                } else // @ts-expect-error Handle browser prefix.\n                if (typeof ctx.mozDashOffset !== 'undefined') {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.mozDashOffset = offset;\n                }\n            }\n        }\n        // font\n        this.modifiedEmSizeStack = false;\n        if (typeof ctx.font !== 'undefined') {\n            const fontStyleProp = this.getStyle('font');\n            const fontStyleStyleProp = this.getStyle('font-style');\n            const fontVariantStyleProp = this.getStyle('font-variant');\n            const fontWeightStyleProp = this.getStyle('font-weight');\n            const fontSizeStyleProp = this.getStyle('font-size');\n            const fontFamilyStyleProp = this.getStyle('font-family');\n            const font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? \"\".concat(fontSizeStyleProp.getPixels(true), \"px\") : '', fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));\n            fontStyleStyleProp.setValue(font.fontStyle);\n            fontVariantStyleProp.setValue(font.fontVariant);\n            fontWeightStyleProp.setValue(font.fontWeight);\n            fontSizeStyleProp.setValue(font.fontSize);\n            fontFamilyStyleProp.setValue(font.fontFamily);\n            ctx.font = font.toString();\n            if (fontSizeStyleProp.isPixels()) {\n                this.document.emSize = fontSizeStyleProp.getPixels();\n                this.modifiedEmSizeStack = true;\n            }\n        }\n        if (!fromMeasure) {\n            // effects\n            this.applyEffects(ctx);\n            // opacity\n            ctx.globalAlpha = this.calculateOpacity();\n        }\n    }\n    clearContext(ctx) {\n        super.clearContext(ctx);\n        if (this.modifiedEmSizeStack) {\n            this.document.popEmSize();\n        }\n    }\n    constructor(...args){\n        super(...args);\n        this.modifiedEmSizeStack = false;\n    }\n}\n\nclass TextElement extends RenderedElement {\n    setContext(ctx) {\n        let fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        super.setContext(ctx, fromMeasure);\n        const textBaseline = this.getStyle('dominant-baseline').getTextBaseline() || this.getStyle('alignment-baseline').getTextBaseline();\n        if (textBaseline) {\n            ctx.textBaseline = textBaseline;\n        }\n    }\n    initializeCoordinates() {\n        this.x = 0;\n        this.y = 0;\n        this.leafTexts = [];\n        this.textChunkStart = 0;\n        this.minX = Number.POSITIVE_INFINITY;\n        this.maxX = Number.NEGATIVE_INFINITY;\n    }\n    getBoundingBox(ctx) {\n        if (this.type !== 'text') {\n            return this.getTElementBoundingBox(ctx);\n        }\n        // first, calculate child positions\n        this.initializeCoordinates();\n        this.adjustChildCoordinatesRecursive(ctx);\n        let boundingBox = null;\n        // then calculate bounding box\n        this.children.forEach((_, i)=>{\n            const childBoundingBox = this.getChildBoundingBox(ctx, this, this, i);\n            if (!boundingBox) {\n                boundingBox = childBoundingBox;\n            } else {\n                boundingBox.addBoundingBox(childBoundingBox);\n            }\n        });\n        return boundingBox;\n    }\n    getFontSize() {\n        const { document , parent  } = this;\n        const inheritFontSize = Font.parse(document.ctx.font).fontSize;\n        const fontSize = parent.getStyle('font-size').getNumber(inheritFontSize);\n        return fontSize;\n    }\n    getTElementBoundingBox(ctx) {\n        const fontSize = this.getFontSize();\n        return new BoundingBox(this.x, this.y - fontSize, this.x + this.measureText(ctx), this.y);\n    }\n    getGlyph(font, text, i) {\n        const char = text[i];\n        let glyph;\n        if (font.isArabic) {\n            var ref;\n            const len = text.length;\n            const prevChar = text[i - 1];\n            const nextChar = text[i + 1];\n            let arabicForm = 'isolated';\n            if ((i === 0 || prevChar === ' ') && i < len - 1 && nextChar !== ' ') {\n                arabicForm = 'terminal';\n            }\n            if (i > 0 && prevChar !== ' ' && i < len - 1 && nextChar !== ' ') {\n                arabicForm = 'medial';\n            }\n            if (i > 0 && prevChar !== ' ' && (i === len - 1 || nextChar === ' ')) {\n                arabicForm = 'initial';\n            }\n            glyph = ((ref = font.arabicGlyphs.get(char)) === null || ref === void 0 ? void 0 : ref.get(arabicForm)) || font.glyphs.get(char);\n        } else {\n            glyph = font.glyphs.get(char);\n        }\n        if (!glyph) {\n            glyph = font.missingGlyph;\n        }\n        return glyph;\n    }\n    getText() {\n        return '';\n    }\n    getTextFromNode(node) {\n        const textNode = node || this.node;\n        const childNodes = Array.from(textNode.parentNode.childNodes);\n        const index = childNodes.indexOf(textNode);\n        const lastIndex = childNodes.length - 1;\n        let text = compressSpaces(// textNode.value\n        // || textNode.text\n        textNode.textContent || '');\n        if (index === 0) {\n            text = trimLeft(text);\n        }\n        if (index === lastIndex) {\n            text = trimRight(text);\n        }\n        return text;\n    }\n    renderChildren(ctx) {\n        if (this.type !== 'text') {\n            this.renderTElementChildren(ctx);\n            return;\n        }\n        // first, calculate child positions\n        this.initializeCoordinates();\n        this.adjustChildCoordinatesRecursive(ctx);\n        // then render\n        this.children.forEach((_, i)=>{\n            this.renderChild(ctx, this, this, i);\n        });\n        const { mouse  } = this.document.screen;\n        // Do not calc bounding box if mouse is not working.\n        if (mouse.isWorking()) {\n            mouse.checkBoundingBox(this, this.getBoundingBox(ctx));\n        }\n    }\n    renderTElementChildren(ctx) {\n        const { document , parent  } = this;\n        const renderText = this.getText();\n        const customFont = parent.getStyle('font-family').getDefinition();\n        if (customFont) {\n            const { unitsPerEm  } = customFont.fontFace;\n            const ctxFont = Font.parse(document.ctx.font);\n            const fontSize = parent.getStyle('font-size').getNumber(ctxFont.fontSize);\n            const fontStyle = parent.getStyle('font-style').getString(ctxFont.fontStyle);\n            const scale = fontSize / unitsPerEm;\n            const text = customFont.isRTL ? renderText.split('').reverse().join('') : renderText;\n            const dx = toNumbers(parent.getAttribute('dx').getString());\n            const len = text.length;\n            for(let i = 0; i < len; i++){\n                const glyph = this.getGlyph(customFont, text, i);\n                ctx.translate(this.x, this.y);\n                ctx.scale(scale, -scale);\n                const lw = ctx.lineWidth;\n                ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize;\n                if (fontStyle === 'italic') {\n                    ctx.transform(1, 0, 0.4, 1, 0, 0);\n                }\n                glyph.render(ctx);\n                if (fontStyle === 'italic') {\n                    ctx.transform(1, 0, -0.4, 1, 0, 0);\n                }\n                ctx.lineWidth = lw;\n                ctx.scale(1 / scale, -1 / scale);\n                ctx.translate(-this.x, -this.y);\n                this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;\n                if (typeof dx[i] !== 'undefined' && !isNaN(dx[i])) {\n                    this.x += dx[i];\n                }\n            }\n            return;\n        }\n        const { x , y  } = this;\n        // NEED TEST\n        // if (ctx.paintOrder === 'stroke') {\n        //   if (ctx.strokeStyle) {\n        //     ctx.strokeText(renderText, x, y);\n        //   }\n        //   if (ctx.fillStyle) {\n        //     ctx.fillText(renderText, x, y);\n        //   }\n        // } else {\n        if (ctx.fillStyle) {\n            ctx.fillText(renderText, x, y);\n        }\n        if (ctx.strokeStyle) {\n            ctx.strokeText(renderText, x, y);\n        }\n    // }\n    }\n    applyAnchoring() {\n        if (this.textChunkStart >= this.leafTexts.length) {\n            return;\n        }\n        // This is basically the \"Apply anchoring\" part of https://www.w3.org/TR/SVG2/text.html#TextLayoutAlgorithm.\n        // The difference is that we apply the anchoring as soon as a chunk is finished. This saves some extra looping.\n        // Vertical text is not supported.\n        const firstElement = this.leafTexts[this.textChunkStart];\n        const textAnchor = firstElement.getStyle('text-anchor').getString('start');\n        const isRTL = false // we treat RTL like LTR\n        ;\n        let shift = 0;\n        if (textAnchor === 'start' && !isRTL || textAnchor === 'end' && isRTL) {\n            shift = firstElement.x - this.minX;\n        } else if (textAnchor === 'end' && !isRTL || textAnchor === 'start' && isRTL) {\n            shift = firstElement.x - this.maxX;\n        } else {\n            shift = firstElement.x - (this.minX + this.maxX) / 2;\n        }\n        for(let i = this.textChunkStart; i < this.leafTexts.length; i++){\n            this.leafTexts[i].x += shift;\n        }\n        // start new chunk\n        this.minX = Number.POSITIVE_INFINITY;\n        this.maxX = Number.NEGATIVE_INFINITY;\n        this.textChunkStart = this.leafTexts.length;\n    }\n    adjustChildCoordinatesRecursive(ctx) {\n        this.children.forEach((_, i)=>{\n            this.adjustChildCoordinatesRecursiveCore(ctx, this, this, i);\n        });\n        this.applyAnchoring();\n    }\n    adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i1) {\n        const child = parent.children[i1];\n        if (child.children.length > 0) {\n            child.children.forEach((_, i)=>{\n                textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i);\n            });\n        } else {\n            // only leafs are relevant\n            this.adjustChildCoordinates(ctx, textParent, parent, i1);\n        }\n    }\n    adjustChildCoordinates(ctx, textParent, parent, i) {\n        const child = parent.children[i];\n        if (typeof child.measureText !== 'function') {\n            return child;\n        }\n        ctx.save();\n        child.setContext(ctx, true);\n        const xAttr = child.getAttribute('x');\n        const yAttr = child.getAttribute('y');\n        const dxAttr = child.getAttribute('dx');\n        const dyAttr = child.getAttribute('dy');\n        const customFont = child.getStyle('font-family').getDefinition();\n        const isRTL = Boolean(customFont === null || customFont === void 0 ? void 0 : customFont.isRTL);\n        if (i === 0) {\n            // First children inherit attributes from parent(s). Positional attributes\n            // are only inherited from a parent to it's first child.\n            if (!xAttr.hasValue()) {\n                xAttr.setValue(child.getInheritedAttribute('x'));\n            }\n            if (!yAttr.hasValue()) {\n                yAttr.setValue(child.getInheritedAttribute('y'));\n            }\n            if (!dxAttr.hasValue()) {\n                dxAttr.setValue(child.getInheritedAttribute('dx'));\n            }\n            if (!dyAttr.hasValue()) {\n                dyAttr.setValue(child.getInheritedAttribute('dy'));\n            }\n        }\n        const width = child.measureText(ctx);\n        if (isRTL) {\n            textParent.x -= width;\n        }\n        if (xAttr.hasValue()) {\n            // an \"x\" attribute marks the start of a new chunk\n            textParent.applyAnchoring();\n            child.x = xAttr.getPixels('x');\n            if (dxAttr.hasValue()) {\n                child.x += dxAttr.getPixels('x');\n            }\n        } else {\n            if (dxAttr.hasValue()) {\n                textParent.x += dxAttr.getPixels('x');\n            }\n            child.x = textParent.x;\n        }\n        textParent.x = child.x;\n        if (!isRTL) {\n            textParent.x += width;\n        }\n        if (yAttr.hasValue()) {\n            child.y = yAttr.getPixels('y');\n            if (dyAttr.hasValue()) {\n                child.y += dyAttr.getPixels('y');\n            }\n        } else {\n            if (dyAttr.hasValue()) {\n                textParent.y += dyAttr.getPixels('y');\n            }\n            child.y = textParent.y;\n        }\n        textParent.y = child.y;\n        // update the current chunk and it's bounds\n        textParent.leafTexts.push(child);\n        textParent.minX = Math.min(textParent.minX, child.x, child.x + width);\n        textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);\n        child.clearContext(ctx);\n        ctx.restore();\n        return child;\n    }\n    getChildBoundingBox(ctx, textParent, parent, i2) {\n        const child = parent.children[i2];\n        // not a text node?\n        if (typeof child.getBoundingBox !== 'function') {\n            return null;\n        }\n        const boundingBox = child.getBoundingBox(ctx);\n        if (boundingBox) {\n            child.children.forEach((_, i)=>{\n                const childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i);\n                boundingBox.addBoundingBox(childBoundingBox);\n            });\n        }\n        return boundingBox;\n    }\n    renderChild(ctx, textParent, parent, i3) {\n        const child = parent.children[i3];\n        child.render(ctx);\n        child.children.forEach((_, i)=>{\n            textParent.renderChild(ctx, textParent, child, i);\n        });\n    }\n    measureText(ctx) {\n        const { measureCache  } = this;\n        if (~measureCache) {\n            return measureCache;\n        }\n        const renderText = this.getText();\n        const measure = this.measureTargetText(ctx, renderText);\n        this.measureCache = measure;\n        return measure;\n    }\n    measureTargetText(ctx, targetText) {\n        if (!targetText.length) {\n            return 0;\n        }\n        const { parent  } = this;\n        const customFont = parent.getStyle('font-family').getDefinition();\n        if (customFont) {\n            const fontSize = this.getFontSize();\n            const text = customFont.isRTL ? targetText.split('').reverse().join('') : targetText;\n            const dx = toNumbers(parent.getAttribute('dx').getString());\n            const len = text.length;\n            let measure = 0;\n            for(let i = 0; i < len; i++){\n                const glyph = this.getGlyph(customFont, text, i);\n                measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;\n                if (typeof dx[i] !== 'undefined' && !isNaN(dx[i])) {\n                    measure += dx[i];\n                }\n            }\n            return measure;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!ctx.measureText) {\n            return targetText.length * 10;\n        }\n        ctx.save();\n        this.setContext(ctx, true);\n        const { width: measure  } = ctx.measureText(targetText);\n        this.clearContext(ctx);\n        ctx.restore();\n        return measure;\n    }\n    /**\n   * Inherits positional attributes from {@link TextElement} parent(s). Attributes\n   * are only inherited from a parent to its first child.\n   * @param name - The attribute name.\n   * @returns The attribute value or null.\n   */ getInheritedAttribute(name) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this\n        let current = this;\n        while(current instanceof TextElement && current.isFirstChild() && current.parent){\n            const parentAttr = current.parent.getAttribute(name);\n            if (parentAttr.hasValue(true)) {\n                return parentAttr.getString('0');\n            }\n            current = current.parent;\n        }\n        return null;\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, new.target === TextElement ? true : captureTextNodes);\n        this.type = 'text';\n        this.x = 0;\n        this.y = 0;\n        this.leafTexts = [];\n        this.textChunkStart = 0;\n        this.minX = Number.POSITIVE_INFINITY;\n        this.maxX = Number.NEGATIVE_INFINITY;\n        this.measureCache = -1;\n    }\n}\n\nclass TSpanElement extends TextElement {\n    getText() {\n        return this.text;\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, new.target === TSpanElement ? true : captureTextNodes);\n        this.type = 'tspan';\n        // if this node has children, then they own the text\n        this.text = this.children.length > 0 ? '' : this.getTextFromNode();\n    }\n}\n\nclass TextNode extends TSpanElement {\n    constructor(...args){\n        super(...args);\n        this.type = 'textNode';\n    }\n}\n\nclass PathParser extends svg_pathdata__WEBPACK_IMPORTED_MODULE_2__.SVGPathData {\n    reset() {\n        this.i = -1;\n        this.command = null;\n        this.previousCommand = null;\n        this.start = new Point(0, 0);\n        this.control = new Point(0, 0);\n        this.current = new Point(0, 0);\n        this.points = [];\n        this.angles = [];\n    }\n    isEnd() {\n        const { i , commands  } = this;\n        return i >= commands.length - 1;\n    }\n    next() {\n        const command = this.commands[++this.i];\n        this.previousCommand = this.command;\n        this.command = command;\n        return command;\n    }\n    getPoint() {\n        let xProp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'x', yProp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'y';\n        const point = new Point(this.command[xProp], this.command[yProp]);\n        return this.makeAbsolute(point);\n    }\n    getAsControlPoint(xProp, yProp) {\n        const point = this.getPoint(xProp, yProp);\n        this.control = point;\n        return point;\n    }\n    getAsCurrentPoint(xProp, yProp) {\n        const point = this.getPoint(xProp, yProp);\n        this.current = point;\n        return point;\n    }\n    getReflectedControlPoint() {\n        const previousCommand = this.previousCommand.type;\n        if (previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_2__.SVGPathData.CURVE_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_2__.SVGPathData.SMOOTH_CURVE_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_2__.SVGPathData.QUAD_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_2__.SVGPathData.SMOOTH_QUAD_TO) {\n            return this.current;\n        }\n        // reflect point\n        const { current: { x: cx , y: cy  } , control: { x: ox , y: oy  }  } = this;\n        const point = new Point(2 * cx - ox, 2 * cy - oy);\n        return point;\n    }\n    makeAbsolute(point) {\n        if (this.command.relative) {\n            const { x , y  } = this.current;\n            point.x += x;\n            point.y += y;\n        }\n        return point;\n    }\n    addMarker(point, from, priorTo) {\n        const { points , angles  } = this;\n        // if the last angle isn't filled in because we didn't have this point yet ...\n        if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {\n            angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);\n        }\n        this.addMarkerAngle(point, from ? from.angleTo(point) : null);\n    }\n    addMarkerAngle(point, angle) {\n        this.points.push(point);\n        this.angles.push(angle);\n    }\n    getMarkerPoints() {\n        return this.points;\n    }\n    getMarkerAngles() {\n        const { angles  } = this;\n        const len = angles.length;\n        for(let i = 0; i < len; i++){\n            if (!angles[i]) {\n                for(let j = i + 1; j < len; j++){\n                    if (angles[j]) {\n                        angles[i] = angles[j];\n                        break;\n                    }\n                }\n            }\n        }\n        return angles;\n    }\n    constructor(path){\n        super(path// Fix spaces after signs.\n        .replace(/([+\\-.])\\s+/gm, '$1')// Remove invalid part.\n        .replace(/[^MmZzLlHhVvCcSsQqTtAae\\d\\s.,+-].*/g, ''));\n        this.control = new Point(0, 0);\n        this.start = new Point(0, 0);\n        this.current = new Point(0, 0);\n        this.command = null;\n        this.commands = this.commands;\n        this.i = -1;\n        this.previousCommand = null;\n        this.points = [];\n        this.angles = [];\n    }\n}\n\nclass PathElement extends RenderedElement {\n    path(ctx) {\n        const { pathParser  } = this;\n        const boundingBox = new BoundingBox();\n        pathParser.reset();\n        if (ctx) {\n            ctx.beginPath();\n        }\n        while(!pathParser.isEnd()){\n            switch(pathParser.next().type){\n                case PathParser.MOVE_TO:\n                    this.pathM(ctx, boundingBox);\n                    break;\n                case PathParser.LINE_TO:\n                    this.pathL(ctx, boundingBox);\n                    break;\n                case PathParser.HORIZ_LINE_TO:\n                    this.pathH(ctx, boundingBox);\n                    break;\n                case PathParser.VERT_LINE_TO:\n                    this.pathV(ctx, boundingBox);\n                    break;\n                case PathParser.CURVE_TO:\n                    this.pathC(ctx, boundingBox);\n                    break;\n                case PathParser.SMOOTH_CURVE_TO:\n                    this.pathS(ctx, boundingBox);\n                    break;\n                case PathParser.QUAD_TO:\n                    this.pathQ(ctx, boundingBox);\n                    break;\n                case PathParser.SMOOTH_QUAD_TO:\n                    this.pathT(ctx, boundingBox);\n                    break;\n                case PathParser.ARC:\n                    this.pathA(ctx, boundingBox);\n                    break;\n                case PathParser.CLOSE_PATH:\n                    this.pathZ(ctx, boundingBox);\n                    break;\n            }\n        }\n        return boundingBox;\n    }\n    getBoundingBox(_ctx) {\n        return this.path();\n    }\n    getMarkers() {\n        const { pathParser  } = this;\n        const points = pathParser.getMarkerPoints();\n        const angles = pathParser.getMarkerAngles();\n        const markers = points.map((point, i)=>[\n                point,\n                angles[i]\n            ]\n        );\n        return markers;\n    }\n    renderChildren(ctx) {\n        this.path(ctx);\n        this.document.screen.mouse.checkPath(this, ctx);\n        const fillRuleStyleProp = this.getStyle('fill-rule');\n        if (ctx.fillStyle !== '') {\n            if (fillRuleStyleProp.getString('inherit') !== 'inherit') {\n                ctx.fill(fillRuleStyleProp.getString());\n            } else {\n                ctx.fill();\n            }\n        }\n        if (ctx.strokeStyle !== '') {\n            if (this.getAttribute('vector-effect').getString() === 'non-scaling-stroke') {\n                ctx.save();\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.stroke();\n                ctx.restore();\n            } else {\n                ctx.stroke();\n            }\n        }\n        const markers = this.getMarkers();\n        if (markers) {\n            const markersLastIndex = markers.length - 1;\n            const markerStartStyleProp = this.getStyle('marker-start');\n            const markerMidStyleProp = this.getStyle('marker-mid');\n            const markerEndStyleProp = this.getStyle('marker-end');\n            if (markerStartStyleProp.isUrlDefinition()) {\n                const marker = markerStartStyleProp.getDefinition();\n                const [point, angle] = markers[0];\n                marker.render(ctx, point, angle);\n            }\n            if (markerMidStyleProp.isUrlDefinition()) {\n                const marker = markerMidStyleProp.getDefinition();\n                for(let i = 1; i < markersLastIndex; i++){\n                    const [point, angle] = markers[i];\n                    marker.render(ctx, point, angle);\n                }\n            }\n            if (markerEndStyleProp.isUrlDefinition()) {\n                const marker = markerEndStyleProp.getDefinition();\n                const [point, angle] = markers[markersLastIndex];\n                marker.render(ctx, point, angle);\n            }\n        }\n    }\n    static pathM(pathParser) {\n        const point = pathParser.getAsCurrentPoint();\n        pathParser.start = pathParser.current;\n        return {\n            point\n        };\n    }\n    pathM(ctx, boundingBox) {\n        const { pathParser  } = this;\n        const { point  } = PathElement.pathM(pathParser);\n        const { x , y  } = point;\n        pathParser.addMarker(point);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.moveTo(x, y);\n        }\n    }\n    static pathL(pathParser) {\n        const { current  } = pathParser;\n        const point = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point\n        };\n    }\n    pathL(ctx, boundingBox) {\n        const { pathParser  } = this;\n        const { current , point  } = PathElement.pathL(pathParser);\n        const { x , y  } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathH(pathParser) {\n        const { current , command  } = pathParser;\n        const point = new Point((command.relative ? current.x : 0) + command.x, current.y);\n        pathParser.current = point;\n        return {\n            current,\n            point\n        };\n    }\n    pathH(ctx, boundingBox) {\n        const { pathParser  } = this;\n        const { current , point  } = PathElement.pathH(pathParser);\n        const { x , y  } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathV(pathParser) {\n        const { current , command  } = pathParser;\n        const point = new Point(current.x, (command.relative ? current.y : 0) + command.y);\n        pathParser.current = point;\n        return {\n            current,\n            point\n        };\n    }\n    pathV(ctx, boundingBox) {\n        const { pathParser  } = this;\n        const { current , point  } = PathElement.pathV(pathParser);\n        const { x , y  } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathC(pathParser) {\n        const { current  } = pathParser;\n        const point = pathParser.getPoint('x1', 'y1');\n        const controlPoint = pathParser.getAsControlPoint('x2', 'y2');\n        const currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathC(ctx, boundingBox) {\n        const { pathParser  } = this;\n        const { current , point , controlPoint , currentPoint  } = PathElement.pathC(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, point);\n        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathS(pathParser) {\n        const { current  } = pathParser;\n        const point = pathParser.getReflectedControlPoint();\n        const controlPoint = pathParser.getAsControlPoint('x2', 'y2');\n        const currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathS(ctx, boundingBox) {\n        const { pathParser  } = this;\n        const { current , point , controlPoint , currentPoint  } = PathElement.pathS(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, point);\n        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathQ(pathParser) {\n        const { current  } = pathParser;\n        const controlPoint = pathParser.getAsControlPoint('x1', 'y1');\n        const currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathQ(ctx, boundingBox) {\n        const { pathParser  } = this;\n        const { current , controlPoint , currentPoint  } = PathElement.pathQ(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathT(pathParser) {\n        const { current  } = pathParser;\n        const controlPoint = pathParser.getReflectedControlPoint();\n        pathParser.control = controlPoint;\n        const currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathT(ctx, boundingBox) {\n        const { pathParser  } = this;\n        const { current , controlPoint , currentPoint  } = PathElement.pathT(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathA(pathParser) {\n        const { current , command  } = pathParser;\n        let { rX , rY , xRot , lArcFlag , sweepFlag  } = command;\n        const xAxisRotation = xRot * (Math.PI / 180);\n        const currentPoint = pathParser.getAsCurrentPoint();\n        // Conversion from endpoint to center parameterization\n        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n        // x1', y1'\n        const currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2);\n        // adjust radii\n        const l = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);\n        if (l > 1) {\n            rX *= Math.sqrt(l);\n            rY *= Math.sqrt(l);\n        }\n        // cx', cy'\n        let s = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));\n        if (isNaN(s)) {\n            s = 0;\n        }\n        const cpp = new Point(s * rX * currp.y / rY, s * -rY * currp.x / rX);\n        // cx, cy\n        const centp = new Point((current.x + currentPoint.x) / 2 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y);\n        // initial angle\n        const a1 = vectorsAngle([\n            1,\n            0\n        ], [\n            (currp.x - cpp.x) / rX,\n            (currp.y - cpp.y) / rY\n        ]) // 1\n        ;\n        // angle delta\n        const u = [\n            (currp.x - cpp.x) / rX,\n            (currp.y - cpp.y) / rY\n        ];\n        const v = [\n            (-currp.x - cpp.x) / rX,\n            (-currp.y - cpp.y) / rY\n        ];\n        let ad = vectorsAngle(u, v) // \n        ;\n        if (vectorsRatio(u, v) <= -1) {\n            ad = Math.PI;\n        }\n        if (vectorsRatio(u, v) >= 1) {\n            ad = 0;\n        }\n        return {\n            currentPoint,\n            rX,\n            rY,\n            sweepFlag,\n            xAxisRotation,\n            centp,\n            a1,\n            ad\n        };\n    }\n    pathA(ctx, boundingBox) {\n        const { pathParser  } = this;\n        const { currentPoint , rX , rY , sweepFlag , xAxisRotation , centp , a1 , ad  } = PathElement.pathA(pathParser);\n        // for markers\n        const dir = 1 - sweepFlag ? 1 : -1;\n        const ah = a1 + dir * (ad / 2);\n        const halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));\n        pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);\n        pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);\n        boundingBox.addPoint(currentPoint.x, currentPoint.y) // TODO: this is too naive, make it better\n        ;\n        if (ctx && !isNaN(a1) && !isNaN(ad)) {\n            const r = rX > rY ? rX : rY;\n            const sx = rX > rY ? 1 : rX / rY;\n            const sy = rX > rY ? rY / rX : 1;\n            ctx.translate(centp.x, centp.y);\n            ctx.rotate(xAxisRotation);\n            ctx.scale(sx, sy);\n            ctx.arc(0, 0, r, a1, a1 + ad, Boolean(1 - sweepFlag));\n            ctx.scale(1 / sx, 1 / sy);\n            ctx.rotate(-xAxisRotation);\n            ctx.translate(-centp.x, -centp.y);\n        }\n    }\n    static pathZ(pathParser) {\n        pathParser.current = pathParser.start;\n    }\n    pathZ(ctx, boundingBox) {\n        PathElement.pathZ(this.pathParser);\n        if (ctx) {\n            // only close path if it is not a straight line\n            if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {\n                ctx.closePath();\n            }\n        }\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'path';\n        this.pathParser = new PathParser(this.getAttribute('d').getString());\n    }\n}\n\nclass SVGElement extends RenderedElement {\n    setContext(ctx) {\n        var ref;\n        const { document  } = this;\n        const { screen , window  } = document;\n        const canvas = ctx.canvas;\n        screen.setDefaults(ctx);\n        if ('style' in canvas && typeof ctx.font !== 'undefined' && window && typeof window.getComputedStyle !== 'undefined') {\n            ctx.font = window.getComputedStyle(canvas).getPropertyValue('font');\n            const fontSizeProp = new Property(document, 'fontSize', Font.parse(ctx.font).fontSize);\n            if (fontSizeProp.hasValue()) {\n                document.rootEmSize = fontSizeProp.getPixels('y');\n                document.emSize = document.rootEmSize;\n            }\n        }\n        // create new view port\n        if (!this.getAttribute('x').hasValue()) {\n            this.getAttribute('x', true).setValue(0);\n        }\n        if (!this.getAttribute('y').hasValue()) {\n            this.getAttribute('y', true).setValue(0);\n        }\n        let { width , height  } = screen.viewPort;\n        if (!this.getStyle('width').hasValue()) {\n            this.getStyle('width', true).setValue('100%');\n        }\n        if (!this.getStyle('height').hasValue()) {\n            this.getStyle('height', true).setValue('100%');\n        }\n        if (!this.getStyle('color').hasValue()) {\n            this.getStyle('color', true).setValue('black');\n        }\n        const refXAttr = this.getAttribute('refX');\n        const refYAttr = this.getAttribute('refY');\n        const viewBoxAttr = this.getAttribute('viewBox');\n        const viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;\n        const clip = !this.root && this.getStyle('overflow').getValue('hidden') !== 'visible';\n        let minX = 0;\n        let minY = 0;\n        let clipX = 0;\n        let clipY = 0;\n        if (viewBox) {\n            minX = viewBox[0];\n            minY = viewBox[1];\n        }\n        if (!this.root) {\n            width = this.getStyle('width').getPixels('x');\n            height = this.getStyle('height').getPixels('y');\n            if (this.type === 'marker') {\n                clipX = minX;\n                clipY = minY;\n                minX = 0;\n                minY = 0;\n            }\n        }\n        screen.viewPort.setCurrent(width, height);\n        // Default value of transform-origin is center only for root SVG elements\n        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform-origin\n        if (this.node // is not temporary SVGElement\n         && (!this.parent || ((ref = this.node.parentNode) === null || ref === void 0 ? void 0 : ref.nodeName) === 'foreignObject') && this.getStyle('transform', false, true).hasValue() && !this.getStyle('transform-origin', false, true).hasValue()) {\n            this.getStyle('transform-origin', true, true).setValue('50% 50%');\n        }\n        super.setContext(ctx);\n        ctx.translate(this.getAttribute('x').getPixels('x'), this.getAttribute('y').getPixels('y'));\n        if (viewBox) {\n            width = viewBox[2];\n            height = viewBox[3];\n        }\n        document.setViewBox({\n            ctx,\n            aspectRatio: this.getAttribute('preserveAspectRatio').getString(),\n            width: screen.viewPort.width,\n            desiredWidth: width,\n            height: screen.viewPort.height,\n            desiredHeight: height,\n            minX,\n            minY,\n            refX: refXAttr.getValue(),\n            refY: refYAttr.getValue(),\n            clip,\n            clipX,\n            clipY\n        });\n        if (viewBox) {\n            screen.viewPort.removeCurrent();\n            screen.viewPort.setCurrent(width, height);\n        }\n    }\n    clearContext(ctx) {\n        super.clearContext(ctx);\n        this.document.screen.viewPort.removeCurrent();\n    }\n    /**\n   * Resize SVG to fit in given size.\n   * @param width\n   * @param height\n   * @param preserveAspectRatio\n   */ resize(width) {\n        let height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width, preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        const widthAttr = this.getAttribute('width', true);\n        const heightAttr = this.getAttribute('height', true);\n        const viewBoxAttr = this.getAttribute('viewBox');\n        const styleAttr = this.getAttribute('style');\n        const originWidth = widthAttr.getNumber(0);\n        const originHeight = heightAttr.getNumber(0);\n        if (preserveAspectRatio) {\n            if (typeof preserveAspectRatio === 'string') {\n                this.getAttribute('preserveAspectRatio', true).setValue(preserveAspectRatio);\n            } else {\n                const preserveAspectRatioAttr = this.getAttribute('preserveAspectRatio');\n                if (preserveAspectRatioAttr.hasValue()) {\n                    preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\\s*(\\S.*\\S)\\s*$/, '$1'));\n                }\n            }\n        }\n        widthAttr.setValue(width);\n        heightAttr.setValue(height);\n        if (!viewBoxAttr.hasValue()) {\n            viewBoxAttr.setValue(\"0 0 \".concat(originWidth || width, \" \").concat(originHeight || height));\n        }\n        if (styleAttr.hasValue()) {\n            const widthStyle = this.getStyle('width');\n            const heightStyle = this.getStyle('height');\n            if (widthStyle.hasValue()) {\n                widthStyle.setValue(\"\".concat(width, \"px\"));\n            }\n            if (heightStyle.hasValue()) {\n                heightStyle.setValue(\"\".concat(height, \"px\"));\n            }\n        }\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'svg';\n        this.root = false;\n    }\n}\n\nclass RectElement extends PathElement {\n    path(ctx) {\n        const x = this.getAttribute('x').getPixels('x');\n        const y = this.getAttribute('y').getPixels('y');\n        const width = this.getStyle('width', false, true).getPixels('x');\n        const height = this.getStyle('height', false, true).getPixels('y');\n        const rxAttr = this.getAttribute('rx');\n        const ryAttr = this.getAttribute('ry');\n        let rx = rxAttr.getPixels('x');\n        let ry = ryAttr.getPixels('y');\n        if (rxAttr.hasValue() && !ryAttr.hasValue()) {\n            ry = rx;\n        }\n        if (ryAttr.hasValue() && !rxAttr.hasValue()) {\n            rx = ry;\n        }\n        rx = Math.min(rx, width / 2);\n        ry = Math.min(ry, height / 2);\n        if (ctx) {\n            const KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n            ctx.beginPath() // always start the path so we don't fill prior paths\n            ;\n            if (height > 0 && width > 0) {\n                ctx.moveTo(x + rx, y);\n                ctx.lineTo(x + width - rx, y);\n                ctx.bezierCurveTo(x + width - rx + KAPPA * rx, y, x + width, y + ry - KAPPA * ry, x + width, y + ry);\n                ctx.lineTo(x + width, y + height - ry);\n                ctx.bezierCurveTo(x + width, y + height - ry + KAPPA * ry, x + width - rx + KAPPA * rx, y + height, x + width - rx, y + height);\n                ctx.lineTo(x + rx, y + height);\n                ctx.bezierCurveTo(x + rx - KAPPA * rx, y + height, x, y + height - ry + KAPPA * ry, x, y + height - ry);\n                ctx.lineTo(x, y + ry);\n                ctx.bezierCurveTo(x, y + ry - KAPPA * ry, x + rx - KAPPA * rx, y, x + rx, y);\n                ctx.closePath();\n            }\n        }\n        return new BoundingBox(x, y, x + width, y + height);\n    }\n    getMarkers() {\n        return null;\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'rect';\n    }\n}\n\nclass CircleElement extends PathElement {\n    path(ctx) {\n        const cx = this.getAttribute('cx').getPixels('x');\n        const cy = this.getAttribute('cy').getPixels('y');\n        const r = this.getAttribute('r').getPixels();\n        if (ctx && r > 0) {\n            ctx.beginPath();\n            ctx.arc(cx, cy, r, 0, Math.PI * 2, false);\n            ctx.closePath();\n        }\n        return new BoundingBox(cx - r, cy - r, cx + r, cy + r);\n    }\n    getMarkers() {\n        return null;\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'circle';\n    }\n}\n\nclass EllipseElement extends PathElement {\n    path(ctx) {\n        const KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n        const rx = this.getAttribute('rx').getPixels('x');\n        const ry = this.getAttribute('ry').getPixels('y');\n        const cx = this.getAttribute('cx').getPixels('x');\n        const cy = this.getAttribute('cy').getPixels('y');\n        if (ctx && rx > 0 && ry > 0) {\n            ctx.beginPath();\n            ctx.moveTo(cx + rx, cy);\n            ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);\n            ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);\n            ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);\n            ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);\n            ctx.closePath();\n        }\n        return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);\n    }\n    getMarkers() {\n        return null;\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'ellipse';\n    }\n}\n\nclass LineElement extends PathElement {\n    getPoints() {\n        return [\n            new Point(this.getAttribute('x1').getPixels('x'), this.getAttribute('y1').getPixels('y')),\n            new Point(this.getAttribute('x2').getPixels('x'), this.getAttribute('y2').getPixels('y'))\n        ];\n    }\n    path(ctx) {\n        const [{ x: x0 , y: y0  }, { x: x1 , y: y1  }] = this.getPoints();\n        if (ctx) {\n            ctx.beginPath();\n            ctx.moveTo(x0, y0);\n            ctx.lineTo(x1, y1);\n        }\n        return new BoundingBox(x0, y0, x1, y1);\n    }\n    getMarkers() {\n        const [p0, p1] = this.getPoints();\n        const a = p0.angleTo(p1);\n        return [\n            [\n                p0,\n                a\n            ],\n            [\n                p1,\n                a\n            ]\n        ];\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'line';\n    }\n}\n\nclass PolylineElement extends PathElement {\n    path(ctx) {\n        const { points  } = this;\n        const [{ x: x0 , y: y0  }] = points;\n        const boundingBox = new BoundingBox(x0, y0);\n        if (ctx) {\n            ctx.beginPath();\n            ctx.moveTo(x0, y0);\n        }\n        points.forEach((param)=>{\n            let { x , y  } = param;\n            boundingBox.addPoint(x, y);\n            if (ctx) {\n                ctx.lineTo(x, y);\n            }\n        });\n        return boundingBox;\n    }\n    getMarkers() {\n        const { points  } = this;\n        const lastIndex = points.length - 1;\n        const markers = [];\n        points.forEach((point, i)=>{\n            if (i === lastIndex) {\n                return;\n            }\n            markers.push([\n                point,\n                point.angleTo(points[i + 1])\n            ]);\n        });\n        if (markers.length > 0) {\n            markers.push([\n                points[points.length - 1],\n                markers[markers.length - 1][1]\n            ]);\n        }\n        return markers;\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'polyline';\n        this.points = [];\n        this.points = Point.parsePath(this.getAttribute('points').getString());\n    }\n}\n\nclass PolygonElement extends PolylineElement {\n    path(ctx) {\n        const boundingBox = super.path(ctx);\n        const [{ x , y  }] = this.points;\n        if (ctx) {\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n        return boundingBox;\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'polygon';\n    }\n}\n\nclass PatternElement extends Element {\n    createPattern(ctx, _, parentOpacityProp) {\n        const width = this.getStyle('width').getPixels('x', true);\n        const height = this.getStyle('height').getPixels('y', true);\n        // render me using a temporary svg element\n        const patternSvg = new SVGElement(this.document, null);\n        patternSvg.attributes.set('viewBox', new Property(this.document, 'viewBox', this.getAttribute('viewBox').getValue()));\n        patternSvg.attributes.set('width', new Property(this.document, 'width', \"\".concat(width, \"px\")));\n        patternSvg.attributes.set('height', new Property(this.document, 'height', \"\".concat(height, \"px\")));\n        patternSvg.attributes.set('transform', new Property(this.document, 'transform', this.getAttribute('patternTransform').getValue()));\n        patternSvg.children = this.children;\n        const patternCanvas = this.document.createCanvas(width, height);\n        const patternCtx = patternCanvas.getContext('2d');\n        const xAttr = this.getAttribute('x');\n        const yAttr = this.getAttribute('y');\n        if (xAttr.hasValue() && yAttr.hasValue()) {\n            patternCtx.translate(xAttr.getPixels('x', true), yAttr.getPixels('y', true));\n        }\n        if (parentOpacityProp.hasValue()) {\n            this.styles.set('fill-opacity', parentOpacityProp);\n        } else {\n            this.styles.delete('fill-opacity');\n        }\n        // render 3x3 grid so when we transform there's no white space on edges\n        for(let x = -1; x <= 1; x++){\n            for(let y = -1; y <= 1; y++){\n                patternCtx.save();\n                patternSvg.attributes.set('x', new Property(this.document, 'x', x * patternCanvas.width));\n                patternSvg.attributes.set('y', new Property(this.document, 'y', y * patternCanvas.height));\n                patternSvg.render(patternCtx);\n                patternCtx.restore();\n            }\n        }\n        const pattern = ctx.createPattern(patternCanvas, 'repeat');\n        return pattern;\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'pattern';\n    }\n}\n\nclass MarkerElement extends Element {\n    render(ctx, point, angle) {\n        if (!point) {\n            return;\n        }\n        const { x , y  } = point;\n        const orient = this.getAttribute('orient').getString('auto');\n        const markerUnits = this.getAttribute('markerUnits').getString('strokeWidth');\n        ctx.translate(x, y);\n        if (orient === 'auto') {\n            ctx.rotate(angle);\n        }\n        if (markerUnits === 'strokeWidth') {\n            ctx.scale(ctx.lineWidth, ctx.lineWidth);\n        }\n        ctx.save();\n        // render me using a temporary svg element\n        const markerSvg = new SVGElement(this.document);\n        markerSvg.type = this.type;\n        markerSvg.attributes.set('viewBox', new Property(this.document, 'viewBox', this.getAttribute('viewBox').getValue()));\n        markerSvg.attributes.set('refX', new Property(this.document, 'refX', this.getAttribute('refX').getValue()));\n        markerSvg.attributes.set('refY', new Property(this.document, 'refY', this.getAttribute('refY').getValue()));\n        markerSvg.attributes.set('width', new Property(this.document, 'width', this.getAttribute('markerWidth').getValue()));\n        markerSvg.attributes.set('height', new Property(this.document, 'height', this.getAttribute('markerHeight').getValue()));\n        markerSvg.attributes.set('overflow', new Property(this.document, 'overflow', this.getAttribute('overflow').getValue()));\n        markerSvg.attributes.set('fill', new Property(this.document, 'fill', this.getAttribute('fill').getColor('black')));\n        markerSvg.attributes.set('stroke', new Property(this.document, 'stroke', this.getAttribute('stroke').getValue('none')));\n        markerSvg.children = this.children;\n        markerSvg.render(ctx);\n        ctx.restore();\n        if (markerUnits === 'strokeWidth') {\n            ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);\n        }\n        if (orient === 'auto') {\n            ctx.rotate(-angle);\n        }\n        ctx.translate(-x, -y);\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'marker';\n    }\n}\n\nclass DefsElement extends Element {\n    render() {\n    // NOOP\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'defs';\n    }\n}\n\nclass GElement extends RenderedElement {\n    getBoundingBox(ctx) {\n        const boundingBox = new BoundingBox();\n        this.children.forEach((child)=>{\n            boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n        });\n        return boundingBox;\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'g';\n    }\n}\n\nclass GradientElement extends Element {\n    getGradientUnits() {\n        return this.getAttribute('gradientUnits').getString('objectBoundingBox');\n    }\n    createGradient(ctx, element, parentOpacityProp) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n        let stopsContainer = this;\n        if (this.getHrefAttribute().hasValue()) {\n            stopsContainer = this.getHrefAttribute().getDefinition();\n            this.inheritStopContainer(stopsContainer);\n        }\n        const { stops  } = stopsContainer;\n        const gradient = this.getGradient(ctx, element);\n        if (!gradient) {\n            return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);\n        }\n        stops.forEach((stop)=>{\n            gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));\n        });\n        if (this.getAttribute('gradientTransform').hasValue()) {\n            // render as transformed pattern on temporary canvas\n            const { document  } = this;\n            const { MAX_VIRTUAL_PIXELS  } = Screen;\n            const { viewPort  } = document.screen;\n            const rootView = viewPort.getRoot();\n            const rect = new RectElement(document);\n            rect.attributes.set('x', new Property(document, 'x', -MAX_VIRTUAL_PIXELS / 3));\n            rect.attributes.set('y', new Property(document, 'y', -MAX_VIRTUAL_PIXELS / 3));\n            rect.attributes.set('width', new Property(document, 'width', MAX_VIRTUAL_PIXELS));\n            rect.attributes.set('height', new Property(document, 'height', MAX_VIRTUAL_PIXELS));\n            const group = new GElement(document);\n            group.attributes.set('transform', new Property(document, 'transform', this.getAttribute('gradientTransform').getValue()));\n            group.children = [\n                rect\n            ];\n            const patternSvg = new SVGElement(document);\n            patternSvg.attributes.set('x', new Property(document, 'x', 0));\n            patternSvg.attributes.set('y', new Property(document, 'y', 0));\n            patternSvg.attributes.set('width', new Property(document, 'width', rootView.width));\n            patternSvg.attributes.set('height', new Property(document, 'height', rootView.height));\n            patternSvg.children = [\n                group\n            ];\n            const patternCanvas = document.createCanvas(rootView.width, rootView.height);\n            const patternCtx = patternCanvas.getContext('2d');\n            patternCtx.fillStyle = gradient;\n            patternSvg.render(patternCtx);\n            return patternCtx.createPattern(patternCanvas, 'no-repeat');\n        }\n        return gradient;\n    }\n    inheritStopContainer(stopsContainer) {\n        this.attributesToInherit.forEach((attributeToInherit)=>{\n            if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {\n                this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());\n            }\n        });\n    }\n    addParentOpacity(parentOpacityProp, color) {\n        if (parentOpacityProp.hasValue()) {\n            const colorProp = new Property(this.document, 'color', color);\n            return colorProp.addOpacity(parentOpacityProp).getColor();\n        }\n        return color;\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.attributesToInherit = [\n            'gradientUnits'\n        ];\n        this.stops = [];\n        const { stops , children  } = this;\n        children.forEach((child)=>{\n            if (child.type === 'stop') {\n                stops.push(child);\n            }\n        });\n    }\n}\n\nclass LinearGradientElement extends GradientElement {\n    getGradient(ctx, element) {\n        const isBoundingBoxUnits = this.getGradientUnits() === 'objectBoundingBox';\n        const boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;\n        if (isBoundingBoxUnits && !boundingBox) {\n            return null;\n        }\n        if (!this.getAttribute('x1').hasValue() && !this.getAttribute('y1').hasValue() && !this.getAttribute('x2').hasValue() && !this.getAttribute('y2').hasValue()) {\n            this.getAttribute('x1', true).setValue(0);\n            this.getAttribute('y1', true).setValue(0);\n            this.getAttribute('x2', true).setValue(1);\n            this.getAttribute('y2', true).setValue(0);\n        }\n        const x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('x1').getNumber() : this.getAttribute('x1').getPixels('x');\n        const y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('y1').getNumber() : this.getAttribute('y1').getPixels('y');\n        const x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('x2').getNumber() : this.getAttribute('x2').getPixels('x');\n        const y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('y2').getNumber() : this.getAttribute('y2').getPixels('y');\n        if (x1 === x2 && y1 === y2) {\n            return null;\n        }\n        return ctx.createLinearGradient(x1, y1, x2, y2);\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'linearGradient';\n        this.attributesToInherit.push('x1', 'y1', 'x2', 'y2');\n    }\n}\n\nclass RadialGradientElement extends GradientElement {\n    getGradient(ctx, element) {\n        const isBoundingBoxUnits = this.getGradientUnits() === 'objectBoundingBox';\n        const boundingBox = element.getBoundingBox(ctx);\n        if (isBoundingBoxUnits && !boundingBox) {\n            return null;\n        }\n        if (!this.getAttribute('cx').hasValue()) {\n            this.getAttribute('cx', true).setValue('50%');\n        }\n        if (!this.getAttribute('cy').hasValue()) {\n            this.getAttribute('cy', true).setValue('50%');\n        }\n        if (!this.getAttribute('r').hasValue()) {\n            this.getAttribute('r', true).setValue('50%');\n        }\n        const cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('cx').getNumber() : this.getAttribute('cx').getPixels('x');\n        const cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('cy').getNumber() : this.getAttribute('cy').getPixels('y');\n        let fx = cx;\n        let fy = cy;\n        if (this.getAttribute('fx').hasValue()) {\n            fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('fx').getNumber() : this.getAttribute('fx').getPixels('x');\n        }\n        if (this.getAttribute('fy').hasValue()) {\n            fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('fy').getNumber() : this.getAttribute('fy').getPixels('y');\n        }\n        const r = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2 * this.getAttribute('r').getNumber() : this.getAttribute('r').getPixels();\n        const fr = this.getAttribute('fr').getPixels();\n        return ctx.createRadialGradient(fx, fy, fr, cx, cy, r);\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'radialGradient';\n        this.attributesToInherit.push('cx', 'cy', 'r', 'fx', 'fy', 'fr');\n    }\n}\n\nclass StopElement extends Element {\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'stop';\n        const offset = Math.max(0, Math.min(1, this.getAttribute('offset').getNumber()));\n        const stopOpacity = this.getStyle('stop-opacity');\n        let stopColor = this.getStyle('stop-color', true);\n        if (stopColor.getString() === '') {\n            stopColor.setValue('#000');\n        }\n        if (stopOpacity.hasValue()) {\n            stopColor = stopColor.addOpacity(stopOpacity);\n        }\n        this.offset = offset;\n        this.color = stopColor.getColor();\n    }\n}\n\nclass AnimateElement extends Element {\n    getProperty() {\n        const attributeType = this.getAttribute('attributeType').getString();\n        const attributeName = this.getAttribute('attributeName').getString();\n        if (attributeType === 'CSS') {\n            return this.parent.getStyle(attributeName, true);\n        }\n        return this.parent.getAttribute(attributeName, true);\n    }\n    calcValue() {\n        const { initialUnits  } = this;\n        const { progress , from , to  } = this.getProgress();\n        // tween value linearly\n        let newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;\n        if (initialUnits === '%') {\n            newValue *= 100 // numValue() returns 0-1 whereas properties are 0-100\n            ;\n        }\n        return \"\".concat(newValue).concat(initialUnits);\n    }\n    update(delta) {\n        const { parent  } = this;\n        const prop = this.getProperty();\n        // set initial value\n        if (!this.initialValue) {\n            this.initialValue = prop.getString();\n            this.initialUnits = prop.getUnits();\n        }\n        // if we're past the end time\n        if (this.duration > this.maxDuration) {\n            const fill = this.getAttribute('fill').getString('remove');\n            // loop for indefinitely repeating animations\n            if (this.getAttribute('repeatCount').getString() === 'indefinite' || this.getAttribute('repeatDur').getString() === 'indefinite') {\n                this.duration = 0;\n            } else if (fill === 'freeze' && !this.frozen) {\n                this.frozen = true;\n                if (parent && prop) {\n                    parent.animationFrozen = true;\n                    parent.animationFrozenValue = prop.getString();\n                }\n            } else if (fill === 'remove' && !this.removed) {\n                this.removed = true;\n                if (parent && prop) {\n                    prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);\n                }\n                return true;\n            }\n            return false;\n        }\n        this.duration += delta;\n        // if we're past the begin time\n        let updated = false;\n        if (this.begin < this.duration) {\n            let newValue = this.calcValue() // tween\n            ;\n            const typeAttr = this.getAttribute('type');\n            if (typeAttr.hasValue()) {\n                // for transform, etc.\n                const type = typeAttr.getString();\n                newValue = \"\".concat(type, \"(\").concat(newValue, \")\");\n            }\n            prop.setValue(newValue);\n            updated = true;\n        }\n        return updated;\n    }\n    getProgress() {\n        const { document , values  } = this;\n        let progress = (this.duration - this.begin) / (this.maxDuration - this.begin);\n        let from;\n        let to;\n        if (values.hasValue()) {\n            const p = progress * (values.getValue().length - 1);\n            const lb = Math.floor(p);\n            const ub = Math.ceil(p);\n            let value;\n            value = values.getValue()[lb];\n            from = new Property(document, 'from', value ? parseFloat(value) : 0);\n            value = values.getValue()[ub];\n            to = new Property(document, 'to', value ? parseFloat(value) : 0);\n            progress = (p - lb) / (ub - lb);\n        } else {\n            from = this.from;\n            to = this.to;\n        }\n        return {\n            progress,\n            from,\n            to\n        };\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'animate';\n        this.duration = 0;\n        this.initialUnits = '';\n        this.removed = false;\n        this.frozen = false;\n        document.screen.animations.push(this);\n        this.begin = this.getAttribute('begin').getMilliseconds();\n        this.maxDuration = this.begin + this.getAttribute('dur').getMilliseconds();\n        this.from = this.getAttribute('from');\n        this.to = this.getAttribute('to');\n        this.values = new Property(document, 'values', null);\n        const valuesAttr = this.getAttribute('values');\n        if (valuesAttr.hasValue()) {\n            this.values.setValue(valuesAttr.getString().split(';'));\n        }\n    }\n}\n\nclass AnimateColorElement extends AnimateElement {\n    calcValue() {\n        const { progress , from , to  } = this.getProgress();\n        const colorFrom = new rgbcolor__WEBPACK_IMPORTED_MODULE_1__(from.getColor());\n        const colorTo = new rgbcolor__WEBPACK_IMPORTED_MODULE_1__(to.getColor());\n        if (colorFrom.ok && colorTo.ok) {\n            // tween color linearly\n            const r = colorFrom.r + (colorTo.r - colorFrom.r) * progress;\n            const g = colorFrom.g + (colorTo.g - colorFrom.g) * progress;\n            const b = colorFrom.b + (colorTo.b - colorFrom.b) * progress;\n            // ? alpha\n            return \"rgb(\".concat(Math.floor(r), \", \").concat(Math.floor(g), \", \").concat(Math.floor(b), \")\");\n        }\n        return this.getAttribute('from').getColor();\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'animateColor';\n    }\n}\n\nclass AnimateTransformElement extends AnimateElement {\n    calcValue() {\n        const { progress , from: from1 , to: to1  } = this.getProgress();\n        // tween value linearly\n        const transformFrom = toNumbers(from1.getString());\n        const transformTo = toNumbers(to1.getString());\n        const newValue = transformFrom.map((from, i)=>{\n            const to = transformTo[i];\n            return from + (to - from) * progress;\n        }).join(' ');\n        return newValue;\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'animateTransform';\n    }\n}\n\nclass FontFaceElement extends Element {\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'font-face';\n        this.ascent = this.getAttribute('ascent').getNumber();\n        this.descent = this.getAttribute('descent').getNumber();\n        this.unitsPerEm = this.getAttribute('units-per-em').getNumber();\n    }\n}\n\nclass GlyphElement extends PathElement {\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'glyph';\n        this.horizAdvX = this.getAttribute('horiz-adv-x').getNumber();\n        this.unicode = this.getAttribute('unicode').getString();\n        this.arabicForm = this.getAttribute('arabic-form').getString();\n    }\n}\n\nclass MissingGlyphElement extends GlyphElement {\n    constructor(...args){\n        super(...args);\n        this.type = 'missing-glyph';\n        this.horizAdvX = 0;\n    }\n}\n\nclass FontElement extends Element {\n    render() {\n    // NO RENDER\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'font';\n        this.isArabic = false;\n        this.glyphs = new Map();\n        this.arabicGlyphs = new Map();\n        this.isRTL = false;\n        this.horizAdvX = this.getAttribute('horiz-adv-x').getNumber();\n        const { definitions  } = document;\n        const { children  } = this;\n        for (const child of children){\n            if (child instanceof FontFaceElement) {\n                this.fontFace = child;\n                const fontFamilyStyle = child.getStyle('font-family');\n                if (fontFamilyStyle.hasValue()) {\n                    definitions.set(fontFamilyStyle.getString(), this);\n                }\n            } else if (child instanceof MissingGlyphElement) {\n                this.missingGlyph = child;\n            } else if (child instanceof GlyphElement) {\n                if (child.arabicForm) {\n                    this.isRTL = true;\n                    this.isArabic = true;\n                    let arabicGlyph = this.arabicGlyphs.get(child.unicode);\n                    if (typeof arabicGlyph === 'undefined') {\n                        arabicGlyph = new Map();\n                        this.arabicGlyphs.set(child.unicode, arabicGlyph);\n                    }\n                    arabicGlyph.set(child.arabicForm, child);\n                } else {\n                    this.glyphs.set(child.unicode, child);\n                }\n            }\n        }\n    }\n}\n\nclass TRefElement extends TextElement {\n    getText() {\n        const element = this.getHrefAttribute().getDefinition();\n        if (element) {\n            const firstChild = element.children[0];\n            if (firstChild) {\n                return firstChild.getText();\n            }\n        }\n        return '';\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'tref';\n    }\n}\n\nclass AElement extends TextElement {\n    getText() {\n        return this.text;\n    }\n    renderChildren(ctx) {\n        if (this.hasText) {\n            // render as text element\n            super.renderChildren(ctx);\n            const { document , x , y  } = this;\n            const { mouse  } = document.screen;\n            const fontSize = new Property(document, 'fontSize', Font.parse(document.ctx.font).fontSize);\n            // Do not calc bounding box if mouse is not working.\n            if (mouse.isWorking()) {\n                mouse.checkBoundingBox(this, new BoundingBox(x, y - fontSize.getPixels('y'), x + this.measureText(ctx), y));\n            }\n        } else if (this.children.length > 0) {\n            // render as temporary group\n            const g = new GElement(this.document);\n            g.children = this.children;\n            g.parent = this;\n            g.render(ctx);\n        }\n    }\n    onClick() {\n        const { window  } = this.document;\n        if (window) {\n            window.open(this.getHrefAttribute().getString());\n        }\n    }\n    onMouseMove() {\n        const ctx = this.document.ctx;\n        ctx.canvas.style.cursor = 'pointer';\n    }\n    constructor(document, node1, captureTextNodes){\n        super(document, node1, captureTextNodes);\n        this.type = 'a';\n        const { childNodes  } = node1;\n        const firstChild = childNodes[0];\n        const hasText = childNodes.length > 0 && Array.from(childNodes).every((node)=>node.nodeType === 3\n        );\n        this.hasText = hasText;\n        this.text = hasText ? this.getTextFromNode(firstChild) : '';\n    }\n}\n\nclass TextPathElement extends TextElement {\n    getText() {\n        return this.text;\n    }\n    path(ctx) {\n        const { dataArray  } = this;\n        if (ctx) {\n            ctx.beginPath();\n        }\n        dataArray.forEach((param)=>{\n            let { type , points  } = param;\n            switch(type){\n                case PathParser.LINE_TO:\n                    if (ctx) {\n                        ctx.lineTo(points[0], points[1]);\n                    }\n                    break;\n                case PathParser.MOVE_TO:\n                    if (ctx) {\n                        ctx.moveTo(points[0], points[1]);\n                    }\n                    break;\n                case PathParser.CURVE_TO:\n                    if (ctx) {\n                        ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);\n                    }\n                    break;\n                case PathParser.QUAD_TO:\n                    if (ctx) {\n                        ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);\n                    }\n                    break;\n                case PathParser.ARC:\n                    {\n                        const [cx, cy, rx, ry, theta, dTheta, psi, fs] = points;\n                        const r = rx > ry ? rx : ry;\n                        const scaleX = rx > ry ? 1 : rx / ry;\n                        const scaleY = rx > ry ? ry / rx : 1;\n                        if (ctx) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, theta + dTheta, Boolean(1 - fs));\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        break;\n                    }\n                case PathParser.CLOSE_PATH:\n                    if (ctx) {\n                        ctx.closePath();\n                    }\n                    break;\n            }\n        });\n    }\n    renderChildren(ctx) {\n        this.setTextData(ctx);\n        ctx.save();\n        const textDecoration = this.parent.getStyle('text-decoration').getString();\n        const fontSize = this.getFontSize();\n        const { glyphInfo  } = this;\n        const fill = ctx.fillStyle;\n        if (textDecoration === 'underline') {\n            ctx.beginPath();\n        }\n        glyphInfo.forEach((glyph, i)=>{\n            const { p0 , p1 , rotation , text: partialText  } = glyph;\n            ctx.save();\n            ctx.translate(p0.x, p0.y);\n            ctx.rotate(rotation);\n            if (ctx.fillStyle) {\n                ctx.fillText(partialText, 0, 0);\n            }\n            if (ctx.strokeStyle) {\n                ctx.strokeText(partialText, 0, 0);\n            }\n            ctx.restore();\n            if (textDecoration === 'underline') {\n                if (i === 0) {\n                    ctx.moveTo(p0.x, p0.y + fontSize / 8);\n                }\n                ctx.lineTo(p1.x, p1.y + fontSize / 5);\n            }\n        // // To assist with debugging visually, uncomment following\n        //\n        // ctx.beginPath();\n        // if (i % 2)\n        //   ctx.strokeStyle = 'red';\n        // else\n        //   ctx.strokeStyle = 'green';\n        // ctx.moveTo(p0.x, p0.y);\n        // ctx.lineTo(p1.x, p1.y);\n        // ctx.stroke();\n        // ctx.closePath();\n        });\n        if (textDecoration === 'underline') {\n            ctx.lineWidth = fontSize / 20;\n            ctx.strokeStyle = fill;\n            ctx.stroke();\n            ctx.closePath();\n        }\n        ctx.restore();\n    }\n    getLetterSpacingAt() {\n        let idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n        return this.letterSpacingCache[idx] || 0;\n    }\n    findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c, charI) {\n        let offset = inputOffset;\n        let glyphWidth = this.measureText(ctx, c);\n        if (c === ' ' && anchor === 'justify' && textFullWidth < fullPathWidth) {\n            glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n        }\n        if (charI > -1) {\n            offset += this.getLetterSpacingAt(charI);\n        }\n        const splineStep = this.textHeight / 20;\n        const p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);\n        const p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);\n        const segment = {\n            p0,\n            p1\n        };\n        const rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;\n        if (dy) {\n            const dyX = Math.cos(Math.PI / 2 + rotation) * dy;\n            const dyY = Math.cos(-rotation) * dy;\n            segment.p0 = {\n                ...p0,\n                x: p0.x + dyX,\n                y: p0.y + dyY\n            };\n            segment.p1 = {\n                ...p1,\n                x: p1.x + dyX,\n                y: p1.y + dyY\n            };\n        }\n        offset += glyphWidth;\n        return {\n            offset,\n            segment,\n            rotation\n        };\n    }\n    measureText(ctx, text) {\n        const { measuresCache  } = this;\n        const targetText = text || this.getText();\n        if (measuresCache.has(targetText)) {\n            return measuresCache.get(targetText);\n        }\n        const measure = this.measureTargetText(ctx, targetText);\n        measuresCache.set(targetText, measure);\n        return measure;\n    }\n    // This method supposes what all custom fonts already loaded.\n    // If some font will be loaded after this method call, <textPath> will not be rendered correctly.\n    // You need to call this method manually to update glyphs cache.\n    setTextData(ctx) {\n        if (this.glyphInfo) {\n            return;\n        }\n        const renderText = this.getText();\n        const chars = renderText.split('');\n        const spacesNumber = renderText.split(' ').length - 1;\n        const dx = this.parent.getAttribute('dx').split().map((_)=>_.getPixels('x')\n        );\n        const dy = this.parent.getAttribute('dy').getPixels('y');\n        const anchor = this.parent.getStyle('text-anchor').getString('start');\n        const thisSpacing = this.getStyle('letter-spacing');\n        const parentSpacing = this.parent.getStyle('letter-spacing');\n        let letterSpacing = 0;\n        if (!thisSpacing.hasValue() || thisSpacing.getValue() === 'inherit') {\n            letterSpacing = parentSpacing.getPixels();\n        } else if (thisSpacing.hasValue()) {\n            if (thisSpacing.getValue() !== 'initial' && thisSpacing.getValue() !== 'unset') {\n                letterSpacing = thisSpacing.getPixels();\n            }\n        }\n        // fill letter-spacing cache\n        const letterSpacingCache = [];\n        const textLen = renderText.length;\n        this.letterSpacingCache = letterSpacingCache;\n        for(let i1 = 0; i1 < textLen; i1++){\n            letterSpacingCache.push(typeof dx[i1] !== 'undefined' ? dx[i1] : letterSpacing);\n        }\n        const dxSum = letterSpacingCache.reduce((acc, cur, i)=>i === 0 ? 0 : acc + cur || 0\n        , 0);\n        const textWidth = this.measureText(ctx);\n        const textFullWidth = Math.max(textWidth + dxSum, 0);\n        this.textWidth = textWidth;\n        this.textHeight = this.getFontSize();\n        this.glyphInfo = [];\n        const fullPathWidth = this.getPathLength();\n        const startOffset = this.getStyle('startOffset').getNumber(0) * fullPathWidth;\n        let offset = 0;\n        if (anchor === 'middle' || anchor === 'center') {\n            offset = -textFullWidth / 2;\n        }\n        if (anchor === 'end' || anchor === 'right') {\n            offset = -textFullWidth;\n        }\n        offset += startOffset;\n        chars.forEach((char, i)=>{\n            // Find such segment what distance between p0 and p1 is approx. width of glyph\n            const { offset: nextOffset , segment , rotation  } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy, char, i);\n            offset = nextOffset;\n            if (!segment.p0 || !segment.p1) {\n                return;\n            }\n            // const width = this.getLineLength(\n            //   segment.p0.x,\n            //   segment.p0.y,\n            //   segment.p1.x,\n            //   segment.p1.y\n            // );\n            // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.\n            // Can foresee having a rough pair table built in that the developer can override as needed.\n            // Or use \"dx\" attribute of the <text> node as a naive replacement\n            // const kern = 0;\n            // placeholder for future implementation\n            // const midpoint = this.getPointOnLine(\n            //   kern + width / 2.0,\n            //   segment.p0.x, segment.p0.y, segment.p1.x, segment.p1.y\n            // );\n            this.glyphInfo.push({\n                // transposeX: midpoint.x,\n                // transposeY: midpoint.y,\n                text: chars[i],\n                p0: segment.p0,\n                p1: segment.p1,\n                rotation\n            });\n        });\n    }\n    parsePathData(path) {\n        this.pathLength = -1 // reset path length\n        ;\n        if (!path) {\n            return [];\n        }\n        const pathCommands = [];\n        const { pathParser  } = path;\n        pathParser.reset();\n        // convert l, H, h, V, and v to L\n        while(!pathParser.isEnd()){\n            const { current  } = pathParser;\n            const startX = current ? current.x : 0;\n            const startY = current ? current.y : 0;\n            const command = pathParser.next();\n            let nextCommandType = command.type;\n            let points = [];\n            switch(command.type){\n                case PathParser.MOVE_TO:\n                    this.pathM(pathParser, points);\n                    break;\n                case PathParser.LINE_TO:\n                    nextCommandType = this.pathL(pathParser, points);\n                    break;\n                case PathParser.HORIZ_LINE_TO:\n                    nextCommandType = this.pathH(pathParser, points);\n                    break;\n                case PathParser.VERT_LINE_TO:\n                    nextCommandType = this.pathV(pathParser, points);\n                    break;\n                case PathParser.CURVE_TO:\n                    this.pathC(pathParser, points);\n                    break;\n                case PathParser.SMOOTH_CURVE_TO:\n                    nextCommandType = this.pathS(pathParser, points);\n                    break;\n                case PathParser.QUAD_TO:\n                    this.pathQ(pathParser, points);\n                    break;\n                case PathParser.SMOOTH_QUAD_TO:\n                    nextCommandType = this.pathT(pathParser, points);\n                    break;\n                case PathParser.ARC:\n                    points = this.pathA(pathParser);\n                    break;\n                case PathParser.CLOSE_PATH:\n                    PathElement.pathZ(pathParser);\n                    break;\n            }\n            if (command.type !== PathParser.CLOSE_PATH) {\n                pathCommands.push({\n                    type: nextCommandType,\n                    points,\n                    start: {\n                        x: startX,\n                        y: startY\n                    },\n                    pathLength: this.calcLength(startX, startY, nextCommandType, points)\n                });\n            } else {\n                pathCommands.push({\n                    type: PathParser.CLOSE_PATH,\n                    points: [],\n                    pathLength: 0\n                });\n            }\n        }\n        return pathCommands;\n    }\n    pathM(pathParser, points) {\n        const { x , y  } = PathElement.pathM(pathParser).point;\n        points.push(x, y);\n    }\n    pathL(pathParser, points) {\n        const { x , y  } = PathElement.pathL(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathH(pathParser, points) {\n        const { x , y  } = PathElement.pathH(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathV(pathParser, points) {\n        const { x , y  } = PathElement.pathV(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathC(pathParser, points) {\n        const { point , controlPoint , currentPoint  } = PathElement.pathC(pathParser);\n        points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    }\n    pathS(pathParser, points) {\n        const { point , controlPoint , currentPoint  } = PathElement.pathS(pathParser);\n        points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        return PathParser.CURVE_TO;\n    }\n    pathQ(pathParser, points) {\n        const { controlPoint , currentPoint  } = PathElement.pathQ(pathParser);\n        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    }\n    pathT(pathParser, points) {\n        const { controlPoint , currentPoint  } = PathElement.pathT(pathParser);\n        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        return PathParser.QUAD_TO;\n    }\n    pathA(pathParser) {\n        let { rX , rY , sweepFlag , xAxisRotation , centp , a1 , ad  } = PathElement.pathA(pathParser);\n        if (sweepFlag === 0 && ad > 0) {\n            ad -= 2 * Math.PI;\n        }\n        if (sweepFlag === 1 && ad < 0) {\n            ad += 2 * Math.PI;\n        }\n        return [\n            centp.x,\n            centp.y,\n            rX,\n            rY,\n            a1,\n            ad,\n            xAxisRotation,\n            sweepFlag\n        ];\n    }\n    calcLength(x, y, commandType, points) {\n        let len = 0;\n        let p1 = null;\n        let p2 = null;\n        let t = 0;\n        switch(commandType){\n            case PathParser.LINE_TO:\n                return this.getLineLength(x, y, points[0], points[1]);\n            case PathParser.CURVE_TO:\n                // Approximates by breaking curve into 100 line segments\n                len = 0;\n                p1 = this.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                for(t = 0.01; t <= 1; t += 0.01){\n                    p2 = this.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    p1 = p2;\n                }\n                return len;\n            case PathParser.QUAD_TO:\n                // Approximates by breaking curve into 100 line segments\n                len = 0;\n                p1 = this.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);\n                for(t = 0.01; t <= 1; t += 0.01){\n                    p2 = this.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    p1 = p2;\n                }\n                return len;\n            case PathParser.ARC:\n                {\n                    // Approximates by breaking curve into line segments\n                    len = 0;\n                    const start = points[4];\n                    // 4 = theta\n                    const dTheta = points[5];\n                    // 5 = dTheta\n                    const end = points[4] + dTheta;\n                    let inc = Math.PI / 180;\n                    // 1 degree resolution\n                    if (Math.abs(start - end) < inc) {\n                        inc = Math.abs(start - end);\n                    }\n                    // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi\n                    p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);\n                    if (dTheta < 0) {\n                        for(t = start - inc; t > end; t -= inc){\n                            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            p1 = p2;\n                        }\n                    } else {\n                        for(t = start + inc; t < end; t += inc){\n                            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            p1 = p2;\n                        }\n                    }\n                    p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    return len;\n                }\n        }\n        return 0;\n    }\n    getPointOnLine(dist, p1x, p1y, p2x, p2y) {\n        let fromX = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : p1x, fromY = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : p1y;\n        const m = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);\n        let run = Math.sqrt(dist * dist / (1 + m * m));\n        if (p2x < p1x) {\n            run *= -1;\n        }\n        let rise = m * run;\n        let pt = null;\n        if (p2x === p1x) {\n            pt = {\n                x: fromX,\n                y: fromY + rise\n            };\n        } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m) {\n            pt = {\n                x: fromX + run,\n                y: fromY + rise\n            };\n        } else {\n            let ix = 0;\n            let iy = 0;\n            const len = this.getLineLength(p1x, p1y, p2x, p2y);\n            if (len < PSEUDO_ZERO) {\n                return null;\n            }\n            let u = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);\n            u /= len * len;\n            ix = p1x + u * (p2x - p1x);\n            iy = p1y + u * (p2y - p1y);\n            const pRise = this.getLineLength(fromX, fromY, ix, iy);\n            const pRun = Math.sqrt(dist * dist - pRise * pRise);\n            run = Math.sqrt(pRun * pRun / (1 + m * m));\n            if (p2x < p1x) {\n                run *= -1;\n            }\n            rise = m * run;\n            pt = {\n                x: ix + run,\n                y: iy + rise\n            };\n        }\n        return pt;\n    }\n    getPointOnPath(distance) {\n        const fullLen = this.getPathLength();\n        let cumulativePathLength = 0;\n        let p = null;\n        if (distance < -0.00005 || distance - 0.00005 > fullLen) {\n            return null;\n        }\n        const { dataArray  } = this;\n        for (const command of dataArray){\n            if (command && (command.pathLength < 0.00005 || cumulativePathLength + command.pathLength + 0.00005 < distance)) {\n                cumulativePathLength += command.pathLength;\n                continue;\n            }\n            const delta = distance - cumulativePathLength;\n            let currentT = 0;\n            switch(command.type){\n                case PathParser.LINE_TO:\n                    p = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);\n                    break;\n                case PathParser.ARC:\n                    {\n                        const start = command.points[4];\n                        // 4 = theta\n                        const dTheta = command.points[5];\n                        // 5 = dTheta\n                        const end = command.points[4] + dTheta;\n                        currentT = start + delta / command.pathLength * dTheta;\n                        if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {\n                            break;\n                        }\n                        p = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);\n                        break;\n                    }\n                case PathParser.CURVE_TO:\n                    currentT = delta / command.pathLength;\n                    if (currentT > 1) {\n                        currentT = 1;\n                    }\n                    p = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);\n                    break;\n                case PathParser.QUAD_TO:\n                    currentT = delta / command.pathLength;\n                    if (currentT > 1) {\n                        currentT = 1;\n                    }\n                    p = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);\n                    break;\n            }\n            if (p) {\n                return p;\n            }\n            break;\n        }\n        return null;\n    }\n    getLineLength(x1, y1, x2, y2) {\n        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    getPathLength() {\n        if (this.pathLength === -1) {\n            this.pathLength = this.dataArray.reduce((length, command)=>command.pathLength > 0 ? length + command.pathLength : length\n            , 0);\n        }\n        return this.pathLength;\n    }\n    getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n        const x = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);\n        const y = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);\n        return {\n            x,\n            y\n        };\n    }\n    getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {\n        const x = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);\n        const y = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);\n        return {\n            x,\n            y\n        };\n    }\n    getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {\n        const cosPsi = Math.cos(psi);\n        const sinPsi = Math.sin(psi);\n        const pt = {\n            x: rx * Math.cos(theta),\n            y: ry * Math.sin(theta)\n        };\n        return {\n            x: cx + (pt.x * cosPsi - pt.y * sinPsi),\n            y: cy + (pt.x * sinPsi + pt.y * cosPsi)\n        };\n    }\n    // TODO need some optimisations. possibly build cache only for curved segments?\n    buildEquidistantCache(inputStep, inputPrecision) {\n        const fullLen = this.getPathLength();\n        const precision = inputPrecision || 0.25 // accuracy vs performance\n        ;\n        const step = inputStep || fullLen / 100;\n        if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {\n            // Prepare cache\n            this.equidistantCache = {\n                step,\n                precision,\n                points: []\n            };\n            // Calculate points\n            let s = 0;\n            for(let l = 0; l <= fullLen; l += precision){\n                const p0 = this.getPointOnPath(l);\n                const p1 = this.getPointOnPath(l + precision);\n                if (!p0 || !p1) {\n                    continue;\n                }\n                s += this.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                if (s >= step) {\n                    this.equidistantCache.points.push({\n                        x: p0.x,\n                        y: p0.y,\n                        distance: l\n                    });\n                    s -= step;\n                }\n            }\n        }\n    }\n    getEquidistantPointOnPath(targetDistance, step, precision) {\n        this.buildEquidistantCache(step, precision);\n        if (targetDistance < 0 || targetDistance - this.getPathLength() > 0.00005) {\n            return null;\n        }\n        const idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));\n        return this.equidistantCache.points[idx] || null;\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'textPath';\n        this.textWidth = 0;\n        this.textHeight = 0;\n        this.pathLength = -1;\n        this.glyphInfo = null;\n        this.letterSpacingCache = [];\n        this.measuresCache = new Map([\n            [\n                '',\n                0\n            ]\n        ]);\n        const pathElement = this.getHrefAttribute().getDefinition();\n        this.text = this.getTextFromNode();\n        this.dataArray = this.parsePathData(pathElement);\n    }\n}\n\n// groups: 1: mime-type (+ charset), 2: mime-type (w/o charset), 3: charset, 4: base64?, 5: body\nconst dataUriRegex = /^\\s*data:(([^/,;]+\\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;\nclass ImageElement extends RenderedElement {\n    async loadImage(href) {\n        try {\n            const image = await this.document.createImage(href);\n            this.image = image;\n        } catch (err) {\n            console.error(\"Error while loading image \\\"\".concat(href, \"\\\":\"), err);\n        }\n        this.loaded = true;\n    }\n    async loadSvg(href) {\n        const match = dataUriRegex.exec(href);\n        if (match) {\n            const data = match[5];\n            if (data) {\n                if (match[4] === 'base64') {\n                    this.image = atob(data);\n                } else {\n                    this.image = decodeURIComponent(data);\n                }\n            }\n        } else {\n            try {\n                const response = await this.document.fetch(href);\n                const svg = await response.text();\n                this.image = svg;\n            } catch (err) {\n                console.error(\"Error while loading image \\\"\".concat(href, \"\\\":\"), err);\n            }\n        }\n        this.loaded = true;\n    }\n    renderChildren(ctx) {\n        const { document , image , loaded  } = this;\n        const x = this.getAttribute('x').getPixels('x');\n        const y = this.getAttribute('y').getPixels('y');\n        const width = this.getStyle('width').getPixels('x');\n        const height = this.getStyle('height').getPixels('y');\n        if (!loaded || !image || !width || !height) {\n            return;\n        }\n        ctx.save();\n        ctx.translate(x, y);\n        if (typeof image === 'string') {\n            const subDocument = document.canvg.forkString(ctx, image, {\n                ignoreMouse: true,\n                ignoreAnimation: true,\n                ignoreDimensions: true,\n                ignoreClear: true,\n                offsetX: 0,\n                offsetY: 0,\n                scaleWidth: width,\n                scaleHeight: height\n            });\n            const { documentElement  } = subDocument.document;\n            if (documentElement) {\n                documentElement.parent = this;\n            }\n            void subDocument.render();\n        } else {\n            document.setViewBox({\n                ctx,\n                aspectRatio: this.getAttribute('preserveAspectRatio').getString(),\n                width,\n                desiredWidth: image.width,\n                height,\n                desiredHeight: image.height\n            });\n            if (this.loaded) {\n                if (!('complete' in image) || image.complete) {\n                    ctx.drawImage(image, 0, 0);\n                }\n            }\n        }\n        ctx.restore();\n    }\n    getBoundingBox() {\n        const x = this.getAttribute('x').getPixels('x');\n        const y = this.getAttribute('y').getPixels('y');\n        const width = this.getStyle('width').getPixels('x');\n        const height = this.getStyle('height').getPixels('y');\n        return new BoundingBox(x, y, x + width, y + height);\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'image';\n        this.loaded = false;\n        const href = this.getHrefAttribute().getString();\n        if (!href) {\n            return;\n        }\n        const isSvg = href.endsWith('.svg') || /^\\s*data:image\\/svg\\+xml/i.test(href);\n        document.images.push(this);\n        if (!isSvg) {\n            void this.loadImage(href);\n        } else {\n            void this.loadSvg(href);\n        }\n    }\n}\n\nclass SymbolElement extends RenderedElement {\n    render(_) {\n    // NO RENDER\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'symbol';\n    }\n}\n\nclass SVGFontLoader {\n    async load(fontFamily, url) {\n        try {\n            const { document  } = this;\n            const svgDocument = await document.canvg.parser.load(url);\n            const fonts = svgDocument.getElementsByTagName('font');\n            Array.from(fonts).forEach((fontNode)=>{\n                const font = document.createElement(fontNode);\n                document.definitions.set(fontFamily, font);\n            });\n        } catch (err) {\n            console.error(\"Error while loading font \\\"\".concat(url, \"\\\":\"), err);\n        }\n        this.loaded = true;\n    }\n    constructor(document){\n        this.document = document;\n        this.loaded = false;\n        document.fonts.push(this);\n    }\n}\n\nclass StyleElement extends Element {\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'style';\n        const css = compressSpaces(Array.from(node.childNodes)// NEED TEST\n        .map((_)=>_.textContent\n        ).join('').replace(/(\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+\\/)|(^[\\s]*\\/\\/.*)/gm, '') // remove comments\n        .replace(/@import.*;/g, '') // remove imports\n        );\n        const cssDefs = css.split('}');\n        cssDefs.forEach((_1)=>{\n            const def = _1.trim();\n            if (!def) {\n                return;\n            }\n            const cssParts = def.split('{');\n            const cssClasses = cssParts[0].split(',');\n            const cssProps = cssParts[1].split(';');\n            cssClasses.forEach((_)=>{\n                const cssClass = _.trim();\n                if (!cssClass) {\n                    return;\n                }\n                const props = document.styles.get(cssClass) || new Map();\n                cssProps.forEach((cssProp)=>{\n                    const prop = cssProp.indexOf(':');\n                    const name = cssProp.substr(0, prop).trim();\n                    const value = cssProp.substr(prop + 1, cssProp.length - prop).trim();\n                    if (name && value) {\n                        props.set(name, new Property(document, name, value));\n                    }\n                });\n                document.styles.set(cssClass, props);\n                document.stylesSpecificity.set(cssClass, getSelectorSpecificity(cssClass));\n                if (cssClass === '@font-face') {\n                    const fontFamily = props.get('font-family').getString().replace(/\"|'/g, '');\n                    const srcs = props.get('src').getString().split(',');\n                    srcs.forEach((src)=>{\n                        if (src.indexOf('format(\"svg\")') > 0) {\n                            const url = parseExternalUrl(src);\n                            if (url) {\n                                void new SVGFontLoader(document).load(fontFamily, url);\n                            }\n                        }\n                    });\n                }\n            });\n        });\n    }\n}\nStyleElement.parseExternalUrl = parseExternalUrl;\n\nclass UseElement extends RenderedElement {\n    setContext(ctx) {\n        super.setContext(ctx);\n        const xAttr = this.getAttribute('x');\n        const yAttr = this.getAttribute('y');\n        if (xAttr.hasValue()) {\n            ctx.translate(xAttr.getPixels('x'), 0);\n        }\n        if (yAttr.hasValue()) {\n            ctx.translate(0, yAttr.getPixels('y'));\n        }\n    }\n    path(ctx) {\n        const { element  } = this;\n        if (element) {\n            element.path(ctx);\n        }\n    }\n    renderChildren(ctx) {\n        const { document , element  } = this;\n        if (element) {\n            let tempSvg = element;\n            if (element.type === 'symbol') {\n                // render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)\n                tempSvg = new SVGElement(document);\n                tempSvg.attributes.set('viewBox', new Property(document, 'viewBox', element.getAttribute('viewBox').getString()));\n                tempSvg.attributes.set('preserveAspectRatio', new Property(document, 'preserveAspectRatio', element.getAttribute('preserveAspectRatio').getString()));\n                tempSvg.attributes.set('overflow', new Property(document, 'overflow', element.getAttribute('overflow').getString()));\n                tempSvg.children = element.children;\n                // element is still the parent of the children\n                element.styles.set('opacity', new Property(document, 'opacity', this.calculateOpacity()));\n            }\n            if (tempSvg.type === 'svg') {\n                const widthStyle = this.getStyle('width', false, true);\n                const heightStyle = this.getStyle('height', false, true);\n                // if symbol or svg, inherit width/height from me\n                if (widthStyle.hasValue()) {\n                    tempSvg.attributes.set('width', new Property(document, 'width', widthStyle.getString()));\n                }\n                if (heightStyle.hasValue()) {\n                    tempSvg.attributes.set('height', new Property(document, 'height', heightStyle.getString()));\n                }\n            }\n            const oldParent = tempSvg.parent;\n            tempSvg.parent = this;\n            tempSvg.render(ctx);\n            tempSvg.parent = oldParent;\n        }\n    }\n    getBoundingBox(ctx) {\n        const { element  } = this;\n        if (element) {\n            return element.getBoundingBox(ctx);\n        }\n        return null;\n    }\n    elementTransform() {\n        const { document , element  } = this;\n        if (!element) {\n            return null;\n        }\n        return Transform.fromElement(document, element);\n    }\n    get element() {\n        if (!this.cachedElement) {\n            this.cachedElement = this.getHrefAttribute().getDefinition();\n        }\n        return this.cachedElement;\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'use';\n    }\n}\n\nfunction imGet(img, x, y, width, _height, rgba) {\n    return img[y * width * 4 + x * 4 + rgba];\n}\nfunction imSet(img, x, y, width, _height, rgba, val) {\n    img[y * width * 4 + x * 4 + rgba] = val;\n}\nfunction m(matrix, i, v) {\n    const mi = matrix[i];\n    return mi * v;\n}\nfunction c(a, m1, m2, m3) {\n    return m1 + Math.cos(a) * m2 + Math.sin(a) * m3;\n}\nclass FeColorMatrixElement extends Element {\n    apply(ctx, _x, _y, width, height) {\n        // assuming x==0 && y==0 for now\n        const { includeOpacity , matrix  } = this;\n        const srcData = ctx.getImageData(0, 0, width, height);\n        for(let y = 0; y < height; y++){\n            for(let x = 0; x < width; x++){\n                const r = imGet(srcData.data, x, y, width, height, 0);\n                const g = imGet(srcData.data, x, y, width, height, 1);\n                const b = imGet(srcData.data, x, y, width, height, 2);\n                const a = imGet(srcData.data, x, y, width, height, 3);\n                let nr = m(matrix, 0, r) + m(matrix, 1, g) + m(matrix, 2, b) + m(matrix, 3, a) + m(matrix, 4, 1);\n                let ng = m(matrix, 5, r) + m(matrix, 6, g) + m(matrix, 7, b) + m(matrix, 8, a) + m(matrix, 9, 1);\n                let nb = m(matrix, 10, r) + m(matrix, 11, g) + m(matrix, 12, b) + m(matrix, 13, a) + m(matrix, 14, 1);\n                let na = m(matrix, 15, r) + m(matrix, 16, g) + m(matrix, 17, b) + m(matrix, 18, a) + m(matrix, 19, 1);\n                if (includeOpacity) {\n                    nr = 0;\n                    ng = 0;\n                    nb = 0;\n                    na *= a / 255;\n                }\n                imSet(srcData.data, x, y, width, height, 0, nr);\n                imSet(srcData.data, x, y, width, height, 1, ng);\n                imSet(srcData.data, x, y, width, height, 2, nb);\n                imSet(srcData.data, x, y, width, height, 3, na);\n            }\n        }\n        ctx.clearRect(0, 0, width, height);\n        ctx.putImageData(srcData, 0, 0);\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'feColorMatrix';\n        let matrix = toNumbers(this.getAttribute('values').getString());\n        switch(this.getAttribute('type').getString('matrix')){\n            case 'saturate':\n                {\n                    const s = matrix[0];\n                    /* eslint-disable array-element-newline */ matrix = [\n                        0.213 + 0.787 * s,\n                        0.715 - 0.715 * s,\n                        0.072 - 0.072 * s,\n                        0,\n                        0,\n                        0.213 - 0.213 * s,\n                        0.715 + 0.285 * s,\n                        0.072 - 0.072 * s,\n                        0,\n                        0,\n                        0.213 - 0.213 * s,\n                        0.715 - 0.715 * s,\n                        0.072 + 0.928 * s,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ];\n                    break;\n                }\n            case 'hueRotate':\n                {\n                    const a = matrix[0] * Math.PI / 180;\n                    /* eslint-disable array-element-newline */ matrix = [\n                        c(a, 0.213, 0.787, -0.213),\n                        c(a, 0.715, -0.715, -0.715),\n                        c(a, 0.072, -0.072, 0.928),\n                        0,\n                        0,\n                        c(a, 0.213, -0.213, 0.143),\n                        c(a, 0.715, 0.285, 0.14),\n                        c(a, 0.072, -0.072, -0.283),\n                        0,\n                        0,\n                        c(a, 0.213, -0.213, -0.787),\n                        c(a, 0.715, -0.715, 0.715),\n                        c(a, 0.072, 0.928, 0.072),\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ];\n                    break;\n                }\n            case 'luminanceToAlpha':\n                /* eslint-disable array-element-newline */ matrix = [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0.2125,\n                    0.7154,\n                    0.0721,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    1\n                ];\n                break;\n        }\n        this.matrix = matrix;\n        this.includeOpacity = this.getAttribute('includeOpacity').hasValue();\n    }\n}\n\nclass MaskElement extends Element {\n    apply(ctx, element) {\n        const { document  } = this;\n        // render as temp svg\n        let x = this.getAttribute('x').getPixels('x');\n        let y = this.getAttribute('y').getPixels('y');\n        let width = this.getStyle('width').getPixels('x');\n        let height = this.getStyle('height').getPixels('y');\n        if (!width && !height) {\n            const boundingBox = new BoundingBox();\n            this.children.forEach((child)=>{\n                boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n            });\n            x = Math.floor(boundingBox.x1);\n            y = Math.floor(boundingBox.y1);\n            width = Math.floor(boundingBox.width);\n            height = Math.floor(boundingBox.height);\n        }\n        const ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);\n        const maskCanvas = document.createCanvas(x + width, y + height);\n        const maskCtx = maskCanvas.getContext('2d');\n        document.screen.setDefaults(maskCtx);\n        this.renderChildren(maskCtx);\n        // convert mask to alpha with a fake node\n        // TODO: refactor out apply from feColorMatrix\n        new FeColorMatrixElement(document, {\n            nodeType: 1,\n            childNodes: [],\n            attributes: [\n                {\n                    nodeName: 'type',\n                    value: 'luminanceToAlpha'\n                },\n                {\n                    nodeName: 'includeOpacity',\n                    value: 'true'\n                }\n            ]\n        }).apply(maskCtx, 0, 0, x + width, y + height);\n        const tmpCanvas = document.createCanvas(x + width, y + height);\n        const tmpCtx = tmpCanvas.getContext('2d');\n        document.screen.setDefaults(tmpCtx);\n        element.render(tmpCtx);\n        tmpCtx.globalCompositeOperation = 'destination-in';\n        tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, 'no-repeat');\n        tmpCtx.fillRect(0, 0, x + width, y + height);\n        ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, 'no-repeat');\n        ctx.fillRect(0, 0, x + width, y + height);\n        // reassign mask\n        this.restoreStyles(element, ignoredStyles);\n    }\n    render(_) {\n    // NO RENDER\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'mask';\n    }\n}\nMaskElement.ignoreStyles = [\n    'mask',\n    'transform',\n    'clip-path'\n];\n\nconst noop = ()=>{\n// NOOP\n};\nclass ClipPathElement extends Element {\n    apply(ctx) {\n        const { document  } = this;\n        const contextProto = Reflect.getPrototypeOf(ctx);\n        const { beginPath , closePath  } = ctx;\n        if (contextProto) {\n            contextProto.beginPath = noop;\n            contextProto.closePath = noop;\n        }\n        Reflect.apply(beginPath, ctx, []);\n        this.children.forEach((child)=>{\n            if (!('path' in child)) {\n                return;\n            }\n            let transform = 'elementTransform' in child ? child.elementTransform() : null // handle <use />\n            ;\n            if (!transform) {\n                transform = Transform.fromElement(document, child);\n            }\n            if (transform) {\n                transform.apply(ctx);\n            }\n            child.path(ctx);\n            if (contextProto) {\n                contextProto.closePath = closePath;\n            }\n            if (transform) {\n                transform.unapply(ctx);\n            }\n        });\n        Reflect.apply(closePath, ctx, []);\n        ctx.clip();\n        if (contextProto) {\n            contextProto.beginPath = beginPath;\n            contextProto.closePath = closePath;\n        }\n    }\n    render(_) {\n    // NO RENDER\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'clipPath';\n    }\n}\n\nclass FilterElement extends Element {\n    apply(ctx, element) {\n        // render as temp svg\n        const { document , children  } = this;\n        const boundingBox = 'getBoundingBox' in element ? element.getBoundingBox(ctx) : null;\n        if (!boundingBox) {\n            return;\n        }\n        let px = 0;\n        let py = 0;\n        children.forEach((child)=>{\n            const efd = child.extraFilterDistance || 0;\n            px = Math.max(px, efd);\n            py = Math.max(py, efd);\n        });\n        const width = Math.floor(boundingBox.width);\n        const height = Math.floor(boundingBox.height);\n        const tmpCanvasWidth = width + 2 * px;\n        const tmpCanvasHeight = height + 2 * py;\n        if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {\n            return;\n        }\n        const x = Math.floor(boundingBox.x);\n        const y = Math.floor(boundingBox.y);\n        const ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);\n        const tmpCanvas = document.createCanvas(tmpCanvasWidth, tmpCanvasHeight);\n        const tmpCtx = tmpCanvas.getContext('2d');\n        document.screen.setDefaults(tmpCtx);\n        tmpCtx.translate(-x + px, -y + py);\n        element.render(tmpCtx);\n        // apply filters\n        children.forEach((child)=>{\n            if (typeof child.apply === 'function') {\n                child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);\n            }\n        });\n        // render on me\n        ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x - px, y - py, tmpCanvasWidth, tmpCanvasHeight);\n        this.restoreStyles(element, ignoredStyles);\n    }\n    render(_) {\n    // NO RENDER\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'filter';\n    }\n}\nFilterElement.ignoreStyles = [\n    'filter',\n    'transform',\n    'clip-path'\n];\n\nclass FeDropShadowElement extends Element {\n    apply(_, _x, _y, _width, _height) {\n    // TODO: implement\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'feDropShadow';\n        this.addStylesFromStyleDefinition();\n    }\n}\n\nclass FeMorphologyElement extends Element {\n    apply(_, _x, _y, _width, _height) {\n    // TODO: implement\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'feMorphology';\n    }\n}\n\nclass FeCompositeElement extends Element {\n    apply(_, _x, _y, _width, _height) {\n    // TODO: implement\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'feComposite';\n    }\n}\n\nclass FeGaussianBlurElement extends Element {\n    apply(ctx, x, y, width, height) {\n        const { document , blurRadius  } = this;\n        const body = document.window ? document.window.document.body : null;\n        const canvas = ctx.canvas;\n        // StackBlur requires canvas be on document\n        canvas.id = document.getUniqueId();\n        if (body) {\n            canvas.style.display = 'none';\n            body.appendChild(canvas);\n        }\n        (0,stackblur_canvas__WEBPACK_IMPORTED_MODULE_3__.canvasRGBA)(canvas, x, y, width, height, blurRadius);\n        if (body) {\n            body.removeChild(canvas);\n        }\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'feGaussianBlur';\n        this.blurRadius = Math.floor(this.getAttribute('stdDeviation').getNumber());\n        this.extraFilterDistance = this.blurRadius;\n    }\n}\n\nclass TitleElement extends Element {\n    constructor(...args){\n        super(...args);\n        this.type = 'title';\n    }\n}\n\nclass DescElement extends Element {\n    constructor(...args){\n        super(...args);\n        this.type = 'desc';\n    }\n}\n\nconst elements = {\n    'svg': SVGElement,\n    'rect': RectElement,\n    'circle': CircleElement,\n    'ellipse': EllipseElement,\n    'line': LineElement,\n    'polyline': PolylineElement,\n    'polygon': PolygonElement,\n    'path': PathElement,\n    'pattern': PatternElement,\n    'marker': MarkerElement,\n    'defs': DefsElement,\n    'linearGradient': LinearGradientElement,\n    'radialGradient': RadialGradientElement,\n    'stop': StopElement,\n    'animate': AnimateElement,\n    'animateColor': AnimateColorElement,\n    'animateTransform': AnimateTransformElement,\n    'font': FontElement,\n    'font-face': FontFaceElement,\n    'missing-glyph': MissingGlyphElement,\n    'glyph': GlyphElement,\n    'text': TextElement,\n    'tspan': TSpanElement,\n    'tref': TRefElement,\n    'a': AElement,\n    'textPath': TextPathElement,\n    'image': ImageElement,\n    'g': GElement,\n    'symbol': SymbolElement,\n    'style': StyleElement,\n    'use': UseElement,\n    'mask': MaskElement,\n    'clipPath': ClipPathElement,\n    'filter': FilterElement,\n    'feDropShadow': FeDropShadowElement,\n    'feMorphology': FeMorphologyElement,\n    'feComposite': FeCompositeElement,\n    'feColorMatrix': FeColorMatrixElement,\n    'feGaussianBlur': FeGaussianBlurElement,\n    'title': TitleElement,\n    'desc': DescElement\n};\n\nfunction createCanvas(width, height) {\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n}\nasync function createImage(src) {\n    let anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    const image = document.createElement('img');\n    if (anonymousCrossOrigin) {\n        image.crossOrigin = 'Anonymous';\n    }\n    return new Promise((resolve, reject)=>{\n        image.onload = ()=>{\n            resolve(image);\n        };\n        image.onerror = (_event, _source, _lineno, _colno, error)=>{\n            reject(error);\n        };\n        image.src = src;\n    });\n}\nconst DEFAULT_EM_SIZE = 12;\nclass Document {\n    bindCreateImage(createImage1, anonymousCrossOrigin) {\n        if (typeof anonymousCrossOrigin === 'boolean') {\n            return (source, forceAnonymousCrossOrigin)=>createImage1(source, typeof forceAnonymousCrossOrigin === 'boolean' ? forceAnonymousCrossOrigin : anonymousCrossOrigin)\n            ;\n        }\n        return createImage1;\n    }\n    get window() {\n        return this.screen.window;\n    }\n    get fetch() {\n        return this.screen.fetch;\n    }\n    get ctx() {\n        return this.screen.ctx;\n    }\n    get emSize() {\n        const { emSizeStack  } = this;\n        return emSizeStack[emSizeStack.length - 1] || DEFAULT_EM_SIZE;\n    }\n    set emSize(value) {\n        const { emSizeStack  } = this;\n        emSizeStack.push(value);\n    }\n    popEmSize() {\n        const { emSizeStack  } = this;\n        emSizeStack.pop();\n    }\n    getUniqueId() {\n        return \"canvg\".concat(++this.uniqueId);\n    }\n    isImagesLoaded() {\n        return this.images.every((_)=>_.loaded\n        );\n    }\n    isFontsLoaded() {\n        return this.fonts.every((_)=>_.loaded\n        );\n    }\n    createDocumentElement(document) {\n        const documentElement = this.createElement(document.documentElement);\n        documentElement.root = true;\n        documentElement.addStylesFromStyleDefinition();\n        this.documentElement = documentElement;\n        return documentElement;\n    }\n    createElement(node) {\n        const elementType = node.nodeName.replace(/^[^:]+:/, '');\n        const ElementType = Document.elementTypes[elementType];\n        if (ElementType) {\n            return new ElementType(this, node);\n        }\n        return new UnknownElement(this, node);\n    }\n    createTextNode(node) {\n        return new TextNode(this, node);\n    }\n    setViewBox(config) {\n        this.screen.setViewBox({\n            document: this,\n            ...config\n        });\n    }\n    constructor(canvg, { rootEmSize =DEFAULT_EM_SIZE , emSize =DEFAULT_EM_SIZE , createCanvas: createCanvas1 = Document.createCanvas , createImage: createImage2 = Document.createImage , anonymousCrossOrigin  } = {}){\n        this.canvg = canvg;\n        this.definitions = new Map();\n        this.styles = new Map();\n        this.stylesSpecificity = new Map();\n        this.images = [];\n        this.fonts = [];\n        this.emSizeStack = [];\n        this.uniqueId = 0;\n        this.screen = canvg.screen;\n        this.rootEmSize = rootEmSize;\n        this.emSize = emSize;\n        this.createCanvas = createCanvas1;\n        this.createImage = this.bindCreateImage(createImage2, anonymousCrossOrigin);\n        this.screen.wait(()=>this.isImagesLoaded()\n        );\n        this.screen.wait(()=>this.isFontsLoaded()\n        );\n    }\n}\nDocument.createCanvas = createCanvas;\nDocument.createImage = createImage;\nDocument.elementTypes = elements;\n\n/**\n * SVG renderer on canvas.\n */ class Canvg {\n    /**\n   * Create Canvg instance from SVG source string or URL.\n   * @param ctx - Rendering context.\n   * @param svg - SVG source string or URL.\n   * @param options - Rendering options.\n   * @returns Canvg instance.\n   */ static async from(ctx, svg) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const parser = new Parser(options);\n        const svgDocument = await parser.parse(svg);\n        return new Canvg(ctx, svgDocument, options);\n    }\n    /**\n   * Create Canvg instance from SVG source string.\n   * @param ctx - Rendering context.\n   * @param svg - SVG source string.\n   * @param options - Rendering options.\n   * @returns Canvg instance.\n   */ static fromString(ctx, svg) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const parser = new Parser(options);\n        const svgDocument = parser.parseFromString(svg);\n        return new Canvg(ctx, svgDocument, options);\n    }\n    /**\n   * Create new Canvg instance with inherited options.\n   * @param ctx - Rendering context.\n   * @param svg - SVG source string or URL.\n   * @param options - Rendering options.\n   * @returns Canvg instance.\n   */ fork(ctx, svg) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        return Canvg.from(ctx, svg, {\n            ...this.options,\n            ...options\n        });\n    }\n    /**\n   * Create new Canvg instance with inherited options.\n   * @param ctx - Rendering context.\n   * @param svg - SVG source string.\n   * @param options - Rendering options.\n   * @returns Canvg instance.\n   */ forkString(ctx, svg) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        return Canvg.fromString(ctx, svg, {\n            ...this.options,\n            ...options\n        });\n    }\n    /**\n   * Document is ready promise.\n   * @returns Ready promise.\n   */ ready() {\n        return this.screen.ready();\n    }\n    /**\n   * Document is ready value.\n   * @returns Is ready or not.\n   */ isReady() {\n        return this.screen.isReady();\n    }\n    /**\n   * Render only first frame, ignoring animations and mouse.\n   * @param options - Rendering options.\n   */ async render() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        this.start({\n            enableRedraw: true,\n            ignoreAnimation: true,\n            ignoreMouse: true,\n            ...options\n        });\n        await this.ready();\n        this.stop();\n    }\n    /**\n   * Start rendering.\n   * @param options - Render options.\n   */ start() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const { documentElement , screen , options: baseOptions  } = this;\n        screen.start(documentElement, {\n            enableRedraw: true,\n            ...baseOptions,\n            ...options\n        });\n    }\n    /**\n   * Stop rendering.\n   */ stop() {\n        this.screen.stop();\n    }\n    /**\n   * Resize SVG to fit in given size.\n   * @param width\n   * @param height\n   * @param preserveAspectRatio\n   */ resize(width) {\n        let height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width, preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        this.documentElement.resize(width, height, preserveAspectRatio);\n    }\n    /**\n   * Main constructor.\n   * @param ctx - Rendering context.\n   * @param svg - SVG Document.\n   * @param options - Rendering options.\n   */ constructor(ctx, svg, options = {}){\n        this.parser = new Parser(options);\n        this.screen = new Screen(ctx, options);\n        this.options = options;\n        const document = new Document(this, options);\n        const documentElement = document.createDocumentElement(svg);\n        this.document = document;\n        this.documentElement = documentElement;\n    }\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jYW52Zy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ1I7QUFDVztBQUNHOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdDQUFnQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscUNBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkNBQTZDO0FBQzdELGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzSkFBc0o7QUFDcEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpTEFBaUw7QUFDL0wsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnQ0FBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0NBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUNBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBaUQsSUFBSTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscURBQXFELElBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTLFNBQVMsdUJBQXVCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVMsU0FBUyx1QkFBdUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHlDQUF5QywyQkFBMkI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQkFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixxREFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxREFBVyxpQ0FBaUMscURBQVcsd0NBQXdDLHFEQUFXLGdDQUFnQyxxREFBVztBQUNyTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVyxpQkFBaUIsYUFBYSxvQkFBb0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLG1CQUFtQjtBQUNuQyxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixtQkFBbUI7QUFDbkMsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsbUJBQW1CO0FBQ25DLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixpREFBaUQ7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGlEQUFpRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQix5Q0FBeUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQix5Q0FBeUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDLGNBQWMseUNBQXlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLHdFQUF3RTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUIsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCLElBQUksZ0JBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQyw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDLG9CQUFvQixzQkFBc0I7QUFDMUMsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQyxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEMsOEJBQThCLHFDQUFRO0FBQ3RDLDRCQUE0QixxQ0FBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixvQ0FBb0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QyxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMENBQTBDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJDQUEyQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseURBQXlEO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxTQUFTLE9BQU8sS0FBSyxRQUFRLFlBQVk7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQywyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EseUJBQXlCLHlMQUF5TCxJQUFJO0FBQ3ROO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtREFBbUQ7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlwQztBQUNqcEMiLCJzb3VyY2VzIjpbIi9hcHAvbm9kZV9tb2R1bGVzL2NhbnZnL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJlcXVlc3RBbmltYXRpb25GcmFtZSBmcm9tICdyYWYnO1xuaW1wb3J0IFJHQkNvbG9yIGZyb20gJ3JnYmNvbG9yJztcbmltcG9ydCB7IFNWR1BhdGhEYXRhIH0gZnJvbSAnc3ZnLXBhdGhkYXRhJztcbmltcG9ydCB7IGNhbnZhc1JHQkEgfSBmcm9tICdzdGFja2JsdXItY2FudmFzJztcblxuLyoqXG4gKiBPcHRpb25zIHByZXNldCBmb3IgYE9mZnNjcmVlbkNhbnZhc2AuXG4gKiBAcGFyYW0gY29uZmlnIC0gUHJlc2V0IHJlcXVpcmVtZW50cy5cbiAqIEBwYXJhbSBjb25maWcuRE9NUGFyc2VyIC0gWE1ML0hUTUwgcGFyc2VyIGZyb20gc3RyaW5nIGludG8gRE9NIERvY3VtZW50LlxuICogQHJldHVybnMgUHJlc2V0IG9iamVjdC5cbiAqLyBmdW5jdGlvbiBvZmZzY3JlZW4oKSB7XG4gICAgbGV0IHsgRE9NUGFyc2VyOiBET01QYXJzZXJGYWxsYmFjayAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY29uc3QgcHJlc2V0ID0ge1xuICAgICAgICB3aW5kb3c6IG51bGwsXG4gICAgICAgIGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgICAgaWdub3JlTW91c2U6IHRydWUsXG4gICAgICAgIERPTVBhcnNlcjogRE9NUGFyc2VyRmFsbGJhY2ssXG4gICAgICAgIGNyZWF0ZUNhbnZhcyAod2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGNyZWF0ZUltYWdlICh1cmwpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICBjb25zdCBpbWcgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChibG9iKTtcbiAgICAgICAgICAgIHJldHVybiBpbWc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5ET01QYXJzZXIgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBET01QYXJzZXJGYWxsYmFjayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShwcmVzZXQsICdET01QYXJzZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIHByZXNldDtcbn1cblxuLyoqXG4gKiBPcHRpb25zIHByZXNldCBmb3IgYG5vZGUtY2FudmFzYC5cbiAqIEBwYXJhbSBjb25maWcgLSBQcmVzZXQgcmVxdWlyZW1lbnRzLlxuICogQHBhcmFtIGNvbmZpZy5ET01QYXJzZXIgLSBYTUwvSFRNTCBwYXJzZXIgZnJvbSBzdHJpbmcgaW50byBET00gRG9jdW1lbnQuXG4gKiBAcGFyYW0gY29uZmlnLmNhbnZhcyAtIGBub2RlLWNhbnZhc2AgZXhwb3J0cy5cbiAqIEBwYXJhbSBjb25maWcuZmV0Y2ggLSBXSEFUV0ctY29tcGF0aWJsZSBgZmV0Y2hgIGZ1bmN0aW9uLlxuICogQHJldHVybnMgUHJlc2V0IG9iamVjdC5cbiAqLyBmdW5jdGlvbiBub2RlKHBhcmFtKSB7XG4gICAgbGV0IHsgRE9NUGFyc2VyICwgY2FudmFzICwgZmV0Y2ggIH0gPSBwYXJhbTtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aW5kb3c6IG51bGwsXG4gICAgICAgIGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgICAgaWdub3JlTW91c2U6IHRydWUsXG4gICAgICAgIERPTVBhcnNlcixcbiAgICAgICAgZmV0Y2gsXG4gICAgICAgIGNyZWF0ZUNhbnZhczogY2FudmFzLmNyZWF0ZUNhbnZhcyxcbiAgICAgICAgY3JlYXRlSW1hZ2U6IGNhbnZhcy5sb2FkSW1hZ2VcbiAgICB9O1xufVxuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgb2Zmc2NyZWVuOiBvZmZzY3JlZW4sXG4gIG5vZGU6IG5vZGVcbn0pO1xuXG4vKipcbiAqIEhUTUwtc2FmZSBjb21wcmVzcyB3aGl0ZS1zcGFjZXMuXG4gKiBAcGFyYW0gc3RyIC0gU3RyaW5nIHRvIGNvbXByZXNzLlxuICogQHJldHVybnMgU3RyaW5nLlxuICovIGZ1bmN0aW9uIGNvbXByZXNzU3BhY2VzKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKD8hXFx1MzAwMClcXHMrL2dtLCAnICcpO1xufVxuLyoqXG4gKiBIVE1MLXNhZmUgbGVmdCB0cmltLlxuICogQHBhcmFtIHN0ciAtIFN0cmluZyB0byB0cmltLlxuICogQHJldHVybnMgU3RyaW5nLlxuICovIGZ1bmN0aW9uIHRyaW1MZWZ0KHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXltcXG4gXFx0XSsvLCAnJyk7XG59XG4vKipcbiAqIEhUTUwtc2FmZSByaWdodCB0cmltLlxuICogQHBhcmFtIHN0ciAtIFN0cmluZyB0byB0cmltLlxuICogQHJldHVybnMgU3RyaW5nLlxuICovIGZ1bmN0aW9uIHRyaW1SaWdodChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXG4gXFx0XSskLywgJycpO1xufVxuLyoqXG4gKiBTdHJpbmcgdG8gbnVtYmVycyBhcnJheS5cbiAqIEBwYXJhbSBzdHIgLSBOdW1iZXJzIHN0cmluZy5cbiAqIEByZXR1cm5zIE51bWJlcnMgYXJyYXkuXG4gKi8gZnVuY3Rpb24gdG9OdW1iZXJzKHN0cikge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBzdHIubWF0Y2goLy0/KFxcZCsoPzpcXC5cXGQqKD86W2VFXVsrLV0/XFxkKyk/KT98XFwuXFxkKykoPz1cXER8JCkvZ20pO1xuICAgIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlcy5tYXAocGFyc2VGbG9hdCkgOiBbXTtcbn1cbi8qKlxuICogU3RyaW5nIHRvIG1hdHJpeCB2YWx1ZS5cbiAqIEBwYXJhbSBzdHIgLSBOdW1iZXJzIHN0cmluZy5cbiAqIEByZXR1cm5zIE1hdHJpeCB2YWx1ZS5cbiAqLyBmdW5jdGlvbiB0b01hdHJpeFZhbHVlKHN0cikge1xuICAgIGNvbnN0IG51bWJlcnMgPSB0b051bWJlcnMoc3RyKTtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAgIG51bWJlcnNbMF0gfHwgMCxcbiAgICAgICAgbnVtYmVyc1sxXSB8fCAwLFxuICAgICAgICBudW1iZXJzWzJdIHx8IDAsXG4gICAgICAgIG51bWJlcnNbM10gfHwgMCxcbiAgICAgICAgbnVtYmVyc1s0XSB8fCAwLFxuICAgICAgICBudW1iZXJzWzVdIHx8IDBcbiAgICBdO1xuICAgIHJldHVybiBtYXRyaXg7XG59XG4vLyBNaWNyb3NvZnQgRWRnZSBmaXhcbmNvbnN0IGFsbFVwcGVyY2FzZSA9IC9eW0EtWi1dKyQvO1xuLyoqXG4gKiBOb3JtYWxpemUgYXR0cmlidXRlIG5hbWUuXG4gKiBAcGFyYW0gbmFtZSAtIEF0dHJpYnV0ZSBuYW1lLlxuICogQHJldHVybnMgTm9ybWFsaXplZCBhdHRyaWJ1dGUgbmFtZS5cbiAqLyBmdW5jdGlvbiBub3JtYWxpemVBdHRyaWJ1dGVOYW1lKG5hbWUpIHtcbiAgICBpZiAoYWxsVXBwZXJjYXNlLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG4vKipcbiAqIFBhcnNlIGV4dGVybmFsIFVSTC5cbiAqIEBwYXJhbSB1cmwgLSBDU1MgdXJsIHN0cmluZy5cbiAqIEByZXR1cm5zIFBhcnNlZCBVUkwuXG4gKi8gZnVuY3Rpb24gcGFyc2VFeHRlcm5hbFVybCh1cmwpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICBzaW5nbGUgcXVvdGVzIFsyXVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICBkb3VibGUgcXVvdGVzIFszXVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICB2ICAgICAgICAgbm8gcXVvdGVzIFs0XVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICB2ICAgICAgICAgdlxuICAgIGNvbnN0IHVybE1hdGNoID0gL3VybFxcKCgnKFteJ10rKSd8XCIoW15cIl0rKVwifChbXidcIildKykpXFwpLy5leGVjKHVybCk7XG4gICAgaWYgKCF1cmxNYXRjaCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiB1cmxNYXRjaFsyXSB8fCB1cmxNYXRjaFszXSB8fCB1cmxNYXRjaFs0XSB8fCAnJztcbn1cbi8qKlxuICogVHJhbnNmb3JtIGZsb2F0cyB0byBpbnRlZ2VycyBpbiByZ2IgY29sb3JzLlxuICogQHBhcmFtIGNvbG9yIC0gQ29sb3IgdG8gbm9ybWFsaXplLlxuICogQHJldHVybnMgTm9ybWFsaXplZCBjb2xvci5cbiAqLyBmdW5jdGlvbiBub3JtYWxpemVDb2xvcihjb2xvcikge1xuICAgIGlmICghY29sb3Iuc3RhcnRzV2l0aCgncmdiJykpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBsZXQgcmdiUGFydHMgPSAzO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRDb2xvciA9IGNvbG9yLnJlcGxhY2UoL1xcZCsoXFwuXFxkKyk/L2csIChudW0sIGlzRmxvYXQpPT4ocmdiUGFydHMtLSkgJiYgaXNGbG9hdCA/IFN0cmluZyhNYXRoLnJvdW5kKHBhcnNlRmxvYXQobnVtKSkpIDogbnVtXG4gICAgKTtcbiAgICByZXR1cm4gbm9ybWFsaXplZENvbG9yO1xufVxuXG4vLyBzbGlnaHRseSBtb2RpZmllZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9rZWVnYW5zdHJlZXQvc3BlY2lmaWNpdHkvYmxvYi9tYXN0ZXIvc3BlY2lmaWNpdHkuanNcbmNvbnN0IGF0dHJpYnV0ZVJlZ2V4ID0gLyhcXFtbXlxcXV0rXFxdKS9nO1xuY29uc3QgaWRSZWdleCA9IC8oI1teXFxzKz5+Lls6XSspL2c7XG5jb25zdCBjbGFzc1JlZ2V4ID0gLyhcXC5bXlxccys+fi5bOl0rKS9nO1xuY29uc3QgcHNldWRvRWxlbWVudFJlZ2V4ID0gLyg6OlteXFxzKz5+Lls6XSt8OmZpcnN0LWxpbmV8OmZpcnN0LWxldHRlcnw6YmVmb3JlfDphZnRlcikvZ2k7XG5jb25zdCBwc2V1ZG9DbGFzc1dpdGhCcmFja2V0c1JlZ2V4ID0gLyg6W1xcdy1dK1xcKFteKV0qXFwpKS9naTtcbmNvbnN0IHBzZXVkb0NsYXNzUmVnZXggPSAvKDpbXlxccys+fi5bOl0rKS9nO1xuY29uc3QgZWxlbWVudFJlZ2V4ID0gLyhbXlxccys+fi5bOl0rKS9nO1xuZnVuY3Rpb24gZmluZFNlbGVjdG9yTWF0Y2goc2VsZWN0b3IsIHJlZ2V4KSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHJlZ2V4LmV4ZWMoc2VsZWN0b3IpO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgICAgICAwXG4gICAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIHNlbGVjdG9yLnJlcGxhY2UocmVnZXgsICcgJyksXG4gICAgICAgIG1hdGNoZXMubGVuZ3RoXG4gICAgXTtcbn1cbi8qKlxuICogTWVhc3VyZSBzZWxlY3RvciBzcGVjaWZpY2l0eS5cbiAqIEBwYXJhbSBzZWxlY3RvciAtIFNlbGVjdG9yIHRvIG1lYXN1cmUuXG4gKiBAcmV0dXJucyBTcGVjaWZpY2l0eS5cbiAqLyBmdW5jdGlvbiBnZXRTZWxlY3RvclNwZWNpZmljaXR5KHNlbGVjdG9yKSB7XG4gICAgY29uc3Qgc3BlY2lmaWNpdHkgPSBbXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDBcbiAgICBdO1xuICAgIGxldCBjdXJyZW50U2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC86bm90XFwoKFteKV0qKVxcKS9nLCAnICAgICAkMSAnKS5yZXBsYWNlKC97W1xcc1xcU10qL2dtLCAnICcpO1xuICAgIGxldCBkZWx0YSA9IDA7XG4gICAgW2N1cnJlbnRTZWxlY3RvciwgZGVsdGFdID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBhdHRyaWJ1dGVSZWdleCk7XG4gICAgc3BlY2lmaWNpdHlbMV0gKz0gZGVsdGE7XG4gICAgW2N1cnJlbnRTZWxlY3RvciwgZGVsdGFdID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBpZFJlZ2V4KTtcbiAgICBzcGVjaWZpY2l0eVswXSArPSBkZWx0YTtcbiAgICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIGNsYXNzUmVnZXgpO1xuICAgIHNwZWNpZmljaXR5WzFdICs9IGRlbHRhO1xuICAgIFtjdXJyZW50U2VsZWN0b3IsIGRlbHRhXSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgcHNldWRvRWxlbWVudFJlZ2V4KTtcbiAgICBzcGVjaWZpY2l0eVsyXSArPSBkZWx0YTtcbiAgICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIHBzZXVkb0NsYXNzV2l0aEJyYWNrZXRzUmVnZXgpO1xuICAgIHNwZWNpZmljaXR5WzFdICs9IGRlbHRhO1xuICAgIFtjdXJyZW50U2VsZWN0b3IsIGRlbHRhXSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgcHNldWRvQ2xhc3NSZWdleCk7XG4gICAgc3BlY2lmaWNpdHlbMV0gKz0gZGVsdGE7XG4gICAgY3VycmVudFNlbGVjdG9yID0gY3VycmVudFNlbGVjdG9yLnJlcGxhY2UoL1sqXFxzKz5+XS9nLCAnICcpLnJlcGxhY2UoL1sjLl0vZywgJyAnKTtcbiAgICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIGVsZW1lbnRSZWdleCkgLy8gbGd0bSBbanMvdXNlbGVzcy1hc3NpZ25tZW50LXRvLWxvY2FsXVxuICAgIDtcbiAgICBzcGVjaWZpY2l0eVsyXSArPSBkZWx0YTtcbiAgICByZXR1cm4gc3BlY2lmaWNpdHkuam9pbignJyk7XG59XG5cbmNvbnN0IFBTRVVET19aRVJPID0gMC4wMDAwMDAwMTtcbi8qKlxuICogVmVjdG9yIG1hZ25pdHVkZS5cbiAqIEBwYXJhbSB2XG4gKiBAcmV0dXJucyBOdW1iZXIgcmVzdWx0LlxuICovIGZ1bmN0aW9uIHZlY3Rvck1hZ25pdHVkZSh2KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh2WzBdLCAyKSArIE1hdGgucG93KHZbMV0sIDIpKTtcbn1cbi8qKlxuICogUmF0aW8gYmV0d2VlbiB0d28gdmVjdG9ycy5cbiAqIEBwYXJhbSB1XG4gKiBAcGFyYW0gdlxuICogQHJldHVybnMgTnVtYmVyIHJlc3VsdC5cbiAqLyBmdW5jdGlvbiB2ZWN0b3JzUmF0aW8odSwgdikge1xuICAgIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodmVjdG9yTWFnbml0dWRlKHUpICogdmVjdG9yTWFnbml0dWRlKHYpKTtcbn1cbi8qKlxuICogQW5nbGUgYmV0d2VlbiB0d28gdmVjdG9ycy5cbiAqIEBwYXJhbSB1XG4gKiBAcGFyYW0gdlxuICogQHJldHVybnMgTnVtYmVyIHJlc3VsdC5cbiAqLyBmdW5jdGlvbiB2ZWN0b3JzQW5nbGUodSwgdikge1xuICAgIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModmVjdG9yc1JhdGlvKHUsIHYpKTtcbn1cbmZ1bmN0aW9uIENCMSh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbn1cbmZ1bmN0aW9uIENCMih0KSB7XG4gICAgcmV0dXJuIDMgKiB0ICogdCAqICgxIC0gdCk7XG59XG5mdW5jdGlvbiBDQjModCkge1xuICAgIHJldHVybiAzICogdCAqICgxIC0gdCkgKiAoMSAtIHQpO1xufVxuZnVuY3Rpb24gQ0I0KHQpIHtcbiAgICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCkgKiAoMSAtIHQpO1xufVxuZnVuY3Rpb24gUUIxKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG59XG5mdW5jdGlvbiBRQjIodCkge1xuICAgIHJldHVybiAyICogdCAqICgxIC0gdCk7XG59XG5mdW5jdGlvbiBRQjModCkge1xuICAgIHJldHVybiAoMSAtIHQpICogKDEgLSB0KTtcbn1cblxuY2xhc3MgUHJvcGVydHkge1xuICAgIHN0YXRpYyBlbXB0eShkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnRU1QVFknLCAnJyk7XG4gICAgfVxuICAgIHNwbGl0KCkge1xuICAgICAgICBsZXQgc2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiAnICc7XG4gICAgICAgIGNvbnN0IHsgZG9jdW1lbnQgLCBuYW1lICB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGNvbXByZXNzU3BhY2VzKHRoaXMuZ2V0U3RyaW5nKCkpLnRyaW0oKS5zcGxpdChzZXBhcmF0b3IpLm1hcCgodmFsdWUpPT5uZXcgUHJvcGVydHkoZG9jdW1lbnQsIG5hbWUsIHZhbHVlKVxuICAgICAgICApO1xuICAgIH1cbiAgICBoYXNWYWx1ZSh6ZXJvSXNWYWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gJycgJiYgKHplcm9Jc1ZhbHVlIHx8IHZhbHVlICE9PSAwKSAmJiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBpc1N0cmluZyhyZWdleHApIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGlmICghcmVzdWx0IHx8ICFyZWdleHApIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZ2V4cC50ZXN0KHZhbHVlKTtcbiAgICB9XG4gICAgaXNVcmxEZWZpbml0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1N0cmluZygvXnVybFxcKC8pO1xuICAgIH1cbiAgICBpc1BpeGVscygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhc1N0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7XG4gICAgICAgIHN3aXRjaCh0cnVlKXtcbiAgICAgICAgICAgIGNhc2UgYXNTdHJpbmcuZW5kc1dpdGgoJ3B4Jyk6XG4gICAgICAgICAgICBjYXNlIC9eWzAtOV0rJC8udGVzdChhc1N0cmluZyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRWYWx1ZShkZWYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICB9XG4gICAgZ2V0TnVtYmVyKGRlZikge1xuICAgICAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFBhcnNlIHVua25vd24gdmFsdWUuXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChkZWYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdmFsdWUgIH0gPSB0aGlzO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFBhcnNlIHVua25vd24gdmFsdWUuXG4gICAgICAgIGxldCBuID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RyaW5nKC8lJC8pKSB7XG4gICAgICAgICAgICBuIC89IDEwMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgZ2V0U3RyaW5nKGRlZikge1xuICAgICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMudmFsdWUgPT09ICd1bmRlZmluZWQnID8gJycgOiBTdHJpbmcodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZyhkZWYpO1xuICAgIH1cbiAgICBnZXRDb2xvcihkZWYpIHtcbiAgICAgICAgbGV0IGNvbG9yID0gdGhpcy5nZXRTdHJpbmcoZGVmKTtcbiAgICAgICAgaWYgKHRoaXMuaXNOb3JtYWxpemVkQ29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzTm9ybWFsaXplZENvbG9yID0gdHJ1ZTtcbiAgICAgICAgY29sb3IgPSBub3JtYWxpemVDb2xvcihjb2xvcik7XG4gICAgICAgIHRoaXMudmFsdWUgPSBjb2xvcjtcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBnZXREcGkoKSB7XG4gICAgICAgIHJldHVybiA5NiAvLyBUT0RPOiBjb21wdXRlP1xuICAgICAgICA7XG4gICAgfVxuICAgIGdldFJlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQucm9vdEVtU2l6ZTtcbiAgICB9XG4gICAgZ2V0RW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmVtU2l6ZTtcbiAgICB9XG4gICAgZ2V0VW5pdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0cmluZygpLnJlcGxhY2UoL1swLTkuLV0vZywgJycpO1xuICAgIH1cbiAgICBnZXRQaXhlbHMoYXhpc09ySXNGb250U2l6ZSkge1xuICAgICAgICBsZXQgcHJvY2Vzc1BlcmNlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2F4aXMsIGlzRm9udFNpemVdID0gdHlwZW9mIGF4aXNPcklzRm9udFNpemUgPT09ICdib29sZWFuJyA/IFtcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF4aXNPcklzRm9udFNpemVcbiAgICAgICAgXSA6IFtcbiAgICAgICAgICAgIGF4aXNPcklzRm9udFNpemVcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgeyB2aWV3UG9ydCAgfSA9IHRoaXMuZG9jdW1lbnQuc2NyZWVuO1xuICAgICAgICBzd2l0Y2godHJ1ZSl7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3ZtaW4kLyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgLyAxMDAgKiBNYXRoLm1pbih2aWV3UG9ydC5jb21wdXRlU2l6ZSgneCcpLCB2aWV3UG9ydC5jb21wdXRlU2l6ZSgneScpKTtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvdm1heCQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAvIDEwMCAqIE1hdGgubWF4KHZpZXdQb3J0LmNvbXB1dGVTaXplKCd4JyksIHZpZXdQb3J0LmNvbXB1dGVTaXplKCd5JykpO1xuICAgICAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC92dyQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAvIDEwMCAqIHZpZXdQb3J0LmNvbXB1dGVTaXplKCd4Jyk7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3ZoJC8pOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpIC8gMTAwICogdmlld1BvcnQuY29tcHV0ZVNpemUoJ3knKTtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvcmVtJC8pOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXRSZW0oKTtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvZW0kLyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldEVtKCk7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2V4JC8pOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXRFbSgpIC8gMjtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvcHgkLyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCk7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3B0JC8pOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXREcGkoKSAqICgxIC8gNzIpO1xuICAgICAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9wYyQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIDE1O1xuICAgICAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9jbSQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RHBpKCkgLyAyLjU0O1xuICAgICAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9tbSQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RHBpKCkgLyAyNS40O1xuICAgICAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9pbiQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RHBpKCk7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoLyUkLykgJiYgaXNGb250U2l6ZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RW0oKTtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvJSQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHZpZXdQb3J0LmNvbXB1dGVTaXplKGF4aXMpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSB0aGlzLmdldE51bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc1BlcmNlbnQgJiYgbiA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuICogdmlld1BvcnQuY29tcHV0ZVNpemUoYXhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldE1pbGxpc2Vjb25kcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzU3RyaW5nKC9tcyQvKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAxMDAwO1xuICAgIH1cbiAgICBnZXRSYWRpYW5zKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKHRydWUpe1xuICAgICAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9kZWckLyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAoTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2dyYWQkLyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAoTWF0aC5QSSAvIDIwMCk7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3JhZCQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAoTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVmaW5pdGlvbigpIHtcbiAgICAgICAgY29uc3QgYXNTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpO1xuICAgICAgICBjb25zdCBtYXRjaCA9IC8jKFteKSdcIl0rKS8uZXhlYyhhc1N0cmluZyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAobWF0Y2ggPT09IG51bGwgfHwgbWF0Y2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoWzFdKSB8fCBhc1N0cmluZztcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuZGVmaW5pdGlvbnMuZ2V0KG5hbWUpO1xuICAgIH1cbiAgICBnZXRGaWxsU3R5bGVEZWZpbml0aW9uKGVsZW1lbnQsIG9wYWNpdHkpIHtcbiAgICAgICAgbGV0IGRlZiA9IHRoaXMuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICBpZiAoIWRlZikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ3JhZGllbnRcbiAgICAgICAgaWYgKHR5cGVvZiBkZWYuY3JlYXRlR3JhZGllbnQgPT09ICdmdW5jdGlvbicgJiYgJ2dldEJvdW5kaW5nQm94JyBpbiBlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmLmNyZWF0ZUdyYWRpZW50KHRoaXMuZG9jdW1lbnQuY3R4LCBlbGVtZW50LCBvcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYXR0ZXJuXG4gICAgICAgIGlmICh0eXBlb2YgZGVmLmNyZWF0ZVBhdHRlcm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChkZWYuZ2V0SHJlZkF0dHJpYnV0ZSgpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuVHJhbnNmb3JtID0gZGVmLmdldEF0dHJpYnV0ZSgncGF0dGVyblRyYW5zZm9ybScpO1xuICAgICAgICAgICAgICAgIGRlZiA9IGRlZi5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChkZWYgJiYgcGF0dGVyblRyYW5zZm9ybS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZi5nZXRBdHRyaWJ1dGUoJ3BhdHRlcm5UcmFuc2Zvcm0nLCB0cnVlKS5zZXRWYWx1ZShwYXR0ZXJuVHJhbnNmb3JtLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZi5jcmVhdGVQYXR0ZXJuKHRoaXMuZG9jdW1lbnQuY3R4LCBlbGVtZW50LCBvcGFjaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0VGV4dEJhc2VsaW5lKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRTdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIFByb3BlcnR5LnRleHRCYXNlbGluZU1hcHBpbmdba2V5XSB8fCBudWxsO1xuICAgIH1cbiAgICBhZGRPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5nZXRDb2xvcigpO1xuICAgICAgICBjb25zdCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGxldCBjb21tYXMgPSAwO1xuICAgICAgICAvLyBTaW11bGF0ZSBvbGQgUkdCQ29sb3IgdmVyc2lvbiwgd2hpY2ggY2FuJ3QgcGFyc2UgcmdiYS5cbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgICAgIGlmICh2YWx1ZVtpXSA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgY29tbWFzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tbWFzID09PSAzKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wYWNpdHkuaGFzVmFsdWUoKSAmJiB0aGlzLmlzU3RyaW5nKCkgJiYgY29tbWFzICE9PSAzKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IG5ldyBSR0JDb2xvcih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY29sb3Iub2spIHtcbiAgICAgICAgICAgICAgICBjb2xvci5hbHBoYSA9IG9wYWNpdHkuZ2V0TnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb2xvci50b1JHQkEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsIHRoaXMubmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbmFtZSwgdmFsdWUpe1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5pc05vcm1hbGl6ZWRDb2xvciA9IGZhbHNlO1xuICAgIH1cbn1cblByb3BlcnR5LnRleHRCYXNlbGluZU1hcHBpbmcgPSB7XG4gICAgJ2Jhc2VsaW5lJzogJ2FscGhhYmV0aWMnLFxuICAgICdiZWZvcmUtZWRnZSc6ICd0b3AnLFxuICAgICd0ZXh0LWJlZm9yZS1lZGdlJzogJ3RvcCcsXG4gICAgJ21pZGRsZSc6ICdtaWRkbGUnLFxuICAgICdjZW50cmFsJzogJ21pZGRsZScsXG4gICAgJ2FmdGVyLWVkZ2UnOiAnYm90dG9tJyxcbiAgICAndGV4dC1hZnRlci1lZGdlJzogJ2JvdHRvbScsXG4gICAgJ2lkZW9ncmFwaGljJzogJ2lkZW9ncmFwaGljJyxcbiAgICAnYWxwaGFiZXRpYyc6ICdhbHBoYWJldGljJyxcbiAgICAnaGFuZ2luZyc6ICdoYW5naW5nJyxcbiAgICAnbWF0aGVtYXRpY2FsJzogJ2FscGhhYmV0aWMnXG59O1xuXG5jbGFzcyBWaWV3UG9ydCB7XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMudmlld1BvcnRzID0gW107XG4gICAgfVxuICAgIHNldEN1cnJlbnQod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLnZpZXdQb3J0cy5wdXNoKHtcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVDdXJyZW50KCkge1xuICAgICAgICB0aGlzLnZpZXdQb3J0cy5wb3AoKTtcbiAgICB9XG4gICAgZ2V0Um9vdCgpIHtcbiAgICAgICAgY29uc3QgW3Jvb3RdID0gdGhpcy52aWV3UG9ydHM7XG4gICAgICAgIGlmICghcm9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gICAgZ2V0Q3VycmVudCgpIHtcbiAgICAgICAgY29uc3QgeyB2aWV3UG9ydHMgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdmlld1BvcnRzW3ZpZXdQb3J0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnQoKS53aWR0aDtcbiAgICB9XG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudCgpLmhlaWdodDtcbiAgICB9XG4gICAgY29tcHV0ZVNpemUoZCkge1xuICAgICAgICBpZiAodHlwZW9mIGQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZCA9PT0gJ3gnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZCA9PT0gJ3knKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0aGlzLndpZHRoLCAyKSArIE1hdGgucG93KHRoaXMuaGVpZ2h0LCAyKSkgLyBNYXRoLnNxcnQoMik7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMudmlld1BvcnRzID0gW107XG4gICAgfVxufVxuVmlld1BvcnQuREVGQVVMVF9WSUVXUE9SVF9XSURUSCA9IDgwMDtcblZpZXdQb3J0LkRFRkFVTFRfVklFV1BPUlRfSEVJR0hUID0gNjAwO1xuZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogVmlld1BvcnQuREVGQVVMVF9WSUVXUE9SVF9XSURUSCxcbiAgICAgICAgaGVpZ2h0OiBWaWV3UG9ydC5ERUZBVUxUX1ZJRVdQT1JUX0hFSUdIVFxuICAgIH07XG59XG5cbmNsYXNzIFBvaW50IHtcbiAgICBzdGF0aWMgcGFyc2UocG9pbnQpIHtcbiAgICAgICAgbGV0IGRlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgICAgY29uc3QgW3ggPSBkZWZhdWx0VmFsdWUsIHkgPSBkZWZhdWx0VmFsdWVdID0gdG9OdW1iZXJzKHBvaW50KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlU2NhbGUoc2NhbGUpIHtcbiAgICAgICAgbGV0IGRlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogMTtcbiAgICAgICAgY29uc3QgW3ggPSBkZWZhdWx0VmFsdWUsIHkgPSB4XSA9IHRvTnVtYmVycyhzY2FsZSk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSk7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZVBhdGgocGF0aCkge1xuICAgICAgICBjb25zdCBwb2ludHMgPSB0b051bWJlcnMocGF0aCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHBhdGhQb2ludHMgPSBbXTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAyKXtcbiAgICAgICAgICAgIHBhdGhQb2ludHMucHVzaChuZXcgUG9pbnQocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGhQb2ludHM7XG4gICAgfVxuICAgIGFuZ2xlVG8ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIocG9pbnQueSAtIHRoaXMueSwgcG9pbnQueCAtIHRoaXMueCk7XG4gICAgfVxuICAgIGFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeHAgPSB4ICogdHJhbnNmb3JtWzBdICsgeSAqIHRyYW5zZm9ybVsyXSArIHRyYW5zZm9ybVs0XTtcbiAgICAgICAgY29uc3QgeXAgPSB4ICogdHJhbnNmb3JtWzFdICsgeSAqIHRyYW5zZm9ybVszXSArIHRyYW5zZm9ybVs1XTtcbiAgICAgICAgdGhpcy54ID0geHA7XG4gICAgICAgIHRoaXMueSA9IHlwO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih4LCB5KXtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICB9XG59XG5cbmNsYXNzIE1vdXNlIHtcbiAgICBpc1dvcmtpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndvcmtpbmc7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy53b3JraW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzY3JlZW4gLCBvbkNsaWNrICwgb25Nb3VzZU1vdmUgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBzY3JlZW4uY3R4LmNhbnZhcztcbiAgICAgICAgY2FudmFzLm9uY2xpY2sgPSBvbkNsaWNrO1xuICAgICAgICBjYW52YXMub25tb3VzZW1vdmUgPSBvbk1vdXNlTW92ZTtcbiAgICAgICAgdGhpcy53b3JraW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLndvcmtpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLnNjcmVlbi5jdHguY2FudmFzO1xuICAgICAgICB0aGlzLndvcmtpbmcgPSBmYWxzZTtcbiAgICAgICAgY2FudmFzLm9uY2xpY2sgPSBudWxsO1xuICAgICAgICBjYW52YXMub25tb3VzZW1vdmUgPSBudWxsO1xuICAgIH1cbiAgICBoYXNFdmVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndvcmtpbmcgJiYgdGhpcy5ldmVudHMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgcnVuRXZlbnRzKCkge1xuICAgICAgICBpZiAoIXRoaXMud29ya2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2NyZWVuOiBkb2N1bWVudCAsIGV2ZW50cyAsIGV2ZW50RWxlbWVudHMgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHN0eWxlICB9ID0gZG9jdW1lbnQuY3R4LmNhbnZhcztcbiAgICAgICAgbGV0IGVsZW1lbnQ7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgc3R5bGUuY3Vyc29yID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRzLmZvckVhY2goKHBhcmFtLCBpKT0+e1xuICAgICAgICAgICAgbGV0IHsgcnVuICB9ID0gcGFyYW07XG4gICAgICAgICAgICBlbGVtZW50ID0gZXZlbnRFbGVtZW50c1tpXTtcbiAgICAgICAgICAgIHdoaWxlKGVsZW1lbnQpe1xuICAgICAgICAgICAgICAgIHJ1bihlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBkb25lIHJ1bm5pbmcsIGNsZWFyXG4gICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuZXZlbnRFbGVtZW50cyA9IFtdO1xuICAgIH1cbiAgICBjaGVja1BhdGgoZWxlbWVudCwgY3R4KSB7XG4gICAgICAgIGlmICghdGhpcy53b3JraW5nIHx8ICFjdHgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGV2ZW50cyAsIGV2ZW50RWxlbWVudHMgIH0gPSB0aGlzO1xuICAgICAgICBldmVudHMuZm9yRWFjaCgocGFyYW0sIGkpPT57XG4gICAgICAgICAgICBsZXQgeyB4ICwgeSAgfSA9IHBhcmFtO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgICAgIGlmICghZXZlbnRFbGVtZW50c1tpXSAmJiBjdHguaXNQb2ludEluUGF0aCAmJiBjdHguaXNQb2ludEluUGF0aCh4LCB5KSkge1xuICAgICAgICAgICAgICAgIGV2ZW50RWxlbWVudHNbaV0gPSBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2hlY2tCb3VuZGluZ0JveChlbGVtZW50LCBib3VuZGluZ0JveCkge1xuICAgICAgICBpZiAoIXRoaXMud29ya2luZyB8fCAhYm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGV2ZW50cyAsIGV2ZW50RWxlbWVudHMgIH0gPSB0aGlzO1xuICAgICAgICBldmVudHMuZm9yRWFjaCgocGFyYW0sIGkpPT57XG4gICAgICAgICAgICBsZXQgeyB4ICwgeSAgfSA9IHBhcmFtO1xuICAgICAgICAgICAgaWYgKCFldmVudEVsZW1lbnRzW2ldICYmIGJvdW5kaW5nQm94LmlzUG9pbnRJbkJveCh4LCB5KSkge1xuICAgICAgICAgICAgICAgIGV2ZW50RWxlbWVudHNbaV0gPSBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFwWFkoeCwgeSkge1xuICAgICAgICBjb25zdCB7IHdpbmRvdyAsIGN0eCAgfSA9IHRoaXMuc2NyZWVuO1xuICAgICAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBjdHguY2FudmFzO1xuICAgICAgICB3aGlsZShlbGVtZW50KXtcbiAgICAgICAgICAgIHBvaW50LnggLT0gZWxlbWVudC5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgcG9pbnQueSAtPSBlbGVtZW50Lm9mZnNldFRvcDtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LnNjcm9sbFgpIHtcbiAgICAgICAgICAgIHBvaW50LnggKz0gd2luZG93LnNjcm9sbFg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5zY3JvbGxZKSB7XG4gICAgICAgICAgICBwb2ludC55ICs9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgb25DbGljayhldmVudCkge1xuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gdGhpcy5tYXBYWShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgICAgdGhpcy5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnb25jbGljaycsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIHJ1biAoZXZlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRUYXJnZXQub25DbGljaykge1xuICAgICAgICAgICAgICAgICAgICBldmVudFRhcmdldC5vbkNsaWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IHRoaXMubWFwWFkoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgIHRoaXMuZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ29ubW91c2Vtb3ZlJyxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgcnVuIChldmVudFRhcmdldCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudFRhcmdldC5vbk1vdXNlTW92ZSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudFRhcmdldC5vbk1vdXNlTW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHNjcmVlbil7XG4gICAgICAgIHRoaXMuc2NyZWVuID0gc2NyZWVuO1xuICAgICAgICB0aGlzLndvcmtpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudEVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMub25DbGljayA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VNb3ZlID0gdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgIH1cbn1cblxuY29uc3QgZGVmYXVsdFdpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogbnVsbDtcbmNvbnN0IGRlZmF1bHRGZXRjaCQxID0gdHlwZW9mIGZldGNoICE9PSAndW5kZWZpbmVkJyA/IGZldGNoLmJpbmQodW5kZWZpbmVkKSAvLyBgZmV0Y2hgIGRlcGVuZHMgb24gY29udGV4dDogYHNvbWVPYmplY3QuZmV0Y2goLi4uKWAgd2lsbCB0aHJvdyBlcnJvci5cbiA6IHVuZGVmaW5lZDtcbmNsYXNzIFNjcmVlbiB7XG4gICAgd2FpdChjaGVja2VyKSB7XG4gICAgICAgIHRoaXMud2FpdHMucHVzaChjaGVja2VyKTtcbiAgICB9XG4gICAgcmVhZHkoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbWlzdXNlZC1wcm9taXNlc1xuICAgICAgICBpZiAoIXRoaXMucmVhZHlQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZHlQcm9taXNlO1xuICAgIH1cbiAgICBpc1JlYWR5KCkge1xuICAgICAgICBpZiAodGhpcy5pc1JlYWR5TG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNSZWFkeUxvY2sgPSB0aGlzLndhaXRzLmV2ZXJ5KChfKT0+XygpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpc1JlYWR5TG9jaykge1xuICAgICAgICAgICAgdGhpcy53YWl0cyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzb2x2ZVJlYWR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlUmVhZHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUmVhZHlMb2NrID0gaXNSZWFkeUxvY2s7XG4gICAgICAgIHJldHVybiBpc1JlYWR5TG9jaztcbiAgICB9XG4gICAgc2V0RGVmYXVsdHMoY3R4KSB7XG4gICAgICAgIC8vIGluaXRpYWwgdmFsdWVzIGFuZCBkZWZhdWx0c1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gJ2J1dHQnO1xuICAgICAgICBjdHgubGluZUpvaW4gPSAnbWl0ZXInO1xuICAgICAgICBjdHgubWl0ZXJMaW1pdCA9IDQ7XG4gICAgfVxuICAgIHNldFZpZXdCb3gocGFyYW0pIHtcbiAgICAgICAgbGV0IHsgZG9jdW1lbnQgLCBjdHggLCBhc3BlY3RSYXRpbyAsIHdpZHRoICwgZGVzaXJlZFdpZHRoICwgaGVpZ2h0ICwgZGVzaXJlZEhlaWdodCAsIG1pblggPTAgLCBtaW5ZID0wICwgcmVmWCAsIHJlZlkgLCBjbGlwID1mYWxzZSAsIGNsaXBYID0wICwgY2xpcFkgPTAgIH0gPSBwYXJhbTtcbiAgICAgICAgLy8gYXNwZWN0IHJhdGlvIC0gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1ByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGVcbiAgICAgICAgY29uc3QgY2xlYW5Bc3BlY3RSYXRpbyA9IGNvbXByZXNzU3BhY2VzKGFzcGVjdFJhdGlvKS5yZXBsYWNlKC9eZGVmZXJcXHMvLCAnJykgLy8gaWdub3JlIGRlZmVyXG4gICAgICAgIDtcbiAgICAgICAgY29uc3QgW2FzcGVjdFJhdGlvQWxpZ24sIGFzcGVjdFJhdGlvTWVldE9yU2xpY2VdID0gY2xlYW5Bc3BlY3RSYXRpby5zcGxpdCgnICcpO1xuICAgICAgICBjb25zdCBhbGlnbiA9IGFzcGVjdFJhdGlvQWxpZ24gfHwgJ3hNaWRZTWlkJztcbiAgICAgICAgY29uc3QgbWVldE9yU2xpY2UgPSBhc3BlY3RSYXRpb01lZXRPclNsaWNlIHx8ICdtZWV0JztcbiAgICAgICAgLy8gY2FsY3VsYXRlIHNjYWxlXG4gICAgICAgIGNvbnN0IHNjYWxlWCA9IHdpZHRoIC8gZGVzaXJlZFdpZHRoO1xuICAgICAgICBjb25zdCBzY2FsZVkgPSBoZWlnaHQgLyBkZXNpcmVkSGVpZ2h0O1xuICAgICAgICBjb25zdCBzY2FsZU1pbiA9IE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgY29uc3Qgc2NhbGVNYXggPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgIGxldCBmaW5hbERlc2lyZWRXaWR0aCA9IGRlc2lyZWRXaWR0aDtcbiAgICAgICAgbGV0IGZpbmFsRGVzaXJlZEhlaWdodCA9IGRlc2lyZWRIZWlnaHQ7XG4gICAgICAgIGlmIChtZWV0T3JTbGljZSA9PT0gJ21lZXQnKSB7XG4gICAgICAgICAgICBmaW5hbERlc2lyZWRXaWR0aCAqPSBzY2FsZU1pbjtcbiAgICAgICAgICAgIGZpbmFsRGVzaXJlZEhlaWdodCAqPSBzY2FsZU1pbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVldE9yU2xpY2UgPT09ICdzbGljZScpIHtcbiAgICAgICAgICAgIGZpbmFsRGVzaXJlZFdpZHRoICo9IHNjYWxlTWF4O1xuICAgICAgICAgICAgZmluYWxEZXNpcmVkSGVpZ2h0ICo9IHNjYWxlTWF4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlZlhQcm9wID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAncmVmWCcsIHJlZlgpO1xuICAgICAgICBjb25zdCByZWZZUHJvcCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3JlZlknLCByZWZZKTtcbiAgICAgICAgY29uc3QgaGFzUmVmcyA9IHJlZlhQcm9wLmhhc1ZhbHVlKCkgJiYgcmVmWVByb3AuaGFzVmFsdWUoKTtcbiAgICAgICAgaWYgKGhhc1JlZnMpIHtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXNjYWxlTWluICogcmVmWFByb3AuZ2V0UGl4ZWxzKCd4JyksIC1zY2FsZU1pbiAqIHJlZllQcm9wLmdldFBpeGVscygneScpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xpcCkge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkQ2xpcFggPSBzY2FsZU1pbiAqIGNsaXBYO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkQ2xpcFkgPSBzY2FsZU1pbiAqIGNsaXBZO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhzY2FsZWRDbGlwWCwgc2NhbGVkQ2xpcFkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh3aWR0aCwgc2NhbGVkQ2xpcFkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oc2NhbGVkQ2xpcFgsIGhlaWdodCk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFzUmVmcykge1xuICAgICAgICAgICAgY29uc3QgaXNNZWV0TWluWSA9IG1lZXRPclNsaWNlID09PSAnbWVldCcgJiYgc2NhbGVNaW4gPT09IHNjYWxlWTtcbiAgICAgICAgICAgIGNvbnN0IGlzU2xpY2VNYXhZID0gbWVldE9yU2xpY2UgPT09ICdzbGljZScgJiYgc2NhbGVNYXggPT09IHNjYWxlWTtcbiAgICAgICAgICAgIGNvbnN0IGlzTWVldE1pblggPSBtZWV0T3JTbGljZSA9PT0gJ21lZXQnICYmIHNjYWxlTWluID09PSBzY2FsZVg7XG4gICAgICAgICAgICBjb25zdCBpc1NsaWNlTWF4WCA9IG1lZXRPclNsaWNlID09PSAnc2xpY2UnICYmIHNjYWxlTWF4ID09PSBzY2FsZVg7XG4gICAgICAgICAgICBpZiAoYWxpZ24uc3RhcnRzV2l0aCgneE1pZCcpICYmIChpc01lZXRNaW5ZIHx8IGlzU2xpY2VNYXhZKSkge1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUod2lkdGggLyAyIC0gZmluYWxEZXNpcmVkV2lkdGggLyAyLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGlnbi5lbmRzV2l0aCgnWU1pZCcpICYmIChpc01lZXRNaW5YIHx8IGlzU2xpY2VNYXhYKSkge1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgaGVpZ2h0IC8gMiAtIGZpbmFsRGVzaXJlZEhlaWdodCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsaWduLnN0YXJ0c1dpdGgoJ3hNYXgnKSAmJiAoaXNNZWV0TWluWSB8fCBpc1NsaWNlTWF4WSkpIHtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoIC0gZmluYWxEZXNpcmVkV2lkdGgsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsaWduLmVuZHNXaXRoKCdZTWF4JykgJiYgKGlzTWVldE1pblggfHwgaXNTbGljZU1heFgpKSB7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCBoZWlnaHQgLSBmaW5hbERlc2lyZWRIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNjYWxlXG4gICAgICAgIHN3aXRjaCh0cnVlKXtcbiAgICAgICAgICAgIGNhc2UgYWxpZ24gPT09ICdub25lJzpcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtZWV0T3JTbGljZSA9PT0gJ21lZXQnOlxuICAgICAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZU1pbiwgc2NhbGVNaW4pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtZWV0T3JTbGljZSA9PT0gJ3NsaWNlJzpcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoc2NhbGVNYXgsIHNjYWxlTWF4KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyB0cmFuc2xhdGVcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtbWluWCwgLW1pblkpO1xuICAgIH1cbiAgICBzdGFydChlbGVtZW50KSB7XG4gICAgICAgIGxldCB7IGVuYWJsZVJlZHJhdyA9ZmFsc2UgLCBpZ25vcmVNb3VzZSA9ZmFsc2UgLCBpZ25vcmVBbmltYXRpb24gPWZhbHNlICwgaWdub3JlRGltZW5zaW9ucyA9ZmFsc2UgLCBpZ25vcmVDbGVhciA9ZmFsc2UgLCBmb3JjZVJlZHJhdyAsIHNjYWxlV2lkdGggLCBzY2FsZUhlaWdodCAsIG9mZnNldFggLCBvZmZzZXRZICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgICAgY29uc3QgeyBtb3VzZSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGZyYW1lRHVyYXRpb24gPSAxMDAwIC8gU2NyZWVuLkZSQU1FUkFURTtcbiAgICAgICAgdGhpcy5pc1JlYWR5TG9jayA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZyYW1lRHVyYXRpb24gPSBmcmFtZUR1cmF0aW9uO1xuICAgICAgICB0aGlzLnJlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+e1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlUmVhZHkgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWFkeSgpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcihlbGVtZW50LCBpZ25vcmVEaW1lbnNpb25zLCBpZ25vcmVDbGVhciwgc2NhbGVXaWR0aCwgc2NhbGVIZWlnaHQsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW5hYmxlUmVkcmF3KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGxldCB0aGVuID0gbm93O1xuICAgICAgICBsZXQgZGVsdGEgPSAwO1xuICAgICAgICBjb25zdCB0aWNrID0gKCk9PntcbiAgICAgICAgICAgIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBkZWx0YSA9IG5vdyAtIHRoZW47XG4gICAgICAgICAgICBpZiAoZGVsdGEgPj0gZnJhbWVEdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoZW4gPSBub3cgLSBkZWx0YSAlIGZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVXBkYXRlKGlnbm9yZUFuaW1hdGlvbiwgZm9yY2VSZWRyYXcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKGVsZW1lbnQsIGlnbm9yZURpbWVuc2lvbnMsIGlnbm9yZUNsZWFyLCBzY2FsZVdpZHRoLCBzY2FsZUhlaWdodCwgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICAgICAgICAgICAgICAgIG1vdXNlLnJ1bkV2ZW50cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFpZ25vcmVNb3VzZSkge1xuICAgICAgICAgICAgbW91c2Uuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVydmFsSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljayk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVydmFsSWQpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZS5jYW5jZWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VzZS5zdG9wKCk7XG4gICAgfVxuICAgIHNob3VsZFVwZGF0ZShpZ25vcmVBbmltYXRpb24sIGZvcmNlUmVkcmF3KSB7XG4gICAgICAgIC8vIG5lZWQgdXBkYXRlIGZyb20gYW5pbWF0aW9ucz9cbiAgICAgICAgaWYgKCFpZ25vcmVBbmltYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZnJhbWVEdXJhdGlvbiAgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRVcGRhdGUxID0gdGhpcy5hbmltYXRpb25zLnJlZHVjZSgoc2hvdWxkVXBkYXRlLCBhbmltYXRpb24pPT5hbmltYXRpb24udXBkYXRlKGZyYW1lRHVyYXRpb24pIHx8IHNob3VsZFVwZGF0ZVxuICAgICAgICAgICAgLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG5lZWQgdXBkYXRlIGZyb20gcmVkcmF3P1xuICAgICAgICBpZiAodHlwZW9mIGZvcmNlUmVkcmF3ID09PSAnZnVuY3Rpb24nICYmIGZvcmNlUmVkcmF3KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc1JlYWR5TG9jayAmJiB0aGlzLmlzUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmVlZCB1cGRhdGUgZnJvbSBtb3VzZSBldmVudHM/XG4gICAgICAgIGlmICh0aGlzLm1vdXNlLmhhc0V2ZW50cygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJlbmRlcihlbGVtZW50LCBpZ25vcmVEaW1lbnNpb25zLCBpZ25vcmVDbGVhciwgc2NhbGVXaWR0aCwgc2NhbGVIZWlnaHQsIG9mZnNldFgsIG9mZnNldFkpIHtcbiAgICAgICAgY29uc3QgeyB2aWV3UG9ydCAsIGN0eCAsIGlzRmlyc3RSZW5kZXIgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBjdHguY2FudmFzO1xuICAgICAgICB2aWV3UG9ydC5jbGVhcigpO1xuICAgICAgICBpZiAoY2FudmFzLndpZHRoICYmIGNhbnZhcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIHZpZXdQb3J0LnNldEN1cnJlbnQoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3aWR0aFN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgnd2lkdGgnKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0U3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCdoZWlnaHQnKTtcbiAgICAgICAgaWYgKCFpZ25vcmVEaW1lbnNpb25zICYmIChpc0ZpcnN0UmVuZGVyIHx8IHR5cGVvZiBzY2FsZVdpZHRoICE9PSAnbnVtYmVyJyAmJiB0eXBlb2Ygc2NhbGVIZWlnaHQgIT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgLy8gc2V0IGNhbnZhcyBzaXplXG4gICAgICAgICAgICBpZiAod2lkdGhTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGhTdHlsZS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICAgICAgICAgIGlmIChjYW52YXMuc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQoY2FudmFzLndpZHRoLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWlnaHRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodFN0eWxlLmdldFBpeGVscygneScpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGNhbnZhcy5zdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQoY2FudmFzLmhlaWdodCwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNXaWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aCB8fCBjYW52YXMud2lkdGg7XG4gICAgICAgIGxldCBjSGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodCB8fCBjYW52YXMuaGVpZ2h0O1xuICAgICAgICBpZiAoaWdub3JlRGltZW5zaW9ucyAmJiB3aWR0aFN0eWxlLmhhc1ZhbHVlKCkgJiYgaGVpZ2h0U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgY1dpZHRoID0gd2lkdGhTdHlsZS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgIGNIZWlnaHQgPSBoZWlnaHRTdHlsZS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3UG9ydC5zZXRDdXJyZW50KGNXaWR0aCwgY0hlaWdodCk7XG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0WCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd4JywgdHJ1ZSkuc2V0VmFsdWUob2Zmc2V0WCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXRZID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3knLCB0cnVlKS5zZXRWYWx1ZShvZmZzZXRZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNjYWxlV2lkdGggPT09ICdudW1iZXInIHx8IHR5cGVvZiBzY2FsZUhlaWdodCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdCb3ggPSB0b051bWJlcnMoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKS5nZXRTdHJpbmcoKSk7XG4gICAgICAgICAgICBsZXQgeFJhdGlvID0gMDtcbiAgICAgICAgICAgIGxldCB5UmF0aW8gPSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2FsZVdpZHRoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoU3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCd3aWR0aCcpO1xuICAgICAgICAgICAgICAgIGlmICh3aWR0aFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeFJhdGlvID0gd2lkdGhTdHlsZS5nZXRQaXhlbHMoJ3gnKSAvIHNjYWxlV2lkdGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2aWV3Qm94WzJdICYmICFpc05hTih2aWV3Qm94WzJdKSkge1xuICAgICAgICAgICAgICAgICAgICB4UmF0aW8gPSB2aWV3Qm94WzJdIC8gc2NhbGVXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjYWxlSGVpZ2h0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodFN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgnaGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGhlaWdodFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeVJhdGlvID0gaGVpZ2h0U3R5bGUuZ2V0UGl4ZWxzKCd5JykgLyBzY2FsZUhlaWdodDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZpZXdCb3hbM10gJiYgIWlzTmFOKHZpZXdCb3hbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgIHlSYXRpbyA9IHZpZXdCb3hbM10gLyBzY2FsZUhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXhSYXRpbykge1xuICAgICAgICAgICAgICAgIHhSYXRpbyA9IHlSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgheVJhdGlvKSB7XG4gICAgICAgICAgICAgICAgeVJhdGlvID0geFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdHJ1ZSkuc2V0VmFsdWUoc2NhbGVXaWR0aCk7XG4gICAgICAgICAgICBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdHJ1ZSkuc2V0VmFsdWUoc2NhbGVIZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtU3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCd0cmFuc2Zvcm0nLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybVN0eWxlLnNldFZhbHVlKFwiXCIuY29uY2F0KHRyYW5zZm9ybVN0eWxlLmdldFN0cmluZygpLCBcIiBzY2FsZShcIikuY29uY2F0KDEgLyB4UmF0aW8sIFwiLCBcIikuY29uY2F0KDEgLyB5UmF0aW8sIFwiKVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xlYXIgYW5kIHJlbmRlclxuICAgICAgICBpZiAoIWlnbm9yZUNsZWFyKSB7XG4gICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNXaWR0aCwgY0hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5yZW5kZXIoY3R4KTtcbiAgICAgICAgaWYgKGlzRmlyc3RSZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaXNGaXJzdFJlbmRlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGN0eCwgeyBmZXRjaCA9ZGVmYXVsdEZldGNoJDEgLCB3aW5kb3cgPWRlZmF1bHRXaW5kb3cgIH0gPSB7fSl7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgICB0aGlzLnZpZXdQb3J0ID0gbmV3IFZpZXdQb3J0KCk7XG4gICAgICAgIHRoaXMubW91c2UgPSBuZXcgTW91c2UodGhpcyk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLndhaXRzID0gW107XG4gICAgICAgIHRoaXMuZnJhbWVEdXJhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMuaXNSZWFkeUxvY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0ZpcnN0UmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbElkID0gbnVsbDtcbiAgICAgICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIGlmICghZmV0Y2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGZpbmQgJ2ZldGNoJyBpbiAnZ2xvYmFsVGhpcycsIHBsZWFzZSBwcm92aWRlIGl0IHZpYSBvcHRpb25zXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmV0Y2ggPSBmZXRjaDtcbiAgICB9XG59XG5TY3JlZW4uZGVmYXVsdFdpbmRvdyA9IGRlZmF1bHRXaW5kb3c7XG5TY3JlZW4uZGVmYXVsdEZldGNoID0gZGVmYXVsdEZldGNoJDE7XG5TY3JlZW4uRlJBTUVSQVRFID0gMzA7XG5TY3JlZW4uTUFYX1ZJUlRVQUxfUElYRUxTID0gMzAwMDA7XG5cbmNvbnN0IHsgZGVmYXVsdEZldGNoICB9ID0gU2NyZWVuO1xuY29uc3QgRGVmYXVsdERPTVBhcnNlciA9IHR5cGVvZiBET01QYXJzZXIgIT09ICd1bmRlZmluZWQnID8gRE9NUGFyc2VyIDogdW5kZWZpbmVkO1xuY2xhc3MgUGFyc2VyIHtcbiAgICBhc3luYyBwYXJzZShyZXNvdXJjZSkge1xuICAgICAgICBpZiAocmVzb3VyY2Uuc3RhcnRzV2l0aCgnPCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZyb21TdHJpbmcocmVzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWQocmVzb3VyY2UpO1xuICAgIH1cbiAgICBwYXJzZUZyb21TdHJpbmcoeG1sKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyB0aGlzLkRPTVBhcnNlcigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tEb2N1bWVudChwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ2ltYWdlL3N2Zyt4bWwnKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tEb2N1bWVudChwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ3RleHQveG1sJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VyRXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgncGFyc2VyZXJyb3InKVswXTtcbiAgICAgICAgaWYgKHBhcnNlckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocGFyc2VyRXJyb3IudGV4dENvbnRlbnQgfHwgJ1Vua25vd24gcGFyc2UgZXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfVxuICAgIGFzeW5jIGxvYWQodXJsKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCh1cmwpO1xuICAgICAgICBjb25zdCB4bWwgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnJvbVN0cmluZyh4bWwpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih7IGZldGNoID1kZWZhdWx0RmV0Y2ggLCBET01QYXJzZXIgPURlZmF1bHRET01QYXJzZXIgIH0gPSB7fSl7XG4gICAgICAgIGlmICghZmV0Y2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGZpbmQgJ2ZldGNoJyBpbiAnZ2xvYmFsVGhpcycsIHBsZWFzZSBwcm92aWRlIGl0IHZpYSBvcHRpb25zXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRE9NUGFyc2VyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBmaW5kICdET01QYXJzZXInIGluICdnbG9iYWxUaGlzJywgcGxlYXNlIHByb3ZpZGUgaXQgdmlhIG9wdGlvbnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mZXRjaCA9IGZldGNoO1xuICAgICAgICB0aGlzLkRPTVBhcnNlciA9IERPTVBhcnNlcjtcbiAgICB9XG59XG5cbmNsYXNzIFRyYW5zbGF0ZSB7XG4gICAgYXBwbHkoY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSB0aGlzLnBvaW50O1xuICAgICAgICBjdHgudHJhbnNsYXRlKHggfHwgMCwgeSB8fCAwKTtcbiAgICB9XG4gICAgdW5hcHBseShjdHgpIHtcbiAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IHRoaXMucG9pbnQ7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLTEgKiB4IHx8IDAsIC0xICogeSB8fCAwKTtcbiAgICB9XG4gICAgYXBwbHlUb1BvaW50KHBvaW50KSB7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSB0aGlzLnBvaW50O1xuICAgICAgICBwb2ludC5hcHBseVRyYW5zZm9ybShbXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgeCB8fCAwLFxuICAgICAgICAgICAgeSB8fCAwXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihfLCBwb2ludCl7XG4gICAgICAgIHRoaXMudHlwZSA9ICd0cmFuc2xhdGUnO1xuICAgICAgICB0aGlzLnBvaW50ID0gUG9pbnQucGFyc2UocG9pbnQpO1xuICAgIH1cbn1cblxuY2xhc3MgUm90YXRlIHtcbiAgICBhcHBseShjdHgpIHtcbiAgICAgICAgY29uc3QgeyBjeCAsIGN5ICwgb3JpZ2luWCAsIG9yaWdpblkgLCBhbmdsZSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHR4ID0gY3ggKyBvcmlnaW5YLmdldFBpeGVscygneCcpO1xuICAgICAgICBjb25zdCB0eSA9IGN5ICsgb3JpZ2luWS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICBjdHgucm90YXRlKGFuZ2xlLmdldFJhZGlhbnMoKSk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLXR4LCAtdHkpO1xuICAgIH1cbiAgICB1bmFwcGx5KGN0eCkge1xuICAgICAgICBjb25zdCB7IGN4ICwgY3kgLCBvcmlnaW5YICwgb3JpZ2luWSAsIGFuZ2xlICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdHggPSBjeCArIG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IHR5ID0gY3kgKyBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIGN0eC5yb3RhdGUoLTEgKiBhbmdsZS5nZXRSYWRpYW5zKCkpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgICB9XG4gICAgYXBwbHlUb1BvaW50KHBvaW50KSB7XG4gICAgICAgIGNvbnN0IHsgY3ggLCBjeSAsIGFuZ2xlICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcmFkID0gYW5nbGUuZ2V0UmFkaWFucygpO1xuICAgICAgICBwb2ludC5hcHBseVRyYW5zZm9ybShbXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgY3ggfHwgMCxcbiAgICAgICAgICAgIGN5IHx8IDAgLy8gdGhpcy5wLnlcbiAgICAgICAgXSk7XG4gICAgICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKFtcbiAgICAgICAgICAgIE1hdGguY29zKHJhZCksXG4gICAgICAgICAgICBNYXRoLnNpbihyYWQpLFxuICAgICAgICAgICAgLU1hdGguc2luKHJhZCksXG4gICAgICAgICAgICBNYXRoLmNvcyhyYWQpLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDBcbiAgICAgICAgXSk7XG4gICAgICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKFtcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAtY3ggfHwgMCxcbiAgICAgICAgICAgIC1jeSB8fCAwIC8vIC10aGlzLnAueVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHJvdGF0ZSwgdHJhbnNmb3JtT3JpZ2luKXtcbiAgICAgICAgdGhpcy50eXBlID0gJ3JvdGF0ZSc7XG4gICAgICAgIGNvbnN0IG51bWJlcnMgPSB0b051bWJlcnMocm90YXRlKTtcbiAgICAgICAgdGhpcy5hbmdsZSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2FuZ2xlJywgbnVtYmVyc1swXSk7XG4gICAgICAgIHRoaXMub3JpZ2luWCA9IHRyYW5zZm9ybU9yaWdpblswXTtcbiAgICAgICAgdGhpcy5vcmlnaW5ZID0gdHJhbnNmb3JtT3JpZ2luWzFdO1xuICAgICAgICB0aGlzLmN4ID0gbnVtYmVyc1sxXSB8fCAwO1xuICAgICAgICB0aGlzLmN5ID0gbnVtYmVyc1syXSB8fCAwO1xuICAgIH1cbn1cblxuY2xhc3MgU2NhbGUge1xuICAgIGFwcGx5KGN0eCkge1xuICAgICAgICBjb25zdCB7IHNjYWxlOiB7IHggLCB5ICB9ICwgb3JpZ2luWCAsIG9yaWdpblkgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB0eCA9IG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IHR5ID0gb3JpZ2luWS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICBjdHguc2NhbGUoeCwgeSB8fCB4KTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gICAgfVxuICAgIHVuYXBwbHkoY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgc2NhbGU6IHsgeCAsIHkgIH0gLCBvcmlnaW5YICwgb3JpZ2luWSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHR4ID0gb3JpZ2luWC5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgY29uc3QgdHkgPSBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIGN0eC5zY2FsZSgxIC8geCwgMSAvIHkgfHwgeCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLXR4LCAtdHkpO1xuICAgIH1cbiAgICBhcHBseVRvUG9pbnQocG9pbnQpIHtcbiAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IHRoaXMuc2NhbGU7XG4gICAgICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKFtcbiAgICAgICAgICAgIHggfHwgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgeSB8fCAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDBcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF8sIHNjYWxlLCB0cmFuc2Zvcm1PcmlnaW4pe1xuICAgICAgICB0aGlzLnR5cGUgPSAnc2NhbGUnO1xuICAgICAgICBjb25zdCBzY2FsZVNpemUgPSBQb2ludC5wYXJzZVNjYWxlKHNjYWxlKTtcbiAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3Igbm9kZS1jYW52YXNcbiAgICAgICAgaWYgKHNjYWxlU2l6ZS54ID09PSAwIHx8IHNjYWxlU2l6ZS55ID09PSAwKSB7XG4gICAgICAgICAgICBzY2FsZVNpemUueCA9IFBTRVVET19aRVJPO1xuICAgICAgICAgICAgc2NhbGVTaXplLnkgPSBQU0VVRE9fWkVSTztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGVTaXplO1xuICAgICAgICB0aGlzLm9yaWdpblggPSB0cmFuc2Zvcm1PcmlnaW5bMF07XG4gICAgICAgIHRoaXMub3JpZ2luWSA9IHRyYW5zZm9ybU9yaWdpblsxXTtcbiAgICB9XG59XG5cbmNsYXNzIE1hdHJpeCB7XG4gICAgYXBwbHkoY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgb3JpZ2luWCAsIG9yaWdpblkgLCBtYXRyaXggIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB0eCA9IG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IHR5ID0gb3JpZ2luWS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICBjdHgudHJhbnNmb3JtKG1hdHJpeFswXSwgbWF0cml4WzFdLCBtYXRyaXhbMl0sIG1hdHJpeFszXSwgbWF0cml4WzRdLCBtYXRyaXhbNV0pO1xuICAgICAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgICB9XG4gICAgdW5hcHBseShjdHgpIHtcbiAgICAgICAgY29uc3QgeyBvcmlnaW5YICwgb3JpZ2luWSAsIG1hdHJpeCAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGEgPSBtYXRyaXhbMF07XG4gICAgICAgIGNvbnN0IGIgPSBtYXRyaXhbMl07XG4gICAgICAgIGNvbnN0IGMgPSBtYXRyaXhbNF07XG4gICAgICAgIGNvbnN0IGQgPSBtYXRyaXhbMV07XG4gICAgICAgIGNvbnN0IGUgPSBtYXRyaXhbM107XG4gICAgICAgIGNvbnN0IGYgPSBtYXRyaXhbNV07XG4gICAgICAgIGNvbnN0IGcgPSAwO1xuICAgICAgICBjb25zdCBoID0gMDtcbiAgICAgICAgY29uc3QgaSA9IDE7XG4gICAgICAgIGNvbnN0IGRldCA9IDEgLyAoYSAqIChlICogaSAtIGYgKiBoKSAtIGIgKiAoZCAqIGkgLSBmICogZykgKyBjICogKGQgKiBoIC0gZSAqIGcpKTtcbiAgICAgICAgY29uc3QgdHggPSBvcmlnaW5YLmdldFBpeGVscygneCcpO1xuICAgICAgICBjb25zdCB0eSA9IG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybShkZXQgKiAoZSAqIGkgLSBmICogaCksIGRldCAqIChmICogZyAtIGQgKiBpKSwgZGV0ICogKGMgKiBoIC0gYiAqIGkpLCBkZXQgKiAoYSAqIGkgLSBjICogZyksIGRldCAqIChiICogZiAtIGMgKiBlKSwgZGV0ICogKGMgKiBkIC0gYSAqIGYpKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gICAgfVxuICAgIGFwcGx5VG9Qb2ludChwb2ludCkge1xuICAgICAgICBwb2ludC5hcHBseVRyYW5zZm9ybSh0aGlzLm1hdHJpeCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF8sIG1hdHJpeCwgdHJhbnNmb3JtT3JpZ2luKXtcbiAgICAgICAgdGhpcy50eXBlID0gJ21hdHJpeCc7XG4gICAgICAgIHRoaXMubWF0cml4ID0gdG9NYXRyaXhWYWx1ZShtYXRyaXgpO1xuICAgICAgICB0aGlzLm9yaWdpblggPSB0cmFuc2Zvcm1PcmlnaW5bMF07XG4gICAgICAgIHRoaXMub3JpZ2luWSA9IHRyYW5zZm9ybU9yaWdpblsxXTtcbiAgICB9XG59XG5cbmNsYXNzIFNrZXcgZXh0ZW5kcyBNYXRyaXgge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3NrZXcnO1xuICAgICAgICB0aGlzLmFuZ2xlID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnYW5nbGUnLCBza2V3KTtcbiAgICB9XG59XG5cbmNsYXNzIFNrZXdYIGV4dGVuZHMgU2tldyB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHNrZXcsIHRyYW5zZm9ybU9yaWdpbil7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pO1xuICAgICAgICB0aGlzLnR5cGUgPSAnc2tld1gnO1xuICAgICAgICB0aGlzLm1hdHJpeCA9IFtcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgTWF0aC50YW4odGhpcy5hbmdsZS5nZXRSYWRpYW5zKCkpLFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwXG4gICAgICAgIF07XG4gICAgfVxufVxuXG5jbGFzcyBTa2V3WSBleHRlbmRzIFNrZXcge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3NrZXdZJztcbiAgICAgICAgdGhpcy5tYXRyaXggPSBbXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgTWF0aC50YW4odGhpcy5hbmdsZS5nZXRSYWRpYW5zKCkpLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMFxuICAgICAgICBdO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm1zKHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBjb21wcmVzc1NwYWNlcyh0cmFuc2Zvcm0pLnRyaW0oKS5yZXBsYWNlKC9cXCkoW2EtekEtWl0pL2csICcpICQxJykucmVwbGFjZSgvXFwpKFxccz8sXFxzPykvZywgJykgJykuc3BsaXQoL1xccyg/PVthLXpdKS8pO1xufVxuZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgY29uc3QgW3R5cGUgPSAnJywgdmFsdWUgPSAnJ10gPSB0cmFuc2Zvcm0uc3BsaXQoJygnKTtcbiAgICByZXR1cm4gW1xuICAgICAgICB0eXBlLnRyaW0oKSxcbiAgICAgICAgdmFsdWUudHJpbSgpLnJlcGxhY2UoJyknLCAnJylcbiAgICBdO1xufVxuY2xhc3MgVHJhbnNmb3JtIHtcbiAgICBzdGF0aWMgZnJvbUVsZW1lbnQoZG9jdW1lbnQsIGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtU3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCd0cmFuc2Zvcm0nLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1TdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBbdHJhbnNmb3JtT3JpZ2luWFByb3BlcnR5LCB0cmFuc2Zvcm1PcmlnaW5ZUHJvcGVydHkgPSB0cmFuc2Zvcm1PcmlnaW5YUHJvcGVydHldID0gZWxlbWVudC5nZXRTdHlsZSgndHJhbnNmb3JtLW9yaWdpbicsIGZhbHNlLCB0cnVlKS5zcGxpdCgpO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybU9yaWdpblhQcm9wZXJ0eSAmJiB0cmFuc2Zvcm1PcmlnaW5ZUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1PcmlnaW4gPSBbXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpblhQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luWVByb3BlcnR5XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShkb2N1bWVudCwgdHJhbnNmb3JtU3R5bGUuZ2V0U3RyaW5nKCksIHRyYW5zZm9ybU9yaWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFwcGx5KGN0eCkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybXMuZm9yRWFjaCgodHJhbnNmb3JtKT0+dHJhbnNmb3JtLmFwcGx5KGN0eClcbiAgICAgICAgKTtcbiAgICB9XG4gICAgdW5hcHBseShjdHgpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1zLmZvckVhY2goKHRyYW5zZm9ybSk9PnRyYW5zZm9ybS51bmFwcGx5KGN0eClcbiAgICAgICAgKTtcbiAgICB9XG4gICAgLy8gVE9ETzogYXBwbHlUb1BvaW50IHVudXNlZCAuLi4gcmVtb3ZlP1xuICAgIGFwcGx5VG9Qb2ludChwb2ludCkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybXMuZm9yRWFjaCgodHJhbnNmb3JtKT0+dHJhbnNmb3JtLmFwcGx5VG9Qb2ludChwb2ludClcbiAgICAgICAgKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHRyYW5zZm9ybTEsIHRyYW5zZm9ybU9yaWdpbil7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1zID0gW107XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwYXJzZVRyYW5zZm9ybXModHJhbnNmb3JtMSk7XG4gICAgICAgIGRhdGEuZm9yRWFjaCgodHJhbnNmb3JtKT0+e1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW3R5cGUsIHZhbHVlXSA9IHBhcnNlVHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgICAgICBjb25zdCBUcmFuc2Zvcm1UeXBlID0gVHJhbnNmb3JtLnRyYW5zZm9ybVR5cGVzW3R5cGVdO1xuICAgICAgICAgICAgaWYgKFRyYW5zZm9ybVR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybXMucHVzaChuZXcgVHJhbnNmb3JtVHlwZSh0aGlzLmRvY3VtZW50LCB2YWx1ZSwgdHJhbnNmb3JtT3JpZ2luKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblRyYW5zZm9ybS50cmFuc2Zvcm1UeXBlcyA9IHtcbiAgICB0cmFuc2xhdGU6IFRyYW5zbGF0ZSxcbiAgICByb3RhdGU6IFJvdGF0ZSxcbiAgICBzY2FsZTogU2NhbGUsXG4gICAgbWF0cml4OiBNYXRyaXgsXG4gICAgc2tld1g6IFNrZXdYLFxuICAgIHNrZXdZOiBTa2V3WVxufTtcblxuY2xhc3MgRWxlbWVudCB7XG4gICAgZ2V0QXR0cmlidXRlKG5hbWUpIHtcbiAgICAgICAgbGV0IGNyZWF0ZUlmTm90RXhpc3RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgICAgY29uc3QgYXR0ciA9IHRoaXMuYXR0cmlidXRlcy5nZXQobmFtZSk7XG4gICAgICAgIGlmICghYXR0ciAmJiBjcmVhdGVJZk5vdEV4aXN0cykge1xuICAgICAgICAgICAgY29uc3QgYXR0ciA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCBuYW1lLCAnJyk7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMuc2V0KG5hbWUsIGF0dHIpO1xuICAgICAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHIgfHwgUHJvcGVydHkuZW1wdHkodGhpcy5kb2N1bWVudCk7XG4gICAgfVxuICAgIGdldEhyZWZBdHRyaWJ1dGUoKSB7XG4gICAgICAgIGxldCBocmVmO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLmF0dHJpYnV0ZXMpe1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2hyZWYnIHx8IGtleS5lbmRzV2l0aCgnOmhyZWYnKSkge1xuICAgICAgICAgICAgICAgIGhyZWYgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHJlZiB8fCBQcm9wZXJ0eS5lbXB0eSh0aGlzLmRvY3VtZW50KTtcbiAgICB9XG4gICAgZ2V0U3R5bGUobmFtZSkge1xuICAgICAgICBsZXQgY3JlYXRlSWZOb3RFeGlzdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlLCBza2lwQW5jZXN0b3JzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSB0aGlzLnN0eWxlcy5nZXQobmFtZSk7XG4gICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgaWYgKGF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZXMuc2V0KG5hbWUsIGF0dHIpIC8vIG1vdmUgdXAgdG8gbWUgdG8gY2FjaGVcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHJldHVybiBhdHRyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2tpcEFuY2VzdG9ycykge1xuICAgICAgICAgICAgY29uc3QgeyBwYXJlbnQgIH0gPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFN0eWxlID0gcGFyZW50LmdldFN0eWxlKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRTdHlsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNyZWF0ZUlmTm90RXhpc3RzKSB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZSA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCBuYW1lLCAnJyk7XG4gICAgICAgICAgICB0aGlzLnN0eWxlcy5zZXQobmFtZSwgc3R5bGUpO1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9wZXJ0eS5lbXB0eSh0aGlzLmRvY3VtZW50KTtcbiAgICB9XG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICAvLyBkb24ndCByZW5kZXIgZGlzcGxheT1ub25lXG4gICAgICAgIC8vIGRvbid0IHJlbmRlciB2aXNpYmlsaXR5PWhpZGRlblxuICAgICAgICBpZiAodGhpcy5nZXRTdHlsZSgnZGlzcGxheScpLmdldFN0cmluZygpID09PSAnbm9uZScgfHwgdGhpcy5nZXRTdHlsZSgndmlzaWJpbGl0eScpLmdldFN0cmluZygpID09PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGlmICh0aGlzLmdldFN0eWxlKCdtYXNrJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IHRoaXMuZ2V0U3R5bGUoJ21hc2snKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICBpZiAobWFzaykge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKGN0eCk7XG4gICAgICAgICAgICAgICAgbWFzay5hcHBseShjdHgsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0U3R5bGUoJ2ZpbHRlcicpLmdldFZhbHVlKCdub25lJykgIT09ICdub25lJykge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gdGhpcy5nZXRTdHlsZSgnZmlsdGVyJykuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKGN0eCk7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmFwcGx5KGN0eCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldENvbnRleHQoY3R4KTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4oY3R4KTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgc2V0Q29udGV4dChfKSB7XG4gICAgLy8gTk8gUkVOREVSXG4gICAgfVxuICAgIGFwcGx5RWZmZWN0cyhjdHgpIHtcbiAgICAgICAgLy8gdHJhbnNmb3JtXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IFRyYW5zZm9ybS5mcm9tRWxlbWVudCh0aGlzLmRvY3VtZW50LCB0aGlzKTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtLmFwcGx5KGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xpcFxuICAgICAgICBjb25zdCBjbGlwUGF0aFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2NsaXAtcGF0aCcsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgaWYgKGNsaXBQYXRoU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsaXAgPSBjbGlwUGF0aFN0eWxlUHJvcC5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICBpZiAoY2xpcCkge1xuICAgICAgICAgICAgICAgIGNsaXAuYXBwbHkoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhckNvbnRleHQoXykge1xuICAgIC8vIE5PIFJFTkRFUlxuICAgIH1cbiAgICByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCk9PntcbiAgICAgICAgICAgIGNoaWxkLnJlbmRlcihjdHgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkQ2hpbGQoY2hpbGROb2RlKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGROb2RlIGluc3RhbmNlb2YgRWxlbWVudCA/IGNoaWxkTm9kZSA6IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjaGlsZE5vZGUpO1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICBpZiAoIUVsZW1lbnQuaWdub3JlQ2hpbGRUeXBlcy5pbmNsdWRlcyhjaGlsZC50eXBlKSkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgY29uc3QgeyBub2RlICB9ID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlLm1hdGNoZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0eWxlQ2xhc3NlcyA9IChyZWYgPSBub2RlLmdldEF0dHJpYnV0ZSkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuY2FsbChub2RlLCAnY2xhc3MnKTtcbiAgICAgICAgaWYgKCFzdHlsZUNsYXNzZXMgfHwgc3R5bGVDbGFzc2VzID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZUNsYXNzZXMuc3BsaXQoJyAnKS5zb21lKChzdHlsZUNsYXNzKT0+XCIuXCIuY29uY2F0KHN0eWxlQ2xhc3MpID09PSBzZWxlY3RvclxuICAgICAgICApO1xuICAgIH1cbiAgICBhZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uKCkge1xuICAgICAgICBjb25zdCB7IHN0eWxlcyAsIHN0eWxlc1NwZWNpZmljaXR5ICB9ID0gdGhpcy5kb2N1bWVudDtcbiAgICAgICAgZm9yIChjb25zdCBbc2VsZWN0b3IsIHN0eWxlXSBvZiBzdHlsZXMpe1xuICAgICAgICAgICAgaWYgKCFzZWxlY3Rvci5zdGFydHNXaXRoKCdAJykgJiYgdGhpcy5tYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BlY2lmaWNpdHkgPSBzdHlsZXNTcGVjaWZpY2l0eS5nZXQoc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBzdHlsZVByb3BdIG9mIHN0eWxlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBleGlzdGluZ1NwZWNpZmljaXR5ID0gdGhpcy5zdHlsZXNTcGVjaWZpY2l0eS5nZXQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4aXN0aW5nU3BlY2lmaWNpdHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdTcGVjaWZpY2l0eSA9ICcwMDAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNpZmljaXR5ICYmIHNwZWNpZmljaXR5ID49IGV4aXN0aW5nU3BlY2lmaWNpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzLnNldChuYW1lLCBzdHlsZVByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlc1NwZWNpZmljaXR5LnNldChuYW1lLCBzcGVjaWZpY2l0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlU3R5bGVzKGVsZW1lbnQsIGlnbm9yZVN0eWxlcykge1xuICAgICAgICBjb25zdCB0b1Jlc3RvcmUxID0gaWdub3JlU3R5bGVzLnJlZHVjZSgodG9SZXN0b3JlLCBuYW1lKT0+e1xuICAgICAgICAgICAgY29uc3Qgc3R5bGVQcm9wID0gZWxlbWVudC5nZXRTdHlsZShuYW1lKTtcbiAgICAgICAgICAgIGlmICghc3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9SZXN0b3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZVByb3AuZ2V0U3RyaW5nKCk7XG4gICAgICAgICAgICBzdHlsZVByb3Auc2V0VmFsdWUoJycpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAuLi50b1Jlc3RvcmUsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmV0dXJuIHRvUmVzdG9yZTE7XG4gICAgfVxuICAgIHJlc3RvcmVTdHlsZXMoZWxlbWVudCwgc3R5bGVzKSB7XG4gICAgICAgIHN0eWxlcy5mb3JFYWNoKChwYXJhbSk9PntcbiAgICAgICAgICAgIGxldCBbbmFtZSwgdmFsdWVdID0gcGFyYW07XG4gICAgICAgICAgICBlbGVtZW50LmdldFN0eWxlKG5hbWUsIHRydWUpLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzRmlyc3RDaGlsZCgpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcmV0dXJuICgocmVmID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmNoaWxkcmVuLmluZGV4T2YodGhpcykpID09PSAwO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2RlcyA9IGZhbHNlKXtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmNhcHR1cmVUZXh0Tm9kZXMgPSBjYXB0dXJlVGV4dE5vZGVzO1xuICAgICAgICB0aGlzLnR5cGUgPSAnJztcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zdHlsZXNTcGVjaWZpY2l0eSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25Gcm96ZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25Gcm96ZW5WYWx1ZSA9ICcnO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgYXR0cmlidXRlc1xuICAgICAgICBBcnJheS5mcm9tKG5vZGUuYXR0cmlidXRlcykuZm9yRWFjaCgoYXR0cmlidXRlKT0+e1xuICAgICAgICAgICAgY29uc3Qgbm9kZU5hbWUgPSBub3JtYWxpemVBdHRyaWJ1dGVOYW1lKGF0dHJpYnV0ZS5ub2RlTmFtZSk7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMuc2V0KG5vZGVOYW1lLCBuZXcgUHJvcGVydHkoZG9jdW1lbnQsIG5vZGVOYW1lLCBhdHRyaWJ1dGUudmFsdWUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkU3R5bGVzRnJvbVN0eWxlRGVmaW5pdGlvbigpO1xuICAgICAgICAvLyBhZGQgaW5saW5lIHN0eWxlc1xuICAgICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGVzID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykuZ2V0U3RyaW5nKCkuc3BsaXQoJzsnKS5tYXAoKF8pPT5fLnRyaW0oKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHN0eWxlcy5mb3JFYWNoKChzdHlsZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgW25hbWUsIHZhbHVlXSA9IHN0eWxlLnNwbGl0KCc6JykubWFwKChfKT0+Xy50cmltKClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzLnNldChuYW1lLCBuZXcgUHJvcGVydHkoZG9jdW1lbnQsIG5hbWUsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBkZWZpbml0aW9ucyAgfSA9IGRvY3VtZW50O1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAvLyBhZGQgaWRcbiAgICAgICAgaWYgKGlkLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIGlmICghZGVmaW5pdGlvbnMuaGFzKGlkLmdldFN0cmluZygpKSkge1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb25zLnNldChpZC5nZXRTdHJpbmcoKSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpLmZvckVhY2goKGNoaWxkTm9kZSk9PntcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkKGNoaWxkTm9kZSkgLy8gRUxFTUVOVF9OT0RFXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjYXB0dXJlVGV4dE5vZGVzICYmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDMgfHwgY2hpbGROb2RlLm5vZGVUeXBlID09PSA0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dE5vZGUuZ2V0VGV4dCgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRDaGlsZCh0ZXh0Tm9kZSkgLy8gVEVYVF9OT0RFXG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbkVsZW1lbnQuaWdub3JlQ2hpbGRUeXBlcyA9IFtcbiAgICAndGl0bGUnXG5dO1xuXG5jbGFzcyBVbmtub3duRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gd3JhcEZvbnRGYW1pbHkoZm9udEZhbWlseSkge1xuICAgIGNvbnN0IHRyaW1tZWQgPSBmb250RmFtaWx5LnRyaW0oKTtcbiAgICByZXR1cm4gL14oJ3xcIikvLnRlc3QodHJpbW1lZCkgPyB0cmltbWVkIDogXCJcXFwiXCIuY29uY2F0KHRyaW1tZWQsIFwiXFxcIlwiKTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVGb250RmFtaWx5KGZvbnRGYW1pbHkpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnID8gZm9udEZhbWlseSA6IGZvbnRGYW1pbHkudHJpbSgpLnNwbGl0KCcsJykubWFwKHdyYXBGb250RmFtaWx5KS5qb2luKCcsJyk7XG59XG4vKipcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250LXN0eWxlXG4gKiBAcGFyYW0gZm9udFN0eWxlXG4gKiBAcmV0dXJucyBDU1MgZm9udCBzdHlsZS5cbiAqLyBmdW5jdGlvbiBwcmVwYXJlRm9udFN0eWxlKGZvbnRTdHlsZSkge1xuICAgIGlmICghZm9udFN0eWxlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0Rm9udFN0eWxlID0gZm9udFN0eWxlLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCh0YXJnZXRGb250U3R5bGUpe1xuICAgICAgICBjYXNlICdub3JtYWwnOlxuICAgICAgICBjYXNlICdpdGFsaWMnOlxuICAgICAgICBjYXNlICdvYmxpcXVlJzpcbiAgICAgICAgY2FzZSAnaW5oZXJpdCc6XG4gICAgICAgIGNhc2UgJ2luaXRpYWwnOlxuICAgICAgICBjYXNlICd1bnNldCc6XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0Rm9udFN0eWxlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKC9eb2JsaXF1ZVxccysoLXwpXFxkK2RlZyQvLnRlc3QodGFyZ2V0Rm9udFN0eWxlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRGb250U3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuLyoqXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udC13ZWlnaHRcbiAqIEBwYXJhbSBmb250V2VpZ2h0XG4gKiBAcmV0dXJucyBDU1MgZm9udCB3ZWlnaHQuXG4gKi8gZnVuY3Rpb24gcHJlcGFyZUZvbnRXZWlnaHQoZm9udFdlaWdodCkge1xuICAgIGlmICghZm9udFdlaWdodCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldEZvbnRXZWlnaHQgPSBmb250V2VpZ2h0LnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCh0YXJnZXRGb250V2VpZ2h0KXtcbiAgICAgICAgY2FzZSAnbm9ybWFsJzpcbiAgICAgICAgY2FzZSAnYm9sZCc6XG4gICAgICAgIGNhc2UgJ2xpZ2h0ZXInOlxuICAgICAgICBjYXNlICdib2xkZXInOlxuICAgICAgICBjYXNlICdpbmhlcml0JzpcbiAgICAgICAgY2FzZSAnaW5pdGlhbCc6XG4gICAgICAgIGNhc2UgJ3Vuc2V0JzpcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRGb250V2VpZ2h0O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKC9eW1xcZC5dKyQvLnRlc3QodGFyZ2V0Rm9udFdlaWdodCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0Rm9udFdlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5jbGFzcyBGb250IHtcbiAgICBzdGF0aWMgcGFyc2UoKSB7XG4gICAgICAgIGxldCBmb250ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiAnJywgaW5oZXJpdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xuICAgICAgICBsZXQgZm9udFN0eWxlID0gJyc7XG4gICAgICAgIGxldCBmb250VmFyaWFudCA9ICcnO1xuICAgICAgICBsZXQgZm9udFdlaWdodCA9ICcnO1xuICAgICAgICBsZXQgZm9udFNpemUgPSAnJztcbiAgICAgICAgbGV0IGZvbnRGYW1pbHkgPSAnJztcbiAgICAgICAgY29uc3QgcGFydHMgPSBjb21wcmVzc1NwYWNlcyhmb250KS50cmltKCkuc3BsaXQoJyAnKTtcbiAgICAgICAgY29uc3Qgc2V0ID0ge1xuICAgICAgICAgICAgZm9udFNpemU6IGZhbHNlLFxuICAgICAgICAgICAgZm9udFN0eWxlOiBmYWxzZSxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IGZhbHNlLFxuICAgICAgICAgICAgZm9udFZhcmlhbnQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHBhcnRzLmZvckVhY2goKHBhcnQpPT57XG4gICAgICAgICAgICBzd2l0Y2godHJ1ZSl7XG4gICAgICAgICAgICAgICAgY2FzZSAhc2V0LmZvbnRTdHlsZSAmJiBGb250LnN0eWxlcy5pbmNsdWRlcyhwYXJ0KTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFN0eWxlID0gcGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXQuZm9udFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAhc2V0LmZvbnRWYXJpYW50ICYmIEZvbnQudmFyaWFudHMuaW5jbHVkZXMocGFydCk6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRWYXJpYW50ID0gcGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXQuZm9udFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0LmZvbnRWYXJpYW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAhc2V0LmZvbnRXZWlnaHQgJiYgRm9udC53ZWlnaHRzLmluY2x1ZGVzKHBhcnQpOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydCAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0ID0gcGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXQuZm9udFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0LmZvbnRWYXJpYW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0LmZvbnRXZWlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICFzZXQuZm9udFNpemU6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplID0gcGFydC5zcGxpdCgnLycpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldC5mb250U3R5bGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzZXQuZm9udFZhcmlhbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzZXQuZm9udFdlaWdodCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNldC5mb250U2l6ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRGYW1pbHkgKz0gcGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBGb250KGZvbnRTdHlsZSwgZm9udFZhcmlhbnQsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5LCBpbmhlcml0KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBwcmVwYXJlRm9udFN0eWxlKHRoaXMuZm9udFN0eWxlKSxcbiAgICAgICAgICAgIHRoaXMuZm9udFZhcmlhbnQsXG4gICAgICAgICAgICBwcmVwYXJlRm9udFdlaWdodCh0aGlzLmZvbnRXZWlnaHQpLFxuICAgICAgICAgICAgdGhpcy5mb250U2l6ZSxcbiAgICAgICAgICAgIC8vIFdyYXAgZm9udEZhbWlseSBvbmx5IG9uIG5vZGVqcyBhbmQgb25seSBmb3IgY2FudmFzLmN0eFxuICAgICAgICAgICAgcHJlcGFyZUZvbnRGYW1pbHkodGhpcy5mb250RmFtaWx5KVxuICAgICAgICBdLmpvaW4oJyAnKS50cmltKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZvbnRTdHlsZSwgZm9udFZhcmlhbnQsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5LCBpbmhlcml0KXtcbiAgICAgICAgY29uc3QgaW5oZXJpdEZvbnQgPSBpbmhlcml0ID8gdHlwZW9mIGluaGVyaXQgPT09ICdzdHJpbmcnID8gRm9udC5wYXJzZShpbmhlcml0KSA6IGluaGVyaXQgOiB7fTtcbiAgICAgICAgdGhpcy5mb250RmFtaWx5ID0gZm9udEZhbWlseSB8fCBpbmhlcml0Rm9udC5mb250RmFtaWx5O1xuICAgICAgICB0aGlzLmZvbnRTaXplID0gZm9udFNpemUgfHwgaW5oZXJpdEZvbnQuZm9udFNpemU7XG4gICAgICAgIHRoaXMuZm9udFN0eWxlID0gZm9udFN0eWxlIHx8IGluaGVyaXRGb250LmZvbnRTdHlsZTtcbiAgICAgICAgdGhpcy5mb250V2VpZ2h0ID0gZm9udFdlaWdodCB8fCBpbmhlcml0Rm9udC5mb250V2VpZ2h0O1xuICAgICAgICB0aGlzLmZvbnRWYXJpYW50ID0gZm9udFZhcmlhbnQgfHwgaW5oZXJpdEZvbnQuZm9udFZhcmlhbnQ7XG4gICAgfVxufVxuRm9udC5zdHlsZXMgPSAnbm9ybWFsfGl0YWxpY3xvYmxpcXVlfGluaGVyaXQnO1xuRm9udC52YXJpYW50cyA9ICdub3JtYWx8c21hbGwtY2Fwc3xpbmhlcml0JztcbkZvbnQud2VpZ2h0cyA9ICdub3JtYWx8Ym9sZHxib2xkZXJ8bGlnaHRlcnwxMDB8MjAwfDMwMHw0MDB8NTAwfDYwMHw3MDB8ODAwfDkwMHxpbmhlcml0JztcblxuY2xhc3MgQm91bmRpbmdCb3gge1xuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy54MTtcbiAgICB9XG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnkxO1xuICAgIH1cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLngyIC0gdGhpcy54MTtcbiAgICB9XG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueTIgLSB0aGlzLnkxO1xuICAgIH1cbiAgICBhZGRQb2ludCh4LCB5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChpc05hTih0aGlzLngxKSB8fCBpc05hTih0aGlzLngyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMueDEgPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMueDIgPSB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHggPCB0aGlzLngxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy54MSA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA+IHRoaXMueDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLngyID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odGhpcy55MSkgfHwgaXNOYU4odGhpcy55MikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnkxID0geTtcbiAgICAgICAgICAgICAgICB0aGlzLnkyID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5IDwgdGhpcy55MSkge1xuICAgICAgICAgICAgICAgIHRoaXMueTEgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkgPiB0aGlzLnkyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy55MiA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkWCh4KSB7XG4gICAgICAgIHRoaXMuYWRkUG9pbnQoeCwgMCk7XG4gICAgfVxuICAgIGFkZFkoeSkge1xuICAgICAgICB0aGlzLmFkZFBvaW50KDAsIHkpO1xuICAgIH1cbiAgICBhZGRCb3VuZGluZ0JveChib3VuZGluZ0JveCkge1xuICAgICAgICBpZiAoIWJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB4MSAsIHkxICwgeDIgLCB5MiAgfSA9IGJvdW5kaW5nQm94O1xuICAgICAgICB0aGlzLmFkZFBvaW50KHgxLCB5MSk7XG4gICAgICAgIHRoaXMuYWRkUG9pbnQoeDIsIHkyKTtcbiAgICB9XG4gICAgc3VtQ3ViaWModCwgcDAsIHAxLCBwMiwgcDMpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDEgLSB0LCAzKSAqIHAwICsgMyAqIE1hdGgucG93KDEgLSB0LCAyKSAqIHQgKiBwMSArIDMgKiAoMSAtIHQpICogTWF0aC5wb3codCwgMikgKiBwMiArIE1hdGgucG93KHQsIDMpICogcDM7XG4gICAgfVxuICAgIGJlemllckN1cnZlQWRkKGZvclgsIHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgICAgIGNvbnN0IGIgPSA2ICogcDAgLSAxMiAqIHAxICsgNiAqIHAyO1xuICAgICAgICBjb25zdCBhID0gLTMgKiBwMCArIDkgKiBwMSAtIDkgKiBwMiArIDMgKiBwMztcbiAgICAgICAgY29uc3QgYyA9IDMgKiBwMSAtIDMgKiBwMDtcbiAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChiID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdCA9IC1jIC8gYjtcbiAgICAgICAgICAgIGlmICgwIDwgdCAmJiB0IDwgMSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3JYKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkWCh0aGlzLnN1bUN1YmljKHQsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRZKHRoaXMuc3VtQ3ViaWModCwgcDAsIHAxLCBwMiwgcDMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYjJhYyA9IE1hdGgucG93KGIsIDIpIC0gNCAqIGMgKiBhO1xuICAgICAgICBpZiAoYjJhYyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0MSA9ICgtYiArIE1hdGguc3FydChiMmFjKSkgLyAoMiAqIGEpO1xuICAgICAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgICAgICAgaWYgKGZvclgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFgodGhpcy5zdW1DdWJpYyh0MSwgcDAsIHAxLCBwMiwgcDMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRZKHRoaXMuc3VtQ3ViaWModDEsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdDIgPSAoLWIgLSBNYXRoLnNxcnQoYjJhYykpIC8gKDIgKiBhKTtcbiAgICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgICAgICAgIGlmIChmb3JYKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRYKHRoaXMuc3VtQ3ViaWModDIsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkWSh0aGlzLnN1bUN1YmljKHQyLCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGZyb20gaHR0cDovL2Jsb2cuaGFja2Vycy1jYWZlLm5ldC8yMDA5LzA2L2hvdy10by1jYWxjdWxhdGUtYmV6aWVyLWN1cnZlcy1ib3VuZGluZy5odG1sXG4gICAgYWRkQmV6aWVyQ3VydmUocDB4LCBwMHksIHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3kpIHtcbiAgICAgICAgdGhpcy5hZGRQb2ludChwMHgsIHAweSk7XG4gICAgICAgIHRoaXMuYWRkUG9pbnQocDN4LCBwM3kpO1xuICAgICAgICB0aGlzLmJlemllckN1cnZlQWRkKHRydWUsIHAweCwgcDF4LCBwMngsIHAzeCk7XG4gICAgICAgIHRoaXMuYmV6aWVyQ3VydmVBZGQoZmFsc2UsIHAweSwgcDF5LCBwMnksIHAzeSk7XG4gICAgfVxuICAgIGFkZFF1YWRyYXRpY0N1cnZlKHAweCwgcDB5LCBwMXgsIHAxeSwgcDJ4LCBwMnkpIHtcbiAgICAgICAgY29uc3QgY3AxeCA9IHAweCArIDIgLyAzICogKHAxeCAtIHAweCkgLy8gQ1AxID0gUVAwICsgMi8zICooUVAxLVFQMClcbiAgICAgICAgO1xuICAgICAgICBjb25zdCBjcDF5ID0gcDB5ICsgMiAvIDMgKiAocDF5IC0gcDB5KSAvLyBDUDEgPSBRUDAgKyAyLzMgKihRUDEtUVAwKVxuICAgICAgICA7XG4gICAgICAgIGNvbnN0IGNwMnggPSBjcDF4ICsgMSAvIDMgKiAocDJ4IC0gcDB4KSAvLyBDUDIgPSBDUDEgKyAxLzMgKihRUDItUVAwKVxuICAgICAgICA7XG4gICAgICAgIGNvbnN0IGNwMnkgPSBjcDF5ICsgMSAvIDMgKiAocDJ5IC0gcDB5KSAvLyBDUDIgPSBDUDEgKyAxLzMgKihRUDItUVAwKVxuICAgICAgICA7XG4gICAgICAgIHRoaXMuYWRkQmV6aWVyQ3VydmUocDB4LCBwMHksIGNwMXgsIGNwMngsIGNwMXksIGNwMnksIHAyeCwgcDJ5KTtcbiAgICB9XG4gICAgaXNQb2ludEluQm94KHgsIHkpIHtcbiAgICAgICAgY29uc3QgeyB4MSAsIHkxICwgeDIgLCB5MiAgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB4MSA8PSB4ICYmIHggPD0geDIgJiYgeTEgPD0geSAmJiB5IDw9IHkyO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih4MSA9IE51bWJlci5OYU4sIHkxID0gTnVtYmVyLk5hTiwgeDIgPSBOdW1iZXIuTmFOLCB5MiA9IE51bWJlci5OYU4pe1xuICAgICAgICB0aGlzLngxID0geDE7XG4gICAgICAgIHRoaXMueTEgPSB5MTtcbiAgICAgICAgdGhpcy54MiA9IHgyO1xuICAgICAgICB0aGlzLnkyID0geTI7XG4gICAgICAgIHRoaXMuYWRkUG9pbnQoeDEsIHkxKTtcbiAgICAgICAgdGhpcy5hZGRQb2ludCh4MiwgeTIpO1xuICAgIH1cbn1cblxuY2xhc3MgUmVuZGVyZWRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgY2FsY3VsYXRlT3BhY2l0eSgpIHtcbiAgICAgICAgbGV0IG9wYWNpdHkgPSAxO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXMsIGNvbnNpc3RlbnQtdGhpc1xuICAgICAgICBsZXQgZWxlbWVudCA9IHRoaXM7XG4gICAgICAgIHdoaWxlKGVsZW1lbnQpe1xuICAgICAgICAgICAgY29uc3Qgb3BhY2l0eVN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgnb3BhY2l0eScsIGZhbHNlLCB0cnVlKSAvLyBubyBhbmNlc3RvcnMgb24gc3R5bGUgY2FsbFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgaWYgKG9wYWNpdHlTdHlsZS5oYXNWYWx1ZSh0cnVlKSkge1xuICAgICAgICAgICAgICAgIG9wYWNpdHkgKj0gb3BhY2l0eVN0eWxlLmdldE51bWJlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcGFjaXR5O1xuICAgIH1cbiAgICBzZXRDb250ZXh0KGN0eCkge1xuICAgICAgICBsZXQgZnJvbU1lYXN1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgICBpZiAoIWZyb21NZWFzdXJlKSB7XG4gICAgICAgICAgICAvLyBmaWxsXG4gICAgICAgICAgICBjb25zdCBmaWxsU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZmlsbCcpO1xuICAgICAgICAgICAgY29uc3QgZmlsbE9wYWNpdHlTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmaWxsLW9wYWNpdHknKTtcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZScpO1xuICAgICAgICAgICAgY29uc3Qgc3Ryb2tlT3BhY2l0eVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2Utb3BhY2l0eScpO1xuICAgICAgICAgICAgaWYgKGZpbGxTdHlsZVByb3AuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsU3R5bGUgPSBmaWxsU3R5bGVQcm9wLmdldEZpbGxTdHlsZURlZmluaXRpb24odGhpcywgZmlsbE9wYWNpdHlTdHlsZVByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChmaWxsU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZpbGxTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWxsU3R5bGVQcm9wLmdldFN0cmluZygpID09PSAnY3VycmVudENvbG9yJykge1xuICAgICAgICAgICAgICAgICAgICBmaWxsU3R5bGVQcm9wLnNldFZhbHVlKHRoaXMuZ2V0U3R5bGUoJ2NvbG9yJykuZ2V0Q29sb3IoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGxTdHlsZSA9IGZpbGxTdHlsZVByb3AuZ2V0Q29sb3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsbFN0eWxlICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZSA9PT0gJ25vbmUnID8gJ3JnYmEoMCwwLDAsMCknIDogZmlsbFN0eWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWxsT3BhY2l0eVN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsbFN0eWxlID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdmaWxsJywgY3R4LmZpbGxTdHlsZSkuYWRkT3BhY2l0eShmaWxsT3BhY2l0eVN0eWxlUHJvcCkuZ2V0Q29sb3IoKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3Ryb2tlXG4gICAgICAgICAgICBpZiAoc3Ryb2tlU3R5bGVQcm9wLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZVByb3AuZ2V0RmlsbFN0eWxlRGVmaW5pdGlvbih0aGlzLCBzdHJva2VPcGFjaXR5UHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cm9rZVN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3Ryb2tlU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Ryb2tlU3R5bGVQcm9wLmdldFN0cmluZygpID09PSAnY3VycmVudENvbG9yJykge1xuICAgICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZVByb3Auc2V0VmFsdWUodGhpcy5nZXRTdHlsZSgnY29sb3InKS5nZXRDb2xvcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZVByb3AuZ2V0U3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cm9rZVN0eWxlICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGUgPT09ICdub25lJyA/ICdyZ2JhKDAsMCwwLDApJyA6IHN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJva2VPcGFjaXR5UHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3N0cm9rZScsIGN0eC5zdHJva2VTdHlsZSkuYWRkT3BhY2l0eShzdHJva2VPcGFjaXR5UHJvcCkuZ2V0U3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJva2VXaWR0aFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS13aWR0aCcpO1xuICAgICAgICAgICAgaWYgKHN0cm9rZVdpZHRoU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdMaW5lV2lkdGggPSBzdHJva2VXaWR0aFN0eWxlUHJvcC5nZXRQaXhlbHMoKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gIW5ld0xpbmVXaWR0aCA/IFBTRVVET19aRVJPIC8vIGJyb3dzZXJzIGRvbid0IHJlc3BlY3QgMCAob3Igbm9kZS1jYW52YXM/IDotKVxuICAgICAgICAgICAgICAgICA6IG5ld0xpbmVXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZUxpbmVjYXBTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UtbGluZWNhcCcpO1xuICAgICAgICAgICAgY29uc3Qgc3Ryb2tlTGluZWpvaW5TdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UtbGluZWpvaW4nKTtcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZU1pdGVybGltaXRQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLW1pdGVybGltaXQnKTtcbiAgICAgICAgICAgIC8vIE5FRUQgVEVTVFxuICAgICAgICAgICAgLy8gY29uc3QgcG9pbnRPcmRlclN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3BhaW50LW9yZGVyJyk7XG4gICAgICAgICAgICBjb25zdCBzdHJva2VEYXNoYXJyYXlTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UtZGFzaGFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBzdHJva2VEYXNob2Zmc2V0UHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jyk7XG4gICAgICAgICAgICBpZiAoc3Ryb2tlTGluZWNhcFN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVDYXAgPSBzdHJva2VMaW5lY2FwU3R5bGVQcm9wLmdldFN0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cm9rZUxpbmVqb2luU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBjdHgubGluZUpvaW4gPSBzdHJva2VMaW5lam9pblN0eWxlUHJvcC5nZXRTdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJva2VNaXRlcmxpbWl0UHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgY3R4Lm1pdGVyTGltaXQgPSBzdHJva2VNaXRlcmxpbWl0UHJvcC5nZXROdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5FRUQgVEVTVFxuICAgICAgICAgICAgLy8gaWYgKHBvaW50T3JkZXJTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgLy8gICAvLyA/XG4gICAgICAgICAgICAvLyAgIGN0eC5wYWludE9yZGVyID0gcG9pbnRPcmRlclN0eWxlUHJvcC5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgaWYgKHN0cm9rZURhc2hhcnJheVN0eWxlUHJvcC5oYXNWYWx1ZSgpICYmIHN0cm9rZURhc2hhcnJheVN0eWxlUHJvcC5nZXRTdHJpbmcoKSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2FwcyA9IHRvTnVtYmVycyhzdHJva2VEYXNoYXJyYXlTdHlsZVByb3AuZ2V0U3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3R4LnNldExpbmVEYXNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2goZ2Fwcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3R4LndlYmtpdExpbmVEYXNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgICAgICAgICAgY3R4LndlYmtpdExpbmVEYXNoID0gZ2FwcztcbiAgICAgICAgICAgICAgICB9IGVsc2UgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdHgubW96RGFzaCAhPT0gJ3VuZGVmaW5lZCcgJiYgIShnYXBzLmxlbmd0aCA9PT0gMSAmJiBnYXBzWzBdID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vekRhc2ggPSBnYXBzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBzdHJva2VEYXNob2Zmc2V0UHJvcC5nZXRQaXhlbHMoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN0eC5saW5lRGFzaE9mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN0eC53ZWJraXRMaW5lRGFzaE9mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICAgICAgICAgIGN0eC53ZWJraXRMaW5lRGFzaE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdHgubW96RGFzaE9mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3pEYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmb250XG4gICAgICAgIHRoaXMubW9kaWZpZWRFbVNpemVTdGFjayA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIGN0eC5mb250ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc3QgZm9udFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQnKTtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTdHlsZVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQtc3R5bGUnKTtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRWYXJpYW50U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC12YXJpYW50Jyk7XG4gICAgICAgICAgICBjb25zdCBmb250V2VpZ2h0U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC13ZWlnaHQnKTtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC1zaXplJyk7XG4gICAgICAgICAgICBjb25zdCBmb250RmFtaWx5U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC1mYW1pbHknKTtcbiAgICAgICAgICAgIGNvbnN0IGZvbnQgPSBuZXcgRm9udChmb250U3R5bGVTdHlsZVByb3AuZ2V0U3RyaW5nKCksIGZvbnRWYXJpYW50U3R5bGVQcm9wLmdldFN0cmluZygpLCBmb250V2VpZ2h0U3R5bGVQcm9wLmdldFN0cmluZygpLCBmb250U2l6ZVN0eWxlUHJvcC5oYXNWYWx1ZSgpID8gXCJcIi5jb25jYXQoZm9udFNpemVTdHlsZVByb3AuZ2V0UGl4ZWxzKHRydWUpLCBcInB4XCIpIDogJycsIGZvbnRGYW1pbHlTdHlsZVByb3AuZ2V0U3RyaW5nKCksIEZvbnQucGFyc2UoZm9udFN0eWxlUHJvcC5nZXRTdHJpbmcoKSwgY3R4LmZvbnQpKTtcbiAgICAgICAgICAgIGZvbnRTdHlsZVN0eWxlUHJvcC5zZXRWYWx1ZShmb250LmZvbnRTdHlsZSk7XG4gICAgICAgICAgICBmb250VmFyaWFudFN0eWxlUHJvcC5zZXRWYWx1ZShmb250LmZvbnRWYXJpYW50KTtcbiAgICAgICAgICAgIGZvbnRXZWlnaHRTdHlsZVByb3Auc2V0VmFsdWUoZm9udC5mb250V2VpZ2h0KTtcbiAgICAgICAgICAgIGZvbnRTaXplU3R5bGVQcm9wLnNldFZhbHVlKGZvbnQuZm9udFNpemUpO1xuICAgICAgICAgICAgZm9udEZhbWlseVN0eWxlUHJvcC5zZXRWYWx1ZShmb250LmZvbnRGYW1pbHkpO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBmb250LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoZm9udFNpemVTdHlsZVByb3AuaXNQaXhlbHMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuZW1TaXplID0gZm9udFNpemVTdHlsZVByb3AuZ2V0UGl4ZWxzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZmllZEVtU2l6ZVN0YWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZyb21NZWFzdXJlKSB7XG4gICAgICAgICAgICAvLyBlZmZlY3RzXG4gICAgICAgICAgICB0aGlzLmFwcGx5RWZmZWN0cyhjdHgpO1xuICAgICAgICAgICAgLy8gb3BhY2l0eVxuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jYWxjdWxhdGVPcGFjaXR5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJDb250ZXh0KGN0eCkge1xuICAgICAgICBzdXBlci5jbGVhckNvbnRleHQoY3R4KTtcbiAgICAgICAgaWYgKHRoaXMubW9kaWZpZWRFbVNpemVTdGFjaykge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5wb3BFbVNpemUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMubW9kaWZpZWRFbVNpemVTdGFjayA9IGZhbHNlO1xuICAgIH1cbn1cblxuY2xhc3MgVGV4dEVsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICAgIHNldENvbnRleHQoY3R4KSB7XG4gICAgICAgIGxldCBmcm9tTWVhc3VyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICAgIHN1cGVyLnNldENvbnRleHQoY3R4LCBmcm9tTWVhc3VyZSk7XG4gICAgICAgIGNvbnN0IHRleHRCYXNlbGluZSA9IHRoaXMuZ2V0U3R5bGUoJ2RvbWluYW50LWJhc2VsaW5lJykuZ2V0VGV4dEJhc2VsaW5lKCkgfHwgdGhpcy5nZXRTdHlsZSgnYWxpZ25tZW50LWJhc2VsaW5lJykuZ2V0VGV4dEJhc2VsaW5lKCk7XG4gICAgICAgIGlmICh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdGlhbGl6ZUNvb3JkaW5hdGVzKCkge1xuICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICB0aGlzLmxlYWZUZXh0cyA9IFtdO1xuICAgICAgICB0aGlzLnRleHRDaHVua1N0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5taW5YID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB0aGlzLm1heFggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgfVxuICAgIGdldEJvdW5kaW5nQm94KGN0eCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRFbGVtZW50Qm91bmRpbmdCb3goY3R4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaXJzdCwgY2FsY3VsYXRlIGNoaWxkIHBvc2l0aW9uc1xuICAgICAgICB0aGlzLmluaXRpYWxpemVDb29yZGluYXRlcygpO1xuICAgICAgICB0aGlzLmFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmUoY3R4KTtcbiAgICAgICAgbGV0IGJvdW5kaW5nQm94ID0gbnVsbDtcbiAgICAgICAgLy8gdGhlbiBjYWxjdWxhdGUgYm91bmRpbmcgYm94XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoXywgaSk9PntcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQm91bmRpbmdCb3ggPSB0aGlzLmdldENoaWxkQm91bmRpbmdCb3goY3R4LCB0aGlzLCB0aGlzLCBpKTtcbiAgICAgICAgICAgIGlmICghYm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgICAgICBib3VuZGluZ0JveCA9IGNoaWxkQm91bmRpbmdCb3g7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvdW5kaW5nQm94LmFkZEJvdW5kaW5nQm94KGNoaWxkQm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICAgIH1cbiAgICBnZXRGb250U2l6ZSgpIHtcbiAgICAgICAgY29uc3QgeyBkb2N1bWVudCAsIHBhcmVudCAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGluaGVyaXRGb250U2l6ZSA9IEZvbnQucGFyc2UoZG9jdW1lbnQuY3R4LmZvbnQpLmZvbnRTaXplO1xuICAgICAgICBjb25zdCBmb250U2l6ZSA9IHBhcmVudC5nZXRTdHlsZSgnZm9udC1zaXplJykuZ2V0TnVtYmVyKGluaGVyaXRGb250U2l6ZSk7XG4gICAgICAgIHJldHVybiBmb250U2l6ZTtcbiAgICB9XG4gICAgZ2V0VEVsZW1lbnRCb3VuZGluZ0JveChjdHgpIHtcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3godGhpcy54LCB0aGlzLnkgLSBmb250U2l6ZSwgdGhpcy54ICsgdGhpcy5tZWFzdXJlVGV4dChjdHgpLCB0aGlzLnkpO1xuICAgIH1cbiAgICBnZXRHbHlwaChmb250LCB0ZXh0LCBpKSB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSB0ZXh0W2ldO1xuICAgICAgICBsZXQgZ2x5cGg7XG4gICAgICAgIGlmIChmb250LmlzQXJhYmljKSB7XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBwcmV2Q2hhciA9IHRleHRbaSAtIDFdO1xuICAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSB0ZXh0W2kgKyAxXTtcbiAgICAgICAgICAgIGxldCBhcmFiaWNGb3JtID0gJ2lzb2xhdGVkJztcbiAgICAgICAgICAgIGlmICgoaSA9PT0gMCB8fCBwcmV2Q2hhciA9PT0gJyAnKSAmJiBpIDwgbGVuIC0gMSAmJiBuZXh0Q2hhciAhPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgYXJhYmljRm9ybSA9ICd0ZXJtaW5hbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+IDAgJiYgcHJldkNoYXIgIT09ICcgJyAmJiBpIDwgbGVuIC0gMSAmJiBuZXh0Q2hhciAhPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgYXJhYmljRm9ybSA9ICdtZWRpYWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPiAwICYmIHByZXZDaGFyICE9PSAnICcgJiYgKGkgPT09IGxlbiAtIDEgfHwgbmV4dENoYXIgPT09ICcgJykpIHtcbiAgICAgICAgICAgICAgICBhcmFiaWNGb3JtID0gJ2luaXRpYWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2x5cGggPSAoKHJlZiA9IGZvbnQuYXJhYmljR2x5cGhzLmdldChjaGFyKSkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuZ2V0KGFyYWJpY0Zvcm0pKSB8fCBmb250LmdseXBocy5nZXQoY2hhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbHlwaCA9IGZvbnQuZ2x5cGhzLmdldChjaGFyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdseXBoKSB7XG4gICAgICAgICAgICBnbHlwaCA9IGZvbnQubWlzc2luZ0dseXBoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbHlwaDtcbiAgICB9XG4gICAgZ2V0VGV4dCgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBnZXRUZXh0RnJvbU5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IG5vZGUgfHwgdGhpcy5ub2RlO1xuICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gQXJyYXkuZnJvbSh0ZXh0Tm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMpO1xuICAgICAgICBjb25zdCBpbmRleCA9IGNoaWxkTm9kZXMuaW5kZXhPZih0ZXh0Tm9kZSk7XG4gICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGNoaWxkTm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgbGV0IHRleHQgPSBjb21wcmVzc1NwYWNlcygvLyB0ZXh0Tm9kZS52YWx1ZVxuICAgICAgICAvLyB8fCB0ZXh0Tm9kZS50ZXh0XG4gICAgICAgIHRleHROb2RlLnRleHRDb250ZW50IHx8ICcnKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdHJpbUxlZnQodGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID09PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIHRleHQgPSB0cmltUmlnaHQodGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVEVsZW1lbnRDaGlsZHJlbihjdHgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpcnN0LCBjYWxjdWxhdGUgY2hpbGQgcG9zaXRpb25zXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUNvb3JkaW5hdGVzKCk7XG4gICAgICAgIHRoaXMuYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZShjdHgpO1xuICAgICAgICAvLyB0aGVuIHJlbmRlclxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKF8sIGkpPT57XG4gICAgICAgICAgICB0aGlzLnJlbmRlckNoaWxkKGN0eCwgdGhpcywgdGhpcywgaSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IG1vdXNlICB9ID0gdGhpcy5kb2N1bWVudC5zY3JlZW47XG4gICAgICAgIC8vIERvIG5vdCBjYWxjIGJvdW5kaW5nIGJveCBpZiBtb3VzZSBpcyBub3Qgd29ya2luZy5cbiAgICAgICAgaWYgKG1vdXNlLmlzV29ya2luZygpKSB7XG4gICAgICAgICAgICBtb3VzZS5jaGVja0JvdW5kaW5nQm94KHRoaXMsIHRoaXMuZ2V0Qm91bmRpbmdCb3goY3R4KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyVEVsZW1lbnRDaGlsZHJlbihjdHgpIHtcbiAgICAgICAgY29uc3QgeyBkb2N1bWVudCAsIHBhcmVudCAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHJlbmRlclRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgICAgICAgY29uc3QgY3VzdG9tRm9udCA9IHBhcmVudC5nZXRTdHlsZSgnZm9udC1mYW1pbHknKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgIGlmIChjdXN0b21Gb250KSB7XG4gICAgICAgICAgICBjb25zdCB7IHVuaXRzUGVyRW0gIH0gPSBjdXN0b21Gb250LmZvbnRGYWNlO1xuICAgICAgICAgICAgY29uc3QgY3R4Rm9udCA9IEZvbnQucGFyc2UoZG9jdW1lbnQuY3R4LmZvbnQpO1xuICAgICAgICAgICAgY29uc3QgZm9udFNpemUgPSBwYXJlbnQuZ2V0U3R5bGUoJ2ZvbnQtc2l6ZScpLmdldE51bWJlcihjdHhGb250LmZvbnRTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTdHlsZSA9IHBhcmVudC5nZXRTdHlsZSgnZm9udC1zdHlsZScpLmdldFN0cmluZyhjdHhGb250LmZvbnRTdHlsZSk7XG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IGZvbnRTaXplIC8gdW5pdHNQZXJFbTtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBjdXN0b21Gb250LmlzUlRMID8gcmVuZGVyVGV4dC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpIDogcmVuZGVyVGV4dDtcbiAgICAgICAgICAgIGNvbnN0IGR4ID0gdG9OdW1iZXJzKHBhcmVudC5nZXRBdHRyaWJ1dGUoJ2R4JykuZ2V0U3RyaW5nKCkpO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgICAgIGNvbnN0IGdseXBoID0gdGhpcy5nZXRHbHlwaChjdXN0b21Gb250LCB0ZXh0LCBpKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoc2NhbGUsIC1zY2FsZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbHcgPSBjdHgubGluZVdpZHRoO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBjdHgubGluZVdpZHRoICogdW5pdHNQZXJFbSAvIGZvbnRTaXplO1xuICAgICAgICAgICAgICAgIGlmIChmb250U3R5bGUgPT09ICdpdGFsaWMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2Zvcm0oMSwgMCwgMC40LCAxLCAwLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2x5cGgucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICAgICAgaWYgKGZvbnRTdHlsZSA9PT0gJ2l0YWxpYycpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zZm9ybSgxLCAwLCAtMC40LCAxLCAwLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGx3O1xuICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgxIC8gc2NhbGUsIC0xIC8gc2NhbGUpO1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXRoaXMueCwgLXRoaXMueSk7XG4gICAgICAgICAgICAgICAgdGhpcy54ICs9IGZvbnRTaXplICogKGdseXBoLmhvcml6QWR2WCB8fCBjdXN0b21Gb250Lmhvcml6QWR2WCkgLyB1bml0c1BlckVtO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZHhbaV0gIT09ICd1bmRlZmluZWQnICYmICFpc05hTihkeFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54ICs9IGR4W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gdGhpcztcbiAgICAgICAgLy8gTkVFRCBURVNUXG4gICAgICAgIC8vIGlmIChjdHgucGFpbnRPcmRlciA9PT0gJ3N0cm9rZScpIHtcbiAgICAgICAgLy8gICBpZiAoY3R4LnN0cm9rZVN0eWxlKSB7XG4gICAgICAgIC8vICAgICBjdHguc3Ryb2tlVGV4dChyZW5kZXJUZXh0LCB4LCB5KTtcbiAgICAgICAgLy8gICB9XG4gICAgICAgIC8vICAgaWYgKGN0eC5maWxsU3R5bGUpIHtcbiAgICAgICAgLy8gICAgIGN0eC5maWxsVGV4dChyZW5kZXJUZXh0LCB4LCB5KTtcbiAgICAgICAgLy8gICB9XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdHguZmlsbFN0eWxlKSB7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQocmVuZGVyVGV4dCwgeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5zdHJva2VTdHlsZSkge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVRleHQocmVuZGVyVGV4dCwgeCwgeSk7XG4gICAgICAgIH1cbiAgICAvLyB9XG4gICAgfVxuICAgIGFwcGx5QW5jaG9yaW5nKCkge1xuICAgICAgICBpZiAodGhpcy50ZXh0Q2h1bmtTdGFydCA+PSB0aGlzLmxlYWZUZXh0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIGJhc2ljYWxseSB0aGUgXCJBcHBseSBhbmNob3JpbmdcIiBwYXJ0IG9mIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcyL3RleHQuaHRtbCNUZXh0TGF5b3V0QWxnb3JpdGhtLlxuICAgICAgICAvLyBUaGUgZGlmZmVyZW5jZSBpcyB0aGF0IHdlIGFwcGx5IHRoZSBhbmNob3JpbmcgYXMgc29vbiBhcyBhIGNodW5rIGlzIGZpbmlzaGVkLiBUaGlzIHNhdmVzIHNvbWUgZXh0cmEgbG9vcGluZy5cbiAgICAgICAgLy8gVmVydGljYWwgdGV4dCBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAgICBjb25zdCBmaXJzdEVsZW1lbnQgPSB0aGlzLmxlYWZUZXh0c1t0aGlzLnRleHRDaHVua1N0YXJ0XTtcbiAgICAgICAgY29uc3QgdGV4dEFuY2hvciA9IGZpcnN0RWxlbWVudC5nZXRTdHlsZSgndGV4dC1hbmNob3InKS5nZXRTdHJpbmcoJ3N0YXJ0Jyk7XG4gICAgICAgIGNvbnN0IGlzUlRMID0gZmFsc2UgLy8gd2UgdHJlYXQgUlRMIGxpa2UgTFRSXG4gICAgICAgIDtcbiAgICAgICAgbGV0IHNoaWZ0ID0gMDtcbiAgICAgICAgaWYgKHRleHRBbmNob3IgPT09ICdzdGFydCcgJiYgIWlzUlRMIHx8IHRleHRBbmNob3IgPT09ICdlbmQnICYmIGlzUlRMKSB7XG4gICAgICAgICAgICBzaGlmdCA9IGZpcnN0RWxlbWVudC54IC0gdGhpcy5taW5YO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHRBbmNob3IgPT09ICdlbmQnICYmICFpc1JUTCB8fCB0ZXh0QW5jaG9yID09PSAnc3RhcnQnICYmIGlzUlRMKSB7XG4gICAgICAgICAgICBzaGlmdCA9IGZpcnN0RWxlbWVudC54IC0gdGhpcy5tYXhYO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hpZnQgPSBmaXJzdEVsZW1lbnQueCAtICh0aGlzLm1pblggKyB0aGlzLm1heFgpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSB0aGlzLnRleHRDaHVua1N0YXJ0OyBpIDwgdGhpcy5sZWFmVGV4dHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdGhpcy5sZWFmVGV4dHNbaV0ueCArPSBzaGlmdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGFydCBuZXcgY2h1bmtcbiAgICAgICAgdGhpcy5taW5YID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB0aGlzLm1heFggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHRoaXMudGV4dENodW5rU3RhcnQgPSB0aGlzLmxlYWZUZXh0cy5sZW5ndGg7XG4gICAgfVxuICAgIGFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmUoY3R4KSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoXywgaSk9PntcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZUNvcmUoY3R4LCB0aGlzLCB0aGlzLCBpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXBwbHlBbmNob3JpbmcoKTtcbiAgICB9XG4gICAgYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZUNvcmUoY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkxKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2kxXTtcbiAgICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNoaWxkLmNoaWxkcmVuLmZvckVhY2goKF8sIGkpPT57XG4gICAgICAgICAgICAgICAgdGV4dFBhcmVudC5hZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlQ29yZShjdHgsIHRleHRQYXJlbnQsIGNoaWxkLCBpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb25seSBsZWFmcyBhcmUgcmVsZXZhbnRcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0Q2hpbGRDb29yZGluYXRlcyhjdHgsIHRleHRQYXJlbnQsIHBhcmVudCwgaTEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkanVzdENoaWxkQ29vcmRpbmF0ZXMoY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQubWVhc3VyZVRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjaGlsZC5zZXRDb250ZXh0KGN0eCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHhBdHRyID0gY2hpbGQuZ2V0QXR0cmlidXRlKCd4Jyk7XG4gICAgICAgIGNvbnN0IHlBdHRyID0gY2hpbGQuZ2V0QXR0cmlidXRlKCd5Jyk7XG4gICAgICAgIGNvbnN0IGR4QXR0ciA9IGNoaWxkLmdldEF0dHJpYnV0ZSgnZHgnKTtcbiAgICAgICAgY29uc3QgZHlBdHRyID0gY2hpbGQuZ2V0QXR0cmlidXRlKCdkeScpO1xuICAgICAgICBjb25zdCBjdXN0b21Gb250ID0gY2hpbGQuZ2V0U3R5bGUoJ2ZvbnQtZmFtaWx5JykuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICBjb25zdCBpc1JUTCA9IEJvb2xlYW4oY3VzdG9tRm9udCA9PT0gbnVsbCB8fCBjdXN0b21Gb250ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21Gb250LmlzUlRMKTtcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNoaWxkcmVuIGluaGVyaXQgYXR0cmlidXRlcyBmcm9tIHBhcmVudChzKS4gUG9zaXRpb25hbCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAvLyBhcmUgb25seSBpbmhlcml0ZWQgZnJvbSBhIHBhcmVudCB0byBpdCdzIGZpcnN0IGNoaWxkLlxuICAgICAgICAgICAgaWYgKCF4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgeEF0dHIuc2V0VmFsdWUoY2hpbGQuZ2V0SW5oZXJpdGVkQXR0cmlidXRlKCd4JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgeUF0dHIuc2V0VmFsdWUoY2hpbGQuZ2V0SW5oZXJpdGVkQXR0cmlidXRlKCd5JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGR4QXR0ci5zZXRWYWx1ZShjaGlsZC5nZXRJbmhlcml0ZWRBdHRyaWJ1dGUoJ2R4JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGR5QXR0ci5zZXRWYWx1ZShjaGlsZC5nZXRJbmhlcml0ZWRBdHRyaWJ1dGUoJ2R5JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdpZHRoID0gY2hpbGQubWVhc3VyZVRleHQoY3R4KTtcbiAgICAgICAgaWYgKGlzUlRMKSB7XG4gICAgICAgICAgICB0ZXh0UGFyZW50LnggLT0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIC8vIGFuIFwieFwiIGF0dHJpYnV0ZSBtYXJrcyB0aGUgc3RhcnQgb2YgYSBuZXcgY2h1bmtcbiAgICAgICAgICAgIHRleHRQYXJlbnQuYXBwbHlBbmNob3JpbmcoKTtcbiAgICAgICAgICAgIGNoaWxkLnggPSB4QXR0ci5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgIGlmIChkeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnggKz0gZHhBdHRyLmdldFBpeGVscygneCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGR4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgdGV4dFBhcmVudC54ICs9IGR4QXR0ci5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkLnggPSB0ZXh0UGFyZW50Lng7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dFBhcmVudC54ID0gY2hpbGQueDtcbiAgICAgICAgaWYgKCFpc1JUTCkge1xuICAgICAgICAgICAgdGV4dFBhcmVudC54ICs9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBjaGlsZC55ID0geUF0dHIuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICBpZiAoZHlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC55ICs9IGR5QXR0ci5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIHRleHRQYXJlbnQueSArPSBkeUF0dHIuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZC55ID0gdGV4dFBhcmVudC55O1xuICAgICAgICB9XG4gICAgICAgIHRleHRQYXJlbnQueSA9IGNoaWxkLnk7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgY3VycmVudCBjaHVuayBhbmQgaXQncyBib3VuZHNcbiAgICAgICAgdGV4dFBhcmVudC5sZWFmVGV4dHMucHVzaChjaGlsZCk7XG4gICAgICAgIHRleHRQYXJlbnQubWluWCA9IE1hdGgubWluKHRleHRQYXJlbnQubWluWCwgY2hpbGQueCwgY2hpbGQueCArIHdpZHRoKTtcbiAgICAgICAgdGV4dFBhcmVudC5tYXhYID0gTWF0aC5tYXgodGV4dFBhcmVudC5tYXhYLCBjaGlsZC54LCBjaGlsZC54ICsgd2lkdGgpO1xuICAgICAgICBjaGlsZC5jbGVhckNvbnRleHQoY3R4KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICBnZXRDaGlsZEJvdW5kaW5nQm94KGN0eCwgdGV4dFBhcmVudCwgcGFyZW50LCBpMikge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbltpMl07XG4gICAgICAgIC8vIG5vdCBhIHRleHQgbm9kZT9cbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC5nZXRCb3VuZGluZ0JveCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm91bmRpbmdCb3ggPSBjaGlsZC5nZXRCb3VuZGluZ0JveChjdHgpO1xuICAgICAgICBpZiAoYm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgIGNoaWxkLmNoaWxkcmVuLmZvckVhY2goKF8sIGkpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRCb3VuZGluZ0JveCA9IHRleHRQYXJlbnQuZ2V0Q2hpbGRCb3VuZGluZ0JveChjdHgsIHRleHRQYXJlbnQsIGNoaWxkLCBpKTtcbiAgICAgICAgICAgICAgICBib3VuZGluZ0JveC5hZGRCb3VuZGluZ0JveChjaGlsZEJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgICB9XG4gICAgcmVuZGVyQ2hpbGQoY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkzKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2kzXTtcbiAgICAgICAgY2hpbGQucmVuZGVyKGN0eCk7XG4gICAgICAgIGNoaWxkLmNoaWxkcmVuLmZvckVhY2goKF8sIGkpPT57XG4gICAgICAgICAgICB0ZXh0UGFyZW50LnJlbmRlckNoaWxkKGN0eCwgdGV4dFBhcmVudCwgY2hpbGQsIGkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWVhc3VyZVRleHQoY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgbWVhc3VyZUNhY2hlICB9ID0gdGhpcztcbiAgICAgICAgaWYgKH5tZWFzdXJlQ2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtZWFzdXJlQ2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVuZGVyVGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgICAgICBjb25zdCBtZWFzdXJlID0gdGhpcy5tZWFzdXJlVGFyZ2V0VGV4dChjdHgsIHJlbmRlclRleHQpO1xuICAgICAgICB0aGlzLm1lYXN1cmVDYWNoZSA9IG1lYXN1cmU7XG4gICAgICAgIHJldHVybiBtZWFzdXJlO1xuICAgIH1cbiAgICBtZWFzdXJlVGFyZ2V0VGV4dChjdHgsIHRhcmdldFRleHQpIHtcbiAgICAgICAgaWYgKCF0YXJnZXRUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwYXJlbnQgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBjdXN0b21Gb250ID0gcGFyZW50LmdldFN0eWxlKCdmb250LWZhbWlseScpLmdldERlZmluaXRpb24oKTtcbiAgICAgICAgaWYgKGN1c3RvbUZvbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGN1c3RvbUZvbnQuaXNSVEwgPyB0YXJnZXRUZXh0LnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykgOiB0YXJnZXRUZXh0O1xuICAgICAgICAgICAgY29uc3QgZHggPSB0b051bWJlcnMocGFyZW50LmdldEF0dHJpYnV0ZSgnZHgnKS5nZXRTdHJpbmcoKSk7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBtZWFzdXJlID0gMDtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2x5cGggPSB0aGlzLmdldEdseXBoKGN1c3RvbUZvbnQsIHRleHQsIGkpO1xuICAgICAgICAgICAgICAgIG1lYXN1cmUgKz0gKGdseXBoLmhvcml6QWR2WCB8fCBjdXN0b21Gb250Lmhvcml6QWR2WCkgKiBmb250U2l6ZSAvIGN1c3RvbUZvbnQuZm9udEZhY2UudW5pdHNQZXJFbTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGR4W2ldICE9PSAndW5kZWZpbmVkJyAmJiAhaXNOYU4oZHhbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lYXN1cmUgKz0gZHhbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lYXN1cmU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgaWYgKCFjdHgubWVhc3VyZVRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRUZXh0Lmxlbmd0aCAqIDEwO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dChjdHgsIHRydWUpO1xuICAgICAgICBjb25zdCB7IHdpZHRoOiBtZWFzdXJlICB9ID0gY3R4Lm1lYXN1cmVUZXh0KHRhcmdldFRleHQpO1xuICAgICAgICB0aGlzLmNsZWFyQ29udGV4dChjdHgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICByZXR1cm4gbWVhc3VyZTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEluaGVyaXRzIHBvc2l0aW9uYWwgYXR0cmlidXRlcyBmcm9tIHtAbGluayBUZXh0RWxlbWVudH0gcGFyZW50KHMpLiBBdHRyaWJ1dGVzXG4gICAqIGFyZSBvbmx5IGluaGVyaXRlZCBmcm9tIGEgcGFyZW50IHRvIGl0cyBmaXJzdCBjaGlsZC5cbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgYXR0cmlidXRlIG5hbWUuXG4gICAqIEByZXR1cm5zIFRoZSBhdHRyaWJ1dGUgdmFsdWUgb3IgbnVsbC5cbiAgICovIGdldEluaGVyaXRlZEF0dHJpYnV0ZShuYW1lKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhcyxjb25zaXN0ZW50LXRoaXNcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICB3aGlsZShjdXJyZW50IGluc3RhbmNlb2YgVGV4dEVsZW1lbnQgJiYgY3VycmVudC5pc0ZpcnN0Q2hpbGQoKSAmJiBjdXJyZW50LnBhcmVudCl7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRBdHRyID0gY3VycmVudC5wYXJlbnQuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHBhcmVudEF0dHIuaGFzVmFsdWUodHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50QXR0ci5nZXRTdHJpbmcoJzAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgbmV3LnRhcmdldCA9PT0gVGV4dEVsZW1lbnQgPyB0cnVlIDogY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICd0ZXh0JztcbiAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgdGhpcy55ID0gMDtcbiAgICAgICAgdGhpcy5sZWFmVGV4dHMgPSBbXTtcbiAgICAgICAgdGhpcy50ZXh0Q2h1bmtTdGFydCA9IDA7XG4gICAgICAgIHRoaXMubWluWCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgdGhpcy5tYXhYID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICB0aGlzLm1lYXN1cmVDYWNoZSA9IC0xO1xuICAgIH1cbn1cblxuY2xhc3MgVFNwYW5FbGVtZW50IGV4dGVuZHMgVGV4dEVsZW1lbnQge1xuICAgIGdldFRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIG5ldy50YXJnZXQgPT09IFRTcGFuRWxlbWVudCA/IHRydWUgOiBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3RzcGFuJztcbiAgICAgICAgLy8gaWYgdGhpcyBub2RlIGhhcyBjaGlsZHJlbiwgdGhlbiB0aGV5IG93biB0aGUgdGV4dFxuICAgICAgICB0aGlzLnRleHQgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDAgPyAnJyA6IHRoaXMuZ2V0VGV4dEZyb21Ob2RlKCk7XG4gICAgfVxufVxuXG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIFRTcGFuRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAndGV4dE5vZGUnO1xuICAgIH1cbn1cblxuY2xhc3MgUGF0aFBhcnNlciBleHRlbmRzIFNWR1BhdGhEYXRhIHtcbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pID0gLTE7XG4gICAgICAgIHRoaXMuY29tbWFuZCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJldmlvdXNDb21tYW5kID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFydCA9IG5ldyBQb2ludCgwLCAwKTtcbiAgICAgICAgdGhpcy5jb250cm9sID0gbmV3IFBvaW50KDAsIDApO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgICAgIHRoaXMuYW5nbGVzID0gW107XG4gICAgfVxuICAgIGlzRW5kKCkge1xuICAgICAgICBjb25zdCB7IGkgLCBjb21tYW5kcyAgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBpID49IGNvbW1hbmRzLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzWysrdGhpcy5pXTtcbiAgICAgICAgdGhpcy5wcmV2aW91c0NvbW1hbmQgPSB0aGlzLmNvbW1hbmQ7XG4gICAgICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XG4gICAgICAgIHJldHVybiBjb21tYW5kO1xuICAgIH1cbiAgICBnZXRQb2ludCgpIHtcbiAgICAgICAgbGV0IHhQcm9wID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiAneCcsIHlQcm9wID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiAneSc7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KHRoaXMuY29tbWFuZFt4UHJvcF0sIHRoaXMuY29tbWFuZFt5UHJvcF0pO1xuICAgICAgICByZXR1cm4gdGhpcy5tYWtlQWJzb2x1dGUocG9pbnQpO1xuICAgIH1cbiAgICBnZXRBc0NvbnRyb2xQb2ludCh4UHJvcCwgeVByb3ApIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLmdldFBvaW50KHhQcm9wLCB5UHJvcCk7XG4gICAgICAgIHRoaXMuY29udHJvbCA9IHBvaW50O1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuICAgIGdldEFzQ3VycmVudFBvaW50KHhQcm9wLCB5UHJvcCkge1xuICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuZ2V0UG9pbnQoeFByb3AsIHlQcm9wKTtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gcG9pbnQ7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCkge1xuICAgICAgICBjb25zdCBwcmV2aW91c0NvbW1hbmQgPSB0aGlzLnByZXZpb3VzQ29tbWFuZC50eXBlO1xuICAgICAgICBpZiAocHJldmlvdXNDb21tYW5kICE9PSBTVkdQYXRoRGF0YS5DVVJWRV9UTyAmJiBwcmV2aW91c0NvbW1hbmQgIT09IFNWR1BhdGhEYXRhLlNNT09USF9DVVJWRV9UTyAmJiBwcmV2aW91c0NvbW1hbmQgIT09IFNWR1BhdGhEYXRhLlFVQURfVE8gJiYgcHJldmlvdXNDb21tYW5kICE9PSBTVkdQYXRoRGF0YS5TTU9PVEhfUVVBRF9UTykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWZsZWN0IHBvaW50XG4gICAgICAgIGNvbnN0IHsgY3VycmVudDogeyB4OiBjeCAsIHk6IGN5ICB9ICwgY29udHJvbDogeyB4OiBveCAsIHk6IG95ICB9ICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgUG9pbnQoMiAqIGN4IC0gb3gsIDIgKiBjeSAtIG95KTtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgICBtYWtlQWJzb2x1dGUocG9pbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tbWFuZC5yZWxhdGl2ZSkge1xuICAgICAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgIHBvaW50LnggKz0geDtcbiAgICAgICAgICAgIHBvaW50LnkgKz0geTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuICAgIGFkZE1hcmtlcihwb2ludCwgZnJvbSwgcHJpb3JUbykge1xuICAgICAgICBjb25zdCB7IHBvaW50cyAsIGFuZ2xlcyAgfSA9IHRoaXM7XG4gICAgICAgIC8vIGlmIHRoZSBsYXN0IGFuZ2xlIGlzbid0IGZpbGxlZCBpbiBiZWNhdXNlIHdlIGRpZG4ndCBoYXZlIHRoaXMgcG9pbnQgeWV0IC4uLlxuICAgICAgICBpZiAocHJpb3JUbyAmJiBhbmdsZXMubGVuZ3RoID4gMCAmJiAhYW5nbGVzW2FuZ2xlcy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgYW5nbGVzW2FuZ2xlcy5sZW5ndGggLSAxXSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0uYW5nbGVUbyhwcmlvclRvKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZE1hcmtlckFuZ2xlKHBvaW50LCBmcm9tID8gZnJvbS5hbmdsZVRvKHBvaW50KSA6IG51bGwpO1xuICAgIH1cbiAgICBhZGRNYXJrZXJBbmdsZShwb2ludCwgYW5nbGUpIHtcbiAgICAgICAgdGhpcy5wb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgIHRoaXMuYW5nbGVzLnB1c2goYW5nbGUpO1xuICAgIH1cbiAgICBnZXRNYXJrZXJQb2ludHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvaW50cztcbiAgICB9XG4gICAgZ2V0TWFya2VyQW5nbGVzKCkge1xuICAgICAgICBjb25zdCB7IGFuZ2xlcyAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxlbiA9IGFuZ2xlcy5sZW5ndGg7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICBpZiAoIWFuZ2xlc1tpXSkge1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaiA9IGkgKyAxOyBqIDwgbGVuOyBqKyspe1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGVzW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmdsZXNbaV0gPSBhbmdsZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5nbGVzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXRoKXtcbiAgICAgICAgc3VwZXIocGF0aC8vIEZpeCBzcGFjZXMgYWZ0ZXIgc2lnbnMuXG4gICAgICAgIC5yZXBsYWNlKC8oWytcXC0uXSlcXHMrL2dtLCAnJDEnKS8vIFJlbW92ZSBpbnZhbGlkIHBhcnQuXG4gICAgICAgIC5yZXBsYWNlKC9bXk1tWnpMbEhoVnZDY1NzUXFUdEFhZVxcZFxccy4sKy1dLiovZywgJycpKTtcbiAgICAgICAgdGhpcy5jb250cm9sID0gbmV3IFBvaW50KDAsIDApO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gbmV3IFBvaW50KDAsIDApO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgICAgIHRoaXMuY29tbWFuZCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tbWFuZHMgPSB0aGlzLmNvbW1hbmRzO1xuICAgICAgICB0aGlzLmkgPSAtMTtcbiAgICAgICAgdGhpcy5wcmV2aW91c0NvbW1hbmQgPSBudWxsO1xuICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLmFuZ2xlcyA9IFtdO1xuICAgIH1cbn1cblxuY2xhc3MgUGF0aEVsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICAgIHBhdGgoY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgcGF0aFBhcnNlciAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94KCk7XG4gICAgICAgIHBhdGhQYXJzZXIucmVzZXQoKTtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKCFwYXRoUGFyc2VyLmlzRW5kKCkpe1xuICAgICAgICAgICAgc3dpdGNoKHBhdGhQYXJzZXIubmV4dCgpLnR5cGUpe1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5NT1ZFX1RPOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhNKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoTChjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkhPUklaX0xJTkVfVE86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aEgoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5WRVJUX0xJTkVfVE86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aFYoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoQyhjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlNNT09USF9DVVJWRV9UTzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoUyhjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aFEoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5TTU9PVEhfUVVBRF9UTzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoVChjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoQShjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNMT1NFX1BBVEg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aFooY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgICB9XG4gICAgZ2V0Qm91bmRpbmdCb3goX2N0eCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRoKCk7XG4gICAgfVxuICAgIGdldE1hcmtlcnMoKSB7XG4gICAgICAgIGNvbnN0IHsgcGF0aFBhcnNlciAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHBhdGhQYXJzZXIuZ2V0TWFya2VyUG9pbnRzKCk7XG4gICAgICAgIGNvbnN0IGFuZ2xlcyA9IHBhdGhQYXJzZXIuZ2V0TWFya2VyQW5nbGVzKCk7XG4gICAgICAgIGNvbnN0IG1hcmtlcnMgPSBwb2ludHMubWFwKChwb2ludCwgaSk9PltcbiAgICAgICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgICAgICBhbmdsZXNbaV1cbiAgICAgICAgICAgIF1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgfVxuICAgIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgICAgICB0aGlzLnBhdGgoY3R4KTtcbiAgICAgICAgdGhpcy5kb2N1bWVudC5zY3JlZW4ubW91c2UuY2hlY2tQYXRoKHRoaXMsIGN0eCk7XG4gICAgICAgIGNvbnN0IGZpbGxSdWxlU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZmlsbC1ydWxlJyk7XG4gICAgICAgIGlmIChjdHguZmlsbFN0eWxlICE9PSAnJykge1xuICAgICAgICAgICAgaWYgKGZpbGxSdWxlU3R5bGVQcm9wLmdldFN0cmluZygnaW5oZXJpdCcpICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbChmaWxsUnVsZVN0eWxlUHJvcC5nZXRTdHJpbmcoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5zdHJva2VTdHlsZSAhPT0gJycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgndmVjdG9yLWVmZmVjdCcpLmdldFN0cmluZygpID09PSAnbm9uLXNjYWxpbmctc3Ryb2tlJykge1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hcmtlcnMgPSB0aGlzLmdldE1hcmtlcnMoKTtcbiAgICAgICAgaWYgKG1hcmtlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlcnNMYXN0SW5kZXggPSBtYXJrZXJzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBjb25zdCBtYXJrZXJTdGFydFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ21hcmtlci1zdGFydCcpO1xuICAgICAgICAgICAgY29uc3QgbWFya2VyTWlkU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnbWFya2VyLW1pZCcpO1xuICAgICAgICAgICAgY29uc3QgbWFya2VyRW5kU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnbWFya2VyLWVuZCcpO1xuICAgICAgICAgICAgaWYgKG1hcmtlclN0YXJ0U3R5bGVQcm9wLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFya2VyID0gbWFya2VyU3RhcnRTdHlsZVByb3AuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtwb2ludCwgYW5nbGVdID0gbWFya2Vyc1swXTtcbiAgICAgICAgICAgICAgICBtYXJrZXIucmVuZGVyKGN0eCwgcG9pbnQsIGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXJrZXJNaWRTdHlsZVByb3AuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBtYXJrZXJNaWRTdHlsZVByb3AuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCBtYXJrZXJzTGFzdEluZGV4OyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbcG9pbnQsIGFuZ2xlXSA9IG1hcmtlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5yZW5kZXIoY3R4LCBwb2ludCwgYW5nbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXJrZXJFbmRTdHlsZVByb3AuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBtYXJrZXJFbmRTdHlsZVByb3AuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtwb2ludCwgYW5nbGVdID0gbWFya2Vyc1ttYXJrZXJzTGFzdEluZGV4XTtcbiAgICAgICAgICAgICAgICBtYXJrZXIucmVuZGVyKGN0eCwgcG9pbnQsIGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGF0aE0ocGF0aFBhcnNlcikge1xuICAgICAgICBjb25zdCBwb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICAgICAgcGF0aFBhcnNlci5zdGFydCA9IHBhdGhQYXJzZXIuY3VycmVudDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvaW50XG4gICAgICAgIH07XG4gICAgfVxuICAgIHBhdGhNKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoUGFyc2VyICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBwb2ludCAgfSA9IFBhdGhFbGVtZW50LnBhdGhNKHBhdGhQYXJzZXIpO1xuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gcG9pbnQ7XG4gICAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKHBvaW50KTtcbiAgICAgICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHBhdGhMKHBhdGhQYXJzZXIpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50ICB9ID0gcGF0aFBhcnNlcjtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgcG9pbnRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGF0aEwoY3R4LCBib3VuZGluZ0JveCkge1xuICAgICAgICBjb25zdCB7IHBhdGhQYXJzZXIgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQgLCBwb2ludCAgfSA9IFBhdGhFbGVtZW50LnBhdGhMKHBhdGhQYXJzZXIpO1xuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gcG9pbnQ7XG4gICAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKHBvaW50LCBjdXJyZW50KTtcbiAgICAgICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHBhdGhIKHBhdGhQYXJzZXIpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50ICwgY29tbWFuZCAgfSA9IHBhdGhQYXJzZXI7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KChjb21tYW5kLnJlbGF0aXZlID8gY3VycmVudC54IDogMCkgKyBjb21tYW5kLngsIGN1cnJlbnQueSk7XG4gICAgICAgIHBhdGhQYXJzZXIuY3VycmVudCA9IHBvaW50O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHBvaW50XG4gICAgICAgIH07XG4gICAgfVxuICAgIHBhdGhIKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoUGFyc2VyICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBjdXJyZW50ICwgcG9pbnQgIH0gPSBQYXRoRWxlbWVudC5wYXRoSChwYXRoUGFyc2VyKTtcbiAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IHBvaW50O1xuICAgICAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihwb2ludCwgY3VycmVudCk7XG4gICAgICAgIGJvdW5kaW5nQm94LmFkZFBvaW50KHgsIHkpO1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBwYXRoVihwYXRoUGFyc2VyKSB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudCAsIGNvbW1hbmQgIH0gPSBwYXRoUGFyc2VyO1xuICAgICAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludChjdXJyZW50LngsIChjb21tYW5kLnJlbGF0aXZlID8gY3VycmVudC55IDogMCkgKyBjb21tYW5kLnkpO1xuICAgICAgICBwYXRoUGFyc2VyLmN1cnJlbnQgPSBwb2ludDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBwb2ludFxuICAgICAgICB9O1xuICAgIH1cbiAgICBwYXRoVihjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgICAgIGNvbnN0IHsgcGF0aFBhcnNlciAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudCAsIHBvaW50ICB9ID0gUGF0aEVsZW1lbnQucGF0aFYocGF0aFBhcnNlcik7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSBwb2ludDtcbiAgICAgICAgcGF0aFBhcnNlci5hZGRNYXJrZXIocG9pbnQsIGN1cnJlbnQpO1xuICAgICAgICBib3VuZGluZ0JveC5hZGRQb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGF0aEMocGF0aFBhcnNlcikge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQgIH0gPSBwYXRoUGFyc2VyO1xuICAgICAgICBjb25zdCBwb2ludCA9IHBhdGhQYXJzZXIuZ2V0UG9pbnQoJ3gxJywgJ3kxJyk7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDb250cm9sUG9pbnQoJ3gyJywgJ3kyJyk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludFxuICAgICAgICB9O1xuICAgIH1cbiAgICBwYXRoQyhjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgICAgIGNvbnN0IHsgcGF0aFBhcnNlciAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudCAsIHBvaW50ICwgY29udHJvbFBvaW50ICwgY3VycmVudFBvaW50ICB9ID0gUGF0aEVsZW1lbnQucGF0aEMocGF0aFBhcnNlcik7XG4gICAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKGN1cnJlbnRQb2ludCwgY29udHJvbFBvaW50LCBwb2ludCk7XG4gICAgICAgIGJvdW5kaW5nQm94LmFkZEJlemllckN1cnZlKGN1cnJlbnQueCwgY3VycmVudC55LCBwb2ludC54LCBwb2ludC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGF0aFMocGF0aFBhcnNlcikge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQgIH0gPSBwYXRoUGFyc2VyO1xuICAgICAgICBjb25zdCBwb2ludCA9IHBhdGhQYXJzZXIuZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCk7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDb250cm9sUG9pbnQoJ3gyJywgJ3kyJyk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludFxuICAgICAgICB9O1xuICAgIH1cbiAgICBwYXRoUyhjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgICAgIGNvbnN0IHsgcGF0aFBhcnNlciAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudCAsIHBvaW50ICwgY29udHJvbFBvaW50ICwgY3VycmVudFBvaW50ICB9ID0gUGF0aEVsZW1lbnQucGF0aFMocGF0aFBhcnNlcik7XG4gICAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKGN1cnJlbnRQb2ludCwgY29udHJvbFBvaW50LCBwb2ludCk7XG4gICAgICAgIGJvdW5kaW5nQm94LmFkZEJlemllckN1cnZlKGN1cnJlbnQueCwgY3VycmVudC55LCBwb2ludC54LCBwb2ludC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGF0aFEocGF0aFBhcnNlcikge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQgIH0gPSBwYXRoUGFyc2VyO1xuICAgICAgICBjb25zdCBjb250cm9sUG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ29udHJvbFBvaW50KCd4MScsICd5MScpO1xuICAgICAgICBjb25zdCBjdXJyZW50UG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY29udHJvbFBvaW50LFxuICAgICAgICAgICAgY3VycmVudFBvaW50XG4gICAgICAgIH07XG4gICAgfVxuICAgIHBhdGhRKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoUGFyc2VyICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBjdXJyZW50ICwgY29udHJvbFBvaW50ICwgY3VycmVudFBvaW50ICB9ID0gUGF0aEVsZW1lbnQucGF0aFEocGF0aFBhcnNlcik7XG4gICAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKGN1cnJlbnRQb2ludCwgY29udHJvbFBvaW50LCBjb250cm9sUG9pbnQpO1xuICAgICAgICBib3VuZGluZ0JveC5hZGRRdWFkcmF0aWNDdXJ2ZShjdXJyZW50LngsIGN1cnJlbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHBhdGhUKHBhdGhQYXJzZXIpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50ICB9ID0gcGF0aFBhcnNlcjtcbiAgICAgICAgY29uc3QgY29udHJvbFBvaW50ID0gcGF0aFBhcnNlci5nZXRSZWZsZWN0ZWRDb250cm9sUG9pbnQoKTtcbiAgICAgICAgcGF0aFBhcnNlci5jb250cm9sID0gY29udHJvbFBvaW50O1xuICAgICAgICBjb25zdCBjdXJyZW50UG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY29udHJvbFBvaW50LFxuICAgICAgICAgICAgY3VycmVudFBvaW50XG4gICAgICAgIH07XG4gICAgfVxuICAgIHBhdGhUKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoUGFyc2VyICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBjdXJyZW50ICwgY29udHJvbFBvaW50ICwgY3VycmVudFBvaW50ICB9ID0gUGF0aEVsZW1lbnQucGF0aFQocGF0aFBhcnNlcik7XG4gICAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKGN1cnJlbnRQb2ludCwgY29udHJvbFBvaW50LCBjb250cm9sUG9pbnQpO1xuICAgICAgICBib3VuZGluZ0JveC5hZGRRdWFkcmF0aWNDdXJ2ZShjdXJyZW50LngsIGN1cnJlbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHBhdGhBKHBhdGhQYXJzZXIpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50ICwgY29tbWFuZCAgfSA9IHBhdGhQYXJzZXI7XG4gICAgICAgIGxldCB7IHJYICwgclkgLCB4Um90ICwgbEFyY0ZsYWcgLCBzd2VlcEZsYWcgIH0gPSBjb21tYW5kO1xuICAgICAgICBjb25zdCB4QXhpc1JvdGF0aW9uID0geFJvdCAqIChNYXRoLlBJIC8gMTgwKTtcbiAgICAgICAgY29uc3QgY3VycmVudFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgICAgICAvLyBDb252ZXJzaW9uIGZyb20gZW5kcG9pbnQgdG8gY2VudGVyIHBhcmFtZXRlcml6YXRpb25cbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXG4gICAgICAgIC8vIHgxJywgeTEnXG4gICAgICAgIGNvbnN0IGN1cnJwID0gbmV3IFBvaW50KE1hdGguY29zKHhBeGlzUm90YXRpb24pICogKGN1cnJlbnQueCAtIGN1cnJlbnRQb2ludC54KSAvIDIgKyBNYXRoLnNpbih4QXhpc1JvdGF0aW9uKSAqIChjdXJyZW50LnkgLSBjdXJyZW50UG9pbnQueSkgLyAyLCAtTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiAoY3VycmVudC54IC0gY3VycmVudFBvaW50LngpIC8gMiArIE1hdGguY29zKHhBeGlzUm90YXRpb24pICogKGN1cnJlbnQueSAtIGN1cnJlbnRQb2ludC55KSAvIDIpO1xuICAgICAgICAvLyBhZGp1c3QgcmFkaWlcbiAgICAgICAgY29uc3QgbCA9IE1hdGgucG93KGN1cnJwLngsIDIpIC8gTWF0aC5wb3coclgsIDIpICsgTWF0aC5wb3coY3VycnAueSwgMikgLyBNYXRoLnBvdyhyWSwgMik7XG4gICAgICAgIGlmIChsID4gMSkge1xuICAgICAgICAgICAgclggKj0gTWF0aC5zcXJ0KGwpO1xuICAgICAgICAgICAgclkgKj0gTWF0aC5zcXJ0KGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGN4JywgY3knXG4gICAgICAgIGxldCBzID0gKGxBcmNGbGFnID09PSBzd2VlcEZsYWcgPyAtMSA6IDEpICogTWF0aC5zcXJ0KChNYXRoLnBvdyhyWCwgMikgKiBNYXRoLnBvdyhyWSwgMikgLSBNYXRoLnBvdyhyWCwgMikgKiBNYXRoLnBvdyhjdXJycC55LCAyKSAtIE1hdGgucG93KHJZLCAyKSAqIE1hdGgucG93KGN1cnJwLngsIDIpKSAvIChNYXRoLnBvdyhyWCwgMikgKiBNYXRoLnBvdyhjdXJycC55LCAyKSArIE1hdGgucG93KHJZLCAyKSAqIE1hdGgucG93KGN1cnJwLngsIDIpKSk7XG4gICAgICAgIGlmIChpc05hTihzKSkge1xuICAgICAgICAgICAgcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3BwID0gbmV3IFBvaW50KHMgKiByWCAqIGN1cnJwLnkgLyByWSwgcyAqIC1yWSAqIGN1cnJwLnggLyByWCk7XG4gICAgICAgIC8vIGN4LCBjeVxuICAgICAgICBjb25zdCBjZW50cCA9IG5ldyBQb2ludCgoY3VycmVudC54ICsgY3VycmVudFBvaW50LngpIC8gMiArIE1hdGguY29zKHhBeGlzUm90YXRpb24pICogY3BwLnggLSBNYXRoLnNpbih4QXhpc1JvdGF0aW9uKSAqIGNwcC55LCAoY3VycmVudC55ICsgY3VycmVudFBvaW50LnkpIC8gMiArIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogY3BwLnggKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIGNwcC55KTtcbiAgICAgICAgLy8gaW5pdGlhbCBhbmdsZVxuICAgICAgICBjb25zdCBhMSA9IHZlY3RvcnNBbmdsZShbXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgMFxuICAgICAgICBdLCBbXG4gICAgICAgICAgICAoY3VycnAueCAtIGNwcC54KSAvIHJYLFxuICAgICAgICAgICAgKGN1cnJwLnkgLSBjcHAueSkgLyByWVxuICAgICAgICBdKSAvLyDOuDFcbiAgICAgICAgO1xuICAgICAgICAvLyBhbmdsZSBkZWx0YVxuICAgICAgICBjb25zdCB1ID0gW1xuICAgICAgICAgICAgKGN1cnJwLnggLSBjcHAueCkgLyByWCxcbiAgICAgICAgICAgIChjdXJycC55IC0gY3BwLnkpIC8gcllcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgdiA9IFtcbiAgICAgICAgICAgICgtY3VycnAueCAtIGNwcC54KSAvIHJYLFxuICAgICAgICAgICAgKC1jdXJycC55IC0gY3BwLnkpIC8gcllcbiAgICAgICAgXTtcbiAgICAgICAgbGV0IGFkID0gdmVjdG9yc0FuZ2xlKHUsIHYpIC8vIM6UzrhcbiAgICAgICAgO1xuICAgICAgICBpZiAodmVjdG9yc1JhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgICAgICAgICBhZCA9IE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlY3RvcnNSYXRpbyh1LCB2KSA+PSAxKSB7XG4gICAgICAgICAgICBhZCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludCxcbiAgICAgICAgICAgIHJYLFxuICAgICAgICAgICAgclksXG4gICAgICAgICAgICBzd2VlcEZsYWcsXG4gICAgICAgICAgICB4QXhpc1JvdGF0aW9uLFxuICAgICAgICAgICAgY2VudHAsXG4gICAgICAgICAgICBhMSxcbiAgICAgICAgICAgIGFkXG4gICAgICAgIH07XG4gICAgfVxuICAgIHBhdGhBKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoUGFyc2VyICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBjdXJyZW50UG9pbnQgLCByWCAsIHJZICwgc3dlZXBGbGFnICwgeEF4aXNSb3RhdGlvbiAsIGNlbnRwICwgYTEgLCBhZCAgfSA9IFBhdGhFbGVtZW50LnBhdGhBKHBhdGhQYXJzZXIpO1xuICAgICAgICAvLyBmb3IgbWFya2Vyc1xuICAgICAgICBjb25zdCBkaXIgPSAxIC0gc3dlZXBGbGFnID8gMSA6IC0xO1xuICAgICAgICBjb25zdCBhaCA9IGExICsgZGlyICogKGFkIC8gMik7XG4gICAgICAgIGNvbnN0IGhhbGZXYXkgPSBuZXcgUG9pbnQoY2VudHAueCArIHJYICogTWF0aC5jb3MoYWgpLCBjZW50cC55ICsgclkgKiBNYXRoLnNpbihhaCkpO1xuICAgICAgICBwYXRoUGFyc2VyLmFkZE1hcmtlckFuZ2xlKGhhbGZXYXksIGFoIC0gZGlyICogTWF0aC5QSSAvIDIpO1xuICAgICAgICBwYXRoUGFyc2VyLmFkZE1hcmtlckFuZ2xlKGN1cnJlbnRQb2ludCwgYWggLSBkaXIgKiBNYXRoLlBJKTtcbiAgICAgICAgYm91bmRpbmdCb3guYWRkUG9pbnQoY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KSAvLyBUT0RPOiB0aGlzIGlzIHRvbyBuYWl2ZSwgbWFrZSBpdCBiZXR0ZXJcbiAgICAgICAgO1xuICAgICAgICBpZiAoY3R4ICYmICFpc05hTihhMSkgJiYgIWlzTmFOKGFkKSkge1xuICAgICAgICAgICAgY29uc3QgciA9IHJYID4gclkgPyByWCA6IHJZO1xuICAgICAgICAgICAgY29uc3Qgc3ggPSByWCA+IHJZID8gMSA6IHJYIC8gclk7XG4gICAgICAgICAgICBjb25zdCBzeSA9IHJYID4gclkgPyByWSAvIHJYIDogMTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY2VudHAueCwgY2VudHAueSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKHhBeGlzUm90YXRpb24pO1xuICAgICAgICAgICAgY3R4LnNjYWxlKHN4LCBzeSk7XG4gICAgICAgICAgICBjdHguYXJjKDAsIDAsIHIsIGExLCBhMSArIGFkLCBCb29sZWFuKDEgLSBzd2VlcEZsYWcpKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZSgxIC8gc3gsIDEgLyBzeSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKC14QXhpc1JvdGF0aW9uKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWNlbnRwLngsIC1jZW50cC55KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGF0aFoocGF0aFBhcnNlcikge1xuICAgICAgICBwYXRoUGFyc2VyLmN1cnJlbnQgPSBwYXRoUGFyc2VyLnN0YXJ0O1xuICAgIH1cbiAgICBwYXRoWihjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgICAgIFBhdGhFbGVtZW50LnBhdGhaKHRoaXMucGF0aFBhcnNlcik7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgY2xvc2UgcGF0aCBpZiBpdCBpcyBub3QgYSBzdHJhaWdodCBsaW5lXG4gICAgICAgICAgICBpZiAoYm91bmRpbmdCb3gueDEgIT09IGJvdW5kaW5nQm94LngyICYmIGJvdW5kaW5nQm94LnkxICE9PSBib3VuZGluZ0JveC55Mikge1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3BhdGgnO1xuICAgICAgICB0aGlzLnBhdGhQYXJzZXIgPSBuZXcgUGF0aFBhcnNlcih0aGlzLmdldEF0dHJpYnV0ZSgnZCcpLmdldFN0cmluZygpKTtcbiAgICB9XG59XG5cbmNsYXNzIFNWR0VsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICAgIHNldENvbnRleHQoY3R4KSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIGNvbnN0IHsgZG9jdW1lbnQgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHNjcmVlbiAsIHdpbmRvdyAgfSA9IGRvY3VtZW50O1xuICAgICAgICBjb25zdCBjYW52YXMgPSBjdHguY2FudmFzO1xuICAgICAgICBzY3JlZW4uc2V0RGVmYXVsdHMoY3R4KTtcbiAgICAgICAgaWYgKCdzdHlsZScgaW4gY2FudmFzICYmIHR5cGVvZiBjdHguZm9udCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93ICYmIHR5cGVvZiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGN0eC5mb250ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY2FudmFzKS5nZXRQcm9wZXJ0eVZhbHVlKCdmb250Jyk7XG4gICAgICAgICAgICBjb25zdCBmb250U2l6ZVByb3AgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdmb250U2l6ZScsIEZvbnQucGFyc2UoY3R4LmZvbnQpLmZvbnRTaXplKTtcbiAgICAgICAgICAgIGlmIChmb250U2l6ZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LnJvb3RFbVNpemUgPSBmb250U2l6ZVByb3AuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZW1TaXplID0gZG9jdW1lbnQucm9vdEVtU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgbmV3IHZpZXcgcG9ydFxuICAgICAgICBpZiAoIXRoaXMuZ2V0QXR0cmlidXRlKCd4JykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnLCB0cnVlKS5zZXRWYWx1ZSgwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZ2V0QXR0cmlidXRlKCd5JykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3knLCB0cnVlKS5zZXRWYWx1ZSgwKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyB3aWR0aCAsIGhlaWdodCAgfSA9IHNjcmVlbi52aWV3UG9ydDtcbiAgICAgICAgaWYgKCF0aGlzLmdldFN0eWxlKCd3aWR0aCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJywgdHJ1ZSkuc2V0VmFsdWUoJzEwMCUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcsIHRydWUpLnNldFZhbHVlKCcxMDAlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmdldFN0eWxlKCdjb2xvcicpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0U3R5bGUoJ2NvbG9yJywgdHJ1ZSkuc2V0VmFsdWUoJ2JsYWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVmWEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgncmVmWCcpO1xuICAgICAgICBjb25zdCByZWZZQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyZWZZJyk7XG4gICAgICAgIGNvbnN0IHZpZXdCb3hBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKTtcbiAgICAgICAgY29uc3Qgdmlld0JveCA9IHZpZXdCb3hBdHRyLmhhc1ZhbHVlKCkgPyB0b051bWJlcnModmlld0JveEF0dHIuZ2V0U3RyaW5nKCkpIDogbnVsbDtcbiAgICAgICAgY29uc3QgY2xpcCA9ICF0aGlzLnJvb3QgJiYgdGhpcy5nZXRTdHlsZSgnb3ZlcmZsb3cnKS5nZXRWYWx1ZSgnaGlkZGVuJykgIT09ICd2aXNpYmxlJztcbiAgICAgICAgbGV0IG1pblggPSAwO1xuICAgICAgICBsZXQgbWluWSA9IDA7XG4gICAgICAgIGxldCBjbGlwWCA9IDA7XG4gICAgICAgIGxldCBjbGlwWSA9IDA7XG4gICAgICAgIGlmICh2aWV3Qm94KSB7XG4gICAgICAgICAgICBtaW5YID0gdmlld0JveFswXTtcbiAgICAgICAgICAgIG1pblkgPSB2aWV3Qm94WzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5yb290KSB7XG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdtYXJrZXInKSB7XG4gICAgICAgICAgICAgICAgY2xpcFggPSBtaW5YO1xuICAgICAgICAgICAgICAgIGNsaXBZID0gbWluWTtcbiAgICAgICAgICAgICAgICBtaW5YID0gMDtcbiAgICAgICAgICAgICAgICBtaW5ZID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzY3JlZW4udmlld1BvcnQuc2V0Q3VycmVudCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZSBvZiB0cmFuc2Zvcm0tb3JpZ2luIGlzIGNlbnRlciBvbmx5IGZvciByb290IFNWRyBlbGVtZW50c1xuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3RyYW5zZm9ybS1vcmlnaW5cbiAgICAgICAgaWYgKHRoaXMubm9kZSAvLyBpcyBub3QgdGVtcG9yYXJ5IFNWR0VsZW1lbnRcbiAgICAgICAgICYmICghdGhpcy5wYXJlbnQgfHwgKChyZWYgPSB0aGlzLm5vZGUucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYubm9kZU5hbWUpID09PSAnZm9yZWlnbk9iamVjdCcpICYmIHRoaXMuZ2V0U3R5bGUoJ3RyYW5zZm9ybScsIGZhbHNlLCB0cnVlKS5oYXNWYWx1ZSgpICYmICF0aGlzLmdldFN0eWxlKCd0cmFuc2Zvcm0tb3JpZ2luJywgZmFsc2UsIHRydWUpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0U3R5bGUoJ3RyYW5zZm9ybS1vcmlnaW4nLCB0cnVlLCB0cnVlKS5zZXRWYWx1ZSgnNTAlIDUwJScpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnNldENvbnRleHQoY3R4KTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLmdldEF0dHJpYnV0ZSgneCcpLmdldFBpeGVscygneCcpLCB0aGlzLmdldEF0dHJpYnV0ZSgneScpLmdldFBpeGVscygneScpKTtcbiAgICAgICAgaWYgKHZpZXdCb3gpIHtcbiAgICAgICAgICAgIHdpZHRoID0gdmlld0JveFsyXTtcbiAgICAgICAgICAgIGhlaWdodCA9IHZpZXdCb3hbM107XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuc2V0Vmlld0JveCh7XG4gICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICBhc3BlY3RSYXRpbzogdGhpcy5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIHdpZHRoOiBzY3JlZW4udmlld1BvcnQud2lkdGgsXG4gICAgICAgICAgICBkZXNpcmVkV2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBzY3JlZW4udmlld1BvcnQuaGVpZ2h0LFxuICAgICAgICAgICAgZGVzaXJlZEhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgbWluWCxcbiAgICAgICAgICAgIG1pblksXG4gICAgICAgICAgICByZWZYOiByZWZYQXR0ci5nZXRWYWx1ZSgpLFxuICAgICAgICAgICAgcmVmWTogcmVmWUF0dHIuZ2V0VmFsdWUoKSxcbiAgICAgICAgICAgIGNsaXAsXG4gICAgICAgICAgICBjbGlwWCxcbiAgICAgICAgICAgIGNsaXBZXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmlld0JveCkge1xuICAgICAgICAgICAgc2NyZWVuLnZpZXdQb3J0LnJlbW92ZUN1cnJlbnQoKTtcbiAgICAgICAgICAgIHNjcmVlbi52aWV3UG9ydC5zZXRDdXJyZW50KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyQ29udGV4dChjdHgpIHtcbiAgICAgICAgc3VwZXIuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQuc2NyZWVuLnZpZXdQb3J0LnJlbW92ZUN1cnJlbnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJlc2l6ZSBTVkcgdG8gZml0IGluIGdpdmVuIHNpemUuXG4gICAqIEBwYXJhbSB3aWR0aFxuICAgKiBAcGFyYW0gaGVpZ2h0XG4gICAqIEBwYXJhbSBwcmVzZXJ2ZUFzcGVjdFJhdGlvXG4gICAqLyByZXNpemUod2lkdGgpIHtcbiAgICAgICAgbGV0IGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogd2lkdGgsIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgICBjb25zdCB3aWR0aEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnLCB0cnVlKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0cnVlKTtcbiAgICAgICAgY29uc3Qgdmlld0JveEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgndmlld0JveCcpO1xuICAgICAgICBjb25zdCBzdHlsZUF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luV2lkdGggPSB3aWR0aEF0dHIuZ2V0TnVtYmVyKDApO1xuICAgICAgICBjb25zdCBvcmlnaW5IZWlnaHQgPSBoZWlnaHRBdHRyLmdldE51bWJlcigwKTtcbiAgICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlc2VydmVBc3BlY3RSYXRpbyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsIHRydWUpLnNldFZhbHVlKHByZXNlcnZlQXNwZWN0UmF0aW8pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW9BdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpb0F0dHIuc2V0VmFsdWUocHJlc2VydmVBc3BlY3RSYXRpb0F0dHIuZ2V0U3RyaW5nKCkucmVwbGFjZSgvXlxccyooXFxTLipcXFMpXFxzKiQvLCAnJDEnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdpZHRoQXR0ci5zZXRWYWx1ZSh3aWR0aCk7XG4gICAgICAgIGhlaWdodEF0dHIuc2V0VmFsdWUoaGVpZ2h0KTtcbiAgICAgICAgaWYgKCF2aWV3Qm94QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICB2aWV3Qm94QXR0ci5zZXRWYWx1ZShcIjAgMCBcIi5jb25jYXQob3JpZ2luV2lkdGggfHwgd2lkdGgsIFwiIFwiKS5jb25jYXQob3JpZ2luSGVpZ2h0IHx8IGhlaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGhTdHlsZSA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJyk7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHRTdHlsZSA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpO1xuICAgICAgICAgICAgaWYgKHdpZHRoU3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIHdpZHRoU3R5bGUuc2V0VmFsdWUoXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlaWdodFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHRTdHlsZS5zZXRWYWx1ZShcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3N2Zyc7XG4gICAgICAgIHRoaXMucm9vdCA9IGZhbHNlO1xuICAgIH1cbn1cblxuY2xhc3MgUmVjdEVsZW1lbnQgZXh0ZW5kcyBQYXRoRWxlbWVudCB7XG4gICAgcGF0aChjdHgpIHtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpLmdldFBpeGVscygneScpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJywgZmFsc2UsIHRydWUpLmdldFBpeGVscygneCcpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnLCBmYWxzZSwgdHJ1ZSkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGNvbnN0IHJ4QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyeCcpO1xuICAgICAgICBjb25zdCByeUF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgncnknKTtcbiAgICAgICAgbGV0IHJ4ID0gcnhBdHRyLmdldFBpeGVscygneCcpO1xuICAgICAgICBsZXQgcnkgPSByeUF0dHIuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGlmIChyeEF0dHIuaGFzVmFsdWUoKSAmJiAhcnlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHJ5ID0gcng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ5QXR0ci5oYXNWYWx1ZSgpICYmICFyeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgcnggPSByeTtcbiAgICAgICAgfVxuICAgICAgICByeCA9IE1hdGgubWluKHJ4LCB3aWR0aCAvIDIpO1xuICAgICAgICByeSA9IE1hdGgubWluKHJ5LCBoZWlnaHQgLyAyKTtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY29uc3QgS0FQUEEgPSA0ICogKChNYXRoLnNxcnQoMikgLSAxKSAvIDMpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpIC8vIGFsd2F5cyBzdGFydCB0aGUgcGF0aCBzbyB3ZSBkb24ndCBmaWxsIHByaW9yIHBhdGhzXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBpZiAoaGVpZ2h0ID4gMCAmJiB3aWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHggKyByeCwgeSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByeCwgeSk7XG4gICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCArIHdpZHRoIC0gcnggKyBLQVBQQSAqIHJ4LCB5LCB4ICsgd2lkdGgsIHkgKyByeSAtIEtBUFBBICogcnksIHggKyB3aWR0aCwgeSArIHJ5KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJ5KTtcbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByeSArIEtBUFBBICogcnksIHggKyB3aWR0aCAtIHJ4ICsgS0FQUEEgKiByeCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcngsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHJ4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4ICsgcnggLSBLQVBQQSAqIHJ4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcnkgKyBLQVBQQSAqIHJ5LCB4LCB5ICsgaGVpZ2h0IC0gcnkpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSArIHJ5KTtcbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4LCB5ICsgcnkgLSBLQVBQQSAqIHJ5LCB4ICsgcnggLSBLQVBQQSAqIHJ4LCB5LCB4ICsgcngsIHkpO1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHgsIHksIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgfVxuICAgIGdldE1hcmtlcnMoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdyZWN0JztcbiAgICB9XG59XG5cbmNsYXNzIENpcmNsZUVsZW1lbnQgZXh0ZW5kcyBQYXRoRWxlbWVudCB7XG4gICAgcGF0aChjdHgpIHtcbiAgICAgICAgY29uc3QgY3ggPSB0aGlzLmdldEF0dHJpYnV0ZSgnY3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgY29uc3QgY3kgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgY29uc3QgciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyJykuZ2V0UGl4ZWxzKCk7XG4gICAgICAgIGlmIChjdHggJiYgciA+IDApIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5hcmMoY3gsIGN5LCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goY3ggLSByLCBjeSAtIHIsIGN4ICsgciwgY3kgKyByKTtcbiAgICB9XG4gICAgZ2V0TWFya2VycygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2NpcmNsZSc7XG4gICAgfVxufVxuXG5jbGFzcyBFbGxpcHNlRWxlbWVudCBleHRlbmRzIFBhdGhFbGVtZW50IHtcbiAgICBwYXRoKGN0eCkge1xuICAgICAgICBjb25zdCBLQVBQQSA9IDQgKiAoKE1hdGguc3FydCgyKSAtIDEpIC8gMyk7XG4gICAgICAgIGNvbnN0IHJ4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3J4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IHJ5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3J5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGNvbnN0IGN4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2N4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IGN5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGlmIChjdHggJiYgcnggPiAwICYmIHJ5ID4gMCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhjeCArIHJ4LCBjeSk7XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjeCArIHJ4LCBjeSArIEtBUFBBICogcnksIGN4ICsgS0FQUEEgKiByeCwgY3kgKyByeSwgY3gsIGN5ICsgcnkpO1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3ggLSBLQVBQQSAqIHJ4LCBjeSArIHJ5LCBjeCAtIHJ4LCBjeSArIEtBUFBBICogcnksIGN4IC0gcngsIGN5KTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN4IC0gcngsIGN5IC0gS0FQUEEgKiByeSwgY3ggLSBLQVBQQSAqIHJ4LCBjeSAtIHJ5LCBjeCwgY3kgLSByeSk7XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjeCArIEtBUFBBICogcngsIGN5IC0gcnksIGN4ICsgcngsIGN5IC0gS0FQUEEgKiByeSwgY3ggKyByeCwgY3kpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goY3ggLSByeCwgY3kgLSByeSwgY3ggKyByeCwgY3kgKyByeSk7XG4gICAgfVxuICAgIGdldE1hcmtlcnMoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdlbGxpcHNlJztcbiAgICB9XG59XG5cbmNsYXNzIExpbmVFbGVtZW50IGV4dGVuZHMgUGF0aEVsZW1lbnQge1xuICAgIGdldFBvaW50cygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBQb2ludCh0aGlzLmdldEF0dHJpYnV0ZSgneDEnKS5nZXRQaXhlbHMoJ3gnKSwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3kxJykuZ2V0UGl4ZWxzKCd5JykpLFxuICAgICAgICAgICAgbmV3IFBvaW50KHRoaXMuZ2V0QXR0cmlidXRlKCd4MicpLmdldFBpeGVscygneCcpLCB0aGlzLmdldEF0dHJpYnV0ZSgneTInKS5nZXRQaXhlbHMoJ3knKSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcGF0aChjdHgpIHtcbiAgICAgICAgY29uc3QgW3sgeDogeDAgLCB5OiB5MCAgfSwgeyB4OiB4MSAsIHk6IHkxICB9XSA9IHRoaXMuZ2V0UG9pbnRzKCk7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeDAsIHkwKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeDEsIHkxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHgwLCB5MCwgeDEsIHkxKTtcbiAgICB9XG4gICAgZ2V0TWFya2VycygpIHtcbiAgICAgICAgY29uc3QgW3AwLCBwMV0gPSB0aGlzLmdldFBvaW50cygpO1xuICAgICAgICBjb25zdCBhID0gcDAuYW5nbGVUbyhwMSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgcDAsXG4gICAgICAgICAgICAgICAgYVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBwMSxcbiAgICAgICAgICAgICAgICBhXG4gICAgICAgICAgICBdXG4gICAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2xpbmUnO1xuICAgIH1cbn1cblxuY2xhc3MgUG9seWxpbmVFbGVtZW50IGV4dGVuZHMgUGF0aEVsZW1lbnQge1xuICAgIHBhdGgoY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgcG9pbnRzICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgW3sgeDogeDAgLCB5OiB5MCAgfV0gPSBwb2ludHM7XG4gICAgICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94KHgwLCB5MCk7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeDAsIHkwKTtcbiAgICAgICAgfVxuICAgICAgICBwb2ludHMuZm9yRWFjaCgocGFyYW0pPT57XG4gICAgICAgICAgICBsZXQgeyB4ICwgeSAgfSA9IHBhcmFtO1xuICAgICAgICAgICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgICB9XG4gICAgZ2V0TWFya2VycygpIHtcbiAgICAgICAgY29uc3QgeyBwb2ludHMgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBsYXN0SW5kZXggPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgbWFya2VycyA9IFtdO1xuICAgICAgICBwb2ludHMuZm9yRWFjaCgocG9pbnQsIGkpPT57XG4gICAgICAgICAgICBpZiAoaSA9PT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFya2Vycy5wdXNoKFtcbiAgICAgICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgICAgICBwb2ludC5hbmdsZVRvKHBvaW50c1tpICsgMV0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtYXJrZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG1hcmtlcnMucHVzaChbXG4gICAgICAgICAgICAgICAgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICBtYXJrZXJzW21hcmtlcnMubGVuZ3RoIC0gMV1bMV1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3BvbHlsaW5lJztcbiAgICAgICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5wb2ludHMgPSBQb2ludC5wYXJzZVBhdGgodGhpcy5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpLmdldFN0cmluZygpKTtcbiAgICB9XG59XG5cbmNsYXNzIFBvbHlnb25FbGVtZW50IGV4dGVuZHMgUG9seWxpbmVFbGVtZW50IHtcbiAgICBwYXRoKGN0eCkge1xuICAgICAgICBjb25zdCBib3VuZGluZ0JveCA9IHN1cGVyLnBhdGgoY3R4KTtcbiAgICAgICAgY29uc3QgW3sgeCAsIHkgIH1dID0gdGhpcy5wb2ludHM7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdwb2x5Z29uJztcbiAgICB9XG59XG5cbmNsYXNzIFBhdHRlcm5FbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgY3JlYXRlUGF0dGVybihjdHgsIF8sIHBhcmVudE9wYWNpdHlQcm9wKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKS5nZXRQaXhlbHMoJ3gnLCB0cnVlKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuZ2V0UGl4ZWxzKCd5JywgdHJ1ZSk7XG4gICAgICAgIC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudFxuICAgICAgICBjb25zdCBwYXR0ZXJuU3ZnID0gbmV3IFNWR0VsZW1lbnQodGhpcy5kb2N1bWVudCwgbnVsbCk7XG4gICAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy5zZXQoJ3ZpZXdCb3gnLCBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3ZpZXdCb3gnLCB0aGlzLmdldEF0dHJpYnV0ZSgndmlld0JveCcpLmdldFZhbHVlKCkpKTtcbiAgICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnNldCgnd2lkdGgnLCBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3dpZHRoJywgXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIikpKTtcbiAgICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnNldCgnaGVpZ2h0JywgbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdoZWlnaHQnLCBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIikpKTtcbiAgICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnNldCgndHJhbnNmb3JtJywgbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd0cmFuc2Zvcm0nLCB0aGlzLmdldEF0dHJpYnV0ZSgncGF0dGVyblRyYW5zZm9ybScpLmdldFZhbHVlKCkpKTtcbiAgICAgICAgcGF0dGVyblN2Zy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IHBhdHRlcm5DYW52YXMgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgcGF0dGVybkN0eCA9IHBhdHRlcm5DYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY29uc3QgeEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpO1xuICAgICAgICBjb25zdCB5QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd5Jyk7XG4gICAgICAgIGlmICh4QXR0ci5oYXNWYWx1ZSgpICYmIHlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHBhdHRlcm5DdHgudHJhbnNsYXRlKHhBdHRyLmdldFBpeGVscygneCcsIHRydWUpLCB5QXR0ci5nZXRQaXhlbHMoJ3knLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudE9wYWNpdHlQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzLnNldCgnZmlsbC1vcGFjaXR5JywgcGFyZW50T3BhY2l0eVByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdHlsZXMuZGVsZXRlKCdmaWxsLW9wYWNpdHknKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW5kZXIgM3gzIGdyaWQgc28gd2hlbiB3ZSB0cmFuc2Zvcm0gdGhlcmUncyBubyB3aGl0ZSBzcGFjZSBvbiBlZGdlc1xuICAgICAgICBmb3IobGV0IHggPSAtMTsgeCA8PSAxOyB4Kyspe1xuICAgICAgICAgICAgZm9yKGxldCB5ID0gLTE7IHkgPD0gMTsgeSsrKXtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuQ3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMuc2V0KCd4JywgbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd4JywgeCAqIHBhdHRlcm5DYW52YXMud2lkdGgpKTtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMuc2V0KCd5JywgbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd5JywgeSAqIHBhdHRlcm5DYW52YXMuaGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgcGF0dGVyblN2Zy5yZW5kZXIocGF0dGVybkN0eCk7XG4gICAgICAgICAgICAgICAgcGF0dGVybkN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKHBhdHRlcm5DYW52YXMsICdyZXBlYXQnKTtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3BhdHRlcm4nO1xuICAgIH1cbn1cblxuY2xhc3MgTWFya2VyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIHJlbmRlcihjdHgsIHBvaW50LCBhbmdsZSkge1xuICAgICAgICBpZiAoIXBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IHBvaW50O1xuICAgICAgICBjb25zdCBvcmllbnQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnb3JpZW50JykuZ2V0U3RyaW5nKCdhdXRvJyk7XG4gICAgICAgIGNvbnN0IG1hcmtlclVuaXRzID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21hcmtlclVuaXRzJykuZ2V0U3RyaW5nKCdzdHJva2VXaWR0aCcpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgICBpZiAob3JpZW50ID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoYW5nbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZXJVbml0cyA9PT0gJ3N0cm9rZVdpZHRoJykge1xuICAgICAgICAgICAgY3R4LnNjYWxlKGN0eC5saW5lV2lkdGgsIGN0eC5saW5lV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudFxuICAgICAgICBjb25zdCBtYXJrZXJTdmcgPSBuZXcgU1ZHRWxlbWVudCh0aGlzLmRvY3VtZW50KTtcbiAgICAgICAgbWFya2VyU3ZnLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLnNldCgndmlld0JveCcsIG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAndmlld0JveCcsIHRoaXMuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykuZ2V0VmFsdWUoKSkpO1xuICAgICAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5zZXQoJ3JlZlgnLCBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3JlZlgnLCB0aGlzLmdldEF0dHJpYnV0ZSgncmVmWCcpLmdldFZhbHVlKCkpKTtcbiAgICAgICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMuc2V0KCdyZWZZJywgbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdyZWZZJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlZlknKS5nZXRWYWx1ZSgpKSk7XG4gICAgICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLnNldCgnd2lkdGgnLCBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3dpZHRoJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ21hcmtlcldpZHRoJykuZ2V0VmFsdWUoKSkpO1xuICAgICAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5zZXQoJ2hlaWdodCcsIG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnaGVpZ2h0JywgdGhpcy5nZXRBdHRyaWJ1dGUoJ21hcmtlckhlaWdodCcpLmdldFZhbHVlKCkpKTtcbiAgICAgICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMuc2V0KCdvdmVyZmxvdycsIG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnb3ZlcmZsb3cnLCB0aGlzLmdldEF0dHJpYnV0ZSgnb3ZlcmZsb3cnKS5nZXRWYWx1ZSgpKSk7XG4gICAgICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLnNldCgnZmlsbCcsIG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnZmlsbCcsIHRoaXMuZ2V0QXR0cmlidXRlKCdmaWxsJykuZ2V0Q29sb3IoJ2JsYWNrJykpKTtcbiAgICAgICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMuc2V0KCdzdHJva2UnLCBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3N0cm9rZScsIHRoaXMuZ2V0QXR0cmlidXRlKCdzdHJva2UnKS5nZXRWYWx1ZSgnbm9uZScpKSk7XG4gICAgICAgIG1hcmtlclN2Zy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgIG1hcmtlclN2Zy5yZW5kZXIoY3R4KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgaWYgKG1hcmtlclVuaXRzID09PSAnc3Ryb2tlV2lkdGgnKSB7XG4gICAgICAgICAgICBjdHguc2NhbGUoMSAvIGN0eC5saW5lV2lkdGgsIDEgLyBjdHgubGluZVdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZW50ID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoLWFuZ2xlKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgudHJhbnNsYXRlKC14LCAteSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ21hcmtlcic7XG4gICAgfVxufVxuXG5jbGFzcyBEZWZzRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAvLyBOT09QXG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2RlZnMnO1xuICAgIH1cbn1cblxuY2xhc3MgR0VsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICAgIGdldEJvdW5kaW5nQm94KGN0eCkge1xuICAgICAgICBjb25zdCBib3VuZGluZ0JveCA9IG5ldyBCb3VuZGluZ0JveCgpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKT0+e1xuICAgICAgICAgICAgYm91bmRpbmdCb3guYWRkQm91bmRpbmdCb3goY2hpbGQuZ2V0Qm91bmRpbmdCb3goY3R4KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2cnO1xuICAgIH1cbn1cblxuY2xhc3MgR3JhZGllbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgZ2V0R3JhZGllbnRVbml0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdncmFkaWVudFVuaXRzJykuZ2V0U3RyaW5nKCdvYmplY3RCb3VuZGluZ0JveCcpO1xuICAgIH1cbiAgICBjcmVhdGVHcmFkaWVudChjdHgsIGVsZW1lbnQsIHBhcmVudE9wYWNpdHlQcm9wKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhcywgY29uc2lzdGVudC10aGlzXG4gICAgICAgIGxldCBzdG9wc0NvbnRhaW5lciA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBzdG9wc0NvbnRhaW5lciA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuaW5oZXJpdFN0b3BDb250YWluZXIoc3RvcHNDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3RvcHMgIH0gPSBzdG9wc0NvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgZ3JhZGllbnQgPSB0aGlzLmdldEdyYWRpZW50KGN0eCwgZWxlbWVudCk7XG4gICAgICAgIGlmICghZ3JhZGllbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZFBhcmVudE9wYWNpdHkocGFyZW50T3BhY2l0eVByb3AsIHN0b3BzW3N0b3BzLmxlbmd0aCAtIDFdLmNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBzdG9wcy5mb3JFYWNoKChzdG9wKT0+e1xuICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3Aub2Zmc2V0LCB0aGlzLmFkZFBhcmVudE9wYWNpdHkocGFyZW50T3BhY2l0eVByb3AsIHN0b3AuY29sb3IpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRUcmFuc2Zvcm0nKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAvLyByZW5kZXIgYXMgdHJhbnNmb3JtZWQgcGF0dGVybiBvbiB0ZW1wb3JhcnkgY2FudmFzXG4gICAgICAgICAgICBjb25zdCB7IGRvY3VtZW50ICB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgTUFYX1ZJUlRVQUxfUElYRUxTICB9ID0gU2NyZWVuO1xuICAgICAgICAgICAgY29uc3QgeyB2aWV3UG9ydCAgfSA9IGRvY3VtZW50LnNjcmVlbjtcbiAgICAgICAgICAgIGNvbnN0IHJvb3RWaWV3ID0gdmlld1BvcnQuZ2V0Um9vdCgpO1xuICAgICAgICAgICAgY29uc3QgcmVjdCA9IG5ldyBSZWN0RWxlbWVudChkb2N1bWVudCk7XG4gICAgICAgICAgICByZWN0LmF0dHJpYnV0ZXMuc2V0KCd4JywgbmV3IFByb3BlcnR5KGRvY3VtZW50LCAneCcsIC1NQVhfVklSVFVBTF9QSVhFTFMgLyAzKSk7XG4gICAgICAgICAgICByZWN0LmF0dHJpYnV0ZXMuc2V0KCd5JywgbmV3IFByb3BlcnR5KGRvY3VtZW50LCAneScsIC1NQVhfVklSVFVBTF9QSVhFTFMgLyAzKSk7XG4gICAgICAgICAgICByZWN0LmF0dHJpYnV0ZXMuc2V0KCd3aWR0aCcsIG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3dpZHRoJywgTUFYX1ZJUlRVQUxfUElYRUxTKSk7XG4gICAgICAgICAgICByZWN0LmF0dHJpYnV0ZXMuc2V0KCdoZWlnaHQnLCBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdoZWlnaHQnLCBNQVhfVklSVFVBTF9QSVhFTFMpKTtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gbmV3IEdFbGVtZW50KGRvY3VtZW50KTtcbiAgICAgICAgICAgIGdyb3VwLmF0dHJpYnV0ZXMuc2V0KCd0cmFuc2Zvcm0nLCBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd0cmFuc2Zvcm0nLCB0aGlzLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRUcmFuc2Zvcm0nKS5nZXRWYWx1ZSgpKSk7XG4gICAgICAgICAgICBncm91cC5jaGlsZHJlbiA9IFtcbiAgICAgICAgICAgICAgICByZWN0XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgcGF0dGVyblN2ZyA9IG5ldyBTVkdFbGVtZW50KGRvY3VtZW50KTtcbiAgICAgICAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy5zZXQoJ3gnLCBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd4JywgMCkpO1xuICAgICAgICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnNldCgneScsIG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3knLCAwKSk7XG4gICAgICAgICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMuc2V0KCd3aWR0aCcsIG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3dpZHRoJywgcm9vdFZpZXcud2lkdGgpKTtcbiAgICAgICAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy5zZXQoJ2hlaWdodCcsIG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2hlaWdodCcsIHJvb3RWaWV3LmhlaWdodCkpO1xuICAgICAgICAgICAgcGF0dGVyblN2Zy5jaGlsZHJlbiA9IFtcbiAgICAgICAgICAgICAgICBncm91cFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVDYW52YXMocm9vdFZpZXcud2lkdGgsIHJvb3RWaWV3LmhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuQ3R4ID0gcGF0dGVybkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgcGF0dGVybkN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICAgICAgICAgIHBhdHRlcm5TdmcucmVuZGVyKHBhdHRlcm5DdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm5DdHguY3JlYXRlUGF0dGVybihwYXR0ZXJuQ2FudmFzLCAnbm8tcmVwZWF0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyYWRpZW50O1xuICAgIH1cbiAgICBpbmhlcml0U3RvcENvbnRhaW5lcihzdG9wc0NvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQuZm9yRWFjaCgoYXR0cmlidXRlVG9Jbmhlcml0KT0+e1xuICAgICAgICAgICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVUb0luaGVyaXQpLmhhc1ZhbHVlKCkgJiYgc3RvcHNDb250YWluZXIuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZVRvSW5oZXJpdCkuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZVRvSW5oZXJpdCwgdHJ1ZSkuc2V0VmFsdWUoc3RvcHNDb250YWluZXIuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZVRvSW5oZXJpdCkuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZGRQYXJlbnRPcGFjaXR5KHBhcmVudE9wYWNpdHlQcm9wLCBjb2xvcikge1xuICAgICAgICBpZiAocGFyZW50T3BhY2l0eVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgY29uc3QgY29sb3JQcm9wID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdjb2xvcicsIGNvbG9yKTtcbiAgICAgICAgICAgIHJldHVybiBjb2xvclByb3AuYWRkT3BhY2l0eShwYXJlbnRPcGFjaXR5UHJvcCkuZ2V0Q29sb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQgPSBbXG4gICAgICAgICAgICAnZ3JhZGllbnRVbml0cydcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5zdG9wcyA9IFtdO1xuICAgICAgICBjb25zdCB7IHN0b3BzICwgY2hpbGRyZW4gIH0gPSB0aGlzO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCk9PntcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnc3RvcCcpIHtcbiAgICAgICAgICAgICAgICBzdG9wcy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBMaW5lYXJHcmFkaWVudEVsZW1lbnQgZXh0ZW5kcyBHcmFkaWVudEVsZW1lbnQge1xuICAgIGdldEdyYWRpZW50KGN0eCwgZWxlbWVudCkge1xuICAgICAgICBjb25zdCBpc0JvdW5kaW5nQm94VW5pdHMgPSB0aGlzLmdldEdyYWRpZW50VW5pdHMoKSA9PT0gJ29iamVjdEJvdW5kaW5nQm94JztcbiAgICAgICAgY29uc3QgYm91bmRpbmdCb3ggPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBlbGVtZW50LmdldEJvdW5kaW5nQm94KGN0eCkgOiBudWxsO1xuICAgICAgICBpZiAoaXNCb3VuZGluZ0JveFVuaXRzICYmICFib3VuZGluZ0JveCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgneDEnKS5oYXNWYWx1ZSgpICYmICF0aGlzLmdldEF0dHJpYnV0ZSgneTEnKS5oYXNWYWx1ZSgpICYmICF0aGlzLmdldEF0dHJpYnV0ZSgneDInKS5oYXNWYWx1ZSgpICYmICF0aGlzLmdldEF0dHJpYnV0ZSgneTInKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgneDEnLCB0cnVlKS5zZXRWYWx1ZSgwKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd5MScsIHRydWUpLnNldFZhbHVlKDApO1xuICAgICAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3gyJywgdHJ1ZSkuc2V0VmFsdWUoMSk7XG4gICAgICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgneTInLCB0cnVlKS5zZXRWYWx1ZSgwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4MSA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnggKyBib3VuZGluZ0JveC53aWR0aCAqIHRoaXMuZ2V0QXR0cmlidXRlKCd4MScpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ3gxJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IHkxID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueSArIGJvdW5kaW5nQm94LmhlaWdodCAqIHRoaXMuZ2V0QXR0cmlidXRlKCd5MScpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ3kxJykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGNvbnN0IHgyID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueCArIGJvdW5kaW5nQm94LndpZHRoICogdGhpcy5nZXRBdHRyaWJ1dGUoJ3gyJykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgneDInKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgY29uc3QgeTIgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC55ICsgYm91bmRpbmdCb3guaGVpZ2h0ICogdGhpcy5nZXRBdHRyaWJ1dGUoJ3kyJykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgneTInKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgaWYgKHgxID09PSB4MiAmJiB5MSA9PT0geTIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeDEsIHkxLCB4MiwgeTIpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2xpbmVhckdyYWRpZW50JztcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LnB1c2goJ3gxJywgJ3kxJywgJ3gyJywgJ3kyJyk7XG4gICAgfVxufVxuXG5jbGFzcyBSYWRpYWxHcmFkaWVudEVsZW1lbnQgZXh0ZW5kcyBHcmFkaWVudEVsZW1lbnQge1xuICAgIGdldEdyYWRpZW50KGN0eCwgZWxlbWVudCkge1xuICAgICAgICBjb25zdCBpc0JvdW5kaW5nQm94VW5pdHMgPSB0aGlzLmdldEdyYWRpZW50VW5pdHMoKSA9PT0gJ29iamVjdEJvdW5kaW5nQm94JztcbiAgICAgICAgY29uc3QgYm91bmRpbmdCb3ggPSBlbGVtZW50LmdldEJvdW5kaW5nQm94KGN0eCk7XG4gICAgICAgIGlmIChpc0JvdW5kaW5nQm94VW5pdHMgJiYgIWJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZ2V0QXR0cmlidXRlKCdjeCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdjeCcsIHRydWUpLnNldFZhbHVlKCc1MCUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZ2V0QXR0cmlidXRlKCdjeScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdjeScsIHRydWUpLnNldFZhbHVlKCc1MCUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZ2V0QXR0cmlidXRlKCdyJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3InLCB0cnVlKS5zZXRWYWx1ZSgnNTAlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3ggPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC54ICsgYm91bmRpbmdCb3gud2lkdGggKiB0aGlzLmdldEF0dHJpYnV0ZSgnY3gnKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCdjeCcpLmdldFBpeGVscygneCcpO1xuICAgICAgICBjb25zdCBjeSA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnkgKyBib3VuZGluZ0JveC5oZWlnaHQgKiB0aGlzLmdldEF0dHJpYnV0ZSgnY3knKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCdjeScpLmdldFBpeGVscygneScpO1xuICAgICAgICBsZXQgZnggPSBjeDtcbiAgICAgICAgbGV0IGZ5ID0gY3k7XG4gICAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnZngnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBmeCA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnggKyBib3VuZGluZ0JveC53aWR0aCAqIHRoaXMuZ2V0QXR0cmlidXRlKCdmeCcpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ2Z4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdmeScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIGZ5ID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueSArIGJvdW5kaW5nQm94LmhlaWdodCAqIHRoaXMuZ2V0QXR0cmlidXRlKCdmeScpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ2Z5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgciA9IGlzQm91bmRpbmdCb3hVbml0cyA/IChib3VuZGluZ0JveC53aWR0aCArIGJvdW5kaW5nQm94LmhlaWdodCkgLyAyICogdGhpcy5nZXRBdHRyaWJ1dGUoJ3InKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCdyJykuZ2V0UGl4ZWxzKCk7XG4gICAgICAgIGNvbnN0IGZyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2ZyJykuZ2V0UGl4ZWxzKCk7XG4gICAgICAgIHJldHVybiBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoZngsIGZ5LCBmciwgY3gsIGN5LCByKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdyYWRpYWxHcmFkaWVudCc7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5wdXNoKCdjeCcsICdjeScsICdyJywgJ2Z4JywgJ2Z5JywgJ2ZyJyk7XG4gICAgfVxufVxuXG5jbGFzcyBTdG9wRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnc3RvcCc7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHRoaXMuZ2V0QXR0cmlidXRlKCdvZmZzZXQnKS5nZXROdW1iZXIoKSkpO1xuICAgICAgICBjb25zdCBzdG9wT3BhY2l0eSA9IHRoaXMuZ2V0U3R5bGUoJ3N0b3Atb3BhY2l0eScpO1xuICAgICAgICBsZXQgc3RvcENvbG9yID0gdGhpcy5nZXRTdHlsZSgnc3RvcC1jb2xvcicsIHRydWUpO1xuICAgICAgICBpZiAoc3RvcENvbG9yLmdldFN0cmluZygpID09PSAnJykge1xuICAgICAgICAgICAgc3RvcENvbG9yLnNldFZhbHVlKCcjMDAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0b3BPcGFjaXR5Lmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHN0b3BDb2xvciA9IHN0b3BDb2xvci5hZGRPcGFjaXR5KHN0b3BPcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5jb2xvciA9IHN0b3BDb2xvci5nZXRDb2xvcigpO1xuICAgIH1cbn1cblxuY2xhc3MgQW5pbWF0ZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBnZXRQcm9wZXJ0eSgpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlVHlwZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhdHRyaWJ1dGVUeXBlJykuZ2V0U3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYXR0cmlidXRlTmFtZScpLmdldFN0cmluZygpO1xuICAgICAgICBpZiAoYXR0cmlidXRlVHlwZSA9PT0gJ0NTUycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRTdHlsZShhdHRyaWJ1dGVOYW1lLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIHRydWUpO1xuICAgIH1cbiAgICBjYWxjVmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHsgaW5pdGlhbFVuaXRzICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBwcm9ncmVzcyAsIGZyb20gLCB0byAgfSA9IHRoaXMuZ2V0UHJvZ3Jlc3MoKTtcbiAgICAgICAgLy8gdHdlZW4gdmFsdWUgbGluZWFybHlcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gZnJvbS5nZXROdW1iZXIoKSArICh0by5nZXROdW1iZXIoKSAtIGZyb20uZ2V0TnVtYmVyKCkpICogcHJvZ3Jlc3M7XG4gICAgICAgIGlmIChpbml0aWFsVW5pdHMgPT09ICclJykge1xuICAgICAgICAgICAgbmV3VmFsdWUgKj0gMTAwIC8vIG51bVZhbHVlKCkgcmV0dXJucyAwLTEgd2hlcmVhcyBwcm9wZXJ0aWVzIGFyZSAwLTEwMFxuICAgICAgICAgICAgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChuZXdWYWx1ZSkuY29uY2F0KGluaXRpYWxVbml0cyk7XG4gICAgfVxuICAgIHVwZGF0ZShkZWx0YSkge1xuICAgICAgICBjb25zdCB7IHBhcmVudCAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHByb3AgPSB0aGlzLmdldFByb3BlcnR5KCk7XG4gICAgICAgIC8vIHNldCBpbml0aWFsIHZhbHVlXG4gICAgICAgIGlmICghdGhpcy5pbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gcHJvcC5nZXRTdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFVuaXRzID0gcHJvcC5nZXRVbml0cygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlJ3JlIHBhc3QgdGhlIGVuZCB0aW1lXG4gICAgICAgIGlmICh0aGlzLmR1cmF0aW9uID4gdGhpcy5tYXhEdXJhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgZmlsbCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdmaWxsJykuZ2V0U3RyaW5nKCdyZW1vdmUnKTtcbiAgICAgICAgICAgIC8vIGxvb3AgZm9yIGluZGVmaW5pdGVseSByZXBlYXRpbmcgYW5pbWF0aW9uc1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdyZXBlYXRDb3VudCcpLmdldFN0cmluZygpID09PSAnaW5kZWZpbml0ZScgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlcGVhdER1cicpLmdldFN0cmluZygpID09PSAnaW5kZWZpbml0ZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2ZyZWV6ZScgJiYgIXRoaXMuZnJvemVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm96ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuYW5pbWF0aW9uRnJvemVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmFuaW1hdGlvbkZyb3plblZhbHVlID0gcHJvcC5nZXRTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZpbGwgPT09ICdyZW1vdmUnICYmICF0aGlzLnJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wLnNldFZhbHVlKHBhcmVudC5hbmltYXRpb25Gcm96ZW4gPyBwYXJlbnQuYW5pbWF0aW9uRnJvemVuVmFsdWUgOiB0aGlzLmluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHVyYXRpb24gKz0gZGVsdGE7XG4gICAgICAgIC8vIGlmIHdlJ3JlIHBhc3QgdGhlIGJlZ2luIHRpbWVcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuYmVnaW4gPCB0aGlzLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICBsZXQgbmV3VmFsdWUgPSB0aGlzLmNhbGNWYWx1ZSgpIC8vIHR3ZWVuXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBjb25zdCB0eXBlQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICBpZiAodHlwZUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIC8vIGZvciB0cmFuc2Zvcm0sIGV0Yy5cbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gdHlwZUF0dHIuZ2V0U3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBcIlwiLmNvbmNhdCh0eXBlLCBcIihcIikuY29uY2F0KG5ld1ZhbHVlLCBcIilcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wLnNldFZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH1cbiAgICBnZXRQcm9ncmVzcygpIHtcbiAgICAgICAgY29uc3QgeyBkb2N1bWVudCAsIHZhbHVlcyAgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwcm9ncmVzcyA9ICh0aGlzLmR1cmF0aW9uIC0gdGhpcy5iZWdpbikgLyAodGhpcy5tYXhEdXJhdGlvbiAtIHRoaXMuYmVnaW4pO1xuICAgICAgICBsZXQgZnJvbTtcbiAgICAgICAgbGV0IHRvO1xuICAgICAgICBpZiAodmFsdWVzLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBwcm9ncmVzcyAqICh2YWx1ZXMuZ2V0VmFsdWUoKS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGNvbnN0IGxiID0gTWF0aC5mbG9vcihwKTtcbiAgICAgICAgICAgIGNvbnN0IHViID0gTWF0aC5jZWlsKHApO1xuICAgICAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuZ2V0VmFsdWUoKVtsYl07XG4gICAgICAgICAgICBmcm9tID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnZnJvbScsIHZhbHVlID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiAwKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmdldFZhbHVlKClbdWJdO1xuICAgICAgICAgICAgdG8gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd0bycsIHZhbHVlID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiAwKTtcbiAgICAgICAgICAgIHByb2dyZXNzID0gKHAgLSBsYikgLyAodWIgLSBsYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gdGhpcy5mcm9tO1xuICAgICAgICAgICAgdG8gPSB0aGlzLnRvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9ncmVzcyxcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0b1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2FuaW1hdGUnO1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICAgICAgdGhpcy5pbml0aWFsVW5pdHMgPSAnJztcbiAgICAgICAgdGhpcy5yZW1vdmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZnJvemVuID0gZmFsc2U7XG4gICAgICAgIGRvY3VtZW50LnNjcmVlbi5hbmltYXRpb25zLnB1c2godGhpcyk7XG4gICAgICAgIHRoaXMuYmVnaW4gPSB0aGlzLmdldEF0dHJpYnV0ZSgnYmVnaW4nKS5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgdGhpcy5tYXhEdXJhdGlvbiA9IHRoaXMuYmVnaW4gKyB0aGlzLmdldEF0dHJpYnV0ZSgnZHVyJykuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdmcm9tJyk7XG4gICAgICAgIHRoaXMudG8gPSB0aGlzLmdldEF0dHJpYnV0ZSgndG8nKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd2YWx1ZXMnLCBudWxsKTtcbiAgICAgICAgY29uc3QgdmFsdWVzQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZXMnKTtcbiAgICAgICAgaWYgKHZhbHVlc0F0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMuc2V0VmFsdWUodmFsdWVzQXR0ci5nZXRTdHJpbmcoKS5zcGxpdCgnOycpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQW5pbWF0ZUNvbG9yRWxlbWVudCBleHRlbmRzIEFuaW1hdGVFbGVtZW50IHtcbiAgICBjYWxjVmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvZ3Jlc3MgLCBmcm9tICwgdG8gIH0gPSB0aGlzLmdldFByb2dyZXNzKCk7XG4gICAgICAgIGNvbnN0IGNvbG9yRnJvbSA9IG5ldyBSR0JDb2xvcihmcm9tLmdldENvbG9yKCkpO1xuICAgICAgICBjb25zdCBjb2xvclRvID0gbmV3IFJHQkNvbG9yKHRvLmdldENvbG9yKCkpO1xuICAgICAgICBpZiAoY29sb3JGcm9tLm9rICYmIGNvbG9yVG8ub2spIHtcbiAgICAgICAgICAgIC8vIHR3ZWVuIGNvbG9yIGxpbmVhcmx5XG4gICAgICAgICAgICBjb25zdCByID0gY29sb3JGcm9tLnIgKyAoY29sb3JUby5yIC0gY29sb3JGcm9tLnIpICogcHJvZ3Jlc3M7XG4gICAgICAgICAgICBjb25zdCBnID0gY29sb3JGcm9tLmcgKyAoY29sb3JUby5nIC0gY29sb3JGcm9tLmcpICogcHJvZ3Jlc3M7XG4gICAgICAgICAgICBjb25zdCBiID0gY29sb3JGcm9tLmIgKyAoY29sb3JUby5iIC0gY29sb3JGcm9tLmIpICogcHJvZ3Jlc3M7XG4gICAgICAgICAgICAvLyA/IGFscGhhXG4gICAgICAgICAgICByZXR1cm4gXCJyZ2IoXCIuY29uY2F0KE1hdGguZmxvb3IociksIFwiLCBcIikuY29uY2F0KE1hdGguZmxvb3IoZyksIFwiLCBcIikuY29uY2F0KE1hdGguZmxvb3IoYiksIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2Zyb20nKS5nZXRDb2xvcigpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdhbmltYXRlQ29sb3InO1xuICAgIH1cbn1cblxuY2xhc3MgQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQgZXh0ZW5kcyBBbmltYXRlRWxlbWVudCB7XG4gICAgY2FsY1ZhbHVlKCkge1xuICAgICAgICBjb25zdCB7IHByb2dyZXNzICwgZnJvbTogZnJvbTEgLCB0bzogdG8xICB9ID0gdGhpcy5nZXRQcm9ncmVzcygpO1xuICAgICAgICAvLyB0d2VlbiB2YWx1ZSBsaW5lYXJseVxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1Gcm9tID0gdG9OdW1iZXJzKGZyb20xLmdldFN0cmluZygpKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtVG8gPSB0b051bWJlcnModG8xLmdldFN0cmluZygpKTtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB0cmFuc2Zvcm1Gcm9tLm1hcCgoZnJvbSwgaSk9PntcbiAgICAgICAgICAgIGNvbnN0IHRvID0gdHJhbnNmb3JtVG9baV07XG4gICAgICAgICAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogcHJvZ3Jlc3M7XG4gICAgICAgIH0pLmpvaW4oJyAnKTtcbiAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdhbmltYXRlVHJhbnNmb3JtJztcbiAgICB9XG59XG5cbmNsYXNzIEZvbnRGYWNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZm9udC1mYWNlJztcbiAgICAgICAgdGhpcy5hc2NlbnQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYXNjZW50JykuZ2V0TnVtYmVyKCk7XG4gICAgICAgIHRoaXMuZGVzY2VudCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdkZXNjZW50JykuZ2V0TnVtYmVyKCk7XG4gICAgICAgIHRoaXMudW5pdHNQZXJFbSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd1bml0cy1wZXItZW0nKS5nZXROdW1iZXIoKTtcbiAgICB9XG59XG5cbmNsYXNzIEdseXBoRWxlbWVudCBleHRlbmRzIFBhdGhFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2dseXBoJztcbiAgICAgICAgdGhpcy5ob3JpekFkdlggPSB0aGlzLmdldEF0dHJpYnV0ZSgnaG9yaXotYWR2LXgnKS5nZXROdW1iZXIoKTtcbiAgICAgICAgdGhpcy51bmljb2RlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3VuaWNvZGUnKS5nZXRTdHJpbmcoKTtcbiAgICAgICAgdGhpcy5hcmFiaWNGb3JtID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FyYWJpYy1mb3JtJykuZ2V0U3RyaW5nKCk7XG4gICAgfVxufVxuXG5jbGFzcyBNaXNzaW5nR2x5cGhFbGVtZW50IGV4dGVuZHMgR2x5cGhFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdtaXNzaW5nLWdseXBoJztcbiAgICAgICAgdGhpcy5ob3JpekFkdlggPSAwO1xuICAgIH1cbn1cblxuY2xhc3MgRm9udEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgLy8gTk8gUkVOREVSXG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZm9udCc7XG4gICAgICAgIHRoaXMuaXNBcmFiaWMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5nbHlwaHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYXJhYmljR2x5cGhzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmlzUlRMID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaG9yaXpBZHZYID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2hvcml6LWFkdi14JykuZ2V0TnVtYmVyKCk7XG4gICAgICAgIGNvbnN0IHsgZGVmaW5pdGlvbnMgIH0gPSBkb2N1bWVudDtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiAgfSA9IHRoaXM7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pe1xuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgRm9udEZhY2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb250RmFjZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvbnRGYW1pbHlTdHlsZSA9IGNoaWxkLmdldFN0eWxlKCdmb250LWZhbWlseScpO1xuICAgICAgICAgICAgICAgIGlmIChmb250RmFtaWx5U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9ucy5zZXQoZm9udEZhbWlseVN0eWxlLmdldFN0cmluZygpLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgTWlzc2luZ0dseXBoRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWlzc2luZ0dseXBoID0gY2hpbGQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgR2x5cGhFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmFyYWJpY0Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1JUTCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNBcmFiaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXJhYmljR2x5cGggPSB0aGlzLmFyYWJpY0dseXBocy5nZXQoY2hpbGQudW5pY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJhYmljR2x5cGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmFiaWNHbHlwaCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJhYmljR2x5cGhzLnNldChjaGlsZC51bmljb2RlLCBhcmFiaWNHbHlwaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJhYmljR2x5cGguc2V0KGNoaWxkLmFyYWJpY0Zvcm0sIGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdseXBocy5zZXQoY2hpbGQudW5pY29kZSwgY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgVFJlZkVsZW1lbnQgZXh0ZW5kcyBUZXh0RWxlbWVudCB7XG4gICAgZ2V0VGV4dCgpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBlbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3RDaGlsZC5nZXRUZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICd0cmVmJztcbiAgICB9XG59XG5cbmNsYXNzIEFFbGVtZW50IGV4dGVuZHMgVGV4dEVsZW1lbnQge1xuICAgIGdldFRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfVxuICAgIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5oYXNUZXh0KSB7XG4gICAgICAgICAgICAvLyByZW5kZXIgYXMgdGV4dCBlbGVtZW50XG4gICAgICAgICAgICBzdXBlci5yZW5kZXJDaGlsZHJlbihjdHgpO1xuICAgICAgICAgICAgY29uc3QgeyBkb2N1bWVudCAsIHggLCB5ICB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgbW91c2UgIH0gPSBkb2N1bWVudC5zY3JlZW47XG4gICAgICAgICAgICBjb25zdCBmb250U2l6ZSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2ZvbnRTaXplJywgRm9udC5wYXJzZShkb2N1bWVudC5jdHguZm9udCkuZm9udFNpemUpO1xuICAgICAgICAgICAgLy8gRG8gbm90IGNhbGMgYm91bmRpbmcgYm94IGlmIG1vdXNlIGlzIG5vdCB3b3JraW5nLlxuICAgICAgICAgICAgaWYgKG1vdXNlLmlzV29ya2luZygpKSB7XG4gICAgICAgICAgICAgICAgbW91c2UuY2hlY2tCb3VuZGluZ0JveCh0aGlzLCBuZXcgQm91bmRpbmdCb3goeCwgeSAtIGZvbnRTaXplLmdldFBpeGVscygneScpLCB4ICsgdGhpcy5tZWFzdXJlVGV4dChjdHgpLCB5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyByZW5kZXIgYXMgdGVtcG9yYXJ5IGdyb3VwXG4gICAgICAgICAgICBjb25zdCBnID0gbmV3IEdFbGVtZW50KHRoaXMuZG9jdW1lbnQpO1xuICAgICAgICAgICAgZy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgICAgICBnLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICBnLnJlbmRlcihjdHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uQ2xpY2soKSB7XG4gICAgICAgIGNvbnN0IHsgd2luZG93ICB9ID0gdGhpcy5kb2N1bWVudDtcbiAgICAgICAgaWYgKHdpbmRvdykge1xuICAgICAgICAgICAgd2luZG93Lm9wZW4odGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0U3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uTW91c2VNb3ZlKCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmRvY3VtZW50LmN0eDtcbiAgICAgICAgY3R4LmNhbnZhcy5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlMSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlMSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdhJztcbiAgICAgICAgY29uc3QgeyBjaGlsZE5vZGVzICB9ID0gbm9kZTE7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBjaGlsZE5vZGVzWzBdO1xuICAgICAgICBjb25zdCBoYXNUZXh0ID0gY2hpbGROb2Rlcy5sZW5ndGggPiAwICYmIEFycmF5LmZyb20oY2hpbGROb2RlcykuZXZlcnkoKG5vZGUpPT5ub2RlLm5vZGVUeXBlID09PSAzXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuaGFzVGV4dCA9IGhhc1RleHQ7XG4gICAgICAgIHRoaXMudGV4dCA9IGhhc1RleHQgPyB0aGlzLmdldFRleHRGcm9tTm9kZShmaXJzdENoaWxkKSA6ICcnO1xuICAgIH1cbn1cblxuY2xhc3MgVGV4dFBhdGhFbGVtZW50IGV4dGVuZHMgVGV4dEVsZW1lbnQge1xuICAgIGdldFRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfVxuICAgIHBhdGgoY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YUFycmF5ICB9ID0gdGhpcztcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFBcnJheS5mb3JFYWNoKChwYXJhbSk9PntcbiAgICAgICAgICAgIGxldCB7IHR5cGUgLCBwb2ludHMgIH0gPSBwYXJhbTtcbiAgICAgICAgICAgIHN3aXRjaCh0eXBlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLk1PVkVfVE86XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBwb2ludHNbNF0sIHBvaW50c1s1XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW2N4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzXSA9IHBvaW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSByeCA+IHJ5ID8gcnggOiByeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlWCA9IHJ4ID4gcnkgPyAxIDogcnggLyByeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IHJ4ID4gcnkgPyByeSAvIHJ4IDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShwc2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYygwLCAwLCByLCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIEJvb2xlYW4oMSAtIGZzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5DTE9TRV9QQVRIOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICAgICAgdGhpcy5zZXRUZXh0RGF0YShjdHgpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjb25zdCB0ZXh0RGVjb3JhdGlvbiA9IHRoaXMucGFyZW50LmdldFN0eWxlKCd0ZXh0LWRlY29yYXRpb24nKS5nZXRTdHJpbmcoKTtcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG4gICAgICAgIGNvbnN0IHsgZ2x5cGhJbmZvICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZmlsbCA9IGN0eC5maWxsU3R5bGU7XG4gICAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbiA9PT0gJ3VuZGVybGluZScpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBnbHlwaEluZm8uZm9yRWFjaCgoZ2x5cGgsIGkpPT57XG4gICAgICAgICAgICBjb25zdCB7IHAwICwgcDEgLCByb3RhdGlvbiAsIHRleHQ6IHBhcnRpYWxUZXh0ICB9ID0gZ2x5cGg7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShwMC54LCBwMC55KTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUocm90YXRpb24pO1xuICAgICAgICAgICAgaWYgKGN0eC5maWxsU3R5bGUpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQocGFydGlhbFRleHQsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN0eC5zdHJva2VTdHlsZSkge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KHBhcnRpYWxUZXh0LCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICBpZiAodGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwMC54LCBwMC55ICsgZm9udFNpemUgLyA4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwMS54LCBwMS55ICsgZm9udFNpemUgLyA1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gLy8gVG8gYXNzaXN0IHdpdGggZGVidWdnaW5nIHZpc3VhbGx5LCB1bmNvbW1lbnQgZm9sbG93aW5nXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgLy8gaWYgKGkgJSAyKVxuICAgICAgICAvLyAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgICAvLyBlbHNlXG4gICAgICAgIC8vICAgY3R4LnN0cm9rZVN0eWxlID0gJ2dyZWVuJztcbiAgICAgICAgLy8gY3R4Lm1vdmVUbyhwMC54LCBwMC55KTtcbiAgICAgICAgLy8gY3R4LmxpbmVUbyhwMS54LCBwMS55KTtcbiAgICAgICAgLy8gY3R4LnN0cm9rZSgpO1xuICAgICAgICAvLyBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnKSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gZm9udFNpemUgLyAyMDtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGZpbGw7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgZ2V0TGV0dGVyU3BhY2luZ0F0KCkge1xuICAgICAgICBsZXQgaWR4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgICByZXR1cm4gdGhpcy5sZXR0ZXJTcGFjaW5nQ2FjaGVbaWR4XSB8fCAwO1xuICAgIH1cbiAgICBmaW5kU2VnbWVudFRvRml0Q2hhcihjdHgsIGFuY2hvciwgdGV4dEZ1bGxXaWR0aCwgZnVsbFBhdGhXaWR0aCwgc3BhY2VzTnVtYmVyLCBpbnB1dE9mZnNldCwgZHksIGMsIGNoYXJJKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSBpbnB1dE9mZnNldDtcbiAgICAgICAgbGV0IGdseXBoV2lkdGggPSB0aGlzLm1lYXN1cmVUZXh0KGN0eCwgYyk7XG4gICAgICAgIGlmIChjID09PSAnICcgJiYgYW5jaG9yID09PSAnanVzdGlmeScgJiYgdGV4dEZ1bGxXaWR0aCA8IGZ1bGxQYXRoV2lkdGgpIHtcbiAgICAgICAgICAgIGdseXBoV2lkdGggKz0gKGZ1bGxQYXRoV2lkdGggLSB0ZXh0RnVsbFdpZHRoKSAvIHNwYWNlc051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhckkgPiAtMSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHRoaXMuZ2V0TGV0dGVyU3BhY2luZ0F0KGNoYXJJKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGxpbmVTdGVwID0gdGhpcy50ZXh0SGVpZ2h0IC8gMjA7XG4gICAgICAgIGNvbnN0IHAwID0gdGhpcy5nZXRFcXVpZGlzdGFudFBvaW50T25QYXRoKG9mZnNldCwgc3BsaW5lU3RlcCwgMCk7XG4gICAgICAgIGNvbnN0IHAxID0gdGhpcy5nZXRFcXVpZGlzdGFudFBvaW50T25QYXRoKG9mZnNldCArIGdseXBoV2lkdGgsIHNwbGluZVN0ZXAsIDApO1xuICAgICAgICBjb25zdCBzZWdtZW50ID0ge1xuICAgICAgICAgICAgcDAsXG4gICAgICAgICAgICBwMVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IHAwICYmIHAxID8gTWF0aC5hdGFuMihwMS55IC0gcDAueSwgcDEueCAtIHAwLngpIDogMDtcbiAgICAgICAgaWYgKGR5KSB7XG4gICAgICAgICAgICBjb25zdCBkeVggPSBNYXRoLmNvcyhNYXRoLlBJIC8gMiArIHJvdGF0aW9uKSAqIGR5O1xuICAgICAgICAgICAgY29uc3QgZHlZID0gTWF0aC5jb3MoLXJvdGF0aW9uKSAqIGR5O1xuICAgICAgICAgICAgc2VnbWVudC5wMCA9IHtcbiAgICAgICAgICAgICAgICAuLi5wMCxcbiAgICAgICAgICAgICAgICB4OiBwMC54ICsgZHlYLFxuICAgICAgICAgICAgICAgIHk6IHAwLnkgKyBkeVlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZWdtZW50LnAxID0ge1xuICAgICAgICAgICAgICAgIC4uLnAxLFxuICAgICAgICAgICAgICAgIHg6IHAxLnggKyBkeVgsXG4gICAgICAgICAgICAgICAgeTogcDEueSArIGR5WVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gZ2x5cGhXaWR0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgICByb3RhdGlvblxuICAgICAgICB9O1xuICAgIH1cbiAgICBtZWFzdXJlVGV4dChjdHgsIHRleHQpIHtcbiAgICAgICAgY29uc3QgeyBtZWFzdXJlc0NhY2hlICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdGFyZ2V0VGV4dCA9IHRleHQgfHwgdGhpcy5nZXRUZXh0KCk7XG4gICAgICAgIGlmIChtZWFzdXJlc0NhY2hlLmhhcyh0YXJnZXRUZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG1lYXN1cmVzQ2FjaGUuZ2V0KHRhcmdldFRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lYXN1cmUgPSB0aGlzLm1lYXN1cmVUYXJnZXRUZXh0KGN0eCwgdGFyZ2V0VGV4dCk7XG4gICAgICAgIG1lYXN1cmVzQ2FjaGUuc2V0KHRhcmdldFRleHQsIG1lYXN1cmUpO1xuICAgICAgICByZXR1cm4gbWVhc3VyZTtcbiAgICB9XG4gICAgLy8gVGhpcyBtZXRob2Qgc3VwcG9zZXMgd2hhdCBhbGwgY3VzdG9tIGZvbnRzIGFscmVhZHkgbG9hZGVkLlxuICAgIC8vIElmIHNvbWUgZm9udCB3aWxsIGJlIGxvYWRlZCBhZnRlciB0aGlzIG1ldGhvZCBjYWxsLCA8dGV4dFBhdGg+IHdpbGwgbm90IGJlIHJlbmRlcmVkIGNvcnJlY3RseS5cbiAgICAvLyBZb3UgbmVlZCB0byBjYWxsIHRoaXMgbWV0aG9kIG1hbnVhbGx5IHRvIHVwZGF0ZSBnbHlwaHMgY2FjaGUuXG4gICAgc2V0VGV4dERhdGEoY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLmdseXBoSW5mbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbmRlclRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgICAgICAgY29uc3QgY2hhcnMgPSByZW5kZXJUZXh0LnNwbGl0KCcnKTtcbiAgICAgICAgY29uc3Qgc3BhY2VzTnVtYmVyID0gcmVuZGVyVGV4dC5zcGxpdCgnICcpLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGR4ID0gdGhpcy5wYXJlbnQuZ2V0QXR0cmlidXRlKCdkeCcpLnNwbGl0KCkubWFwKChfKT0+Xy5nZXRQaXhlbHMoJ3gnKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBkeSA9IHRoaXMucGFyZW50LmdldEF0dHJpYnV0ZSgnZHknKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5wYXJlbnQuZ2V0U3R5bGUoJ3RleHQtYW5jaG9yJykuZ2V0U3RyaW5nKCdzdGFydCcpO1xuICAgICAgICBjb25zdCB0aGlzU3BhY2luZyA9IHRoaXMuZ2V0U3R5bGUoJ2xldHRlci1zcGFjaW5nJyk7XG4gICAgICAgIGNvbnN0IHBhcmVudFNwYWNpbmcgPSB0aGlzLnBhcmVudC5nZXRTdHlsZSgnbGV0dGVyLXNwYWNpbmcnKTtcbiAgICAgICAgbGV0IGxldHRlclNwYWNpbmcgPSAwO1xuICAgICAgICBpZiAoIXRoaXNTcGFjaW5nLmhhc1ZhbHVlKCkgfHwgdGhpc1NwYWNpbmcuZ2V0VmFsdWUoKSA9PT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICBsZXR0ZXJTcGFjaW5nID0gcGFyZW50U3BhY2luZy5nZXRQaXhlbHMoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzU3BhY2luZy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBpZiAodGhpc1NwYWNpbmcuZ2V0VmFsdWUoKSAhPT0gJ2luaXRpYWwnICYmIHRoaXNTcGFjaW5nLmdldFZhbHVlKCkgIT09ICd1bnNldCcpIHtcbiAgICAgICAgICAgICAgICBsZXR0ZXJTcGFjaW5nID0gdGhpc1NwYWNpbmcuZ2V0UGl4ZWxzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlsbCBsZXR0ZXItc3BhY2luZyBjYWNoZVxuICAgICAgICBjb25zdCBsZXR0ZXJTcGFjaW5nQ2FjaGUgPSBbXTtcbiAgICAgICAgY29uc3QgdGV4dExlbiA9IHJlbmRlclRleHQubGVuZ3RoO1xuICAgICAgICB0aGlzLmxldHRlclNwYWNpbmdDYWNoZSA9IGxldHRlclNwYWNpbmdDYWNoZTtcbiAgICAgICAgZm9yKGxldCBpMSA9IDA7IGkxIDwgdGV4dExlbjsgaTErKyl7XG4gICAgICAgICAgICBsZXR0ZXJTcGFjaW5nQ2FjaGUucHVzaCh0eXBlb2YgZHhbaTFdICE9PSAndW5kZWZpbmVkJyA/IGR4W2kxXSA6IGxldHRlclNwYWNpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGR4U3VtID0gbGV0dGVyU3BhY2luZ0NhY2hlLnJlZHVjZSgoYWNjLCBjdXIsIGkpPT5pID09PSAwID8gMCA6IGFjYyArIGN1ciB8fCAwXG4gICAgICAgICwgMCk7XG4gICAgICAgIGNvbnN0IHRleHRXaWR0aCA9IHRoaXMubWVhc3VyZVRleHQoY3R4KTtcbiAgICAgICAgY29uc3QgdGV4dEZ1bGxXaWR0aCA9IE1hdGgubWF4KHRleHRXaWR0aCArIGR4U3VtLCAwKTtcbiAgICAgICAgdGhpcy50ZXh0V2lkdGggPSB0ZXh0V2lkdGg7XG4gICAgICAgIHRoaXMudGV4dEhlaWdodCA9IHRoaXMuZ2V0Rm9udFNpemUoKTtcbiAgICAgICAgdGhpcy5nbHlwaEluZm8gPSBbXTtcbiAgICAgICAgY29uc3QgZnVsbFBhdGhXaWR0aCA9IHRoaXMuZ2V0UGF0aExlbmd0aCgpO1xuICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHRoaXMuZ2V0U3R5bGUoJ3N0YXJ0T2Zmc2V0JykuZ2V0TnVtYmVyKDApICogZnVsbFBhdGhXaWR0aDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGlmIChhbmNob3IgPT09ICdtaWRkbGUnIHx8IGFuY2hvciA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IC10ZXh0RnVsbFdpZHRoIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5jaG9yID09PSAnZW5kJyB8fCBhbmNob3IgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IC10ZXh0RnVsbFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBzdGFydE9mZnNldDtcbiAgICAgICAgY2hhcnMuZm9yRWFjaCgoY2hhciwgaSk9PntcbiAgICAgICAgICAgIC8vIEZpbmQgc3VjaCBzZWdtZW50IHdoYXQgZGlzdGFuY2UgYmV0d2VlbiBwMCBhbmQgcDEgaXMgYXBwcm94LiB3aWR0aCBvZiBnbHlwaFxuICAgICAgICAgICAgY29uc3QgeyBvZmZzZXQ6IG5leHRPZmZzZXQgLCBzZWdtZW50ICwgcm90YXRpb24gIH0gPSB0aGlzLmZpbmRTZWdtZW50VG9GaXRDaGFyKGN0eCwgYW5jaG9yLCB0ZXh0RnVsbFdpZHRoLCBmdWxsUGF0aFdpZHRoLCBzcGFjZXNOdW1iZXIsIG9mZnNldCwgZHksIGNoYXIsIGkpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbmV4dE9mZnNldDtcbiAgICAgICAgICAgIGlmICghc2VnbWVudC5wMCB8fCAhc2VnbWVudC5wMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRMaW5lTGVuZ3RoKFxuICAgICAgICAgICAgLy8gICBzZWdtZW50LnAwLngsXG4gICAgICAgICAgICAvLyAgIHNlZ21lbnQucDAueSxcbiAgICAgICAgICAgIC8vICAgc2VnbWVudC5wMS54LFxuICAgICAgICAgICAgLy8gICBzZWdtZW50LnAxLnlcbiAgICAgICAgICAgIC8vICk7XG4gICAgICAgICAgICAvLyBOb3RlOiBTaW5jZSBnbHlwaHMgYXJlIHJlbmRlcmVkIG9uZSBhdCBhIHRpbWUsIGFueSBrZXJuaW5nIHBhaXIgZGF0YSBidWlsdCBpbnRvIHRoZSBmb250IHdpbGwgbm90IGJlIHVzZWQuXG4gICAgICAgICAgICAvLyBDYW4gZm9yZXNlZSBoYXZpbmcgYSByb3VnaCBwYWlyIHRhYmxlIGJ1aWx0IGluIHRoYXQgdGhlIGRldmVsb3BlciBjYW4gb3ZlcnJpZGUgYXMgbmVlZGVkLlxuICAgICAgICAgICAgLy8gT3IgdXNlIFwiZHhcIiBhdHRyaWJ1dGUgb2YgdGhlIDx0ZXh0PiBub2RlIGFzIGEgbmFpdmUgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgIC8vIGNvbnN0IGtlcm4gPSAwO1xuICAgICAgICAgICAgLy8gcGxhY2Vob2xkZXIgZm9yIGZ1dHVyZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgLy8gY29uc3QgbWlkcG9pbnQgPSB0aGlzLmdldFBvaW50T25MaW5lKFxuICAgICAgICAgICAgLy8gICBrZXJuICsgd2lkdGggLyAyLjAsXG4gICAgICAgICAgICAvLyAgIHNlZ21lbnQucDAueCwgc2VnbWVudC5wMC55LCBzZWdtZW50LnAxLngsIHNlZ21lbnQucDEueVxuICAgICAgICAgICAgLy8gKTtcbiAgICAgICAgICAgIHRoaXMuZ2x5cGhJbmZvLnB1c2goe1xuICAgICAgICAgICAgICAgIC8vIHRyYW5zcG9zZVg6IG1pZHBvaW50LngsXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNwb3NlWTogbWlkcG9pbnQueSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBjaGFyc1tpXSxcbiAgICAgICAgICAgICAgICBwMDogc2VnbWVudC5wMCxcbiAgICAgICAgICAgICAgICBwMTogc2VnbWVudC5wMSxcbiAgICAgICAgICAgICAgICByb3RhdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXJzZVBhdGhEYXRhKHBhdGgpIHtcbiAgICAgICAgdGhpcy5wYXRoTGVuZ3RoID0gLTEgLy8gcmVzZXQgcGF0aCBsZW5ndGhcbiAgICAgICAgO1xuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXRoQ29tbWFuZHMgPSBbXTtcbiAgICAgICAgY29uc3QgeyBwYXRoUGFyc2VyICB9ID0gcGF0aDtcbiAgICAgICAgcGF0aFBhcnNlci5yZXNldCgpO1xuICAgICAgICAvLyBjb252ZXJ0IGwsIEgsIGgsIFYsIGFuZCB2IHRvIExcbiAgICAgICAgd2hpbGUoIXBhdGhQYXJzZXIuaXNFbmQoKSl7XG4gICAgICAgICAgICBjb25zdCB7IGN1cnJlbnQgIH0gPSBwYXRoUGFyc2VyO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRYID0gY3VycmVudCA/IGN1cnJlbnQueCA6IDA7XG4gICAgICAgICAgICBjb25zdCBzdGFydFkgPSBjdXJyZW50ID8gY3VycmVudC55IDogMDtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1hbmQgPSBwYXRoUGFyc2VyLm5leHQoKTtcbiAgICAgICAgICAgIGxldCBuZXh0Q29tbWFuZFR5cGUgPSBjb21tYW5kLnR5cGU7XG4gICAgICAgICAgICBsZXQgcG9pbnRzID0gW107XG4gICAgICAgICAgICBzd2l0Y2goY29tbWFuZC50eXBlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTU9WRV9UTzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoTShwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICAgICAgICAgICAgbmV4dENvbW1hbmRUeXBlID0gdGhpcy5wYXRoTChwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuSE9SSVpfTElORV9UTzpcbiAgICAgICAgICAgICAgICAgICAgbmV4dENvbW1hbmRUeXBlID0gdGhpcy5wYXRoSChwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuVkVSVF9MSU5FX1RPOlxuICAgICAgICAgICAgICAgICAgICBuZXh0Q29tbWFuZFR5cGUgPSB0aGlzLnBhdGhWKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoQyhwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuU01PT1RIX0NVUlZFX1RPOlxuICAgICAgICAgICAgICAgICAgICBuZXh0Q29tbWFuZFR5cGUgPSB0aGlzLnBhdGhTKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5RVUFEX1RPOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhRKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5TTU9PVEhfUVVBRF9UTzpcbiAgICAgICAgICAgICAgICAgICAgbmV4dENvbW1hbmRUeXBlID0gdGhpcy5wYXRoVChwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQVJDOlxuICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSB0aGlzLnBhdGhBKHBhdGhQYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQ0xPU0VfUEFUSDpcbiAgICAgICAgICAgICAgICAgICAgUGF0aEVsZW1lbnQucGF0aFoocGF0aFBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbW1hbmQudHlwZSAhPT0gUGF0aFBhcnNlci5DTE9TRV9QQVRIKSB7XG4gICAgICAgICAgICAgICAgcGF0aENvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBuZXh0Q29tbWFuZFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHN0YXJ0WCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHN0YXJ0WVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXRoTGVuZ3RoOiB0aGlzLmNhbGNMZW5ndGgoc3RhcnRYLCBzdGFydFksIG5leHRDb21tYW5kVHlwZSwgcG9pbnRzKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXRoQ29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFBhdGhQYXJzZXIuQ0xPU0VfUEFUSCxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aExlbmd0aDogMFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoQ29tbWFuZHM7XG4gICAgfVxuICAgIHBhdGhNKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gUGF0aEVsZW1lbnQucGF0aE0ocGF0aFBhcnNlcikucG9pbnQ7XG4gICAgICAgIHBvaW50cy5wdXNoKHgsIHkpO1xuICAgIH1cbiAgICBwYXRoTChwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IFBhdGhFbGVtZW50LnBhdGhMKHBhdGhQYXJzZXIpLnBvaW50O1xuICAgICAgICBwb2ludHMucHVzaCh4LCB5KTtcbiAgICAgICAgcmV0dXJuIFBhdGhQYXJzZXIuTElORV9UTztcbiAgICB9XG4gICAgcGF0aEgocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSBQYXRoRWxlbWVudC5wYXRoSChwYXRoUGFyc2VyKS5wb2ludDtcbiAgICAgICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgICAgIHJldHVybiBQYXRoUGFyc2VyLkxJTkVfVE87XG4gICAgfVxuICAgIHBhdGhWKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gUGF0aEVsZW1lbnQucGF0aFYocGF0aFBhcnNlcikucG9pbnQ7XG4gICAgICAgIHBvaW50cy5wdXNoKHgsIHkpO1xuICAgICAgICByZXR1cm4gUGF0aFBhcnNlci5MSU5FX1RPO1xuICAgIH1cbiAgICBwYXRoQyhwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICAgICAgY29uc3QgeyBwb2ludCAsIGNvbnRyb2xQb2ludCAsIGN1cnJlbnRQb2ludCAgfSA9IFBhdGhFbGVtZW50LnBhdGhDKHBhdGhQYXJzZXIpO1xuICAgICAgICBwb2ludHMucHVzaChwb2ludC54LCBwb2ludC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgfVxuICAgIHBhdGhTKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgICAgICBjb25zdCB7IHBvaW50ICwgY29udHJvbFBvaW50ICwgY3VycmVudFBvaW50ICB9ID0gUGF0aEVsZW1lbnQucGF0aFMocGF0aFBhcnNlcik7XG4gICAgICAgIHBvaW50cy5wdXNoKHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgICAgcmV0dXJuIFBhdGhQYXJzZXIuQ1VSVkVfVE87XG4gICAgfVxuICAgIHBhdGhRKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgICAgICBjb25zdCB7IGNvbnRyb2xQb2ludCAsIGN1cnJlbnRQb2ludCAgfSA9IFBhdGhFbGVtZW50LnBhdGhRKHBhdGhQYXJzZXIpO1xuICAgICAgICBwb2ludHMucHVzaChjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgfVxuICAgIHBhdGhUKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgICAgICBjb25zdCB7IGNvbnRyb2xQb2ludCAsIGN1cnJlbnRQb2ludCAgfSA9IFBhdGhFbGVtZW50LnBhdGhUKHBhdGhQYXJzZXIpO1xuICAgICAgICBwb2ludHMucHVzaChjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICAgIHJldHVybiBQYXRoUGFyc2VyLlFVQURfVE87XG4gICAgfVxuICAgIHBhdGhBKHBhdGhQYXJzZXIpIHtcbiAgICAgICAgbGV0IHsgclggLCByWSAsIHN3ZWVwRmxhZyAsIHhBeGlzUm90YXRpb24gLCBjZW50cCAsIGExICwgYWQgIH0gPSBQYXRoRWxlbWVudC5wYXRoQShwYXRoUGFyc2VyKTtcbiAgICAgICAgaWYgKHN3ZWVwRmxhZyA9PT0gMCAmJiBhZCA+IDApIHtcbiAgICAgICAgICAgIGFkIC09IDIgKiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzd2VlcEZsYWcgPT09IDEgJiYgYWQgPCAwKSB7XG4gICAgICAgICAgICBhZCArPSAyICogTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgY2VudHAueCxcbiAgICAgICAgICAgIGNlbnRwLnksXG4gICAgICAgICAgICByWCxcbiAgICAgICAgICAgIHJZLFxuICAgICAgICAgICAgYTEsXG4gICAgICAgICAgICBhZCxcbiAgICAgICAgICAgIHhBeGlzUm90YXRpb24sXG4gICAgICAgICAgICBzd2VlcEZsYWdcbiAgICAgICAgXTtcbiAgICB9XG4gICAgY2FsY0xlbmd0aCh4LCB5LCBjb21tYW5kVHlwZSwgcG9pbnRzKSB7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBsZXQgcDEgPSBudWxsO1xuICAgICAgICBsZXQgcDIgPSBudWxsO1xuICAgICAgICBsZXQgdCA9IDA7XG4gICAgICAgIHN3aXRjaChjb21tYW5kVHlwZSl7XG4gICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lTGVuZ3RoKHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgICAgICAgICAvLyBBcHByb3hpbWF0ZXMgYnkgYnJlYWtpbmcgY3VydmUgaW50byAxMDAgbGluZSBzZWdtZW50c1xuICAgICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgICAgcDEgPSB0aGlzLmdldFBvaW50T25DdWJpY0JlemllcigwLCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHBvaW50c1s0XSwgcG9pbnRzWzVdKTtcbiAgICAgICAgICAgICAgICBmb3IodCA9IDAuMDE7IHQgPD0gMTsgdCArPSAwLjAxKXtcbiAgICAgICAgICAgICAgICAgICAgcDIgPSB0aGlzLmdldFBvaW50T25DdWJpY0Jlemllcih0LCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHBvaW50c1s0XSwgcG9pbnRzWzVdKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICAgICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5RVUFEX1RPOlxuICAgICAgICAgICAgICAgIC8vIEFwcHJveGltYXRlcyBieSBicmVha2luZyBjdXJ2ZSBpbnRvIDEwMCBsaW5lIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgICBwMSA9IHRoaXMuZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcigwLCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgICAgICAgICAgICAgIGZvcih0ID0gMC4wMTsgdCA8PSAxOyB0ICs9IDAuMDEpe1xuICAgICAgICAgICAgICAgICAgICBwMiA9IHRoaXMuZ2V0UG9pbnRPblF1YWRyYXRpY0Jlemllcih0LCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcHJveGltYXRlcyBieSBicmVha2luZyBjdXJ2ZSBpbnRvIGxpbmUgc2VnbWVudHNcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBwb2ludHNbNF07XG4gICAgICAgICAgICAgICAgICAgIC8vIDQgPSB0aGV0YVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkVGhldGEgPSBwb2ludHNbNV07XG4gICAgICAgICAgICAgICAgICAgIC8vIDUgPSBkVGhldGFcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gcG9pbnRzWzRdICsgZFRoZXRhO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5jID0gTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgICAgICAgICAgICAgLy8gMSBkZWdyZWUgcmVzb2x1dGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoc3RhcnQgLSBlbmQpIDwgaW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmMgPSBNYXRoLmFicyhzdGFydCAtIGVuZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogZm9yIHB1cnBvc2Ugb2YgY2FsY3VsYXRpbmcgYXJjIGxlbmd0aCwgbm90IGdvaW5nIHRvIHdvcnJ5IGFib3V0IHJvdGF0aW5nIFgtYXhpcyBieSBhbmdsZSBwc2lcbiAgICAgICAgICAgICAgICAgICAgcDEgPSB0aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgc3RhcnQsIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZFRoZXRhIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHQgPSBzdGFydCAtIGluYzsgdCA+IGVuZDsgdCAtPSBpbmMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAyID0gdGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHQsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiArPSB0aGlzLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih0ID0gc3RhcnQgKyBpbmM7IHQgPCBlbmQ7IHQgKz0gaW5jKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMiA9IHRoaXMuZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCB0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gKz0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcDIgPSB0aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgZW5kLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGdldFBvaW50T25MaW5lKGRpc3QsIHAxeCwgcDF5LCBwMngsIHAyeSkge1xuICAgICAgICBsZXQgZnJvbVggPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1s1XSA6IHAxeCwgZnJvbVkgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1s2XSA6IHAxeTtcbiAgICAgICAgY29uc3QgbSA9IChwMnkgLSBwMXkpIC8gKHAyeCAtIHAxeCArIFBTRVVET19aRVJPKTtcbiAgICAgICAgbGV0IHJ1biA9IE1hdGguc3FydChkaXN0ICogZGlzdCAvICgxICsgbSAqIG0pKTtcbiAgICAgICAgaWYgKHAyeCA8IHAxeCkge1xuICAgICAgICAgICAgcnVuICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGxldCByaXNlID0gbSAqIHJ1bjtcbiAgICAgICAgbGV0IHB0ID0gbnVsbDtcbiAgICAgICAgaWYgKHAyeCA9PT0gcDF4KSB7XG4gICAgICAgICAgICBwdCA9IHtcbiAgICAgICAgICAgICAgICB4OiBmcm9tWCxcbiAgICAgICAgICAgICAgICB5OiBmcm9tWSArIHJpc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoKGZyb21ZIC0gcDF5KSAvIChmcm9tWCAtIHAxeCArIFBTRVVET19aRVJPKSA9PT0gbSkge1xuICAgICAgICAgICAgcHQgPSB7XG4gICAgICAgICAgICAgICAgeDogZnJvbVggKyBydW4sXG4gICAgICAgICAgICAgICAgeTogZnJvbVkgKyByaXNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGl4ID0gMDtcbiAgICAgICAgICAgIGxldCBpeSA9IDA7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmdldExpbmVMZW5ndGgocDF4LCBwMXksIHAyeCwgcDJ5KTtcbiAgICAgICAgICAgIGlmIChsZW4gPCBQU0VVRE9fWkVSTykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHUgPSAoZnJvbVggLSBwMXgpICogKHAyeCAtIHAxeCkgKyAoZnJvbVkgLSBwMXkpICogKHAyeSAtIHAxeSk7XG4gICAgICAgICAgICB1IC89IGxlbiAqIGxlbjtcbiAgICAgICAgICAgIGl4ID0gcDF4ICsgdSAqIChwMnggLSBwMXgpO1xuICAgICAgICAgICAgaXkgPSBwMXkgKyB1ICogKHAyeSAtIHAxeSk7XG4gICAgICAgICAgICBjb25zdCBwUmlzZSA9IHRoaXMuZ2V0TGluZUxlbmd0aChmcm9tWCwgZnJvbVksIGl4LCBpeSk7XG4gICAgICAgICAgICBjb25zdCBwUnVuID0gTWF0aC5zcXJ0KGRpc3QgKiBkaXN0IC0gcFJpc2UgKiBwUmlzZSk7XG4gICAgICAgICAgICBydW4gPSBNYXRoLnNxcnQocFJ1biAqIHBSdW4gLyAoMSArIG0gKiBtKSk7XG4gICAgICAgICAgICBpZiAocDJ4IDwgcDF4KSB7XG4gICAgICAgICAgICAgICAgcnVuICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmlzZSA9IG0gKiBydW47XG4gICAgICAgICAgICBwdCA9IHtcbiAgICAgICAgICAgICAgICB4OiBpeCArIHJ1bixcbiAgICAgICAgICAgICAgICB5OiBpeSArIHJpc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHB0O1xuICAgIH1cbiAgICBnZXRQb2ludE9uUGF0aChkaXN0YW5jZSkge1xuICAgICAgICBjb25zdCBmdWxsTGVuID0gdGhpcy5nZXRQYXRoTGVuZ3RoKCk7XG4gICAgICAgIGxldCBjdW11bGF0aXZlUGF0aExlbmd0aCA9IDA7XG4gICAgICAgIGxldCBwID0gbnVsbDtcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgLTAuMDAwMDUgfHwgZGlzdGFuY2UgLSAwLjAwMDA1ID4gZnVsbExlbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBkYXRhQXJyYXkgIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGNvbnN0IGNvbW1hbmQgb2YgZGF0YUFycmF5KXtcbiAgICAgICAgICAgIGlmIChjb21tYW5kICYmIChjb21tYW5kLnBhdGhMZW5ndGggPCAwLjAwMDA1IHx8IGN1bXVsYXRpdmVQYXRoTGVuZ3RoICsgY29tbWFuZC5wYXRoTGVuZ3RoICsgMC4wMDAwNSA8IGRpc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgIGN1bXVsYXRpdmVQYXRoTGVuZ3RoICs9IGNvbW1hbmQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZGlzdGFuY2UgLSBjdW11bGF0aXZlUGF0aExlbmd0aDtcbiAgICAgICAgICAgIGxldCBjdXJyZW50VCA9IDA7XG4gICAgICAgICAgICBzd2l0Y2goY29tbWFuZC50eXBlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMuZ2V0UG9pbnRPbkxpbmUoZGVsdGEsIGNvbW1hbmQuc3RhcnQueCwgY29tbWFuZC5zdGFydC55LCBjb21tYW5kLnBvaW50c1swXSwgY29tbWFuZC5wb2ludHNbMV0sIGNvbW1hbmQuc3RhcnQueCwgY29tbWFuZC5zdGFydC55KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBjb21tYW5kLnBvaW50c1s0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDQgPSB0aGV0YVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZFRoZXRhID0gY29tbWFuZC5wb2ludHNbNV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA1ID0gZFRoZXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBjb21tYW5kLnBvaW50c1s0XSArIGRUaGV0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gc3RhcnQgKyBkZWx0YSAvIGNvbW1hbmQucGF0aExlbmd0aCAqIGRUaGV0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkVGhldGEgPCAwICYmIGN1cnJlbnRUIDwgZW5kIHx8IGRUaGV0YSA+PSAwICYmIGN1cnJlbnRUID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gdGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhjb21tYW5kLnBvaW50c1swXSwgY29tbWFuZC5wb2ludHNbMV0sIGNvbW1hbmQucG9pbnRzWzJdLCBjb21tYW5kLnBvaW50c1szXSwgY3VycmVudFQsIGNvbW1hbmQucG9pbnRzWzZdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNVUlZFX1RPOlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IGRlbHRhIC8gY29tbWFuZC5wYXRoTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMuZ2V0UG9pbnRPbkN1YmljQmV6aWVyKGN1cnJlbnRULCBjb21tYW5kLnN0YXJ0LngsIGNvbW1hbmQuc3RhcnQueSwgY29tbWFuZC5wb2ludHNbMF0sIGNvbW1hbmQucG9pbnRzWzFdLCBjb21tYW5kLnBvaW50c1syXSwgY29tbWFuZC5wb2ludHNbM10sIGNvbW1hbmQucG9pbnRzWzRdLCBjb21tYW5kLnBvaW50c1s1XSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5RVUFEX1RPOlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IGRlbHRhIC8gY29tbWFuZC5wYXRoTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMuZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcihjdXJyZW50VCwgY29tbWFuZC5zdGFydC54LCBjb21tYW5kLnN0YXJ0LnksIGNvbW1hbmQucG9pbnRzWzBdLCBjb21tYW5kLnBvaW50c1sxXSwgY29tbWFuZC5wb2ludHNbMl0sIGNvbW1hbmQucG9pbnRzWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldExpbmVMZW5ndGgoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xuICAgIH1cbiAgICBnZXRQYXRoTGVuZ3RoKCkge1xuICAgICAgICBpZiAodGhpcy5wYXRoTGVuZ3RoID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5wYXRoTGVuZ3RoID0gdGhpcy5kYXRhQXJyYXkucmVkdWNlKChsZW5ndGgsIGNvbW1hbmQpPT5jb21tYW5kLnBhdGhMZW5ndGggPiAwID8gbGVuZ3RoICsgY29tbWFuZC5wYXRoTGVuZ3RoIDogbGVuZ3RoXG4gICAgICAgICAgICAsIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGhMZW5ndGg7XG4gICAgfVxuICAgIGdldFBvaW50T25DdWJpY0JlemllcihwY3QsIHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3ksIHA0eCwgcDR5KSB7XG4gICAgICAgIGNvbnN0IHggPSBwNHggKiBDQjEocGN0KSArIHAzeCAqIENCMihwY3QpICsgcDJ4ICogQ0IzKHBjdCkgKyBwMXggKiBDQjQocGN0KTtcbiAgICAgICAgY29uc3QgeSA9IHA0eSAqIENCMShwY3QpICsgcDN5ICogQ0IyKHBjdCkgKyBwMnkgKiBDQjMocGN0KSArIHAxeSAqIENCNChwY3QpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcihwY3QsIHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3kpIHtcbiAgICAgICAgY29uc3QgeCA9IHAzeCAqIFFCMShwY3QpICsgcDJ4ICogUUIyKHBjdCkgKyBwMXggKiBRQjMocGN0KTtcbiAgICAgICAgY29uc3QgeSA9IHAzeSAqIFFCMShwY3QpICsgcDJ5ICogUUIyKHBjdCkgKyBwMXkgKiBRQjMocGN0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFBvaW50T25FbGxpcHRpY2FsQXJjKGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgcHNpKSB7XG4gICAgICAgIGNvbnN0IGNvc1BzaSA9IE1hdGguY29zKHBzaSk7XG4gICAgICAgIGNvbnN0IHNpblBzaSA9IE1hdGguc2luKHBzaSk7XG4gICAgICAgIGNvbnN0IHB0ID0ge1xuICAgICAgICAgICAgeDogcnggKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgICAgICB5OiByeSAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogY3ggKyAocHQueCAqIGNvc1BzaSAtIHB0LnkgKiBzaW5Qc2kpLFxuICAgICAgICAgICAgeTogY3kgKyAocHQueCAqIHNpblBzaSArIHB0LnkgKiBjb3NQc2kpXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFRPRE8gbmVlZCBzb21lIG9wdGltaXNhdGlvbnMuIHBvc3NpYmx5IGJ1aWxkIGNhY2hlIG9ubHkgZm9yIGN1cnZlZCBzZWdtZW50cz9cbiAgICBidWlsZEVxdWlkaXN0YW50Q2FjaGUoaW5wdXRTdGVwLCBpbnB1dFByZWNpc2lvbikge1xuICAgICAgICBjb25zdCBmdWxsTGVuID0gdGhpcy5nZXRQYXRoTGVuZ3RoKCk7XG4gICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IGlucHV0UHJlY2lzaW9uIHx8IDAuMjUgLy8gYWNjdXJhY3kgdnMgcGVyZm9ybWFuY2VcbiAgICAgICAgO1xuICAgICAgICBjb25zdCBzdGVwID0gaW5wdXRTdGVwIHx8IGZ1bGxMZW4gLyAxMDA7XG4gICAgICAgIGlmICghdGhpcy5lcXVpZGlzdGFudENhY2hlIHx8IHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5zdGVwICE9PSBzdGVwIHx8IHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5wcmVjaXNpb24gIT09IHByZWNpc2lvbikge1xuICAgICAgICAgICAgLy8gUHJlcGFyZSBjYWNoZVxuICAgICAgICAgICAgdGhpcy5lcXVpZGlzdGFudENhY2hlID0ge1xuICAgICAgICAgICAgICAgIHN0ZXAsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgIHBvaW50czogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcG9pbnRzXG4gICAgICAgICAgICBsZXQgcyA9IDA7XG4gICAgICAgICAgICBmb3IobGV0IGwgPSAwOyBsIDw9IGZ1bGxMZW47IGwgKz0gcHJlY2lzaW9uKXtcbiAgICAgICAgICAgICAgICBjb25zdCBwMCA9IHRoaXMuZ2V0UG9pbnRPblBhdGgobCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcDEgPSB0aGlzLmdldFBvaW50T25QYXRoKGwgKyBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgIGlmICghcDAgfHwgIXAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMC54LCBwMC55LCBwMS54LCBwMS55KTtcbiAgICAgICAgICAgICAgICBpZiAocyA+PSBzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5wb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBwMC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogcDAueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzIC09IHN0ZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldEVxdWlkaXN0YW50UG9pbnRPblBhdGgodGFyZ2V0RGlzdGFuY2UsIHN0ZXAsIHByZWNpc2lvbikge1xuICAgICAgICB0aGlzLmJ1aWxkRXF1aWRpc3RhbnRDYWNoZShzdGVwLCBwcmVjaXNpb24pO1xuICAgICAgICBpZiAodGFyZ2V0RGlzdGFuY2UgPCAwIHx8IHRhcmdldERpc3RhbmNlIC0gdGhpcy5nZXRQYXRoTGVuZ3RoKCkgPiAwLjAwMDA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZHggPSBNYXRoLnJvdW5kKHRhcmdldERpc3RhbmNlIC8gdGhpcy5nZXRQYXRoTGVuZ3RoKCkgKiAodGhpcy5lcXVpZGlzdGFudENhY2hlLnBvaW50cy5sZW5ndGggLSAxKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVxdWlkaXN0YW50Q2FjaGUucG9pbnRzW2lkeF0gfHwgbnVsbDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICd0ZXh0UGF0aCc7XG4gICAgICAgIHRoaXMudGV4dFdpZHRoID0gMDtcbiAgICAgICAgdGhpcy50ZXh0SGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5wYXRoTGVuZ3RoID0gLTE7XG4gICAgICAgIHRoaXMuZ2x5cGhJbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5sZXR0ZXJTcGFjaW5nQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5tZWFzdXJlc0NhY2hlID0gbmV3IE1hcChbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgXVxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgcGF0aEVsZW1lbnQgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMuZ2V0VGV4dEZyb21Ob2RlKCk7XG4gICAgICAgIHRoaXMuZGF0YUFycmF5ID0gdGhpcy5wYXJzZVBhdGhEYXRhKHBhdGhFbGVtZW50KTtcbiAgICB9XG59XG5cbi8vIGdyb3VwczogMTogbWltZS10eXBlICgrIGNoYXJzZXQpLCAyOiBtaW1lLXR5cGUgKHcvbyBjaGFyc2V0KSwgMzogY2hhcnNldCwgNDogYmFzZTY0PywgNTogYm9keVxuY29uc3QgZGF0YVVyaVJlZ2V4ID0gL15cXHMqZGF0YTooKFteLyw7XStcXC9bXi8sO10rKSg/OjsoW14sOz1dKz1bXiw7PV0rKSk/KT8oPzo7KGJhc2U2NCkpPywoLiopJC9pO1xuY2xhc3MgSW1hZ2VFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgICBhc3luYyBsb2FkSW1hZ2UoaHJlZikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSBhd2FpdCB0aGlzLmRvY3VtZW50LmNyZWF0ZUltYWdlKGhyZWYpO1xuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB3aGlsZSBsb2FkaW5nIGltYWdlIFxcXCJcIi5jb25jYXQoaHJlZiwgXCJcXFwiOlwiKSwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgfVxuICAgIGFzeW5jIGxvYWRTdmcoaHJlZikge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGRhdGFVcmlSZWdleC5leGVjKGhyZWYpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBtYXRjaFs1XTtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoWzRdID09PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlID0gYXRvYihkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlID0gZGVjb2RlVVJJQ29tcG9uZW50KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmRvY3VtZW50LmZldGNoKGhyZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN2ZyA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlID0gc3ZnO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHdoaWxlIGxvYWRpbmcgaW1hZ2UgXFxcIlwiLmNvbmNhdChocmVmLCBcIlxcXCI6XCIpLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgZG9jdW1lbnQgLCBpbWFnZSAsIGxvYWRlZCAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpLmdldFBpeGVscygneCcpO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcpLmdldFBpeGVscygneCcpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgaWYgKCFsb2FkZWQgfHwgIWltYWdlIHx8ICF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YkRvY3VtZW50ID0gZG9jdW1lbnQuY2FudmcuZm9ya1N0cmluZyhjdHgsIGltYWdlLCB7XG4gICAgICAgICAgICAgICAgaWdub3JlTW91c2U6IHRydWUsXG4gICAgICAgICAgICAgICAgaWdub3JlQW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlnbm9yZURpbWVuc2lvbnM6IHRydWUsXG4gICAgICAgICAgICAgICAgaWdub3JlQ2xlYXI6IHRydWUsXG4gICAgICAgICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgICAgICAgIHNjYWxlV2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIHNjYWxlSGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBkb2N1bWVudEVsZW1lbnQgIH0gPSBzdWJEb2N1bWVudC5kb2N1bWVudDtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudEVsZW1lbnQucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZvaWQgc3ViRG9jdW1lbnQucmVuZGVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5zZXRWaWV3Qm94KHtcbiAgICAgICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICAgICAgYXNwZWN0UmF0aW86IHRoaXMuZ2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJykuZ2V0U3RyaW5nKCksXG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgZGVzaXJlZFdpZHRoOiBpbWFnZS53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgZGVzaXJlZEhlaWdodDogaW1hZ2UuaGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgIGlmICghKCdjb21wbGV0ZScgaW4gaW1hZ2UpIHx8IGltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBnZXRCb3VuZGluZ0JveCgpIHtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpLmdldFBpeGVscygneScpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmdldFBpeGVscygneScpO1xuICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHgsIHksIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnaW1hZ2UnO1xuICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBocmVmID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0U3RyaW5nKCk7XG4gICAgICAgIGlmICghaHJlZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzU3ZnID0gaHJlZi5lbmRzV2l0aCgnLnN2ZycpIHx8IC9eXFxzKmRhdGE6aW1hZ2VcXC9zdmdcXCt4bWwvaS50ZXN0KGhyZWYpO1xuICAgICAgICBkb2N1bWVudC5pbWFnZXMucHVzaCh0aGlzKTtcbiAgICAgICAgaWYgKCFpc1N2Zykge1xuICAgICAgICAgICAgdm9pZCB0aGlzLmxvYWRJbWFnZShocmVmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZvaWQgdGhpcy5sb2FkU3ZnKGhyZWYpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBTeW1ib2xFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgICByZW5kZXIoXykge1xuICAgIC8vIE5PIFJFTkRFUlxuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdzeW1ib2wnO1xuICAgIH1cbn1cblxuY2xhc3MgU1ZHRm9udExvYWRlciB7XG4gICAgYXN5bmMgbG9hZChmb250RmFtaWx5LCB1cmwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9jdW1lbnQgIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3Qgc3ZnRG9jdW1lbnQgPSBhd2FpdCBkb2N1bWVudC5jYW52Zy5wYXJzZXIubG9hZCh1cmwpO1xuICAgICAgICAgICAgY29uc3QgZm9udHMgPSBzdmdEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZm9udCcpO1xuICAgICAgICAgICAgQXJyYXkuZnJvbShmb250cykuZm9yRWFjaCgoZm9udE5vZGUpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgZm9udCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZm9udE5vZGUpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRlZmluaXRpb25zLnNldChmb250RmFtaWx5LCBmb250KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB3aGlsZSBsb2FkaW5nIGZvbnQgXFxcIlwiLmNvbmNhdCh1cmwsIFwiXFxcIjpcIiksIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCl7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgZG9jdW1lbnQuZm9udHMucHVzaCh0aGlzKTtcbiAgICB9XG59XG5cbmNsYXNzIFN0eWxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnc3R5bGUnO1xuICAgICAgICBjb25zdCBjc3MgPSBjb21wcmVzc1NwYWNlcyhBcnJheS5mcm9tKG5vZGUuY2hpbGROb2RlcykvLyBORUVEIFRFU1RcbiAgICAgICAgLm1hcCgoXyk9Pl8udGV4dENvbnRlbnRcbiAgICAgICAgKS5qb2luKCcnKS5yZXBsYWNlKC8oXFwvXFwqKFteKl18W1xcclxcbl18KFxcKisoW14qL118W1xcclxcbl0pKSkqXFwqK1xcLyl8KF5bXFxzXSpcXC9cXC8uKikvZ20sICcnKSAvLyByZW1vdmUgY29tbWVudHNcbiAgICAgICAgLnJlcGxhY2UoL0BpbXBvcnQuKjsvZywgJycpIC8vIHJlbW92ZSBpbXBvcnRzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGNzc0RlZnMgPSBjc3Muc3BsaXQoJ30nKTtcbiAgICAgICAgY3NzRGVmcy5mb3JFYWNoKChfMSk9PntcbiAgICAgICAgICAgIGNvbnN0IGRlZiA9IF8xLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICghZGVmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3NzUGFydHMgPSBkZWYuc3BsaXQoJ3snKTtcbiAgICAgICAgICAgIGNvbnN0IGNzc0NsYXNzZXMgPSBjc3NQYXJ0c1swXS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgY29uc3QgY3NzUHJvcHMgPSBjc3NQYXJ0c1sxXS5zcGxpdCgnOycpO1xuICAgICAgICAgICAgY3NzQ2xhc3Nlcy5mb3JFYWNoKChfKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IGNzc0NsYXNzID0gXy50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFjc3NDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0gZG9jdW1lbnQuc3R5bGVzLmdldChjc3NDbGFzcykgfHwgbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIGNzc1Byb3BzLmZvckVhY2goKGNzc1Byb3ApPT57XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSBjc3NQcm9wLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNzc1Byb3Auc3Vic3RyKDAsIHByb3ApLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjc3NQcm9wLnN1YnN0cihwcm9wICsgMSwgY3NzUHJvcC5sZW5ndGggLSBwcm9wKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5zZXQobmFtZSwgbmV3IFByb3BlcnR5KGRvY3VtZW50LCBuYW1lLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuc3R5bGVzLnNldChjc3NDbGFzcywgcHJvcHMpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LnN0eWxlc1NwZWNpZmljaXR5LnNldChjc3NDbGFzcywgZ2V0U2VsZWN0b3JTcGVjaWZpY2l0eShjc3NDbGFzcykpO1xuICAgICAgICAgICAgICAgIGlmIChjc3NDbGFzcyA9PT0gJ0Bmb250LWZhY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvbnRGYW1pbHkgPSBwcm9wcy5nZXQoJ2ZvbnQtZmFtaWx5JykuZ2V0U3RyaW5nKCkucmVwbGFjZSgvXCJ8Jy9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNyY3MgPSBwcm9wcy5nZXQoJ3NyYycpLmdldFN0cmluZygpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIHNyY3MuZm9yRWFjaCgoc3JjKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNyYy5pbmRleE9mKCdmb3JtYXQoXCJzdmdcIiknKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBwYXJzZUV4dGVybmFsVXJsKHNyYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIG5ldyBTVkdGb250TG9hZGVyKGRvY3VtZW50KS5sb2FkKGZvbnRGYW1pbHksIHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuU3R5bGVFbGVtZW50LnBhcnNlRXh0ZXJuYWxVcmwgPSBwYXJzZUV4dGVybmFsVXJsO1xuXG5jbGFzcyBVc2VFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgICBzZXRDb250ZXh0KGN0eCkge1xuICAgICAgICBzdXBlci5zZXRDb250ZXh0KGN0eCk7XG4gICAgICAgIGNvbnN0IHhBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKTtcbiAgICAgICAgY29uc3QgeUF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpO1xuICAgICAgICBpZiAoeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh4QXR0ci5nZXRQaXhlbHMoJ3gnKSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgeUF0dHIuZ2V0UGl4ZWxzKCd5JykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhdGgoY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCAgfSA9IHRoaXM7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LnBhdGgoY3R4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICAgICAgY29uc3QgeyBkb2N1bWVudCAsIGVsZW1lbnQgIH0gPSB0aGlzO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgbGV0IHRlbXBTdmcgPSBlbGVtZW50O1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgbWUgdXNpbmcgYSB0ZW1wb3Jhcnkgc3ZnIGVsZW1lbnQgaW4gc3ltYm9sIGNhc2VzIChodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwjVXNlRWxlbWVudClcbiAgICAgICAgICAgICAgICB0ZW1wU3ZnID0gbmV3IFNWR0VsZW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlcy5zZXQoJ3ZpZXdCb3gnLCBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd2aWV3Qm94JywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKS5nZXRTdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlcy5zZXQoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKS5nZXRTdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlcy5zZXQoJ292ZXJmbG93JywgbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnb3ZlcmZsb3cnLCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnb3ZlcmZsb3cnKS5nZXRTdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgc3RpbGwgdGhlIHBhcmVudCBvZiB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlcy5zZXQoJ29wYWNpdHknLCBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdvcGFjaXR5JywgdGhpcy5jYWxjdWxhdGVPcGFjaXR5KCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZW1wU3ZnLnR5cGUgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGhTdHlsZSA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJywgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodFN0eWxlID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JywgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIGlmIHN5bWJvbCBvciBzdmcsIGluaGVyaXQgd2lkdGgvaGVpZ2h0IGZyb20gbWVcbiAgICAgICAgICAgICAgICBpZiAod2lkdGhTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlcy5zZXQoJ3dpZHRoJywgbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnd2lkdGgnLCB3aWR0aFN0eWxlLmdldFN0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoZWlnaHRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlcy5zZXQoJ2hlaWdodCcsIG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2hlaWdodCcsIGhlaWdodFN0eWxlLmdldFN0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2xkUGFyZW50ID0gdGVtcFN2Zy5wYXJlbnQ7XG4gICAgICAgICAgICB0ZW1wU3ZnLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB0ZW1wU3ZnLnJlbmRlcihjdHgpO1xuICAgICAgICAgICAgdGVtcFN2Zy5wYXJlbnQgPSBvbGRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Qm91bmRpbmdCb3goY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCAgfSA9IHRoaXM7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRCb3VuZGluZ0JveChjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbGVtZW50VHJhbnNmb3JtKCkge1xuICAgICAgICBjb25zdCB7IGRvY3VtZW50ICwgZWxlbWVudCAgfSA9IHRoaXM7XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRyYW5zZm9ybS5mcm9tRWxlbWVudChkb2N1bWVudCwgZWxlbWVudCk7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuY2FjaGVkRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRFbGVtZW50ID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlZEVsZW1lbnQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3VzZSc7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbUdldChpbWcsIHgsIHksIHdpZHRoLCBfaGVpZ2h0LCByZ2JhKSB7XG4gICAgcmV0dXJuIGltZ1t5ICogd2lkdGggKiA0ICsgeCAqIDQgKyByZ2JhXTtcbn1cbmZ1bmN0aW9uIGltU2V0KGltZywgeCwgeSwgd2lkdGgsIF9oZWlnaHQsIHJnYmEsIHZhbCkge1xuICAgIGltZ1t5ICogd2lkdGggKiA0ICsgeCAqIDQgKyByZ2JhXSA9IHZhbDtcbn1cbmZ1bmN0aW9uIG0obWF0cml4LCBpLCB2KSB7XG4gICAgY29uc3QgbWkgPSBtYXRyaXhbaV07XG4gICAgcmV0dXJuIG1pICogdjtcbn1cbmZ1bmN0aW9uIGMoYSwgbTEsIG0yLCBtMykge1xuICAgIHJldHVybiBtMSArIE1hdGguY29zKGEpICogbTIgKyBNYXRoLnNpbihhKSAqIG0zO1xufVxuY2xhc3MgRmVDb2xvck1hdHJpeEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBhcHBseShjdHgsIF94LCBfeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAvLyBhc3N1bWluZyB4PT0wICYmIHk9PTAgZm9yIG5vd1xuICAgICAgICBjb25zdCB7IGluY2x1ZGVPcGFjaXR5ICwgbWF0cml4ICB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc3JjRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGZvcihsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKyl7XG4gICAgICAgICAgICBmb3IobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKyl7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IGltR2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZyA9IGltR2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IGltR2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMik7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGltR2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMyk7XG4gICAgICAgICAgICAgICAgbGV0IG5yID0gbShtYXRyaXgsIDAsIHIpICsgbShtYXRyaXgsIDEsIGcpICsgbShtYXRyaXgsIDIsIGIpICsgbShtYXRyaXgsIDMsIGEpICsgbShtYXRyaXgsIDQsIDEpO1xuICAgICAgICAgICAgICAgIGxldCBuZyA9IG0obWF0cml4LCA1LCByKSArIG0obWF0cml4LCA2LCBnKSArIG0obWF0cml4LCA3LCBiKSArIG0obWF0cml4LCA4LCBhKSArIG0obWF0cml4LCA5LCAxKTtcbiAgICAgICAgICAgICAgICBsZXQgbmIgPSBtKG1hdHJpeCwgMTAsIHIpICsgbShtYXRyaXgsIDExLCBnKSArIG0obWF0cml4LCAxMiwgYikgKyBtKG1hdHJpeCwgMTMsIGEpICsgbShtYXRyaXgsIDE0LCAxKTtcbiAgICAgICAgICAgICAgICBsZXQgbmEgPSBtKG1hdHJpeCwgMTUsIHIpICsgbShtYXRyaXgsIDE2LCBnKSArIG0obWF0cml4LCAxNywgYikgKyBtKG1hdHJpeCwgMTgsIGEpICsgbShtYXRyaXgsIDE5LCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZU9wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgbnIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBuZyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG5iID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbmEgKj0gYSAvIDI1NTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwLCBucik7XG4gICAgICAgICAgICAgICAgaW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAxLCBuZyk7XG4gICAgICAgICAgICAgICAgaW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAyLCBuYik7XG4gICAgICAgICAgICAgICAgaW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAzLCBuYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShzcmNEYXRhLCAwLCAwKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdmZUNvbG9yTWF0cml4JztcbiAgICAgICAgbGV0IG1hdHJpeCA9IHRvTnVtYmVycyh0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWVzJykuZ2V0U3RyaW5nKCkpO1xuICAgICAgICBzd2l0Y2godGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKS5nZXRTdHJpbmcoJ21hdHJpeCcpKXtcbiAgICAgICAgICAgIGNhc2UgJ3NhdHVyYXRlJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBtYXRyaXhbMF07XG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGFycmF5LWVsZW1lbnQtbmV3bGluZSAqLyBtYXRyaXggPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjIxMyArIDAuNzg3ICogcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuNzE1IC0gMC43MTUgKiBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgMC4wNzIgLSAwLjA3MiAqIHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuMjEzIC0gMC4yMTMgKiBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgMC43MTUgKyAwLjI4NSAqIHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjA3MiAtIDAuMDcyICogcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMC4yMTMgLSAwLjIxMyAqIHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjcxNSAtIDAuNzE1ICogcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuMDcyICsgMC45MjggKiBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2h1ZVJvdGF0ZSc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gbWF0cml4WzBdICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgYXJyYXktZWxlbWVudC1uZXdsaW5lICovIG1hdHJpeCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMoYSwgMC4yMTMsIDAuNzg3LCAtMC4yMTMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYyhhLCAwLjcxNSwgLTAuNzE1LCAtMC43MTUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYyhhLCAwLjA3MiwgLTAuMDcyLCAwLjkyOCksXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMoYSwgMC4yMTMsIC0wLjIxMywgMC4xNDMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYyhhLCAwLjcxNSwgMC4yODUsIDAuMTQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYyhhLCAwLjA3MiwgLTAuMDcyLCAtMC4yODMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjKGEsIDAuMjEzLCAtMC4yMTMsIC0wLjc4NyksXG4gICAgICAgICAgICAgICAgICAgICAgICBjKGEsIDAuNzE1LCAtMC43MTUsIDAuNzE1KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMoYSwgMC4wNzIsIDAuOTI4LCAwLjA3MiksXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbHVtaW5hbmNlVG9BbHBoYSc6XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgYXJyYXktZWxlbWVudC1uZXdsaW5lICovIG1hdHJpeCA9IFtcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMC4yMTI1LFxuICAgICAgICAgICAgICAgICAgICAwLjcxNTQsXG4gICAgICAgICAgICAgICAgICAgIDAuMDcyMSxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXRyaXggPSBtYXRyaXg7XG4gICAgICAgIHRoaXMuaW5jbHVkZU9wYWNpdHkgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaW5jbHVkZU9wYWNpdHknKS5oYXNWYWx1ZSgpO1xuICAgIH1cbn1cblxuY2xhc3MgTWFza0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBhcHBseShjdHgsIGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgeyBkb2N1bWVudCAgfSA9IHRoaXM7XG4gICAgICAgIC8vIHJlbmRlciBhcyB0ZW1wIHN2Z1xuICAgICAgICBsZXQgeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGxldCB5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmdldFBpeGVscygneScpO1xuICAgICAgICBpZiAoIXdpZHRoICYmICFoZWlnaHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKT0+e1xuICAgICAgICAgICAgICAgIGJvdW5kaW5nQm94LmFkZEJvdW5kaW5nQm94KGNoaWxkLmdldEJvdW5kaW5nQm94KGN0eCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB4ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC54MSk7XG4gICAgICAgICAgICB5ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC55MSk7XG4gICAgICAgICAgICB3aWR0aCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gud2lkdGgpO1xuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlnbm9yZWRTdHlsZXMgPSB0aGlzLnJlbW92ZVN0eWxlcyhlbGVtZW50LCBNYXNrRWxlbWVudC5pZ25vcmVTdHlsZXMpO1xuICAgICAgICBjb25zdCBtYXNrQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlQ2FudmFzKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IG1hc2tDdHggPSBtYXNrQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGRvY3VtZW50LnNjcmVlbi5zZXREZWZhdWx0cyhtYXNrQ3R4KTtcbiAgICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbihtYXNrQ3R4KTtcbiAgICAgICAgLy8gY29udmVydCBtYXNrIHRvIGFscGhhIHdpdGggYSBmYWtlIG5vZGVcbiAgICAgICAgLy8gVE9ETzogcmVmYWN0b3Igb3V0IGFwcGx5IGZyb20gZmVDb2xvck1hdHJpeFxuICAgICAgICBuZXcgRmVDb2xvck1hdHJpeEVsZW1lbnQoZG9jdW1lbnQsIHtcbiAgICAgICAgICAgIG5vZGVUeXBlOiAxLFxuICAgICAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBub2RlTmFtZTogJ3R5cGUnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ2x1bWluYW5jZVRvQWxwaGEnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lOiAnaW5jbHVkZU9wYWNpdHknLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ3RydWUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9KS5hcHBseShtYXNrQ3R4LCAwLCAwLCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICBjb25zdCB0bXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVDYW52YXMoeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGRvY3VtZW50LnNjcmVlbi5zZXREZWZhdWx0cyh0bXBDdHgpO1xuICAgICAgICBlbGVtZW50LnJlbmRlcih0bXBDdHgpO1xuICAgICAgICB0bXBDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWluJztcbiAgICAgICAgdG1wQ3R4LmZpbGxTdHlsZSA9IG1hc2tDdHguY3JlYXRlUGF0dGVybihtYXNrQ2FudmFzLCAnbm8tcmVwZWF0Jyk7XG4gICAgICAgIHRtcEN0eC5maWxsUmVjdCgwLCAwLCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdG1wQ3R4LmNyZWF0ZVBhdHRlcm4odG1wQ2FudmFzLCAnbm8tcmVwZWF0Jyk7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICAvLyByZWFzc2lnbiBtYXNrXG4gICAgICAgIHRoaXMucmVzdG9yZVN0eWxlcyhlbGVtZW50LCBpZ25vcmVkU3R5bGVzKTtcbiAgICB9XG4gICAgcmVuZGVyKF8pIHtcbiAgICAvLyBOTyBSRU5ERVJcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnbWFzayc7XG4gICAgfVxufVxuTWFza0VsZW1lbnQuaWdub3JlU3R5bGVzID0gW1xuICAgICdtYXNrJyxcbiAgICAndHJhbnNmb3JtJyxcbiAgICAnY2xpcC1wYXRoJ1xuXTtcblxuY29uc3Qgbm9vcCA9ICgpPT57XG4vLyBOT09QXG59O1xuY2xhc3MgQ2xpcFBhdGhFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgYXBwbHkoY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgZG9jdW1lbnQgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBjb250ZXh0UHJvdG8gPSBSZWZsZWN0LmdldFByb3RvdHlwZU9mKGN0eCk7XG4gICAgICAgIGNvbnN0IHsgYmVnaW5QYXRoICwgY2xvc2VQYXRoICB9ID0gY3R4O1xuICAgICAgICBpZiAoY29udGV4dFByb3RvKSB7XG4gICAgICAgICAgICBjb250ZXh0UHJvdG8uYmVnaW5QYXRoID0gbm9vcDtcbiAgICAgICAgICAgIGNvbnRleHRQcm90by5jbG9zZVBhdGggPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIFJlZmxlY3QuYXBwbHkoYmVnaW5QYXRoLCBjdHgsIFtdKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCk9PntcbiAgICAgICAgICAgIGlmICghKCdwYXRoJyBpbiBjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdHJhbnNmb3JtID0gJ2VsZW1lbnRUcmFuc2Zvcm0nIGluIGNoaWxkID8gY2hpbGQuZWxlbWVudFRyYW5zZm9ybSgpIDogbnVsbCAvLyBoYW5kbGUgPHVzZSAvPlxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gPSBUcmFuc2Zvcm0uZnJvbUVsZW1lbnQoZG9jdW1lbnQsIGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uYXBwbHkoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkLnBhdGgoY3R4KTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0UHJvdG8pIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0UHJvdG8uY2xvc2VQYXRoID0gY2xvc2VQYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybS51bmFwcGx5KGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBSZWZsZWN0LmFwcGx5KGNsb3NlUGF0aCwgY3R4LCBbXSk7XG4gICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIGlmIChjb250ZXh0UHJvdG8pIHtcbiAgICAgICAgICAgIGNvbnRleHRQcm90by5iZWdpblBhdGggPSBiZWdpblBhdGg7XG4gICAgICAgICAgICBjb250ZXh0UHJvdG8uY2xvc2VQYXRoID0gY2xvc2VQYXRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcihfKSB7XG4gICAgLy8gTk8gUkVOREVSXG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2NsaXBQYXRoJztcbiAgICB9XG59XG5cbmNsYXNzIEZpbHRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBhcHBseShjdHgsIGVsZW1lbnQpIHtcbiAgICAgICAgLy8gcmVuZGVyIGFzIHRlbXAgc3ZnXG4gICAgICAgIGNvbnN0IHsgZG9jdW1lbnQgLCBjaGlsZHJlbiAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gJ2dldEJvdW5kaW5nQm94JyBpbiBlbGVtZW50ID8gZWxlbWVudC5nZXRCb3VuZGluZ0JveChjdHgpIDogbnVsbDtcbiAgICAgICAgaWYgKCFib3VuZGluZ0JveCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBweCA9IDA7XG4gICAgICAgIGxldCBweSA9IDA7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKT0+e1xuICAgICAgICAgICAgY29uc3QgZWZkID0gY2hpbGQuZXh0cmFGaWx0ZXJEaXN0YW5jZSB8fCAwO1xuICAgICAgICAgICAgcHggPSBNYXRoLm1heChweCwgZWZkKTtcbiAgICAgICAgICAgIHB5ID0gTWF0aC5tYXgocHksIGVmZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gud2lkdGgpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LmhlaWdodCk7XG4gICAgICAgIGNvbnN0IHRtcENhbnZhc1dpZHRoID0gd2lkdGggKyAyICogcHg7XG4gICAgICAgIGNvbnN0IHRtcENhbnZhc0hlaWdodCA9IGhlaWdodCArIDIgKiBweTtcbiAgICAgICAgaWYgKHRtcENhbnZhc1dpZHRoIDwgMSB8fCB0bXBDYW52YXNIZWlnaHQgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gueCk7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LnkpO1xuICAgICAgICBjb25zdCBpZ25vcmVkU3R5bGVzID0gdGhpcy5yZW1vdmVTdHlsZXMoZWxlbWVudCwgRmlsdGVyRWxlbWVudC5pZ25vcmVTdHlsZXMpO1xuICAgICAgICBjb25zdCB0bXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVDYW52YXModG1wQ2FudmFzV2lkdGgsIHRtcENhbnZhc0hlaWdodCk7XG4gICAgICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBkb2N1bWVudC5zY3JlZW4uc2V0RGVmYXVsdHModG1wQ3R4KTtcbiAgICAgICAgdG1wQ3R4LnRyYW5zbGF0ZSgteCArIHB4LCAteSArIHB5KTtcbiAgICAgICAgZWxlbWVudC5yZW5kZXIodG1wQ3R4KTtcbiAgICAgICAgLy8gYXBwbHkgZmlsdGVyc1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCk9PntcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQuYXBwbHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5hcHBseSh0bXBDdHgsIDAsIDAsIHRtcENhbnZhc1dpZHRoLCB0bXBDYW52YXNIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gcmVuZGVyIG9uIG1lXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodG1wQ2FudmFzLCAwLCAwLCB0bXBDYW52YXNXaWR0aCwgdG1wQ2FudmFzSGVpZ2h0LCB4IC0gcHgsIHkgLSBweSwgdG1wQ2FudmFzV2lkdGgsIHRtcENhbnZhc0hlaWdodCk7XG4gICAgICAgIHRoaXMucmVzdG9yZVN0eWxlcyhlbGVtZW50LCBpZ25vcmVkU3R5bGVzKTtcbiAgICB9XG4gICAgcmVuZGVyKF8pIHtcbiAgICAvLyBOTyBSRU5ERVJcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZmlsdGVyJztcbiAgICB9XG59XG5GaWx0ZXJFbGVtZW50Lmlnbm9yZVN0eWxlcyA9IFtcbiAgICAnZmlsdGVyJyxcbiAgICAndHJhbnNmb3JtJyxcbiAgICAnY2xpcC1wYXRoJ1xuXTtcblxuY2xhc3MgRmVEcm9wU2hhZG93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIGFwcGx5KF8sIF94LCBfeSwgX3dpZHRoLCBfaGVpZ2h0KSB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZmVEcm9wU2hhZG93JztcbiAgICAgICAgdGhpcy5hZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uKCk7XG4gICAgfVxufVxuXG5jbGFzcyBGZU1vcnBob2xvZ3lFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgYXBwbHkoXywgX3gsIF95LCBfd2lkdGgsIF9oZWlnaHQpIHtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnRcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZmVNb3JwaG9sb2d5JztcbiAgICB9XG59XG5cbmNsYXNzIEZlQ29tcG9zaXRlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIGFwcGx5KF8sIF94LCBfeSwgX3dpZHRoLCBfaGVpZ2h0KSB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2ZlQ29tcG9zaXRlJztcbiAgICB9XG59XG5cbmNsYXNzIEZlR2F1c3NpYW5CbHVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIGFwcGx5KGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBjb25zdCB7IGRvY3VtZW50ICwgYmx1clJhZGl1cyAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC53aW5kb3cgPyBkb2N1bWVudC53aW5kb3cuZG9jdW1lbnQuYm9keSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGN0eC5jYW52YXM7XG4gICAgICAgIC8vIFN0YWNrQmx1ciByZXF1aXJlcyBjYW52YXMgYmUgb24gZG9jdW1lbnRcbiAgICAgICAgY2FudmFzLmlkID0gZG9jdW1lbnQuZ2V0VW5pcXVlSWQoKTtcbiAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhbnZhc1JHQkEoY2FudmFzLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBibHVyUmFkaXVzKTtcbiAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2ZlR2F1c3NpYW5CbHVyJztcbiAgICAgICAgdGhpcy5ibHVyUmFkaXVzID0gTWF0aC5mbG9vcih0aGlzLmdldEF0dHJpYnV0ZSgnc3RkRGV2aWF0aW9uJykuZ2V0TnVtYmVyKCkpO1xuICAgICAgICB0aGlzLmV4dHJhRmlsdGVyRGlzdGFuY2UgPSB0aGlzLmJsdXJSYWRpdXM7XG4gICAgfVxufVxuXG5jbGFzcyBUaXRsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICd0aXRsZSc7XG4gICAgfVxufVxuXG5jbGFzcyBEZXNjRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Rlc2MnO1xuICAgIH1cbn1cblxuY29uc3QgZWxlbWVudHMgPSB7XG4gICAgJ3N2Zyc6IFNWR0VsZW1lbnQsXG4gICAgJ3JlY3QnOiBSZWN0RWxlbWVudCxcbiAgICAnY2lyY2xlJzogQ2lyY2xlRWxlbWVudCxcbiAgICAnZWxsaXBzZSc6IEVsbGlwc2VFbGVtZW50LFxuICAgICdsaW5lJzogTGluZUVsZW1lbnQsXG4gICAgJ3BvbHlsaW5lJzogUG9seWxpbmVFbGVtZW50LFxuICAgICdwb2x5Z29uJzogUG9seWdvbkVsZW1lbnQsXG4gICAgJ3BhdGgnOiBQYXRoRWxlbWVudCxcbiAgICAncGF0dGVybic6IFBhdHRlcm5FbGVtZW50LFxuICAgICdtYXJrZXInOiBNYXJrZXJFbGVtZW50LFxuICAgICdkZWZzJzogRGVmc0VsZW1lbnQsXG4gICAgJ2xpbmVhckdyYWRpZW50JzogTGluZWFyR3JhZGllbnRFbGVtZW50LFxuICAgICdyYWRpYWxHcmFkaWVudCc6IFJhZGlhbEdyYWRpZW50RWxlbWVudCxcbiAgICAnc3RvcCc6IFN0b3BFbGVtZW50LFxuICAgICdhbmltYXRlJzogQW5pbWF0ZUVsZW1lbnQsXG4gICAgJ2FuaW1hdGVDb2xvcic6IEFuaW1hdGVDb2xvckVsZW1lbnQsXG4gICAgJ2FuaW1hdGVUcmFuc2Zvcm0nOiBBbmltYXRlVHJhbnNmb3JtRWxlbWVudCxcbiAgICAnZm9udCc6IEZvbnRFbGVtZW50LFxuICAgICdmb250LWZhY2UnOiBGb250RmFjZUVsZW1lbnQsXG4gICAgJ21pc3NpbmctZ2x5cGgnOiBNaXNzaW5nR2x5cGhFbGVtZW50LFxuICAgICdnbHlwaCc6IEdseXBoRWxlbWVudCxcbiAgICAndGV4dCc6IFRleHRFbGVtZW50LFxuICAgICd0c3Bhbic6IFRTcGFuRWxlbWVudCxcbiAgICAndHJlZic6IFRSZWZFbGVtZW50LFxuICAgICdhJzogQUVsZW1lbnQsXG4gICAgJ3RleHRQYXRoJzogVGV4dFBhdGhFbGVtZW50LFxuICAgICdpbWFnZSc6IEltYWdlRWxlbWVudCxcbiAgICAnZyc6IEdFbGVtZW50LFxuICAgICdzeW1ib2wnOiBTeW1ib2xFbGVtZW50LFxuICAgICdzdHlsZSc6IFN0eWxlRWxlbWVudCxcbiAgICAndXNlJzogVXNlRWxlbWVudCxcbiAgICAnbWFzayc6IE1hc2tFbGVtZW50LFxuICAgICdjbGlwUGF0aCc6IENsaXBQYXRoRWxlbWVudCxcbiAgICAnZmlsdGVyJzogRmlsdGVyRWxlbWVudCxcbiAgICAnZmVEcm9wU2hhZG93JzogRmVEcm9wU2hhZG93RWxlbWVudCxcbiAgICAnZmVNb3JwaG9sb2d5JzogRmVNb3JwaG9sb2d5RWxlbWVudCxcbiAgICAnZmVDb21wb3NpdGUnOiBGZUNvbXBvc2l0ZUVsZW1lbnQsXG4gICAgJ2ZlQ29sb3JNYXRyaXgnOiBGZUNvbG9yTWF0cml4RWxlbWVudCxcbiAgICAnZmVHYXVzc2lhbkJsdXInOiBGZUdhdXNzaWFuQmx1ckVsZW1lbnQsXG4gICAgJ3RpdGxlJzogVGl0bGVFbGVtZW50LFxuICAgICdkZXNjJzogRGVzY0VsZW1lbnRcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gY2FudmFzO1xufVxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlSW1hZ2Uoc3JjKSB7XG4gICAgbGV0IGFub255bW91c0Nyb3NzT3JpZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICBjb25zdCBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIGlmIChhbm9ueW1vdXNDcm9zc09yaWdpbikge1xuICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gKCk9PntcbiAgICAgICAgICAgIHJlc29sdmUoaW1hZ2UpO1xuICAgICAgICB9O1xuICAgICAgICBpbWFnZS5vbmVycm9yID0gKF9ldmVudCwgX3NvdXJjZSwgX2xpbmVubywgX2NvbG5vLCBlcnJvcik9PntcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIGltYWdlLnNyYyA9IHNyYztcbiAgICB9KTtcbn1cbmNvbnN0IERFRkFVTFRfRU1fU0laRSA9IDEyO1xuY2xhc3MgRG9jdW1lbnQge1xuICAgIGJpbmRDcmVhdGVJbWFnZShjcmVhdGVJbWFnZTEsIGFub255bW91c0Nyb3NzT3JpZ2luKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYW5vbnltb3VzQ3Jvc3NPcmlnaW4gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIChzb3VyY2UsIGZvcmNlQW5vbnltb3VzQ3Jvc3NPcmlnaW4pPT5jcmVhdGVJbWFnZTEoc291cmNlLCB0eXBlb2YgZm9yY2VBbm9ueW1vdXNDcm9zc09yaWdpbiA9PT0gJ2Jvb2xlYW4nID8gZm9yY2VBbm9ueW1vdXNDcm9zc09yaWdpbiA6IGFub255bW91c0Nyb3NzT3JpZ2luKVxuICAgICAgICAgICAgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVJbWFnZTE7XG4gICAgfVxuICAgIGdldCB3aW5kb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi53aW5kb3c7XG4gICAgfVxuICAgIGdldCBmZXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmZldGNoO1xuICAgIH1cbiAgICBnZXQgY3R4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4uY3R4O1xuICAgIH1cbiAgICBnZXQgZW1TaXplKCkge1xuICAgICAgICBjb25zdCB7IGVtU2l6ZVN0YWNrICB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGVtU2l6ZVN0YWNrW2VtU2l6ZVN0YWNrLmxlbmd0aCAtIDFdIHx8IERFRkFVTFRfRU1fU0laRTtcbiAgICB9XG4gICAgc2V0IGVtU2l6ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCB7IGVtU2l6ZVN0YWNrICB9ID0gdGhpcztcbiAgICAgICAgZW1TaXplU3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcEVtU2l6ZSgpIHtcbiAgICAgICAgY29uc3QgeyBlbVNpemVTdGFjayAgfSA9IHRoaXM7XG4gICAgICAgIGVtU2l6ZVN0YWNrLnBvcCgpO1xuICAgIH1cbiAgICBnZXRVbmlxdWVJZCgpIHtcbiAgICAgICAgcmV0dXJuIFwiY2FudmdcIi5jb25jYXQoKyt0aGlzLnVuaXF1ZUlkKTtcbiAgICB9XG4gICAgaXNJbWFnZXNMb2FkZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlcy5ldmVyeSgoXyk9Pl8ubG9hZGVkXG4gICAgICAgICk7XG4gICAgfVxuICAgIGlzRm9udHNMb2FkZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvbnRzLmV2ZXJ5KChfKT0+Xy5sb2FkZWRcbiAgICAgICAgKTtcbiAgICB9XG4gICAgY3JlYXRlRG9jdW1lbnRFbGVtZW50KGRvY3VtZW50KSB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IHRoaXMuY3JlYXRlRWxlbWVudChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgICAgICBkb2N1bWVudEVsZW1lbnQucm9vdCA9IHRydWU7XG4gICAgICAgIGRvY3VtZW50RWxlbWVudC5hZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uKCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cbiAgICBjcmVhdGVFbGVtZW50KG5vZGUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudFR5cGUgPSBub2RlLm5vZGVOYW1lLnJlcGxhY2UoL15bXjpdKzovLCAnJyk7XG4gICAgICAgIGNvbnN0IEVsZW1lbnRUeXBlID0gRG9jdW1lbnQuZWxlbWVudFR5cGVzW2VsZW1lbnRUeXBlXTtcbiAgICAgICAgaWYgKEVsZW1lbnRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnRUeXBlKHRoaXMsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVW5rbm93bkVsZW1lbnQodGhpcywgbm9kZSk7XG4gICAgfVxuICAgIGNyZWF0ZVRleHROb2RlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Tm9kZSh0aGlzLCBub2RlKTtcbiAgICB9XG4gICAgc2V0Vmlld0JveChjb25maWcpIHtcbiAgICAgICAgdGhpcy5zY3JlZW4uc2V0Vmlld0JveCh7XG4gICAgICAgICAgICBkb2N1bWVudDogdGhpcyxcbiAgICAgICAgICAgIC4uLmNvbmZpZ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY2FudmcsIHsgcm9vdEVtU2l6ZSA9REVGQVVMVF9FTV9TSVpFICwgZW1TaXplID1ERUZBVUxUX0VNX1NJWkUgLCBjcmVhdGVDYW52YXM6IGNyZWF0ZUNhbnZhczEgPSBEb2N1bWVudC5jcmVhdGVDYW52YXMgLCBjcmVhdGVJbWFnZTogY3JlYXRlSW1hZ2UyID0gRG9jdW1lbnQuY3JlYXRlSW1hZ2UgLCBhbm9ueW1vdXNDcm9zc09yaWdpbiAgfSA9IHt9KXtcbiAgICAgICAgdGhpcy5jYW52ZyA9IGNhbnZnO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zdHlsZXNTcGVjaWZpY2l0eSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pbWFnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5mb250cyA9IFtdO1xuICAgICAgICB0aGlzLmVtU2l6ZVN0YWNrID0gW107XG4gICAgICAgIHRoaXMudW5pcXVlSWQgPSAwO1xuICAgICAgICB0aGlzLnNjcmVlbiA9IGNhbnZnLnNjcmVlbjtcbiAgICAgICAgdGhpcy5yb290RW1TaXplID0gcm9vdEVtU2l6ZTtcbiAgICAgICAgdGhpcy5lbVNpemUgPSBlbVNpemU7XG4gICAgICAgIHRoaXMuY3JlYXRlQ2FudmFzID0gY3JlYXRlQ2FudmFzMTtcbiAgICAgICAgdGhpcy5jcmVhdGVJbWFnZSA9IHRoaXMuYmluZENyZWF0ZUltYWdlKGNyZWF0ZUltYWdlMiwgYW5vbnltb3VzQ3Jvc3NPcmlnaW4pO1xuICAgICAgICB0aGlzLnNjcmVlbi53YWl0KCgpPT50aGlzLmlzSW1hZ2VzTG9hZGVkKClcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zY3JlZW4ud2FpdCgoKT0+dGhpcy5pc0ZvbnRzTG9hZGVkKClcbiAgICAgICAgKTtcbiAgICB9XG59XG5Eb2N1bWVudC5jcmVhdGVDYW52YXMgPSBjcmVhdGVDYW52YXM7XG5Eb2N1bWVudC5jcmVhdGVJbWFnZSA9IGNyZWF0ZUltYWdlO1xuRG9jdW1lbnQuZWxlbWVudFR5cGVzID0gZWxlbWVudHM7XG5cbi8qKlxuICogU1ZHIHJlbmRlcmVyIG9uIGNhbnZhcy5cbiAqLyBjbGFzcyBDYW52ZyB7XG4gICAgLyoqXG4gICAqIENyZWF0ZSBDYW52ZyBpbnN0YW5jZSBmcm9tIFNWRyBzb3VyY2Ugc3RyaW5nIG9yIFVSTC5cbiAgICogQHBhcmFtIGN0eCAtIFJlbmRlcmluZyBjb250ZXh0LlxuICAgKiBAcGFyYW0gc3ZnIC0gU1ZHIHNvdXJjZSBzdHJpbmcgb3IgVVJMLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxuICAgKiBAcmV0dXJucyBDYW52ZyBpbnN0YW5jZS5cbiAgICovIHN0YXRpYyBhc3luYyBmcm9tKGN0eCwgc3ZnKSB7XG4gICAgICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgc3ZnRG9jdW1lbnQgPSBhd2FpdCBwYXJzZXIucGFyc2Uoc3ZnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDYW52ZyhjdHgsIHN2Z0RvY3VtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENyZWF0ZSBDYW52ZyBpbnN0YW5jZSBmcm9tIFNWRyBzb3VyY2Ugc3RyaW5nLlxuICAgKiBAcGFyYW0gY3R4IC0gUmVuZGVyaW5nIGNvbnRleHQuXG4gICAqIEBwYXJhbSBzdmcgLSBTVkcgc291cmNlIHN0cmluZy5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXJpbmcgb3B0aW9ucy5cbiAgICogQHJldHVybnMgQ2FudmcgaW5zdGFuY2UuXG4gICAqLyBzdGF0aWMgZnJvbVN0cmluZyhjdHgsIHN2Zykge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHN2Z0RvY3VtZW50ID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhzdmcpO1xuICAgICAgICByZXR1cm4gbmV3IENhbnZnKGN0eCwgc3ZnRG9jdW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICogQ3JlYXRlIG5ldyBDYW52ZyBpbnN0YW5jZSB3aXRoIGluaGVyaXRlZCBvcHRpb25zLlxuICAgKiBAcGFyYW0gY3R4IC0gUmVuZGVyaW5nIGNvbnRleHQuXG4gICAqIEBwYXJhbSBzdmcgLSBTVkcgc291cmNlIHN0cmluZyBvciBVUkwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIENhbnZnIGluc3RhbmNlLlxuICAgKi8gZm9yayhjdHgsIHN2Zykge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICAgIHJldHVybiBDYW52Zy5mcm9tKGN0eCwgc3ZnLCB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICogQ3JlYXRlIG5ldyBDYW52ZyBpbnN0YW5jZSB3aXRoIGluaGVyaXRlZCBvcHRpb25zLlxuICAgKiBAcGFyYW0gY3R4IC0gUmVuZGVyaW5nIGNvbnRleHQuXG4gICAqIEBwYXJhbSBzdmcgLSBTVkcgc291cmNlIHN0cmluZy5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXJpbmcgb3B0aW9ucy5cbiAgICogQHJldHVybnMgQ2FudmcgaW5zdGFuY2UuXG4gICAqLyBmb3JrU3RyaW5nKGN0eCwgc3ZnKSB7XG4gICAgICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgICAgcmV0dXJuIENhbnZnLmZyb21TdHJpbmcoY3R4LCBzdmcsIHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBEb2N1bWVudCBpcyByZWFkeSBwcm9taXNlLlxuICAgKiBAcmV0dXJucyBSZWFkeSBwcm9taXNlLlxuICAgKi8gcmVhZHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5yZWFkeSgpO1xuICAgIH1cbiAgICAvKipcbiAgICogRG9jdW1lbnQgaXMgcmVhZHkgdmFsdWUuXG4gICAqIEByZXR1cm5zIElzIHJlYWR5IG9yIG5vdC5cbiAgICovIGlzUmVhZHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5pc1JlYWR5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZW5kZXIgb25seSBmaXJzdCBmcmFtZSwgaWdub3JpbmcgYW5pbWF0aW9ucyBhbmQgbW91c2UuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXG4gICAqLyBhc3luYyByZW5kZXIoKSB7XG4gICAgICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgdGhpcy5zdGFydCh7XG4gICAgICAgICAgICBlbmFibGVSZWRyYXc6IHRydWUsXG4gICAgICAgICAgICBpZ25vcmVBbmltYXRpb246IHRydWUsXG4gICAgICAgICAgICBpZ25vcmVNb3VzZTogdHJ1ZSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMucmVhZHkoKTtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTdGFydCByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyIG9wdGlvbnMuXG4gICAqLyBzdGFydCgpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICBjb25zdCB7IGRvY3VtZW50RWxlbWVudCAsIHNjcmVlbiAsIG9wdGlvbnM6IGJhc2VPcHRpb25zICB9ID0gdGhpcztcbiAgICAgICAgc2NyZWVuLnN0YXJ0KGRvY3VtZW50RWxlbWVudCwge1xuICAgICAgICAgICAgZW5hYmxlUmVkcmF3OiB0cnVlLFxuICAgICAgICAgICAgLi4uYmFzZU9wdGlvbnMsXG4gICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICogU3RvcCByZW5kZXJpbmcuXG4gICAqLyBzdG9wKCkge1xuICAgICAgICB0aGlzLnNjcmVlbi5zdG9wKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXNpemUgU1ZHIHRvIGZpdCBpbiBnaXZlbiBzaXplLlxuICAgKiBAcGFyYW0gd2lkdGhcbiAgICogQHBhcmFtIGhlaWdodFxuICAgKiBAcGFyYW0gcHJlc2VydmVBc3BlY3RSYXRpb1xuICAgKi8gcmVzaXplKHdpZHRoKSB7XG4gICAgICAgIGxldCBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHdpZHRoLCBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgICAgdGhpcy5kb2N1bWVudEVsZW1lbnQucmVzaXplKHdpZHRoLCBoZWlnaHQsIHByZXNlcnZlQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICAvKipcbiAgICogTWFpbiBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIGN0eCAtIFJlbmRlcmluZyBjb250ZXh0LlxuICAgKiBAcGFyYW0gc3ZnIC0gU1ZHIERvY3VtZW50LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxuICAgKi8gY29uc3RydWN0b3IoY3R4LCBzdmcsIG9wdGlvbnMgPSB7fSl7XG4gICAgICAgIHRoaXMucGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5zY3JlZW4gPSBuZXcgU2NyZWVuKGN0eCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gbmV3IERvY3VtZW50KHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEVsZW1lbnQoc3ZnKTtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLmRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50RWxlbWVudDtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEFFbGVtZW50LCBBbmltYXRlQ29sb3JFbGVtZW50LCBBbmltYXRlRWxlbWVudCwgQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQsIEJvdW5kaW5nQm94LCBDQjEsIENCMiwgQ0IzLCBDQjQsIENhbnZnLCBDaXJjbGVFbGVtZW50LCBDbGlwUGF0aEVsZW1lbnQsIERlZnNFbGVtZW50LCBEZXNjRWxlbWVudCwgRG9jdW1lbnQsIEVsZW1lbnQsIEVsbGlwc2VFbGVtZW50LCBGZUNvbG9yTWF0cml4RWxlbWVudCwgRmVDb21wb3NpdGVFbGVtZW50LCBGZURyb3BTaGFkb3dFbGVtZW50LCBGZUdhdXNzaWFuQmx1ckVsZW1lbnQsIEZlTW9ycGhvbG9neUVsZW1lbnQsIEZpbHRlckVsZW1lbnQsIEZvbnQsIEZvbnRFbGVtZW50LCBGb250RmFjZUVsZW1lbnQsIEdFbGVtZW50LCBHbHlwaEVsZW1lbnQsIEdyYWRpZW50RWxlbWVudCwgSW1hZ2VFbGVtZW50LCBMaW5lRWxlbWVudCwgTGluZWFyR3JhZGllbnRFbGVtZW50LCBNYXJrZXJFbGVtZW50LCBNYXNrRWxlbWVudCwgTWF0cml4LCBNaXNzaW5nR2x5cGhFbGVtZW50LCBNb3VzZSwgUFNFVURPX1pFUk8sIFBhcnNlciwgUGF0aEVsZW1lbnQsIFBhdGhQYXJzZXIsIFBhdHRlcm5FbGVtZW50LCBQb2ludCwgUG9seWdvbkVsZW1lbnQsIFBvbHlsaW5lRWxlbWVudCwgUHJvcGVydHksIFFCMSwgUUIyLCBRQjMsIFJhZGlhbEdyYWRpZW50RWxlbWVudCwgUmVjdEVsZW1lbnQsIFJlbmRlcmVkRWxlbWVudCwgUm90YXRlLCBTVkdFbGVtZW50LCBTVkdGb250TG9hZGVyLCBTY2FsZSwgU2NyZWVuLCBTa2V3LCBTa2V3WCwgU2tld1ksIFN0b3BFbGVtZW50LCBTdHlsZUVsZW1lbnQsIFN5bWJvbEVsZW1lbnQsIFRSZWZFbGVtZW50LCBUU3BhbkVsZW1lbnQsIFRleHRFbGVtZW50LCBUZXh0UGF0aEVsZW1lbnQsIFRpdGxlRWxlbWVudCwgVHJhbnNmb3JtLCBUcmFuc2xhdGUsIFVua25vd25FbGVtZW50LCBVc2VFbGVtZW50LCBWaWV3UG9ydCwgY29tcHJlc3NTcGFjZXMsIGVsZW1lbnRzLCBnZXRTZWxlY3RvclNwZWNpZmljaXR5LCBub3JtYWxpemVBdHRyaWJ1dGVOYW1lLCBub3JtYWxpemVDb2xvciwgcGFyc2VFeHRlcm5hbFVybCwgaW5kZXggYXMgcHJlc2V0cywgdG9NYXRyaXhWYWx1ZSwgdG9OdW1iZXJzLCB0cmltTGVmdCwgdHJpbVJpZ2h0LCB2ZWN0b3JNYWduaXR1ZGUsIHZlY3RvcnNBbmdsZSwgdmVjdG9yc1JhdGlvIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/canvg/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/performance-now/lib/performance-now.js":
/*!*************************************************************!*\
  !*** ./node_modules/performance-now/lib/performance-now.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// Generated by CoffeeScript 1.12.2\n(function() {\n  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;\n\n  if ((typeof performance !== \"undefined\" && performance !== null) && performance.now) {\n    module.exports = function() {\n      return performance.now();\n    };\n  } else if ((typeof process !== \"undefined\" && process !== null) && process.hrtime) {\n    module.exports = function() {\n      return (getNanoSeconds() - nodeLoadTime) / 1e6;\n    };\n    hrtime = process.hrtime;\n    getNanoSeconds = function() {\n      var hr;\n      hr = hrtime();\n      return hr[0] * 1e9 + hr[1];\n    };\n    moduleLoadTime = getNanoSeconds();\n    upTime = process.uptime() * 1e9;\n    nodeLoadTime = moduleLoadTime - upTime;\n  } else if (Date.now) {\n    module.exports = function() {\n      return Date.now() - loadTime;\n    };\n    loadTime = Date.now();\n  } else {\n    module.exports = function() {\n      return new Date().getTime() - loadTime;\n    };\n    loadTime = new Date().getTime();\n  }\n\n}).call(this);\n\n//# sourceMappingURL=performance-now.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wZXJmb3JtYW5jZS1ub3cvbGliL3BlcmZvcm1hbmNlLW5vdy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpQkFBaUIsT0FBTyxvQkFBb0IsT0FBTyxjQUFjLE9BQU87QUFDNUU7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIi9hcHAvbm9kZV9tb2R1bGVzL3BlcmZvcm1hbmNlLW5vdy9saWIvcGVyZm9ybWFuY2Utbm93LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi4yXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBnZXROYW5vU2Vjb25kcywgaHJ0aW1lLCBsb2FkVGltZSwgbW9kdWxlTG9hZFRpbWUsIG5vZGVMb2FkVGltZSwgdXBUaW1lO1xuXG4gIGlmICgodHlwZW9mIHBlcmZvcm1hbmNlICE9PSBcInVuZGVmaW5lZFwiICYmIHBlcmZvcm1hbmNlICE9PSBudWxsKSAmJiBwZXJmb3JtYW5jZS5ub3cpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MgIT09IG51bGwpICYmIHByb2Nlc3MuaHJ0aW1lKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoZ2V0TmFub1NlY29uZHMoKSAtIG5vZGVMb2FkVGltZSkgLyAxZTY7XG4gICAgfTtcbiAgICBocnRpbWUgPSBwcm9jZXNzLmhydGltZTtcbiAgICBnZXROYW5vU2Vjb25kcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhyO1xuICAgICAgaHIgPSBocnRpbWUoKTtcbiAgICAgIHJldHVybiBoclswXSAqIDFlOSArIGhyWzFdO1xuICAgIH07XG4gICAgbW9kdWxlTG9hZFRpbWUgPSBnZXROYW5vU2Vjb25kcygpO1xuICAgIHVwVGltZSA9IHByb2Nlc3MudXB0aW1lKCkgKiAxZTk7XG4gICAgbm9kZUxvYWRUaW1lID0gbW9kdWxlTG9hZFRpbWUgLSB1cFRpbWU7XG4gIH0gZWxzZSBpZiAoRGF0ZS5ub3cpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBsb2FkVGltZTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gRGF0ZS5ub3coKTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gbG9hZFRpbWU7XG4gICAgfTtcbiAgICBsb2FkVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlcmZvcm1hbmNlLW5vdy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/performance-now/lib/performance-now.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/raf/index.js":
/*!***********************************!*\
  !*** ./node_modules/raf/index.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var now = __webpack_require__(/*! performance-now */ \"(app-pages-browser)/./node_modules/performance-now/lib/performance-now.js\")\n  , root = typeof window === 'undefined' ? __webpack_require__.g : window\n  , vendors = ['moz', 'webkit']\n  , suffix = 'AnimationFrame'\n  , raf = root['request' + suffix]\n  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]\n\nfor(var i = 0; !raf && i < vendors.length; i++) {\n  raf = root[vendors[i] + 'Request' + suffix]\n  caf = root[vendors[i] + 'Cancel' + suffix]\n      || root[vendors[i] + 'CancelRequest' + suffix]\n}\n\n// Some versions of FF have rAF but not cAF\nif(!raf || !caf) {\n  var last = 0\n    , id = 0\n    , queue = []\n    , frameDuration = 1000 / 60\n\n  raf = function(callback) {\n    if(queue.length === 0) {\n      var _now = now()\n        , next = Math.max(0, frameDuration - (_now - last))\n      last = next + _now\n      setTimeout(function() {\n        var cp = queue.slice(0)\n        // Clear queue here to prevent\n        // callbacks from appending listeners\n        // to the current frame's queue\n        queue.length = 0\n        for(var i = 0; i < cp.length; i++) {\n          if(!cp[i].cancelled) {\n            try{\n              cp[i].callback(last)\n            } catch(e) {\n              setTimeout(function() { throw e }, 0)\n            }\n          }\n        }\n      }, Math.round(next))\n    }\n    queue.push({\n      handle: ++id,\n      callback: callback,\n      cancelled: false\n    })\n    return id\n  }\n\n  caf = function(handle) {\n    for(var i = 0; i < queue.length; i++) {\n      if(queue[i].handle === handle) {\n        queue[i].cancelled = true\n      }\n    }\n  }\n}\n\nmodule.exports = function(fn) {\n  // Wrap in a new function to prevent\n  // `cancel` potentially being assigned\n  // to the native rAF function\n  return raf.call(root, fn)\n}\nmodule.exports.cancel = function() {\n  caf.apply(root, arguments)\n}\nmodule.exports.polyfill = function(object) {\n  if (!object) {\n    object = root;\n  }\n  object.requestAnimationFrame = raf\n  object.cancelAnimationFrame = caf\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yYWYvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLGtHQUFpQjtBQUNuQywyQ0FBMkMscUJBQU07QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSw0QkFBNEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2FwcC9ub2RlX21vZHVsZXMvcmFmL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBub3cgPSByZXF1aXJlKCdwZXJmb3JtYW5jZS1ub3cnKVxuICAsIHJvb3QgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvd1xuICAsIHZlbmRvcnMgPSBbJ21veicsICd3ZWJraXQnXVxuICAsIHN1ZmZpeCA9ICdBbmltYXRpb25GcmFtZSdcbiAgLCByYWYgPSByb290WydyZXF1ZXN0JyArIHN1ZmZpeF1cbiAgLCBjYWYgPSByb290WydjYW5jZWwnICsgc3VmZml4XSB8fCByb290WydjYW5jZWxSZXF1ZXN0JyArIHN1ZmZpeF1cblxuZm9yKHZhciBpID0gMDsgIXJhZiAmJiBpIDwgdmVuZG9ycy5sZW5ndGg7IGkrKykge1xuICByYWYgPSByb290W3ZlbmRvcnNbaV0gKyAnUmVxdWVzdCcgKyBzdWZmaXhdXG4gIGNhZiA9IHJvb3RbdmVuZG9yc1tpXSArICdDYW5jZWwnICsgc3VmZml4XVxuICAgICAgfHwgcm9vdFt2ZW5kb3JzW2ldICsgJ0NhbmNlbFJlcXVlc3QnICsgc3VmZml4XVxufVxuXG4vLyBTb21lIHZlcnNpb25zIG9mIEZGIGhhdmUgckFGIGJ1dCBub3QgY0FGXG5pZighcmFmIHx8ICFjYWYpIHtcbiAgdmFyIGxhc3QgPSAwXG4gICAgLCBpZCA9IDBcbiAgICAsIHF1ZXVlID0gW11cbiAgICAsIGZyYW1lRHVyYXRpb24gPSAxMDAwIC8gNjBcblxuICByYWYgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFyIF9ub3cgPSBub3coKVxuICAgICAgICAsIG5leHQgPSBNYXRoLm1heCgwLCBmcmFtZUR1cmF0aW9uIC0gKF9ub3cgLSBsYXN0KSlcbiAgICAgIGxhc3QgPSBuZXh0ICsgX25vd1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNwID0gcXVldWUuc2xpY2UoMClcbiAgICAgICAgLy8gQ2xlYXIgcXVldWUgaGVyZSB0byBwcmV2ZW50XG4gICAgICAgIC8vIGNhbGxiYWNrcyBmcm9tIGFwcGVuZGluZyBsaXN0ZW5lcnNcbiAgICAgICAgLy8gdG8gdGhlIGN1cnJlbnQgZnJhbWUncyBxdWV1ZVxuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKCFjcFtpXS5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgY3BbaV0uY2FsbGJhY2sobGFzdClcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0aHJvdyBlIH0sIDApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBNYXRoLnJvdW5kKG5leHQpKVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKHtcbiAgICAgIGhhbmRsZTogKytpZCxcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIGNhbmNlbGxlZDogZmFsc2VcbiAgICB9KVxuICAgIHJldHVybiBpZFxuICB9XG5cbiAgY2FmID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZihxdWV1ZVtpXS5oYW5kbGUgPT09IGhhbmRsZSkge1xuICAgICAgICBxdWV1ZVtpXS5jYW5jZWxsZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4pIHtcbiAgLy8gV3JhcCBpbiBhIG5ldyBmdW5jdGlvbiB0byBwcmV2ZW50XG4gIC8vIGBjYW5jZWxgIHBvdGVudGlhbGx5IGJlaW5nIGFzc2lnbmVkXG4gIC8vIHRvIHRoZSBuYXRpdmUgckFGIGZ1bmN0aW9uXG4gIHJldHVybiByYWYuY2FsbChyb290LCBmbilcbn1cbm1vZHVsZS5leHBvcnRzLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICBjYWYuYXBwbHkocm9vdCwgYXJndW1lbnRzKVxufVxubW9kdWxlLmV4cG9ydHMucG9seWZpbGwgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKCFvYmplY3QpIHtcbiAgICBvYmplY3QgPSByb290O1xuICB9XG4gIG9iamVjdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByYWZcbiAgb2JqZWN0LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gY2FmXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/raf/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rgbcolor/index.js":
/*!****************************************!*\
  !*** ./node_modules/rgbcolor/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/*\n\tBased on rgbcolor.js by Stoyan Stefanov <sstoo@gmail.com>\n\thttp://www.phpied.com/rgb-color-parser-in-javascript/\n*/\n\nmodule.exports = function(color_string) {\n    this.ok = false;\n    this.alpha = 1.0;\n\n    // strip any leading #\n    if (color_string.charAt(0) == '#') { // remove # if any\n        color_string = color_string.substr(1,6);\n    }\n\n    color_string = color_string.replace(/ /g,'');\n    color_string = color_string.toLowerCase();\n\n    // before getting into regexps, try simple matches\n    // and overwrite the input\n    var simple_colors = {\n        aliceblue: 'f0f8ff',\n        antiquewhite: 'faebd7',\n        aqua: '00ffff',\n        aquamarine: '7fffd4',\n        azure: 'f0ffff',\n        beige: 'f5f5dc',\n        bisque: 'ffe4c4',\n        black: '000000',\n        blanchedalmond: 'ffebcd',\n        blue: '0000ff',\n        blueviolet: '8a2be2',\n        brown: 'a52a2a',\n        burlywood: 'deb887',\n        cadetblue: '5f9ea0',\n        chartreuse: '7fff00',\n        chocolate: 'd2691e',\n        coral: 'ff7f50',\n        cornflowerblue: '6495ed',\n        cornsilk: 'fff8dc',\n        crimson: 'dc143c',\n        cyan: '00ffff',\n        darkblue: '00008b',\n        darkcyan: '008b8b',\n        darkgoldenrod: 'b8860b',\n        darkgray: 'a9a9a9',\n        darkgreen: '006400',\n        darkkhaki: 'bdb76b',\n        darkmagenta: '8b008b',\n        darkolivegreen: '556b2f',\n        darkorange: 'ff8c00',\n        darkorchid: '9932cc',\n        darkred: '8b0000',\n        darksalmon: 'e9967a',\n        darkseagreen: '8fbc8f',\n        darkslateblue: '483d8b',\n        darkslategray: '2f4f4f',\n        darkturquoise: '00ced1',\n        darkviolet: '9400d3',\n        deeppink: 'ff1493',\n        deepskyblue: '00bfff',\n        dimgray: '696969',\n        dodgerblue: '1e90ff',\n        feldspar: 'd19275',\n        firebrick: 'b22222',\n        floralwhite: 'fffaf0',\n        forestgreen: '228b22',\n        fuchsia: 'ff00ff',\n        gainsboro: 'dcdcdc',\n        ghostwhite: 'f8f8ff',\n        gold: 'ffd700',\n        goldenrod: 'daa520',\n        gray: '808080',\n        green: '008000',\n        greenyellow: 'adff2f',\n        honeydew: 'f0fff0',\n        hotpink: 'ff69b4',\n        indianred : 'cd5c5c',\n        indigo : '4b0082',\n        ivory: 'fffff0',\n        khaki: 'f0e68c',\n        lavender: 'e6e6fa',\n        lavenderblush: 'fff0f5',\n        lawngreen: '7cfc00',\n        lemonchiffon: 'fffacd',\n        lightblue: 'add8e6',\n        lightcoral: 'f08080',\n        lightcyan: 'e0ffff',\n        lightgoldenrodyellow: 'fafad2',\n        lightgrey: 'd3d3d3',\n        lightgreen: '90ee90',\n        lightpink: 'ffb6c1',\n        lightsalmon: 'ffa07a',\n        lightseagreen: '20b2aa',\n        lightskyblue: '87cefa',\n        lightslateblue: '8470ff',\n        lightslategray: '778899',\n        lightsteelblue: 'b0c4de',\n        lightyellow: 'ffffe0',\n        lime: '00ff00',\n        limegreen: '32cd32',\n        linen: 'faf0e6',\n        magenta: 'ff00ff',\n        maroon: '800000',\n        mediumaquamarine: '66cdaa',\n        mediumblue: '0000cd',\n        mediumorchid: 'ba55d3',\n        mediumpurple: '9370d8',\n        mediumseagreen: '3cb371',\n        mediumslateblue: '7b68ee',\n        mediumspringgreen: '00fa9a',\n        mediumturquoise: '48d1cc',\n        mediumvioletred: 'c71585',\n        midnightblue: '191970',\n        mintcream: 'f5fffa',\n        mistyrose: 'ffe4e1',\n        moccasin: 'ffe4b5',\n        navajowhite: 'ffdead',\n        navy: '000080',\n        oldlace: 'fdf5e6',\n        olive: '808000',\n        olivedrab: '6b8e23',\n        orange: 'ffa500',\n        orangered: 'ff4500',\n        orchid: 'da70d6',\n        palegoldenrod: 'eee8aa',\n        palegreen: '98fb98',\n        paleturquoise: 'afeeee',\n        palevioletred: 'd87093',\n        papayawhip: 'ffefd5',\n        peachpuff: 'ffdab9',\n        peru: 'cd853f',\n        pink: 'ffc0cb',\n        plum: 'dda0dd',\n        powderblue: 'b0e0e6',\n        purple: '800080',\n        rebeccapurple: '663399',\n        red: 'ff0000',\n        rosybrown: 'bc8f8f',\n        royalblue: '4169e1',\n        saddlebrown: '8b4513',\n        salmon: 'fa8072',\n        sandybrown: 'f4a460',\n        seagreen: '2e8b57',\n        seashell: 'fff5ee',\n        sienna: 'a0522d',\n        silver: 'c0c0c0',\n        skyblue: '87ceeb',\n        slateblue: '6a5acd',\n        slategray: '708090',\n        snow: 'fffafa',\n        springgreen: '00ff7f',\n        steelblue: '4682b4',\n        tan: 'd2b48c',\n        teal: '008080',\n        thistle: 'd8bfd8',\n        tomato: 'ff6347',\n        turquoise: '40e0d0',\n        violet: 'ee82ee',\n        violetred: 'd02090',\n        wheat: 'f5deb3',\n        white: 'ffffff',\n        whitesmoke: 'f5f5f5',\n        yellow: 'ffff00',\n        yellowgreen: '9acd32'\n    };\n    color_string = simple_colors[color_string] || color_string;\n    // emd of simple type-in colors\n\n    // array of color definition objects\n    var color_defs = [\n        {\n            re: /^rgba\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3}),\\s*((?:\\d?\\.)?\\d)\\)$/,\n            example: ['rgba(123, 234, 45, 0.8)', 'rgba(255,234,245,1.0)'],\n            process: function (bits){\n                return [\n                    parseInt(bits[1]),\n                    parseInt(bits[2]),\n                    parseInt(bits[3]),\n                    parseFloat(bits[4])\n                ];\n            }\n        },\n        {\n            re: /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/,\n            example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],\n            process: function (bits){\n                return [\n                    parseInt(bits[1]),\n                    parseInt(bits[2]),\n                    parseInt(bits[3])\n                ];\n            }\n        },\n        {\n            re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,\n            example: ['#00ff00', '336699'],\n            process: function (bits){\n                return [\n                    parseInt(bits[1], 16),\n                    parseInt(bits[2], 16),\n                    parseInt(bits[3], 16)\n                ];\n            }\n        },\n        {\n            re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n            example: ['#fb0', 'f0f'],\n            process: function (bits){\n                return [\n                    parseInt(bits[1] + bits[1], 16),\n                    parseInt(bits[2] + bits[2], 16),\n                    parseInt(bits[3] + bits[3], 16)\n                ];\n            }\n        }\n    ];\n\n    // search through the definitions to find a match\n    for (var i = 0; i < color_defs.length; i++) {\n        var re = color_defs[i].re;\n        var processor = color_defs[i].process;\n        var bits = re.exec(color_string);\n        if (bits) {\n            var channels = processor(bits);\n            this.r = channels[0];\n            this.g = channels[1];\n            this.b = channels[2];\n            if (channels.length > 3) {\n                this.alpha = channels[3];\n            }\n            this.ok = true;\n        }\n\n    }\n\n    // validate/cleanup values\n    this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);\n    this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);\n    this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);\n    this.alpha = (this.alpha < 0) ? 0 : ((this.alpha > 1.0 || isNaN(this.alpha)) ? 1.0 : this.alpha);\n\n    // some getters\n    this.toRGB = function () {\n        return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';\n    }\n    this.toRGBA = function () {\n        return 'rgba(' + this.r + ', ' + this.g + ', ' + this.b + ', ' + this.alpha + ')';\n    }\n    this.toHex = function () {\n        var r = this.r.toString(16);\n        var g = this.g.toString(16);\n        var b = this.b.toString(16);\n        if (r.length == 1) r = '0' + r;\n        if (g.length == 1) g = '0' + g;\n        if (b.length == 1) b = '0' + b;\n        return '#' + r + g + b;\n    }\n\n    // help\n    this.getHelpXML = function () {\n\n        var examples = new Array();\n        // add regexps\n        for (var i = 0; i < color_defs.length; i++) {\n            var example = color_defs[i].example;\n            for (var j = 0; j < example.length; j++) {\n                examples[examples.length] = example[j];\n            }\n        }\n        // add type-in colors\n        for (var sc in simple_colors) {\n            examples[examples.length] = sc;\n        }\n\n        var xml = document.createElement('ul');\n        xml.setAttribute('id', 'rgbcolor-examples');\n        for (var i = 0; i < examples.length; i++) {\n            try {\n                var list_item = document.createElement('li');\n                var list_color = new RGBColor(examples[i]);\n                var example_div = document.createElement('div');\n                example_div.style.cssText =\n                        'margin: 3px; '\n                        + 'border: 1px solid black; '\n                        + 'background:' + list_color.toHex() + '; '\n                        + 'color:' + list_color.toHex()\n                ;\n                example_div.appendChild(document.createTextNode('test'));\n                var list_item_value = document.createTextNode(\n                    ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()\n                );\n                list_item.appendChild(example_div);\n                list_item.appendChild(list_item_value);\n                xml.appendChild(list_item);\n\n            } catch(e){}\n        }\n        return xml;\n\n    }\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZ2Jjb2xvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSSxTQUFTLElBQUksU0FBUyxJQUFJO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDJCQUEyQixJQUFJLFNBQVMsSUFBSSxTQUFTLElBQUk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLCtCQUErQixFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLCtCQUErQixFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxvREFBb0Q7QUFDcEQsa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsiL2FwcC9ub2RlX21vZHVsZXMvcmdiY29sb3IvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcblx0QmFzZWQgb24gcmdiY29sb3IuanMgYnkgU3RveWFuIFN0ZWZhbm92IDxzc3Rvb0BnbWFpbC5jb20+XG5cdGh0dHA6Ly93d3cucGhwaWVkLmNvbS9yZ2ItY29sb3ItcGFyc2VyLWluLWphdmFzY3JpcHQvXG4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbG9yX3N0cmluZykge1xuICAgIHRoaXMub2sgPSBmYWxzZTtcbiAgICB0aGlzLmFscGhhID0gMS4wO1xuXG4gICAgLy8gc3RyaXAgYW55IGxlYWRpbmcgI1xuICAgIGlmIChjb2xvcl9zdHJpbmcuY2hhckF0KDApID09ICcjJykgeyAvLyByZW1vdmUgIyBpZiBhbnlcbiAgICAgICAgY29sb3Jfc3RyaW5nID0gY29sb3Jfc3RyaW5nLnN1YnN0cigxLDYpO1xuICAgIH1cblxuICAgIGNvbG9yX3N0cmluZyA9IGNvbG9yX3N0cmluZy5yZXBsYWNlKC8gL2csJycpO1xuICAgIGNvbG9yX3N0cmluZyA9IGNvbG9yX3N0cmluZy50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gYmVmb3JlIGdldHRpbmcgaW50byByZWdleHBzLCB0cnkgc2ltcGxlIG1hdGNoZXNcbiAgICAvLyBhbmQgb3ZlcndyaXRlIHRoZSBpbnB1dFxuICAgIHZhciBzaW1wbGVfY29sb3JzID0ge1xuICAgICAgICBhbGljZWJsdWU6ICdmMGY4ZmYnLFxuICAgICAgICBhbnRpcXVld2hpdGU6ICdmYWViZDcnLFxuICAgICAgICBhcXVhOiAnMDBmZmZmJyxcbiAgICAgICAgYXF1YW1hcmluZTogJzdmZmZkNCcsXG4gICAgICAgIGF6dXJlOiAnZjBmZmZmJyxcbiAgICAgICAgYmVpZ2U6ICdmNWY1ZGMnLFxuICAgICAgICBiaXNxdWU6ICdmZmU0YzQnLFxuICAgICAgICBibGFjazogJzAwMDAwMCcsXG4gICAgICAgIGJsYW5jaGVkYWxtb25kOiAnZmZlYmNkJyxcbiAgICAgICAgYmx1ZTogJzAwMDBmZicsXG4gICAgICAgIGJsdWV2aW9sZXQ6ICc4YTJiZTInLFxuICAgICAgICBicm93bjogJ2E1MmEyYScsXG4gICAgICAgIGJ1cmx5d29vZDogJ2RlYjg4NycsXG4gICAgICAgIGNhZGV0Ymx1ZTogJzVmOWVhMCcsXG4gICAgICAgIGNoYXJ0cmV1c2U6ICc3ZmZmMDAnLFxuICAgICAgICBjaG9jb2xhdGU6ICdkMjY5MWUnLFxuICAgICAgICBjb3JhbDogJ2ZmN2Y1MCcsXG4gICAgICAgIGNvcm5mbG93ZXJibHVlOiAnNjQ5NWVkJyxcbiAgICAgICAgY29ybnNpbGs6ICdmZmY4ZGMnLFxuICAgICAgICBjcmltc29uOiAnZGMxNDNjJyxcbiAgICAgICAgY3lhbjogJzAwZmZmZicsXG4gICAgICAgIGRhcmtibHVlOiAnMDAwMDhiJyxcbiAgICAgICAgZGFya2N5YW46ICcwMDhiOGInLFxuICAgICAgICBkYXJrZ29sZGVucm9kOiAnYjg4NjBiJyxcbiAgICAgICAgZGFya2dyYXk6ICdhOWE5YTknLFxuICAgICAgICBkYXJrZ3JlZW46ICcwMDY0MDAnLFxuICAgICAgICBkYXJra2hha2k6ICdiZGI3NmInLFxuICAgICAgICBkYXJrbWFnZW50YTogJzhiMDA4YicsXG4gICAgICAgIGRhcmtvbGl2ZWdyZWVuOiAnNTU2YjJmJyxcbiAgICAgICAgZGFya29yYW5nZTogJ2ZmOGMwMCcsXG4gICAgICAgIGRhcmtvcmNoaWQ6ICc5OTMyY2MnLFxuICAgICAgICBkYXJrcmVkOiAnOGIwMDAwJyxcbiAgICAgICAgZGFya3NhbG1vbjogJ2U5OTY3YScsXG4gICAgICAgIGRhcmtzZWFncmVlbjogJzhmYmM4ZicsXG4gICAgICAgIGRhcmtzbGF0ZWJsdWU6ICc0ODNkOGInLFxuICAgICAgICBkYXJrc2xhdGVncmF5OiAnMmY0ZjRmJyxcbiAgICAgICAgZGFya3R1cnF1b2lzZTogJzAwY2VkMScsXG4gICAgICAgIGRhcmt2aW9sZXQ6ICc5NDAwZDMnLFxuICAgICAgICBkZWVwcGluazogJ2ZmMTQ5MycsXG4gICAgICAgIGRlZXBza3libHVlOiAnMDBiZmZmJyxcbiAgICAgICAgZGltZ3JheTogJzY5Njk2OScsXG4gICAgICAgIGRvZGdlcmJsdWU6ICcxZTkwZmYnLFxuICAgICAgICBmZWxkc3BhcjogJ2QxOTI3NScsXG4gICAgICAgIGZpcmVicmljazogJ2IyMjIyMicsXG4gICAgICAgIGZsb3JhbHdoaXRlOiAnZmZmYWYwJyxcbiAgICAgICAgZm9yZXN0Z3JlZW46ICcyMjhiMjInLFxuICAgICAgICBmdWNoc2lhOiAnZmYwMGZmJyxcbiAgICAgICAgZ2FpbnNib3JvOiAnZGNkY2RjJyxcbiAgICAgICAgZ2hvc3R3aGl0ZTogJ2Y4ZjhmZicsXG4gICAgICAgIGdvbGQ6ICdmZmQ3MDAnLFxuICAgICAgICBnb2xkZW5yb2Q6ICdkYWE1MjAnLFxuICAgICAgICBncmF5OiAnODA4MDgwJyxcbiAgICAgICAgZ3JlZW46ICcwMDgwMDAnLFxuICAgICAgICBncmVlbnllbGxvdzogJ2FkZmYyZicsXG4gICAgICAgIGhvbmV5ZGV3OiAnZjBmZmYwJyxcbiAgICAgICAgaG90cGluazogJ2ZmNjliNCcsXG4gICAgICAgIGluZGlhbnJlZCA6ICdjZDVjNWMnLFxuICAgICAgICBpbmRpZ28gOiAnNGIwMDgyJyxcbiAgICAgICAgaXZvcnk6ICdmZmZmZjAnLFxuICAgICAgICBraGFraTogJ2YwZTY4YycsXG4gICAgICAgIGxhdmVuZGVyOiAnZTZlNmZhJyxcbiAgICAgICAgbGF2ZW5kZXJibHVzaDogJ2ZmZjBmNScsXG4gICAgICAgIGxhd25ncmVlbjogJzdjZmMwMCcsXG4gICAgICAgIGxlbW9uY2hpZmZvbjogJ2ZmZmFjZCcsXG4gICAgICAgIGxpZ2h0Ymx1ZTogJ2FkZDhlNicsXG4gICAgICAgIGxpZ2h0Y29yYWw6ICdmMDgwODAnLFxuICAgICAgICBsaWdodGN5YW46ICdlMGZmZmYnLFxuICAgICAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogJ2ZhZmFkMicsXG4gICAgICAgIGxpZ2h0Z3JleTogJ2QzZDNkMycsXG4gICAgICAgIGxpZ2h0Z3JlZW46ICc5MGVlOTAnLFxuICAgICAgICBsaWdodHBpbms6ICdmZmI2YzEnLFxuICAgICAgICBsaWdodHNhbG1vbjogJ2ZmYTA3YScsXG4gICAgICAgIGxpZ2h0c2VhZ3JlZW46ICcyMGIyYWEnLFxuICAgICAgICBsaWdodHNreWJsdWU6ICc4N2NlZmEnLFxuICAgICAgICBsaWdodHNsYXRlYmx1ZTogJzg0NzBmZicsXG4gICAgICAgIGxpZ2h0c2xhdGVncmF5OiAnNzc4ODk5JyxcbiAgICAgICAgbGlnaHRzdGVlbGJsdWU6ICdiMGM0ZGUnLFxuICAgICAgICBsaWdodHllbGxvdzogJ2ZmZmZlMCcsXG4gICAgICAgIGxpbWU6ICcwMGZmMDAnLFxuICAgICAgICBsaW1lZ3JlZW46ICczMmNkMzInLFxuICAgICAgICBsaW5lbjogJ2ZhZjBlNicsXG4gICAgICAgIG1hZ2VudGE6ICdmZjAwZmYnLFxuICAgICAgICBtYXJvb246ICc4MDAwMDAnLFxuICAgICAgICBtZWRpdW1hcXVhbWFyaW5lOiAnNjZjZGFhJyxcbiAgICAgICAgbWVkaXVtYmx1ZTogJzAwMDBjZCcsXG4gICAgICAgIG1lZGl1bW9yY2hpZDogJ2JhNTVkMycsXG4gICAgICAgIG1lZGl1bXB1cnBsZTogJzkzNzBkOCcsXG4gICAgICAgIG1lZGl1bXNlYWdyZWVuOiAnM2NiMzcxJyxcbiAgICAgICAgbWVkaXVtc2xhdGVibHVlOiAnN2I2OGVlJyxcbiAgICAgICAgbWVkaXVtc3ByaW5nZ3JlZW46ICcwMGZhOWEnLFxuICAgICAgICBtZWRpdW10dXJxdW9pc2U6ICc0OGQxY2MnLFxuICAgICAgICBtZWRpdW12aW9sZXRyZWQ6ICdjNzE1ODUnLFxuICAgICAgICBtaWRuaWdodGJsdWU6ICcxOTE5NzAnLFxuICAgICAgICBtaW50Y3JlYW06ICdmNWZmZmEnLFxuICAgICAgICBtaXN0eXJvc2U6ICdmZmU0ZTEnLFxuICAgICAgICBtb2NjYXNpbjogJ2ZmZTRiNScsXG4gICAgICAgIG5hdmFqb3doaXRlOiAnZmZkZWFkJyxcbiAgICAgICAgbmF2eTogJzAwMDA4MCcsXG4gICAgICAgIG9sZGxhY2U6ICdmZGY1ZTYnLFxuICAgICAgICBvbGl2ZTogJzgwODAwMCcsXG4gICAgICAgIG9saXZlZHJhYjogJzZiOGUyMycsXG4gICAgICAgIG9yYW5nZTogJ2ZmYTUwMCcsXG4gICAgICAgIG9yYW5nZXJlZDogJ2ZmNDUwMCcsXG4gICAgICAgIG9yY2hpZDogJ2RhNzBkNicsXG4gICAgICAgIHBhbGVnb2xkZW5yb2Q6ICdlZWU4YWEnLFxuICAgICAgICBwYWxlZ3JlZW46ICc5OGZiOTgnLFxuICAgICAgICBwYWxldHVycXVvaXNlOiAnYWZlZWVlJyxcbiAgICAgICAgcGFsZXZpb2xldHJlZDogJ2Q4NzA5MycsXG4gICAgICAgIHBhcGF5YXdoaXA6ICdmZmVmZDUnLFxuICAgICAgICBwZWFjaHB1ZmY6ICdmZmRhYjknLFxuICAgICAgICBwZXJ1OiAnY2Q4NTNmJyxcbiAgICAgICAgcGluazogJ2ZmYzBjYicsXG4gICAgICAgIHBsdW06ICdkZGEwZGQnLFxuICAgICAgICBwb3dkZXJibHVlOiAnYjBlMGU2JyxcbiAgICAgICAgcHVycGxlOiAnODAwMDgwJyxcbiAgICAgICAgcmViZWNjYXB1cnBsZTogJzY2MzM5OScsXG4gICAgICAgIHJlZDogJ2ZmMDAwMCcsXG4gICAgICAgIHJvc3licm93bjogJ2JjOGY4ZicsXG4gICAgICAgIHJveWFsYmx1ZTogJzQxNjllMScsXG4gICAgICAgIHNhZGRsZWJyb3duOiAnOGI0NTEzJyxcbiAgICAgICAgc2FsbW9uOiAnZmE4MDcyJyxcbiAgICAgICAgc2FuZHlicm93bjogJ2Y0YTQ2MCcsXG4gICAgICAgIHNlYWdyZWVuOiAnMmU4YjU3JyxcbiAgICAgICAgc2Vhc2hlbGw6ICdmZmY1ZWUnLFxuICAgICAgICBzaWVubmE6ICdhMDUyMmQnLFxuICAgICAgICBzaWx2ZXI6ICdjMGMwYzAnLFxuICAgICAgICBza3libHVlOiAnODdjZWViJyxcbiAgICAgICAgc2xhdGVibHVlOiAnNmE1YWNkJyxcbiAgICAgICAgc2xhdGVncmF5OiAnNzA4MDkwJyxcbiAgICAgICAgc25vdzogJ2ZmZmFmYScsXG4gICAgICAgIHNwcmluZ2dyZWVuOiAnMDBmZjdmJyxcbiAgICAgICAgc3RlZWxibHVlOiAnNDY4MmI0JyxcbiAgICAgICAgdGFuOiAnZDJiNDhjJyxcbiAgICAgICAgdGVhbDogJzAwODA4MCcsXG4gICAgICAgIHRoaXN0bGU6ICdkOGJmZDgnLFxuICAgICAgICB0b21hdG86ICdmZjYzNDcnLFxuICAgICAgICB0dXJxdW9pc2U6ICc0MGUwZDAnLFxuICAgICAgICB2aW9sZXQ6ICdlZTgyZWUnLFxuICAgICAgICB2aW9sZXRyZWQ6ICdkMDIwOTAnLFxuICAgICAgICB3aGVhdDogJ2Y1ZGViMycsXG4gICAgICAgIHdoaXRlOiAnZmZmZmZmJyxcbiAgICAgICAgd2hpdGVzbW9rZTogJ2Y1ZjVmNScsXG4gICAgICAgIHllbGxvdzogJ2ZmZmYwMCcsXG4gICAgICAgIHllbGxvd2dyZWVuOiAnOWFjZDMyJ1xuICAgIH07XG4gICAgY29sb3Jfc3RyaW5nID0gc2ltcGxlX2NvbG9yc1tjb2xvcl9zdHJpbmddIHx8IGNvbG9yX3N0cmluZztcbiAgICAvLyBlbWQgb2Ygc2ltcGxlIHR5cGUtaW4gY29sb3JzXG5cbiAgICAvLyBhcnJheSBvZiBjb2xvciBkZWZpbml0aW9uIG9iamVjdHNcbiAgICB2YXIgY29sb3JfZGVmcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcmU6IC9ecmdiYVxcKChcXGR7MSwzfSksXFxzKihcXGR7MSwzfSksXFxzKihcXGR7MSwzfSksXFxzKigoPzpcXGQ/XFwuKT9cXGQpXFwpJC8sXG4gICAgICAgICAgICBleGFtcGxlOiBbJ3JnYmEoMTIzLCAyMzQsIDQ1LCAwLjgpJywgJ3JnYmEoMjU1LDIzNCwyNDUsMS4wKSddLFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKGJpdHMpe1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMV0pLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1szXSksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoYml0c1s0XSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByZTogL15yZ2JcXCgoXFxkezEsM30pLFxccyooXFxkezEsM30pLFxccyooXFxkezEsM30pXFwpJC8sXG4gICAgICAgICAgICBleGFtcGxlOiBbJ3JnYigxMjMsIDIzNCwgNDUpJywgJ3JnYigyNTUsMjM0LDI0NSknXSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChiaXRzKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1syXSksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbM10pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcmU6IC9eKFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pJC8sXG4gICAgICAgICAgICBleGFtcGxlOiBbJyMwMGZmMDAnLCAnMzM2Njk5J10sXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoYml0cyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1sxXSwgMTYpLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzJdLCAxNiksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbM10sIDE2KVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlOiAvXihbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvLFxuICAgICAgICAgICAgZXhhbXBsZTogWycjZmIwJywgJ2YwZiddLFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKGJpdHMpe1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMV0gKyBiaXRzWzFdLCAxNiksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMl0gKyBiaXRzWzJdLCAxNiksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbM10gKyBiaXRzWzNdLCAxNilcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXTtcblxuICAgIC8vIHNlYXJjaCB0aHJvdWdoIHRoZSBkZWZpbml0aW9ucyB0byBmaW5kIGEgbWF0Y2hcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yX2RlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlID0gY29sb3JfZGVmc1tpXS5yZTtcbiAgICAgICAgdmFyIHByb2Nlc3NvciA9IGNvbG9yX2RlZnNbaV0ucHJvY2VzcztcbiAgICAgICAgdmFyIGJpdHMgPSByZS5leGVjKGNvbG9yX3N0cmluZyk7XG4gICAgICAgIGlmIChiaXRzKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbHMgPSBwcm9jZXNzb3IoYml0cyk7XG4gICAgICAgICAgICB0aGlzLnIgPSBjaGFubmVsc1swXTtcbiAgICAgICAgICAgIHRoaXMuZyA9IGNoYW5uZWxzWzFdO1xuICAgICAgICAgICAgdGhpcy5iID0gY2hhbm5lbHNbMl07XG4gICAgICAgICAgICBpZiAoY2hhbm5lbHMubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxwaGEgPSBjaGFubmVsc1szXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub2sgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZS9jbGVhbnVwIHZhbHVlc1xuICAgIHRoaXMuciA9ICh0aGlzLnIgPCAwIHx8IGlzTmFOKHRoaXMucikpID8gMCA6ICgodGhpcy5yID4gMjU1KSA/IDI1NSA6IHRoaXMucik7XG4gICAgdGhpcy5nID0gKHRoaXMuZyA8IDAgfHwgaXNOYU4odGhpcy5nKSkgPyAwIDogKCh0aGlzLmcgPiAyNTUpID8gMjU1IDogdGhpcy5nKTtcbiAgICB0aGlzLmIgPSAodGhpcy5iIDwgMCB8fCBpc05hTih0aGlzLmIpKSA/IDAgOiAoKHRoaXMuYiA+IDI1NSkgPyAyNTUgOiB0aGlzLmIpO1xuICAgIHRoaXMuYWxwaGEgPSAodGhpcy5hbHBoYSA8IDApID8gMCA6ICgodGhpcy5hbHBoYSA+IDEuMCB8fCBpc05hTih0aGlzLmFscGhhKSkgPyAxLjAgOiB0aGlzLmFscGhhKTtcblxuICAgIC8vIHNvbWUgZ2V0dGVyc1xuICAgIHRoaXMudG9SR0IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAncmdiKCcgKyB0aGlzLnIgKyAnLCAnICsgdGhpcy5nICsgJywgJyArIHRoaXMuYiArICcpJztcbiAgICB9XG4gICAgdGhpcy50b1JHQkEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAncmdiYSgnICsgdGhpcy5yICsgJywgJyArIHRoaXMuZyArICcsICcgKyB0aGlzLmIgKyAnLCAnICsgdGhpcy5hbHBoYSArICcpJztcbiAgICB9XG4gICAgdGhpcy50b0hleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLnIudG9TdHJpbmcoMTYpO1xuICAgICAgICB2YXIgZyA9IHRoaXMuZy50b1N0cmluZygxNik7XG4gICAgICAgIHZhciBiID0gdGhpcy5iLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKHIubGVuZ3RoID09IDEpIHIgPSAnMCcgKyByO1xuICAgICAgICBpZiAoZy5sZW5ndGggPT0gMSkgZyA9ICcwJyArIGc7XG4gICAgICAgIGlmIChiLmxlbmd0aCA9PSAxKSBiID0gJzAnICsgYjtcbiAgICAgICAgcmV0dXJuICcjJyArIHIgKyBnICsgYjtcbiAgICB9XG5cbiAgICAvLyBoZWxwXG4gICAgdGhpcy5nZXRIZWxwWE1MID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBleGFtcGxlcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAvLyBhZGQgcmVnZXhwc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yX2RlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBleGFtcGxlID0gY29sb3JfZGVmc1tpXS5leGFtcGxlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBleGFtcGxlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgZXhhbXBsZXNbZXhhbXBsZXMubGVuZ3RoXSA9IGV4YW1wbGVbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHR5cGUtaW4gY29sb3JzXG4gICAgICAgIGZvciAodmFyIHNjIGluIHNpbXBsZV9jb2xvcnMpIHtcbiAgICAgICAgICAgIGV4YW1wbGVzW2V4YW1wbGVzLmxlbmd0aF0gPSBzYztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgICAgICB4bWwuc2V0QXR0cmlidXRlKCdpZCcsICdyZ2Jjb2xvci1leGFtcGxlcycpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4YW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0X2l0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgICAgIHZhciBsaXN0X2NvbG9yID0gbmV3IFJHQkNvbG9yKGV4YW1wbGVzW2ldKTtcbiAgICAgICAgICAgICAgICB2YXIgZXhhbXBsZV9kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBleGFtcGxlX2Rpdi5zdHlsZS5jc3NUZXh0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJnaW46IDNweDsgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAnYm9yZGVyOiAxcHggc29saWQgYmxhY2s7ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2JhY2tncm91bmQ6JyArIGxpc3RfY29sb3IudG9IZXgoKSArICc7ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2NvbG9yOicgKyBsaXN0X2NvbG9yLnRvSGV4KClcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgZXhhbXBsZV9kaXYuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ3Rlc3QnKSk7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RfaXRlbV92YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxuICAgICAgICAgICAgICAgICAgICAnICcgKyBleGFtcGxlc1tpXSArICcgLT4gJyArIGxpc3RfY29sb3IudG9SR0IoKSArICcgLT4gJyArIGxpc3RfY29sb3IudG9IZXgoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbGlzdF9pdGVtLmFwcGVuZENoaWxkKGV4YW1wbGVfZGl2KTtcbiAgICAgICAgICAgICAgICBsaXN0X2l0ZW0uYXBwZW5kQ2hpbGQobGlzdF9pdGVtX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICB4bWwuYXBwZW5kQ2hpbGQobGlzdF9pdGVtKTtcblxuICAgICAgICAgICAgfSBjYXRjaChlKXt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHhtbDtcblxuICAgIH1cblxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rgbcolor/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/stackblur-canvas/dist/stackblur-es.js":
/*!************************************************************!*\
  !*** ./node_modules/stackblur-canvas/dist/stackblur-es.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlurStack: () => (/* binding */ BlurStack),\n/* harmony export */   canvasRGB: () => (/* binding */ processCanvasRGB),\n/* harmony export */   canvasRGBA: () => (/* binding */ processCanvasRGBA),\n/* harmony export */   image: () => (/* binding */ processImage),\n/* harmony export */   imageDataRGB: () => (/* binding */ processImageDataRGB),\n/* harmony export */   imageDataRGBA: () => (/* binding */ processImageDataRGBA)\n/* harmony export */ });\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/* eslint-disable no-bitwise -- used for calculations */\n\n/* eslint-disable unicorn/prefer-query-selector -- aiming at\n  backward-compatibility */\n\n/**\n* StackBlur - a fast almost Gaussian Blur For Canvas\n*\n* In case you find this class useful - especially in commercial projects -\n* I am not totally unhappy for a small donation to my PayPal account\n* mario@quasimondo.de\n*\n* Or support me on flattr:\n* {@link https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript}.\n*\n* @module StackBlur\n* @author Mario Klingemann\n* Contact: mario@quasimondo.com\n* Website: {@link http://www.quasimondo.com/StackBlurForCanvas/StackBlurDemo.html}\n* Twitter: @quasimondo\n*\n* @copyright (c) 2010 Mario Klingemann\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\nvar mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];\nvar shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];\n/**\n * @param {string|HTMLImageElement} img\n * @param {string|HTMLCanvasElement} canvas\n * @param {Float} radius\n * @param {boolean} blurAlphaChannel\n * @param {boolean} useOffset\n * @param {boolean} skipStyles\n * @returns {undefined}\n */\n\nfunction processImage(img, canvas, radius, blurAlphaChannel, useOffset, skipStyles) {\n  if (typeof img === 'string') {\n    img = document.getElementById(img);\n  }\n\n  if (!img || Object.prototype.toString.call(img).slice(8, -1) === 'HTMLImageElement' && !('naturalWidth' in img)) {\n    return;\n  }\n\n  var dimensionType = useOffset ? 'offset' : 'natural';\n  var w = img[dimensionType + 'Width'];\n  var h = img[dimensionType + 'Height']; // add ImageBitmap support,can blur texture source\n\n  if (Object.prototype.toString.call(img).slice(8, -1) === 'ImageBitmap') {\n    w = img.width;\n    h = img.height;\n  }\n\n  if (typeof canvas === 'string') {\n    canvas = document.getElementById(canvas);\n  }\n\n  if (!canvas || !('getContext' in canvas)) {\n    return;\n  }\n\n  if (!skipStyles) {\n    canvas.style.width = w + 'px';\n    canvas.style.height = h + 'px';\n  }\n\n  canvas.width = w;\n  canvas.height = h;\n  var context = canvas.getContext('2d');\n  context.clearRect(0, 0, w, h);\n  context.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, 0, 0, w, h);\n\n  if (isNaN(radius) || radius < 1) {\n    return;\n  }\n\n  if (blurAlphaChannel) {\n    processCanvasRGBA(canvas, 0, 0, w, h, radius);\n  } else {\n    processCanvasRGB(canvas, 0, 0, w, h, radius);\n  }\n}\n/**\n * @param {string|HTMLCanvasElement} canvas\n * @param {Integer} topX\n * @param {Integer} topY\n * @param {Integer} width\n * @param {Integer} height\n * @throws {Error|TypeError}\n * @returns {ImageData} See {@link https://html.spec.whatwg.org/multipage/canvas.html#imagedata}\n */\n\n\nfunction getImageDataFromCanvas(canvas, topX, topY, width, height) {\n  if (typeof canvas === 'string') {\n    canvas = document.getElementById(canvas);\n  }\n\n  if (!canvas || _typeof(canvas) !== 'object' || !('getContext' in canvas)) {\n    throw new TypeError('Expecting canvas with `getContext` method ' + 'in processCanvasRGB(A) calls!');\n  }\n\n  var context = canvas.getContext('2d');\n\n  try {\n    return context.getImageData(topX, topY, width, height);\n  } catch (e) {\n    throw new Error('unable to access image data: ' + e);\n  }\n}\n/**\n * @param {HTMLCanvasElement} canvas\n * @param {Integer} topX\n * @param {Integer} topY\n * @param {Integer} width\n * @param {Integer} height\n * @param {Float} radius\n * @returns {undefined}\n */\n\n\nfunction processCanvasRGBA(canvas, topX, topY, width, height, radius) {\n  if (isNaN(radius) || radius < 1) {\n    return;\n  }\n\n  radius |= 0;\n  var imageData = getImageDataFromCanvas(canvas, topX, topY, width, height);\n  imageData = processImageDataRGBA(imageData, topX, topY, width, height, radius);\n  canvas.getContext('2d').putImageData(imageData, topX, topY);\n}\n/**\n * @param {ImageData} imageData\n * @param {Integer} topX\n * @param {Integer} topY\n * @param {Integer} width\n * @param {Integer} height\n * @param {Float} radius\n * @returns {ImageData}\n */\n\n\nfunction processImageDataRGBA(imageData, topX, topY, width, height, radius) {\n  var pixels = imageData.data;\n  var div = 2 * radius + 1; // const w4 = width << 2;\n\n  var widthMinus1 = width - 1;\n  var heightMinus1 = height - 1;\n  var radiusPlus1 = radius + 1;\n  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;\n  var stackStart = new BlurStack();\n  var stack = stackStart;\n  var stackEnd;\n\n  for (var i = 1; i < div; i++) {\n    stack = stack.next = new BlurStack();\n\n    if (i === radiusPlus1) {\n      stackEnd = stack;\n    }\n  }\n\n  stack.next = stackStart;\n  var stackIn = null,\n      stackOut = null,\n      yw = 0,\n      yi = 0;\n  var mulSum = mulTable[radius];\n  var shgSum = shgTable[radius];\n\n  for (var y = 0; y < height; y++) {\n    stack = stackStart;\n    var pr = pixels[yi],\n        pg = pixels[yi + 1],\n        pb = pixels[yi + 2],\n        pa = pixels[yi + 3];\n\n    for (var _i = 0; _i < radiusPlus1; _i++) {\n      stack.r = pr;\n      stack.g = pg;\n      stack.b = pb;\n      stack.a = pa;\n      stack = stack.next;\n    }\n\n    var rInSum = 0,\n        gInSum = 0,\n        bInSum = 0,\n        aInSum = 0,\n        rOutSum = radiusPlus1 * pr,\n        gOutSum = radiusPlus1 * pg,\n        bOutSum = radiusPlus1 * pb,\n        aOutSum = radiusPlus1 * pa,\n        rSum = sumFactor * pr,\n        gSum = sumFactor * pg,\n        bSum = sumFactor * pb,\n        aSum = sumFactor * pa;\n\n    for (var _i2 = 1; _i2 < radiusPlus1; _i2++) {\n      var p = yi + ((widthMinus1 < _i2 ? widthMinus1 : _i2) << 2);\n      var r = pixels[p],\n          g = pixels[p + 1],\n          b = pixels[p + 2],\n          a = pixels[p + 3];\n      var rbs = radiusPlus1 - _i2;\n      rSum += (stack.r = r) * rbs;\n      gSum += (stack.g = g) * rbs;\n      bSum += (stack.b = b) * rbs;\n      aSum += (stack.a = a) * rbs;\n      rInSum += r;\n      gInSum += g;\n      bInSum += b;\n      aInSum += a;\n      stack = stack.next;\n    }\n\n    stackIn = stackStart;\n    stackOut = stackEnd;\n\n    for (var x = 0; x < width; x++) {\n      var paInitial = aSum * mulSum >>> shgSum;\n      pixels[yi + 3] = paInitial;\n\n      if (paInitial !== 0) {\n        var _a2 = 255 / paInitial;\n\n        pixels[yi] = (rSum * mulSum >>> shgSum) * _a2;\n        pixels[yi + 1] = (gSum * mulSum >>> shgSum) * _a2;\n        pixels[yi + 2] = (bSum * mulSum >>> shgSum) * _a2;\n      } else {\n        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;\n      }\n\n      rSum -= rOutSum;\n      gSum -= gOutSum;\n      bSum -= bOutSum;\n      aSum -= aOutSum;\n      rOutSum -= stackIn.r;\n      gOutSum -= stackIn.g;\n      bOutSum -= stackIn.b;\n      aOutSum -= stackIn.a;\n\n      var _p = x + radius + 1;\n\n      _p = yw + (_p < widthMinus1 ? _p : widthMinus1) << 2;\n      rInSum += stackIn.r = pixels[_p];\n      gInSum += stackIn.g = pixels[_p + 1];\n      bInSum += stackIn.b = pixels[_p + 2];\n      aInSum += stackIn.a = pixels[_p + 3];\n      rSum += rInSum;\n      gSum += gInSum;\n      bSum += bInSum;\n      aSum += aInSum;\n      stackIn = stackIn.next;\n      var _stackOut = stackOut,\n          _r = _stackOut.r,\n          _g = _stackOut.g,\n          _b = _stackOut.b,\n          _a = _stackOut.a;\n      rOutSum += _r;\n      gOutSum += _g;\n      bOutSum += _b;\n      aOutSum += _a;\n      rInSum -= _r;\n      gInSum -= _g;\n      bInSum -= _b;\n      aInSum -= _a;\n      stackOut = stackOut.next;\n      yi += 4;\n    }\n\n    yw += width;\n  }\n\n  for (var _x = 0; _x < width; _x++) {\n    yi = _x << 2;\n\n    var _pr = pixels[yi],\n        _pg = pixels[yi + 1],\n        _pb = pixels[yi + 2],\n        _pa = pixels[yi + 3],\n        _rOutSum = radiusPlus1 * _pr,\n        _gOutSum = radiusPlus1 * _pg,\n        _bOutSum = radiusPlus1 * _pb,\n        _aOutSum = radiusPlus1 * _pa,\n        _rSum = sumFactor * _pr,\n        _gSum = sumFactor * _pg,\n        _bSum = sumFactor * _pb,\n        _aSum = sumFactor * _pa;\n\n    stack = stackStart;\n\n    for (var _i3 = 0; _i3 < radiusPlus1; _i3++) {\n      stack.r = _pr;\n      stack.g = _pg;\n      stack.b = _pb;\n      stack.a = _pa;\n      stack = stack.next;\n    }\n\n    var yp = width;\n    var _gInSum = 0,\n        _bInSum = 0,\n        _aInSum = 0,\n        _rInSum = 0;\n\n    for (var _i4 = 1; _i4 <= radius; _i4++) {\n      yi = yp + _x << 2;\n\n      var _rbs = radiusPlus1 - _i4;\n\n      _rSum += (stack.r = _pr = pixels[yi]) * _rbs;\n      _gSum += (stack.g = _pg = pixels[yi + 1]) * _rbs;\n      _bSum += (stack.b = _pb = pixels[yi + 2]) * _rbs;\n      _aSum += (stack.a = _pa = pixels[yi + 3]) * _rbs;\n      _rInSum += _pr;\n      _gInSum += _pg;\n      _bInSum += _pb;\n      _aInSum += _pa;\n      stack = stack.next;\n\n      if (_i4 < heightMinus1) {\n        yp += width;\n      }\n    }\n\n    yi = _x;\n    stackIn = stackStart;\n    stackOut = stackEnd;\n\n    for (var _y = 0; _y < height; _y++) {\n      var _p2 = yi << 2;\n\n      pixels[_p2 + 3] = _pa = _aSum * mulSum >>> shgSum;\n\n      if (_pa > 0) {\n        _pa = 255 / _pa;\n        pixels[_p2] = (_rSum * mulSum >>> shgSum) * _pa;\n        pixels[_p2 + 1] = (_gSum * mulSum >>> shgSum) * _pa;\n        pixels[_p2 + 2] = (_bSum * mulSum >>> shgSum) * _pa;\n      } else {\n        pixels[_p2] = pixels[_p2 + 1] = pixels[_p2 + 2] = 0;\n      }\n\n      _rSum -= _rOutSum;\n      _gSum -= _gOutSum;\n      _bSum -= _bOutSum;\n      _aSum -= _aOutSum;\n      _rOutSum -= stackIn.r;\n      _gOutSum -= stackIn.g;\n      _bOutSum -= stackIn.b;\n      _aOutSum -= stackIn.a;\n      _p2 = _x + ((_p2 = _y + radiusPlus1) < heightMinus1 ? _p2 : heightMinus1) * width << 2;\n      _rSum += _rInSum += stackIn.r = pixels[_p2];\n      _gSum += _gInSum += stackIn.g = pixels[_p2 + 1];\n      _bSum += _bInSum += stackIn.b = pixels[_p2 + 2];\n      _aSum += _aInSum += stackIn.a = pixels[_p2 + 3];\n      stackIn = stackIn.next;\n      _rOutSum += _pr = stackOut.r;\n      _gOutSum += _pg = stackOut.g;\n      _bOutSum += _pb = stackOut.b;\n      _aOutSum += _pa = stackOut.a;\n      _rInSum -= _pr;\n      _gInSum -= _pg;\n      _bInSum -= _pb;\n      _aInSum -= _pa;\n      stackOut = stackOut.next;\n      yi += width;\n    }\n  }\n\n  return imageData;\n}\n/**\n * @param {HTMLCanvasElement} canvas\n * @param {Integer} topX\n * @param {Integer} topY\n * @param {Integer} width\n * @param {Integer} height\n * @param {Float} radius\n * @returns {undefined}\n */\n\n\nfunction processCanvasRGB(canvas, topX, topY, width, height, radius) {\n  if (isNaN(radius) || radius < 1) {\n    return;\n  }\n\n  radius |= 0;\n  var imageData = getImageDataFromCanvas(canvas, topX, topY, width, height);\n  imageData = processImageDataRGB(imageData, topX, topY, width, height, radius);\n  canvas.getContext('2d').putImageData(imageData, topX, topY);\n}\n/**\n * @param {ImageData} imageData\n * @param {Integer} topX\n * @param {Integer} topY\n * @param {Integer} width\n * @param {Integer} height\n * @param {Float} radius\n * @returns {ImageData}\n */\n\n\nfunction processImageDataRGB(imageData, topX, topY, width, height, radius) {\n  var pixels = imageData.data;\n  var div = 2 * radius + 1; // const w4 = width << 2;\n\n  var widthMinus1 = width - 1;\n  var heightMinus1 = height - 1;\n  var radiusPlus1 = radius + 1;\n  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;\n  var stackStart = new BlurStack();\n  var stack = stackStart;\n  var stackEnd;\n\n  for (var i = 1; i < div; i++) {\n    stack = stack.next = new BlurStack();\n\n    if (i === radiusPlus1) {\n      stackEnd = stack;\n    }\n  }\n\n  stack.next = stackStart;\n  var stackIn = null;\n  var stackOut = null;\n  var mulSum = mulTable[radius];\n  var shgSum = shgTable[radius];\n  var p, rbs;\n  var yw = 0,\n      yi = 0;\n\n  for (var y = 0; y < height; y++) {\n    var pr = pixels[yi],\n        pg = pixels[yi + 1],\n        pb = pixels[yi + 2],\n        rOutSum = radiusPlus1 * pr,\n        gOutSum = radiusPlus1 * pg,\n        bOutSum = radiusPlus1 * pb,\n        rSum = sumFactor * pr,\n        gSum = sumFactor * pg,\n        bSum = sumFactor * pb;\n    stack = stackStart;\n\n    for (var _i5 = 0; _i5 < radiusPlus1; _i5++) {\n      stack.r = pr;\n      stack.g = pg;\n      stack.b = pb;\n      stack = stack.next;\n    }\n\n    var rInSum = 0,\n        gInSum = 0,\n        bInSum = 0;\n\n    for (var _i6 = 1; _i6 < radiusPlus1; _i6++) {\n      p = yi + ((widthMinus1 < _i6 ? widthMinus1 : _i6) << 2);\n      rSum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - _i6);\n      gSum += (stack.g = pg = pixels[p + 1]) * rbs;\n      bSum += (stack.b = pb = pixels[p + 2]) * rbs;\n      rInSum += pr;\n      gInSum += pg;\n      bInSum += pb;\n      stack = stack.next;\n    }\n\n    stackIn = stackStart;\n    stackOut = stackEnd;\n\n    for (var x = 0; x < width; x++) {\n      pixels[yi] = rSum * mulSum >>> shgSum;\n      pixels[yi + 1] = gSum * mulSum >>> shgSum;\n      pixels[yi + 2] = bSum * mulSum >>> shgSum;\n      rSum -= rOutSum;\n      gSum -= gOutSum;\n      bSum -= bOutSum;\n      rOutSum -= stackIn.r;\n      gOutSum -= stackIn.g;\n      bOutSum -= stackIn.b;\n      p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2;\n      rInSum += stackIn.r = pixels[p];\n      gInSum += stackIn.g = pixels[p + 1];\n      bInSum += stackIn.b = pixels[p + 2];\n      rSum += rInSum;\n      gSum += gInSum;\n      bSum += bInSum;\n      stackIn = stackIn.next;\n      rOutSum += pr = stackOut.r;\n      gOutSum += pg = stackOut.g;\n      bOutSum += pb = stackOut.b;\n      rInSum -= pr;\n      gInSum -= pg;\n      bInSum -= pb;\n      stackOut = stackOut.next;\n      yi += 4;\n    }\n\n    yw += width;\n  }\n\n  for (var _x2 = 0; _x2 < width; _x2++) {\n    yi = _x2 << 2;\n\n    var _pr2 = pixels[yi],\n        _pg2 = pixels[yi + 1],\n        _pb2 = pixels[yi + 2],\n        _rOutSum2 = radiusPlus1 * _pr2,\n        _gOutSum2 = radiusPlus1 * _pg2,\n        _bOutSum2 = radiusPlus1 * _pb2,\n        _rSum2 = sumFactor * _pr2,\n        _gSum2 = sumFactor * _pg2,\n        _bSum2 = sumFactor * _pb2;\n\n    stack = stackStart;\n\n    for (var _i7 = 0; _i7 < radiusPlus1; _i7++) {\n      stack.r = _pr2;\n      stack.g = _pg2;\n      stack.b = _pb2;\n      stack = stack.next;\n    }\n\n    var _rInSum2 = 0,\n        _gInSum2 = 0,\n        _bInSum2 = 0;\n\n    for (var _i8 = 1, yp = width; _i8 <= radius; _i8++) {\n      yi = yp + _x2 << 2;\n      _rSum2 += (stack.r = _pr2 = pixels[yi]) * (rbs = radiusPlus1 - _i8);\n      _gSum2 += (stack.g = _pg2 = pixels[yi + 1]) * rbs;\n      _bSum2 += (stack.b = _pb2 = pixels[yi + 2]) * rbs;\n      _rInSum2 += _pr2;\n      _gInSum2 += _pg2;\n      _bInSum2 += _pb2;\n      stack = stack.next;\n\n      if (_i8 < heightMinus1) {\n        yp += width;\n      }\n    }\n\n    yi = _x2;\n    stackIn = stackStart;\n    stackOut = stackEnd;\n\n    for (var _y2 = 0; _y2 < height; _y2++) {\n      p = yi << 2;\n      pixels[p] = _rSum2 * mulSum >>> shgSum;\n      pixels[p + 1] = _gSum2 * mulSum >>> shgSum;\n      pixels[p + 2] = _bSum2 * mulSum >>> shgSum;\n      _rSum2 -= _rOutSum2;\n      _gSum2 -= _gOutSum2;\n      _bSum2 -= _bOutSum2;\n      _rOutSum2 -= stackIn.r;\n      _gOutSum2 -= stackIn.g;\n      _bOutSum2 -= stackIn.b;\n      p = _x2 + ((p = _y2 + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2;\n      _rSum2 += _rInSum2 += stackIn.r = pixels[p];\n      _gSum2 += _gInSum2 += stackIn.g = pixels[p + 1];\n      _bSum2 += _bInSum2 += stackIn.b = pixels[p + 2];\n      stackIn = stackIn.next;\n      _rOutSum2 += _pr2 = stackOut.r;\n      _gOutSum2 += _pg2 = stackOut.g;\n      _bOutSum2 += _pb2 = stackOut.b;\n      _rInSum2 -= _pr2;\n      _gInSum2 -= _pg2;\n      _bInSum2 -= _pb2;\n      stackOut = stackOut.next;\n      yi += width;\n    }\n  }\n\n  return imageData;\n}\n/**\n *\n */\n\n\nvar BlurStack =\n/**\n * Set properties.\n */\nfunction BlurStack() {\n  _classCallCheck(this, BlurStack);\n\n  this.r = 0;\n  this.g = 0;\n  this.b = 0;\n  this.a = 0;\n  this.next = null;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFja2JsdXItY2FudmFzL2Rpc3Qvc3RhY2tibHVyLWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsdUdBQXVHO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEMsV0FBVywwQkFBMEI7QUFDckMsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQkFBMEI7QUFDckMsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWixhQUFhLFdBQVcsS0FBSztBQUM3Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixZQUFZO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixlQUFlO0FBQ3JDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGFBQWE7QUFDbEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixhQUFhO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxlQUFlO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXdMIiwic291cmNlcyI6WyIvYXBwL25vZGVfbW9kdWxlcy9zdGFja2JsdXItY2FudmFzL2Rpc3Qvc3RhY2tibHVyLWVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgLS0gdXNlZCBmb3IgY2FsY3VsYXRpb25zICovXG5cbi8qIGVzbGludC1kaXNhYmxlIHVuaWNvcm4vcHJlZmVyLXF1ZXJ5LXNlbGVjdG9yIC0tIGFpbWluZyBhdFxuICBiYWNrd2FyZC1jb21wYXRpYmlsaXR5ICovXG5cbi8qKlxuKiBTdGFja0JsdXIgLSBhIGZhc3QgYWxtb3N0IEdhdXNzaWFuIEJsdXIgRm9yIENhbnZhc1xuKlxuKiBJbiBjYXNlIHlvdSBmaW5kIHRoaXMgY2xhc3MgdXNlZnVsIC0gZXNwZWNpYWxseSBpbiBjb21tZXJjaWFsIHByb2plY3RzIC1cbiogSSBhbSBub3QgdG90YWxseSB1bmhhcHB5IGZvciBhIHNtYWxsIGRvbmF0aW9uIHRvIG15IFBheVBhbCBhY2NvdW50XG4qIG1hcmlvQHF1YXNpbW9uZG8uZGVcbipcbiogT3Igc3VwcG9ydCBtZSBvbiBmbGF0dHI6XG4qIHtAbGluayBodHRwczovL2ZsYXR0ci5jb20vdGhpbmcvNzI3OTEvU3RhY2tCbHVyLWEtZmFzdC1hbG1vc3QtR2F1c3NpYW4tQmx1ci1FZmZlY3QtZm9yLUNhbnZhc0phdmFzY3JpcHR9LlxuKlxuKiBAbW9kdWxlIFN0YWNrQmx1clxuKiBAYXV0aG9yIE1hcmlvIEtsaW5nZW1hbm5cbiogQ29udGFjdDogbWFyaW9AcXVhc2ltb25kby5jb21cbiogV2Vic2l0ZToge0BsaW5rIGh0dHA6Ly93d3cucXVhc2ltb25kby5jb20vU3RhY2tCbHVyRm9yQ2FudmFzL1N0YWNrQmx1ckRlbW8uaHRtbH1cbiogVHdpdHRlcjogQHF1YXNpbW9uZG9cbipcbiogQGNvcHlyaWdodCAoYykgMjAxMCBNYXJpbyBLbGluZ2VtYW5uXG4qXG4qIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4qIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4qIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4qIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4qIGNvbmRpdGlvbnM6XG4qXG4qIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4qIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuKlxuKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4qIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4qIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG52YXIgbXVsVGFibGUgPSBbNTEyLCA1MTIsIDQ1NiwgNTEyLCAzMjgsIDQ1NiwgMzM1LCA1MTIsIDQwNSwgMzI4LCAyNzEsIDQ1NiwgMzg4LCAzMzUsIDI5MiwgNTEyLCA0NTQsIDQwNSwgMzY0LCAzMjgsIDI5OCwgMjcxLCA0OTYsIDQ1NiwgNDIwLCAzODgsIDM2MCwgMzM1LCAzMTIsIDI5MiwgMjczLCA1MTIsIDQ4MiwgNDU0LCA0MjgsIDQwNSwgMzgzLCAzNjQsIDM0NSwgMzI4LCAzMTIsIDI5OCwgMjg0LCAyNzEsIDI1OSwgNDk2LCA0NzUsIDQ1NiwgNDM3LCA0MjAsIDQwNCwgMzg4LCAzNzQsIDM2MCwgMzQ3LCAzMzUsIDMyMywgMzEyLCAzMDIsIDI5MiwgMjgyLCAyNzMsIDI2NSwgNTEyLCA0OTcsIDQ4MiwgNDY4LCA0NTQsIDQ0MSwgNDI4LCA0MTcsIDQwNSwgMzk0LCAzODMsIDM3MywgMzY0LCAzNTQsIDM0NSwgMzM3LCAzMjgsIDMyMCwgMzEyLCAzMDUsIDI5OCwgMjkxLCAyODQsIDI3OCwgMjcxLCAyNjUsIDI1OSwgNTA3LCA0OTYsIDQ4NSwgNDc1LCA0NjUsIDQ1NiwgNDQ2LCA0MzcsIDQyOCwgNDIwLCA0MTIsIDQwNCwgMzk2LCAzODgsIDM4MSwgMzc0LCAzNjcsIDM2MCwgMzU0LCAzNDcsIDM0MSwgMzM1LCAzMjksIDMyMywgMzE4LCAzMTIsIDMwNywgMzAyLCAyOTcsIDI5MiwgMjg3LCAyODIsIDI3OCwgMjczLCAyNjksIDI2NSwgMjYxLCA1MTIsIDUwNSwgNDk3LCA0ODksIDQ4MiwgNDc1LCA0NjgsIDQ2MSwgNDU0LCA0NDcsIDQ0MSwgNDM1LCA0MjgsIDQyMiwgNDE3LCA0MTEsIDQwNSwgMzk5LCAzOTQsIDM4OSwgMzgzLCAzNzgsIDM3MywgMzY4LCAzNjQsIDM1OSwgMzU0LCAzNTAsIDM0NSwgMzQxLCAzMzcsIDMzMiwgMzI4LCAzMjQsIDMyMCwgMzE2LCAzMTIsIDMwOSwgMzA1LCAzMDEsIDI5OCwgMjk0LCAyOTEsIDI4NywgMjg0LCAyODEsIDI3OCwgMjc0LCAyNzEsIDI2OCwgMjY1LCAyNjIsIDI1OSwgMjU3LCA1MDcsIDUwMSwgNDk2LCA0OTEsIDQ4NSwgNDgwLCA0NzUsIDQ3MCwgNDY1LCA0NjAsIDQ1NiwgNDUxLCA0NDYsIDQ0MiwgNDM3LCA0MzMsIDQyOCwgNDI0LCA0MjAsIDQxNiwgNDEyLCA0MDgsIDQwNCwgNDAwLCAzOTYsIDM5MiwgMzg4LCAzODUsIDM4MSwgMzc3LCAzNzQsIDM3MCwgMzY3LCAzNjMsIDM2MCwgMzU3LCAzNTQsIDM1MCwgMzQ3LCAzNDQsIDM0MSwgMzM4LCAzMzUsIDMzMiwgMzI5LCAzMjYsIDMyMywgMzIwLCAzMTgsIDMxNSwgMzEyLCAzMTAsIDMwNywgMzA0LCAzMDIsIDI5OSwgMjk3LCAyOTQsIDI5MiwgMjg5LCAyODcsIDI4NSwgMjgyLCAyODAsIDI3OCwgMjc1LCAyNzMsIDI3MSwgMjY5LCAyNjcsIDI2NSwgMjYzLCAyNjEsIDI1OV07XG52YXIgc2hnVGFibGUgPSBbOSwgMTEsIDEyLCAxMywgMTMsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0XTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8SFRNTEltYWdlRWxlbWVudH0gaW1nXG4gKiBAcGFyYW0ge3N0cmluZ3xIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gKiBAcGFyYW0ge0Zsb2F0fSByYWRpdXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYmx1ckFscGhhQ2hhbm5lbFxuICogQHBhcmFtIHtib29sZWFufSB1c2VPZmZzZXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2tpcFN0eWxlc1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBwcm9jZXNzSW1hZ2UoaW1nLCBjYW52YXMsIHJhZGl1cywgYmx1ckFscGhhQ2hhbm5lbCwgdXNlT2Zmc2V0LCBza2lwU3R5bGVzKSB7XG4gIGlmICh0eXBlb2YgaW1nID09PSAnc3RyaW5nJykge1xuICAgIGltZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGltZyk7XG4gIH1cblxuICBpZiAoIWltZyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW1nKS5zbGljZSg4LCAtMSkgPT09ICdIVE1MSW1hZ2VFbGVtZW50JyAmJiAhKCduYXR1cmFsV2lkdGgnIGluIGltZykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGltZW5zaW9uVHlwZSA9IHVzZU9mZnNldCA/ICdvZmZzZXQnIDogJ25hdHVyYWwnO1xuICB2YXIgdyA9IGltZ1tkaW1lbnNpb25UeXBlICsgJ1dpZHRoJ107XG4gIHZhciBoID0gaW1nW2RpbWVuc2lvblR5cGUgKyAnSGVpZ2h0J107IC8vIGFkZCBJbWFnZUJpdG1hcCBzdXBwb3J0LGNhbiBibHVyIHRleHR1cmUgc291cmNlXG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbWcpLnNsaWNlKDgsIC0xKSA9PT0gJ0ltYWdlQml0bWFwJykge1xuICAgIHcgPSBpbWcud2lkdGg7XG4gICAgaCA9IGltZy5oZWlnaHQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGNhbnZhcyA9PT0gJ3N0cmluZycpIHtcbiAgICBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXMpO1xuICB9XG5cbiAgaWYgKCFjYW52YXMgfHwgISgnZ2V0Q29udGV4dCcgaW4gY2FudmFzKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghc2tpcFN0eWxlcykge1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcbiAgfVxuXG4gIGNhbnZhcy53aWR0aCA9IHc7XG4gIGNhbnZhcy5oZWlnaHQgPSBoO1xuICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcbiAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBpbWcubmF0dXJhbFdpZHRoLCBpbWcubmF0dXJhbEhlaWdodCwgMCwgMCwgdywgaCk7XG5cbiAgaWYgKGlzTmFOKHJhZGl1cykgfHwgcmFkaXVzIDwgMSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChibHVyQWxwaGFDaGFubmVsKSB7XG4gICAgcHJvY2Vzc0NhbnZhc1JHQkEoY2FudmFzLCAwLCAwLCB3LCBoLCByYWRpdXMpO1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3NDYW52YXNSR0IoY2FudmFzLCAwLCAwLCB3LCBoLCByYWRpdXMpO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEhUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAqIEBwYXJhbSB7SW50ZWdlcn0gdG9wWFxuICogQHBhcmFtIHtJbnRlZ2VyfSB0b3BZXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge0ludGVnZXJ9IGhlaWdodFxuICogQHRocm93cyB7RXJyb3J8VHlwZUVycm9yfVxuICogQHJldHVybnMge0ltYWdlRGF0YX0gU2VlIHtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9jYW52YXMuaHRtbCNpbWFnZWRhdGF9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRJbWFnZURhdGFGcm9tQ2FudmFzKGNhbnZhcywgdG9wWCwgdG9wWSwgd2lkdGgsIGhlaWdodCkge1xuICBpZiAodHlwZW9mIGNhbnZhcyA9PT0gJ3N0cmluZycpIHtcbiAgICBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXMpO1xuICB9XG5cbiAgaWYgKCFjYW52YXMgfHwgX3R5cGVvZihjYW52YXMpICE9PSAnb2JqZWN0JyB8fCAhKCdnZXRDb250ZXh0JyBpbiBjYW52YXMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0aW5nIGNhbnZhcyB3aXRoIGBnZXRDb250ZXh0YCBtZXRob2QgJyArICdpbiBwcm9jZXNzQ2FudmFzUkdCKEEpIGNhbGxzIScpO1xuICB9XG5cbiAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICB0cnkge1xuICAgIHJldHVybiBjb250ZXh0LmdldEltYWdlRGF0YSh0b3BYLCB0b3BZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGFjY2VzcyBpbWFnZSBkYXRhOiAnICsgZSk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHRvcFhcbiAqIEBwYXJhbSB7SW50ZWdlcn0gdG9wWVxuICogQHBhcmFtIHtJbnRlZ2VyfSB3aWR0aFxuICogQHBhcmFtIHtJbnRlZ2VyfSBoZWlnaHRcbiAqIEBwYXJhbSB7RmxvYXR9IHJhZGl1c1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5cbmZ1bmN0aW9uIHByb2Nlc3NDYW52YXNSR0JBKGNhbnZhcywgdG9wWCwgdG9wWSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gIGlmIChpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8IDEpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByYWRpdXMgfD0gMDtcbiAgdmFyIGltYWdlRGF0YSA9IGdldEltYWdlRGF0YUZyb21DYW52YXMoY2FudmFzLCB0b3BYLCB0b3BZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgaW1hZ2VEYXRhID0gcHJvY2Vzc0ltYWdlRGF0YVJHQkEoaW1hZ2VEYXRhLCB0b3BYLCB0b3BZLCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpO1xuICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCB0b3BYLCB0b3BZKTtcbn1cbi8qKlxuICogQHBhcmFtIHtJbWFnZURhdGF9IGltYWdlRGF0YVxuICogQHBhcmFtIHtJbnRlZ2VyfSB0b3BYXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHRvcFlcbiAqIEBwYXJhbSB7SW50ZWdlcn0gd2lkdGhcbiAqIEBwYXJhbSB7SW50ZWdlcn0gaGVpZ2h0XG4gKiBAcGFyYW0ge0Zsb2F0fSByYWRpdXNcbiAqIEByZXR1cm5zIHtJbWFnZURhdGF9XG4gKi9cblxuXG5mdW5jdGlvbiBwcm9jZXNzSW1hZ2VEYXRhUkdCQShpbWFnZURhdGEsIHRvcFgsIHRvcFksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuICB2YXIgcGl4ZWxzID0gaW1hZ2VEYXRhLmRhdGE7XG4gIHZhciBkaXYgPSAyICogcmFkaXVzICsgMTsgLy8gY29uc3QgdzQgPSB3aWR0aCA8PCAyO1xuXG4gIHZhciB3aWR0aE1pbnVzMSA9IHdpZHRoIC0gMTtcbiAgdmFyIGhlaWdodE1pbnVzMSA9IGhlaWdodCAtIDE7XG4gIHZhciByYWRpdXNQbHVzMSA9IHJhZGl1cyArIDE7XG4gIHZhciBzdW1GYWN0b3IgPSByYWRpdXNQbHVzMSAqIChyYWRpdXNQbHVzMSArIDEpIC8gMjtcbiAgdmFyIHN0YWNrU3RhcnQgPSBuZXcgQmx1clN0YWNrKCk7XG4gIHZhciBzdGFjayA9IHN0YWNrU3RhcnQ7XG4gIHZhciBzdGFja0VuZDtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGRpdjsgaSsrKSB7XG4gICAgc3RhY2sgPSBzdGFjay5uZXh0ID0gbmV3IEJsdXJTdGFjaygpO1xuXG4gICAgaWYgKGkgPT09IHJhZGl1c1BsdXMxKSB7XG4gICAgICBzdGFja0VuZCA9IHN0YWNrO1xuICAgIH1cbiAgfVxuXG4gIHN0YWNrLm5leHQgPSBzdGFja1N0YXJ0O1xuICB2YXIgc3RhY2tJbiA9IG51bGwsXG4gICAgICBzdGFja091dCA9IG51bGwsXG4gICAgICB5dyA9IDAsXG4gICAgICB5aSA9IDA7XG4gIHZhciBtdWxTdW0gPSBtdWxUYWJsZVtyYWRpdXNdO1xuICB2YXIgc2hnU3VtID0gc2hnVGFibGVbcmFkaXVzXTtcblxuICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgc3RhY2sgPSBzdGFja1N0YXJ0O1xuICAgIHZhciBwciA9IHBpeGVsc1t5aV0sXG4gICAgICAgIHBnID0gcGl4ZWxzW3lpICsgMV0sXG4gICAgICAgIHBiID0gcGl4ZWxzW3lpICsgMl0sXG4gICAgICAgIHBhID0gcGl4ZWxzW3lpICsgM107XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcmFkaXVzUGx1czE7IF9pKyspIHtcbiAgICAgIHN0YWNrLnIgPSBwcjtcbiAgICAgIHN0YWNrLmcgPSBwZztcbiAgICAgIHN0YWNrLmIgPSBwYjtcbiAgICAgIHN0YWNrLmEgPSBwYTtcbiAgICAgIHN0YWNrID0gc3RhY2submV4dDtcbiAgICB9XG5cbiAgICB2YXIgckluU3VtID0gMCxcbiAgICAgICAgZ0luU3VtID0gMCxcbiAgICAgICAgYkluU3VtID0gMCxcbiAgICAgICAgYUluU3VtID0gMCxcbiAgICAgICAgck91dFN1bSA9IHJhZGl1c1BsdXMxICogcHIsXG4gICAgICAgIGdPdXRTdW0gPSByYWRpdXNQbHVzMSAqIHBnLFxuICAgICAgICBiT3V0U3VtID0gcmFkaXVzUGx1czEgKiBwYixcbiAgICAgICAgYU91dFN1bSA9IHJhZGl1c1BsdXMxICogcGEsXG4gICAgICAgIHJTdW0gPSBzdW1GYWN0b3IgKiBwcixcbiAgICAgICAgZ1N1bSA9IHN1bUZhY3RvciAqIHBnLFxuICAgICAgICBiU3VtID0gc3VtRmFjdG9yICogcGIsXG4gICAgICAgIGFTdW0gPSBzdW1GYWN0b3IgKiBwYTtcblxuICAgIGZvciAodmFyIF9pMiA9IDE7IF9pMiA8IHJhZGl1c1BsdXMxOyBfaTIrKykge1xuICAgICAgdmFyIHAgPSB5aSArICgod2lkdGhNaW51czEgPCBfaTIgPyB3aWR0aE1pbnVzMSA6IF9pMikgPDwgMik7XG4gICAgICB2YXIgciA9IHBpeGVsc1twXSxcbiAgICAgICAgICBnID0gcGl4ZWxzW3AgKyAxXSxcbiAgICAgICAgICBiID0gcGl4ZWxzW3AgKyAyXSxcbiAgICAgICAgICBhID0gcGl4ZWxzW3AgKyAzXTtcbiAgICAgIHZhciByYnMgPSByYWRpdXNQbHVzMSAtIF9pMjtcbiAgICAgIHJTdW0gKz0gKHN0YWNrLnIgPSByKSAqIHJicztcbiAgICAgIGdTdW0gKz0gKHN0YWNrLmcgPSBnKSAqIHJicztcbiAgICAgIGJTdW0gKz0gKHN0YWNrLmIgPSBiKSAqIHJicztcbiAgICAgIGFTdW0gKz0gKHN0YWNrLmEgPSBhKSAqIHJicztcbiAgICAgIHJJblN1bSArPSByO1xuICAgICAgZ0luU3VtICs9IGc7XG4gICAgICBiSW5TdW0gKz0gYjtcbiAgICAgIGFJblN1bSArPSBhO1xuICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuICAgIH1cblxuICAgIHN0YWNrSW4gPSBzdGFja1N0YXJ0O1xuICAgIHN0YWNrT3V0ID0gc3RhY2tFbmQ7XG5cbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgIHZhciBwYUluaXRpYWwgPSBhU3VtICogbXVsU3VtID4+PiBzaGdTdW07XG4gICAgICBwaXhlbHNbeWkgKyAzXSA9IHBhSW5pdGlhbDtcblxuICAgICAgaWYgKHBhSW5pdGlhbCAhPT0gMCkge1xuICAgICAgICB2YXIgX2EyID0gMjU1IC8gcGFJbml0aWFsO1xuXG4gICAgICAgIHBpeGVsc1t5aV0gPSAoclN1bSAqIG11bFN1bSA+Pj4gc2hnU3VtKSAqIF9hMjtcbiAgICAgICAgcGl4ZWxzW3lpICsgMV0gPSAoZ1N1bSAqIG11bFN1bSA+Pj4gc2hnU3VtKSAqIF9hMjtcbiAgICAgICAgcGl4ZWxzW3lpICsgMl0gPSAoYlN1bSAqIG11bFN1bSA+Pj4gc2hnU3VtKSAqIF9hMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBpeGVsc1t5aV0gPSBwaXhlbHNbeWkgKyAxXSA9IHBpeGVsc1t5aSArIDJdID0gMDtcbiAgICAgIH1cblxuICAgICAgclN1bSAtPSByT3V0U3VtO1xuICAgICAgZ1N1bSAtPSBnT3V0U3VtO1xuICAgICAgYlN1bSAtPSBiT3V0U3VtO1xuICAgICAgYVN1bSAtPSBhT3V0U3VtO1xuICAgICAgck91dFN1bSAtPSBzdGFja0luLnI7XG4gICAgICBnT3V0U3VtIC09IHN0YWNrSW4uZztcbiAgICAgIGJPdXRTdW0gLT0gc3RhY2tJbi5iO1xuICAgICAgYU91dFN1bSAtPSBzdGFja0luLmE7XG5cbiAgICAgIHZhciBfcCA9IHggKyByYWRpdXMgKyAxO1xuXG4gICAgICBfcCA9IHl3ICsgKF9wIDwgd2lkdGhNaW51czEgPyBfcCA6IHdpZHRoTWludXMxKSA8PCAyO1xuICAgICAgckluU3VtICs9IHN0YWNrSW4uciA9IHBpeGVsc1tfcF07XG4gICAgICBnSW5TdW0gKz0gc3RhY2tJbi5nID0gcGl4ZWxzW19wICsgMV07XG4gICAgICBiSW5TdW0gKz0gc3RhY2tJbi5iID0gcGl4ZWxzW19wICsgMl07XG4gICAgICBhSW5TdW0gKz0gc3RhY2tJbi5hID0gcGl4ZWxzW19wICsgM107XG4gICAgICByU3VtICs9IHJJblN1bTtcbiAgICAgIGdTdW0gKz0gZ0luU3VtO1xuICAgICAgYlN1bSArPSBiSW5TdW07XG4gICAgICBhU3VtICs9IGFJblN1bTtcbiAgICAgIHN0YWNrSW4gPSBzdGFja0luLm5leHQ7XG4gICAgICB2YXIgX3N0YWNrT3V0ID0gc3RhY2tPdXQsXG4gICAgICAgICAgX3IgPSBfc3RhY2tPdXQucixcbiAgICAgICAgICBfZyA9IF9zdGFja091dC5nLFxuICAgICAgICAgIF9iID0gX3N0YWNrT3V0LmIsXG4gICAgICAgICAgX2EgPSBfc3RhY2tPdXQuYTtcbiAgICAgIHJPdXRTdW0gKz0gX3I7XG4gICAgICBnT3V0U3VtICs9IF9nO1xuICAgICAgYk91dFN1bSArPSBfYjtcbiAgICAgIGFPdXRTdW0gKz0gX2E7XG4gICAgICBySW5TdW0gLT0gX3I7XG4gICAgICBnSW5TdW0gLT0gX2c7XG4gICAgICBiSW5TdW0gLT0gX2I7XG4gICAgICBhSW5TdW0gLT0gX2E7XG4gICAgICBzdGFja091dCA9IHN0YWNrT3V0Lm5leHQ7XG4gICAgICB5aSArPSA0O1xuICAgIH1cblxuICAgIHl3ICs9IHdpZHRoO1xuICB9XG5cbiAgZm9yICh2YXIgX3ggPSAwOyBfeCA8IHdpZHRoOyBfeCsrKSB7XG4gICAgeWkgPSBfeCA8PCAyO1xuXG4gICAgdmFyIF9wciA9IHBpeGVsc1t5aV0sXG4gICAgICAgIF9wZyA9IHBpeGVsc1t5aSArIDFdLFxuICAgICAgICBfcGIgPSBwaXhlbHNbeWkgKyAyXSxcbiAgICAgICAgX3BhID0gcGl4ZWxzW3lpICsgM10sXG4gICAgICAgIF9yT3V0U3VtID0gcmFkaXVzUGx1czEgKiBfcHIsXG4gICAgICAgIF9nT3V0U3VtID0gcmFkaXVzUGx1czEgKiBfcGcsXG4gICAgICAgIF9iT3V0U3VtID0gcmFkaXVzUGx1czEgKiBfcGIsXG4gICAgICAgIF9hT3V0U3VtID0gcmFkaXVzUGx1czEgKiBfcGEsXG4gICAgICAgIF9yU3VtID0gc3VtRmFjdG9yICogX3ByLFxuICAgICAgICBfZ1N1bSA9IHN1bUZhY3RvciAqIF9wZyxcbiAgICAgICAgX2JTdW0gPSBzdW1GYWN0b3IgKiBfcGIsXG4gICAgICAgIF9hU3VtID0gc3VtRmFjdG9yICogX3BhO1xuXG4gICAgc3RhY2sgPSBzdGFja1N0YXJ0O1xuXG4gICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgcmFkaXVzUGx1czE7IF9pMysrKSB7XG4gICAgICBzdGFjay5yID0gX3ByO1xuICAgICAgc3RhY2suZyA9IF9wZztcbiAgICAgIHN0YWNrLmIgPSBfcGI7XG4gICAgICBzdGFjay5hID0gX3BhO1xuICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuICAgIH1cblxuICAgIHZhciB5cCA9IHdpZHRoO1xuICAgIHZhciBfZ0luU3VtID0gMCxcbiAgICAgICAgX2JJblN1bSA9IDAsXG4gICAgICAgIF9hSW5TdW0gPSAwLFxuICAgICAgICBfckluU3VtID0gMDtcblxuICAgIGZvciAodmFyIF9pNCA9IDE7IF9pNCA8PSByYWRpdXM7IF9pNCsrKSB7XG4gICAgICB5aSA9IHlwICsgX3ggPDwgMjtcblxuICAgICAgdmFyIF9yYnMgPSByYWRpdXNQbHVzMSAtIF9pNDtcblxuICAgICAgX3JTdW0gKz0gKHN0YWNrLnIgPSBfcHIgPSBwaXhlbHNbeWldKSAqIF9yYnM7XG4gICAgICBfZ1N1bSArPSAoc3RhY2suZyA9IF9wZyA9IHBpeGVsc1t5aSArIDFdKSAqIF9yYnM7XG4gICAgICBfYlN1bSArPSAoc3RhY2suYiA9IF9wYiA9IHBpeGVsc1t5aSArIDJdKSAqIF9yYnM7XG4gICAgICBfYVN1bSArPSAoc3RhY2suYSA9IF9wYSA9IHBpeGVsc1t5aSArIDNdKSAqIF9yYnM7XG4gICAgICBfckluU3VtICs9IF9wcjtcbiAgICAgIF9nSW5TdW0gKz0gX3BnO1xuICAgICAgX2JJblN1bSArPSBfcGI7XG4gICAgICBfYUluU3VtICs9IF9wYTtcbiAgICAgIHN0YWNrID0gc3RhY2submV4dDtcblxuICAgICAgaWYgKF9pNCA8IGhlaWdodE1pbnVzMSkge1xuICAgICAgICB5cCArPSB3aWR0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB5aSA9IF94O1xuICAgIHN0YWNrSW4gPSBzdGFja1N0YXJ0O1xuICAgIHN0YWNrT3V0ID0gc3RhY2tFbmQ7XG5cbiAgICBmb3IgKHZhciBfeSA9IDA7IF95IDwgaGVpZ2h0OyBfeSsrKSB7XG4gICAgICB2YXIgX3AyID0geWkgPDwgMjtcblxuICAgICAgcGl4ZWxzW19wMiArIDNdID0gX3BhID0gX2FTdW0gKiBtdWxTdW0gPj4+IHNoZ1N1bTtcblxuICAgICAgaWYgKF9wYSA+IDApIHtcbiAgICAgICAgX3BhID0gMjU1IC8gX3BhO1xuICAgICAgICBwaXhlbHNbX3AyXSA9IChfclN1bSAqIG11bFN1bSA+Pj4gc2hnU3VtKSAqIF9wYTtcbiAgICAgICAgcGl4ZWxzW19wMiArIDFdID0gKF9nU3VtICogbXVsU3VtID4+PiBzaGdTdW0pICogX3BhO1xuICAgICAgICBwaXhlbHNbX3AyICsgMl0gPSAoX2JTdW0gKiBtdWxTdW0gPj4+IHNoZ1N1bSkgKiBfcGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaXhlbHNbX3AyXSA9IHBpeGVsc1tfcDIgKyAxXSA9IHBpeGVsc1tfcDIgKyAyXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIF9yU3VtIC09IF9yT3V0U3VtO1xuICAgICAgX2dTdW0gLT0gX2dPdXRTdW07XG4gICAgICBfYlN1bSAtPSBfYk91dFN1bTtcbiAgICAgIF9hU3VtIC09IF9hT3V0U3VtO1xuICAgICAgX3JPdXRTdW0gLT0gc3RhY2tJbi5yO1xuICAgICAgX2dPdXRTdW0gLT0gc3RhY2tJbi5nO1xuICAgICAgX2JPdXRTdW0gLT0gc3RhY2tJbi5iO1xuICAgICAgX2FPdXRTdW0gLT0gc3RhY2tJbi5hO1xuICAgICAgX3AyID0gX3ggKyAoKF9wMiA9IF95ICsgcmFkaXVzUGx1czEpIDwgaGVpZ2h0TWludXMxID8gX3AyIDogaGVpZ2h0TWludXMxKSAqIHdpZHRoIDw8IDI7XG4gICAgICBfclN1bSArPSBfckluU3VtICs9IHN0YWNrSW4uciA9IHBpeGVsc1tfcDJdO1xuICAgICAgX2dTdW0gKz0gX2dJblN1bSArPSBzdGFja0luLmcgPSBwaXhlbHNbX3AyICsgMV07XG4gICAgICBfYlN1bSArPSBfYkluU3VtICs9IHN0YWNrSW4uYiA9IHBpeGVsc1tfcDIgKyAyXTtcbiAgICAgIF9hU3VtICs9IF9hSW5TdW0gKz0gc3RhY2tJbi5hID0gcGl4ZWxzW19wMiArIDNdO1xuICAgICAgc3RhY2tJbiA9IHN0YWNrSW4ubmV4dDtcbiAgICAgIF9yT3V0U3VtICs9IF9wciA9IHN0YWNrT3V0LnI7XG4gICAgICBfZ091dFN1bSArPSBfcGcgPSBzdGFja091dC5nO1xuICAgICAgX2JPdXRTdW0gKz0gX3BiID0gc3RhY2tPdXQuYjtcbiAgICAgIF9hT3V0U3VtICs9IF9wYSA9IHN0YWNrT3V0LmE7XG4gICAgICBfckluU3VtIC09IF9wcjtcbiAgICAgIF9nSW5TdW0gLT0gX3BnO1xuICAgICAgX2JJblN1bSAtPSBfcGI7XG4gICAgICBfYUluU3VtIC09IF9wYTtcbiAgICAgIHN0YWNrT3V0ID0gc3RhY2tPdXQubmV4dDtcbiAgICAgIHlpICs9IHdpZHRoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbWFnZURhdGE7XG59XG4vKipcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICogQHBhcmFtIHtJbnRlZ2VyfSB0b3BYXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHRvcFlcbiAqIEBwYXJhbSB7SW50ZWdlcn0gd2lkdGhcbiAqIEBwYXJhbSB7SW50ZWdlcn0gaGVpZ2h0XG4gKiBAcGFyYW0ge0Zsb2F0fSByYWRpdXNcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuXG5mdW5jdGlvbiBwcm9jZXNzQ2FudmFzUkdCKGNhbnZhcywgdG9wWCwgdG9wWSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gIGlmIChpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8IDEpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByYWRpdXMgfD0gMDtcbiAgdmFyIGltYWdlRGF0YSA9IGdldEltYWdlRGF0YUZyb21DYW52YXMoY2FudmFzLCB0b3BYLCB0b3BZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgaW1hZ2VEYXRhID0gcHJvY2Vzc0ltYWdlRGF0YVJHQihpbWFnZURhdGEsIHRvcFgsIHRvcFksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyk7XG4gIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnB1dEltYWdlRGF0YShpbWFnZURhdGEsIHRvcFgsIHRvcFkpO1xufVxuLyoqXG4gKiBAcGFyYW0ge0ltYWdlRGF0YX0gaW1hZ2VEYXRhXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHRvcFhcbiAqIEBwYXJhbSB7SW50ZWdlcn0gdG9wWVxuICogQHBhcmFtIHtJbnRlZ2VyfSB3aWR0aFxuICogQHBhcmFtIHtJbnRlZ2VyfSBoZWlnaHRcbiAqIEBwYXJhbSB7RmxvYXR9IHJhZGl1c1xuICogQHJldHVybnMge0ltYWdlRGF0YX1cbiAqL1xuXG5cbmZ1bmN0aW9uIHByb2Nlc3NJbWFnZURhdGFSR0IoaW1hZ2VEYXRhLCB0b3BYLCB0b3BZLCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcbiAgdmFyIHBpeGVscyA9IGltYWdlRGF0YS5kYXRhO1xuICB2YXIgZGl2ID0gMiAqIHJhZGl1cyArIDE7IC8vIGNvbnN0IHc0ID0gd2lkdGggPDwgMjtcblxuICB2YXIgd2lkdGhNaW51czEgPSB3aWR0aCAtIDE7XG4gIHZhciBoZWlnaHRNaW51czEgPSBoZWlnaHQgLSAxO1xuICB2YXIgcmFkaXVzUGx1czEgPSByYWRpdXMgKyAxO1xuICB2YXIgc3VtRmFjdG9yID0gcmFkaXVzUGx1czEgKiAocmFkaXVzUGx1czEgKyAxKSAvIDI7XG4gIHZhciBzdGFja1N0YXJ0ID0gbmV3IEJsdXJTdGFjaygpO1xuICB2YXIgc3RhY2sgPSBzdGFja1N0YXJ0O1xuICB2YXIgc3RhY2tFbmQ7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBkaXY7IGkrKykge1xuICAgIHN0YWNrID0gc3RhY2submV4dCA9IG5ldyBCbHVyU3RhY2soKTtcblxuICAgIGlmIChpID09PSByYWRpdXNQbHVzMSkge1xuICAgICAgc3RhY2tFbmQgPSBzdGFjaztcbiAgICB9XG4gIH1cblxuICBzdGFjay5uZXh0ID0gc3RhY2tTdGFydDtcbiAgdmFyIHN0YWNrSW4gPSBudWxsO1xuICB2YXIgc3RhY2tPdXQgPSBudWxsO1xuICB2YXIgbXVsU3VtID0gbXVsVGFibGVbcmFkaXVzXTtcbiAgdmFyIHNoZ1N1bSA9IHNoZ1RhYmxlW3JhZGl1c107XG4gIHZhciBwLCByYnM7XG4gIHZhciB5dyA9IDAsXG4gICAgICB5aSA9IDA7XG5cbiAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgIHZhciBwciA9IHBpeGVsc1t5aV0sXG4gICAgICAgIHBnID0gcGl4ZWxzW3lpICsgMV0sXG4gICAgICAgIHBiID0gcGl4ZWxzW3lpICsgMl0sXG4gICAgICAgIHJPdXRTdW0gPSByYWRpdXNQbHVzMSAqIHByLFxuICAgICAgICBnT3V0U3VtID0gcmFkaXVzUGx1czEgKiBwZyxcbiAgICAgICAgYk91dFN1bSA9IHJhZGl1c1BsdXMxICogcGIsXG4gICAgICAgIHJTdW0gPSBzdW1GYWN0b3IgKiBwcixcbiAgICAgICAgZ1N1bSA9IHN1bUZhY3RvciAqIHBnLFxuICAgICAgICBiU3VtID0gc3VtRmFjdG9yICogcGI7XG4gICAgc3RhY2sgPSBzdGFja1N0YXJ0O1xuXG4gICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgcmFkaXVzUGx1czE7IF9pNSsrKSB7XG4gICAgICBzdGFjay5yID0gcHI7XG4gICAgICBzdGFjay5nID0gcGc7XG4gICAgICBzdGFjay5iID0gcGI7XG4gICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG4gICAgfVxuXG4gICAgdmFyIHJJblN1bSA9IDAsXG4gICAgICAgIGdJblN1bSA9IDAsXG4gICAgICAgIGJJblN1bSA9IDA7XG5cbiAgICBmb3IgKHZhciBfaTYgPSAxOyBfaTYgPCByYWRpdXNQbHVzMTsgX2k2KyspIHtcbiAgICAgIHAgPSB5aSArICgod2lkdGhNaW51czEgPCBfaTYgPyB3aWR0aE1pbnVzMSA6IF9pNikgPDwgMik7XG4gICAgICByU3VtICs9IChzdGFjay5yID0gcHIgPSBwaXhlbHNbcF0pICogKHJicyA9IHJhZGl1c1BsdXMxIC0gX2k2KTtcbiAgICAgIGdTdW0gKz0gKHN0YWNrLmcgPSBwZyA9IHBpeGVsc1twICsgMV0pICogcmJzO1xuICAgICAgYlN1bSArPSAoc3RhY2suYiA9IHBiID0gcGl4ZWxzW3AgKyAyXSkgKiByYnM7XG4gICAgICBySW5TdW0gKz0gcHI7XG4gICAgICBnSW5TdW0gKz0gcGc7XG4gICAgICBiSW5TdW0gKz0gcGI7XG4gICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG4gICAgfVxuXG4gICAgc3RhY2tJbiA9IHN0YWNrU3RhcnQ7XG4gICAgc3RhY2tPdXQgPSBzdGFja0VuZDtcblxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgcGl4ZWxzW3lpXSA9IHJTdW0gKiBtdWxTdW0gPj4+IHNoZ1N1bTtcbiAgICAgIHBpeGVsc1t5aSArIDFdID0gZ1N1bSAqIG11bFN1bSA+Pj4gc2hnU3VtO1xuICAgICAgcGl4ZWxzW3lpICsgMl0gPSBiU3VtICogbXVsU3VtID4+PiBzaGdTdW07XG4gICAgICByU3VtIC09IHJPdXRTdW07XG4gICAgICBnU3VtIC09IGdPdXRTdW07XG4gICAgICBiU3VtIC09IGJPdXRTdW07XG4gICAgICByT3V0U3VtIC09IHN0YWNrSW4ucjtcbiAgICAgIGdPdXRTdW0gLT0gc3RhY2tJbi5nO1xuICAgICAgYk91dFN1bSAtPSBzdGFja0luLmI7XG4gICAgICBwID0geXcgKyAoKHAgPSB4ICsgcmFkaXVzICsgMSkgPCB3aWR0aE1pbnVzMSA/IHAgOiB3aWR0aE1pbnVzMSkgPDwgMjtcbiAgICAgIHJJblN1bSArPSBzdGFja0luLnIgPSBwaXhlbHNbcF07XG4gICAgICBnSW5TdW0gKz0gc3RhY2tJbi5nID0gcGl4ZWxzW3AgKyAxXTtcbiAgICAgIGJJblN1bSArPSBzdGFja0luLmIgPSBwaXhlbHNbcCArIDJdO1xuICAgICAgclN1bSArPSBySW5TdW07XG4gICAgICBnU3VtICs9IGdJblN1bTtcbiAgICAgIGJTdW0gKz0gYkluU3VtO1xuICAgICAgc3RhY2tJbiA9IHN0YWNrSW4ubmV4dDtcbiAgICAgIHJPdXRTdW0gKz0gcHIgPSBzdGFja091dC5yO1xuICAgICAgZ091dFN1bSArPSBwZyA9IHN0YWNrT3V0Lmc7XG4gICAgICBiT3V0U3VtICs9IHBiID0gc3RhY2tPdXQuYjtcbiAgICAgIHJJblN1bSAtPSBwcjtcbiAgICAgIGdJblN1bSAtPSBwZztcbiAgICAgIGJJblN1bSAtPSBwYjtcbiAgICAgIHN0YWNrT3V0ID0gc3RhY2tPdXQubmV4dDtcbiAgICAgIHlpICs9IDQ7XG4gICAgfVxuXG4gICAgeXcgKz0gd2lkdGg7XG4gIH1cblxuICBmb3IgKHZhciBfeDIgPSAwOyBfeDIgPCB3aWR0aDsgX3gyKyspIHtcbiAgICB5aSA9IF94MiA8PCAyO1xuXG4gICAgdmFyIF9wcjIgPSBwaXhlbHNbeWldLFxuICAgICAgICBfcGcyID0gcGl4ZWxzW3lpICsgMV0sXG4gICAgICAgIF9wYjIgPSBwaXhlbHNbeWkgKyAyXSxcbiAgICAgICAgX3JPdXRTdW0yID0gcmFkaXVzUGx1czEgKiBfcHIyLFxuICAgICAgICBfZ091dFN1bTIgPSByYWRpdXNQbHVzMSAqIF9wZzIsXG4gICAgICAgIF9iT3V0U3VtMiA9IHJhZGl1c1BsdXMxICogX3BiMixcbiAgICAgICAgX3JTdW0yID0gc3VtRmFjdG9yICogX3ByMixcbiAgICAgICAgX2dTdW0yID0gc3VtRmFjdG9yICogX3BnMixcbiAgICAgICAgX2JTdW0yID0gc3VtRmFjdG9yICogX3BiMjtcblxuICAgIHN0YWNrID0gc3RhY2tTdGFydDtcblxuICAgIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IHJhZGl1c1BsdXMxOyBfaTcrKykge1xuICAgICAgc3RhY2suciA9IF9wcjI7XG4gICAgICBzdGFjay5nID0gX3BnMjtcbiAgICAgIHN0YWNrLmIgPSBfcGIyO1xuICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuICAgIH1cblxuICAgIHZhciBfckluU3VtMiA9IDAsXG4gICAgICAgIF9nSW5TdW0yID0gMCxcbiAgICAgICAgX2JJblN1bTIgPSAwO1xuXG4gICAgZm9yICh2YXIgX2k4ID0gMSwgeXAgPSB3aWR0aDsgX2k4IDw9IHJhZGl1czsgX2k4KyspIHtcbiAgICAgIHlpID0geXAgKyBfeDIgPDwgMjtcbiAgICAgIF9yU3VtMiArPSAoc3RhY2suciA9IF9wcjIgPSBwaXhlbHNbeWldKSAqIChyYnMgPSByYWRpdXNQbHVzMSAtIF9pOCk7XG4gICAgICBfZ1N1bTIgKz0gKHN0YWNrLmcgPSBfcGcyID0gcGl4ZWxzW3lpICsgMV0pICogcmJzO1xuICAgICAgX2JTdW0yICs9IChzdGFjay5iID0gX3BiMiA9IHBpeGVsc1t5aSArIDJdKSAqIHJicztcbiAgICAgIF9ySW5TdW0yICs9IF9wcjI7XG4gICAgICBfZ0luU3VtMiArPSBfcGcyO1xuICAgICAgX2JJblN1bTIgKz0gX3BiMjtcbiAgICAgIHN0YWNrID0gc3RhY2submV4dDtcblxuICAgICAgaWYgKF9pOCA8IGhlaWdodE1pbnVzMSkge1xuICAgICAgICB5cCArPSB3aWR0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB5aSA9IF94MjtcbiAgICBzdGFja0luID0gc3RhY2tTdGFydDtcbiAgICBzdGFja091dCA9IHN0YWNrRW5kO1xuXG4gICAgZm9yICh2YXIgX3kyID0gMDsgX3kyIDwgaGVpZ2h0OyBfeTIrKykge1xuICAgICAgcCA9IHlpIDw8IDI7XG4gICAgICBwaXhlbHNbcF0gPSBfclN1bTIgKiBtdWxTdW0gPj4+IHNoZ1N1bTtcbiAgICAgIHBpeGVsc1twICsgMV0gPSBfZ1N1bTIgKiBtdWxTdW0gPj4+IHNoZ1N1bTtcbiAgICAgIHBpeGVsc1twICsgMl0gPSBfYlN1bTIgKiBtdWxTdW0gPj4+IHNoZ1N1bTtcbiAgICAgIF9yU3VtMiAtPSBfck91dFN1bTI7XG4gICAgICBfZ1N1bTIgLT0gX2dPdXRTdW0yO1xuICAgICAgX2JTdW0yIC09IF9iT3V0U3VtMjtcbiAgICAgIF9yT3V0U3VtMiAtPSBzdGFja0luLnI7XG4gICAgICBfZ091dFN1bTIgLT0gc3RhY2tJbi5nO1xuICAgICAgX2JPdXRTdW0yIC09IHN0YWNrSW4uYjtcbiAgICAgIHAgPSBfeDIgKyAoKHAgPSBfeTIgKyByYWRpdXNQbHVzMSkgPCBoZWlnaHRNaW51czEgPyBwIDogaGVpZ2h0TWludXMxKSAqIHdpZHRoIDw8IDI7XG4gICAgICBfclN1bTIgKz0gX3JJblN1bTIgKz0gc3RhY2tJbi5yID0gcGl4ZWxzW3BdO1xuICAgICAgX2dTdW0yICs9IF9nSW5TdW0yICs9IHN0YWNrSW4uZyA9IHBpeGVsc1twICsgMV07XG4gICAgICBfYlN1bTIgKz0gX2JJblN1bTIgKz0gc3RhY2tJbi5iID0gcGl4ZWxzW3AgKyAyXTtcbiAgICAgIHN0YWNrSW4gPSBzdGFja0luLm5leHQ7XG4gICAgICBfck91dFN1bTIgKz0gX3ByMiA9IHN0YWNrT3V0LnI7XG4gICAgICBfZ091dFN1bTIgKz0gX3BnMiA9IHN0YWNrT3V0Lmc7XG4gICAgICBfYk91dFN1bTIgKz0gX3BiMiA9IHN0YWNrT3V0LmI7XG4gICAgICBfckluU3VtMiAtPSBfcHIyO1xuICAgICAgX2dJblN1bTIgLT0gX3BnMjtcbiAgICAgIF9iSW5TdW0yIC09IF9wYjI7XG4gICAgICBzdGFja091dCA9IHN0YWNrT3V0Lm5leHQ7XG4gICAgICB5aSArPSB3aWR0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW1hZ2VEYXRhO1xufVxuLyoqXG4gKlxuICovXG5cblxudmFyIEJsdXJTdGFjayA9XG4vKipcbiAqIFNldCBwcm9wZXJ0aWVzLlxuICovXG5mdW5jdGlvbiBCbHVyU3RhY2soKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCbHVyU3RhY2spO1xuXG4gIHRoaXMuciA9IDA7XG4gIHRoaXMuZyA9IDA7XG4gIHRoaXMuYiA9IDA7XG4gIHRoaXMuYSA9IDA7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59O1xuXG5leHBvcnQgeyBCbHVyU3RhY2ssIHByb2Nlc3NDYW52YXNSR0IgYXMgY2FudmFzUkdCLCBwcm9jZXNzQ2FudmFzUkdCQSBhcyBjYW52YXNSR0JBLCBwcm9jZXNzSW1hZ2UgYXMgaW1hZ2UsIHByb2Nlc3NJbWFnZURhdGFSR0IgYXMgaW1hZ2VEYXRhUkdCLCBwcm9jZXNzSW1hZ2VEYXRhUkdCQSBhcyBpbWFnZURhdGFSR0JBIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/stackblur-canvas/dist/stackblur-es.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/svg-pathdata/lib/SVGPathData.module.js":
/*!*************************************************************!*\
  !*** ./node_modules/svg-pathdata/lib/SVGPathData.module.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   COMMAND_ARG_COUNTS: () => (/* binding */ N),\n/* harmony export */   SVGPathData: () => (/* binding */ _),\n/* harmony export */   SVGPathDataParser: () => (/* binding */ f),\n/* harmony export */   SVGPathDataTransformer: () => (/* binding */ u),\n/* harmony export */   encodeSVGPath: () => (/* binding */ e)\n/* harmony export */ });\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar t=function(r,e){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var e in r)Object.prototype.hasOwnProperty.call(r,e)&&(t[e]=r[e])})(r,e)};function r(r,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Class extends value \"+String(e)+\" is not a constructor or null\");function i(){this.constructor=r}t(r,e),r.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}function e(t){var r=\"\";Array.isArray(t)||(t=[t]);for(var e=0;e<t.length;e++){var i=t[e];if(i.type===_.CLOSE_PATH)r+=\"z\";else if(i.type===_.HORIZ_LINE_TO)r+=(i.relative?\"h\":\"H\")+i.x;else if(i.type===_.VERT_LINE_TO)r+=(i.relative?\"v\":\"V\")+i.y;else if(i.type===_.MOVE_TO)r+=(i.relative?\"m\":\"M\")+i.x+\" \"+i.y;else if(i.type===_.LINE_TO)r+=(i.relative?\"l\":\"L\")+i.x+\" \"+i.y;else if(i.type===_.CURVE_TO)r+=(i.relative?\"c\":\"C\")+i.x1+\" \"+i.y1+\" \"+i.x2+\" \"+i.y2+\" \"+i.x+\" \"+i.y;else if(i.type===_.SMOOTH_CURVE_TO)r+=(i.relative?\"s\":\"S\")+i.x2+\" \"+i.y2+\" \"+i.x+\" \"+i.y;else if(i.type===_.QUAD_TO)r+=(i.relative?\"q\":\"Q\")+i.x1+\" \"+i.y1+\" \"+i.x+\" \"+i.y;else if(i.type===_.SMOOTH_QUAD_TO)r+=(i.relative?\"t\":\"T\")+i.x+\" \"+i.y;else{if(i.type!==_.ARC)throw new Error('Unexpected command type \"'+i.type+'\" at index '+e+\".\");r+=(i.relative?\"a\":\"A\")+i.rX+\" \"+i.rY+\" \"+i.xRot+\" \"+ +i.lArcFlag+\" \"+ +i.sweepFlag+\" \"+i.x+\" \"+i.y}}return r}function i(t,r){var e=t[0],i=t[1];return[e*Math.cos(r)-i*Math.sin(r),e*Math.sin(r)+i*Math.cos(r)]}function a(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];for(var e=0;e<t.length;e++)if(\"number\"!=typeof t[e])throw new Error(\"assertNumbers arguments[\"+e+\"] is not a number. \"+typeof t[e]+\" == typeof \"+t[e]);return!0}var n=Math.PI;function o(t,r,e){t.lArcFlag=0===t.lArcFlag?0:1,t.sweepFlag=0===t.sweepFlag?0:1;var a=t.rX,o=t.rY,s=t.x,u=t.y;a=Math.abs(t.rX),o=Math.abs(t.rY);var h=i([(r-s)/2,(e-u)/2],-t.xRot/180*n),c=h[0],y=h[1],p=Math.pow(c,2)/Math.pow(a,2)+Math.pow(y,2)/Math.pow(o,2);1<p&&(a*=Math.sqrt(p),o*=Math.sqrt(p)),t.rX=a,t.rY=o;var m=Math.pow(a,2)*Math.pow(y,2)+Math.pow(o,2)*Math.pow(c,2),O=(t.lArcFlag!==t.sweepFlag?1:-1)*Math.sqrt(Math.max(0,(Math.pow(a,2)*Math.pow(o,2)-m)/m)),l=a*y/o*O,T=-o*c/a*O,v=i([l,T],t.xRot/180*n);t.cX=v[0]+(r+s)/2,t.cY=v[1]+(e+u)/2,t.phi1=Math.atan2((y-T)/o,(c-l)/a),t.phi2=Math.atan2((-y-T)/o,(-c-l)/a),0===t.sweepFlag&&t.phi2>t.phi1&&(t.phi2-=2*n),1===t.sweepFlag&&t.phi2<t.phi1&&(t.phi2+=2*n),t.phi1*=180/n,t.phi2*=180/n}function s(t,r,e){a(t,r,e);var i=t*t+r*r-e*e;if(0>i)return[];if(0===i)return[[t*e/(t*t+r*r),r*e/(t*t+r*r)]];var n=Math.sqrt(i);return[[(t*e+r*n)/(t*t+r*r),(r*e-t*n)/(t*t+r*r)],[(t*e-r*n)/(t*t+r*r),(r*e+t*n)/(t*t+r*r)]]}var u,h=Math.PI/180;function c(t,r,e){return(1-e)*t+e*r}function y(t,r,e,i){return t+Math.cos(i/180*n)*r+Math.sin(i/180*n)*e}function p(t,r,e,i){var a=1e-6,n=r-t,o=e-r,s=3*n+3*(i-e)-6*o,u=6*(o-n),h=3*n;return Math.abs(s)<a?[-h/u]:function(t,r,e){void 0===e&&(e=1e-6);var i=t*t/4-r;if(i<-e)return[];if(i<=e)return[-t/2];var a=Math.sqrt(i);return[-t/2-a,-t/2+a]}(u/s,h/s,a)}function m(t,r,e,i,a){var n=1-a;return t*(n*n*n)+r*(3*n*n*a)+e*(3*n*a*a)+i*(a*a*a)}!function(t){function r(){return u((function(t,r,e){return t.relative&&(void 0!==t.x1&&(t.x1+=r),void 0!==t.y1&&(t.y1+=e),void 0!==t.x2&&(t.x2+=r),void 0!==t.y2&&(t.y2+=e),void 0!==t.x&&(t.x+=r),void 0!==t.y&&(t.y+=e),t.relative=!1),t}))}function e(){var t=NaN,r=NaN,e=NaN,i=NaN;return u((function(a,n,o){return a.type&_.SMOOTH_CURVE_TO&&(a.type=_.CURVE_TO,t=isNaN(t)?n:t,r=isNaN(r)?o:r,a.x1=a.relative?n-t:2*n-t,a.y1=a.relative?o-r:2*o-r),a.type&_.CURVE_TO?(t=a.relative?n+a.x2:a.x2,r=a.relative?o+a.y2:a.y2):(t=NaN,r=NaN),a.type&_.SMOOTH_QUAD_TO&&(a.type=_.QUAD_TO,e=isNaN(e)?n:e,i=isNaN(i)?o:i,a.x1=a.relative?n-e:2*n-e,a.y1=a.relative?o-i:2*o-i),a.type&_.QUAD_TO?(e=a.relative?n+a.x1:a.x1,i=a.relative?o+a.y1:a.y1):(e=NaN,i=NaN),a}))}function n(){var t=NaN,r=NaN;return u((function(e,i,a){if(e.type&_.SMOOTH_QUAD_TO&&(e.type=_.QUAD_TO,t=isNaN(t)?i:t,r=isNaN(r)?a:r,e.x1=e.relative?i-t:2*i-t,e.y1=e.relative?a-r:2*a-r),e.type&_.QUAD_TO){t=e.relative?i+e.x1:e.x1,r=e.relative?a+e.y1:e.y1;var n=e.x1,o=e.y1;e.type=_.CURVE_TO,e.x1=((e.relative?0:i)+2*n)/3,e.y1=((e.relative?0:a)+2*o)/3,e.x2=(e.x+2*n)/3,e.y2=(e.y+2*o)/3}else t=NaN,r=NaN;return e}))}function u(t){var r=0,e=0,i=NaN,a=NaN;return function(n){if(isNaN(i)&&!(n.type&_.MOVE_TO))throw new Error(\"path must start with moveto\");var o=t(n,r,e,i,a);return n.type&_.CLOSE_PATH&&(r=i,e=a),void 0!==n.x&&(r=n.relative?r+n.x:n.x),void 0!==n.y&&(e=n.relative?e+n.y:n.y),n.type&_.MOVE_TO&&(i=r,a=e),o}}function O(t,r,e,i,n,o){return a(t,r,e,i,n,o),u((function(a,s,u,h){var c=a.x1,y=a.x2,p=a.relative&&!isNaN(h),m=void 0!==a.x?a.x:p?0:s,O=void 0!==a.y?a.y:p?0:u;function l(t){return t*t}a.type&_.HORIZ_LINE_TO&&0!==r&&(a.type=_.LINE_TO,a.y=a.relative?0:u),a.type&_.VERT_LINE_TO&&0!==e&&(a.type=_.LINE_TO,a.x=a.relative?0:s),void 0!==a.x&&(a.x=a.x*t+O*e+(p?0:n)),void 0!==a.y&&(a.y=m*r+a.y*i+(p?0:o)),void 0!==a.x1&&(a.x1=a.x1*t+a.y1*e+(p?0:n)),void 0!==a.y1&&(a.y1=c*r+a.y1*i+(p?0:o)),void 0!==a.x2&&(a.x2=a.x2*t+a.y2*e+(p?0:n)),void 0!==a.y2&&(a.y2=y*r+a.y2*i+(p?0:o));var T=t*i-r*e;if(void 0!==a.xRot&&(1!==t||0!==r||0!==e||1!==i))if(0===T)delete a.rX,delete a.rY,delete a.xRot,delete a.lArcFlag,delete a.sweepFlag,a.type=_.LINE_TO;else{var v=a.xRot*Math.PI/180,f=Math.sin(v),N=Math.cos(v),x=1/l(a.rX),d=1/l(a.rY),E=l(N)*x+l(f)*d,A=2*f*N*(x-d),C=l(f)*x+l(N)*d,M=E*i*i-A*r*i+C*r*r,R=A*(t*i+r*e)-2*(E*e*i+C*t*r),g=E*e*e-A*t*e+C*t*t,I=(Math.atan2(R,M-g)+Math.PI)%Math.PI/2,S=Math.sin(I),L=Math.cos(I);a.rX=Math.abs(T)/Math.sqrt(M*l(L)+R*S*L+g*l(S)),a.rY=Math.abs(T)/Math.sqrt(M*l(S)-R*S*L+g*l(L)),a.xRot=180*I/Math.PI}return void 0!==a.sweepFlag&&0>T&&(a.sweepFlag=+!a.sweepFlag),a}))}function l(){return function(t){var r={};for(var e in t)r[e]=t[e];return r}}t.ROUND=function(t){function r(r){return Math.round(r*t)/t}return void 0===t&&(t=1e13),a(t),function(t){return void 0!==t.x1&&(t.x1=r(t.x1)),void 0!==t.y1&&(t.y1=r(t.y1)),void 0!==t.x2&&(t.x2=r(t.x2)),void 0!==t.y2&&(t.y2=r(t.y2)),void 0!==t.x&&(t.x=r(t.x)),void 0!==t.y&&(t.y=r(t.y)),void 0!==t.rX&&(t.rX=r(t.rX)),void 0!==t.rY&&(t.rY=r(t.rY)),t}},t.TO_ABS=r,t.TO_REL=function(){return u((function(t,r,e){return t.relative||(void 0!==t.x1&&(t.x1-=r),void 0!==t.y1&&(t.y1-=e),void 0!==t.x2&&(t.x2-=r),void 0!==t.y2&&(t.y2-=e),void 0!==t.x&&(t.x-=r),void 0!==t.y&&(t.y-=e),t.relative=!0),t}))},t.NORMALIZE_HVZ=function(t,r,e){return void 0===t&&(t=!0),void 0===r&&(r=!0),void 0===e&&(e=!0),u((function(i,a,n,o,s){if(isNaN(o)&&!(i.type&_.MOVE_TO))throw new Error(\"path must start with moveto\");return r&&i.type&_.HORIZ_LINE_TO&&(i.type=_.LINE_TO,i.y=i.relative?0:n),e&&i.type&_.VERT_LINE_TO&&(i.type=_.LINE_TO,i.x=i.relative?0:a),t&&i.type&_.CLOSE_PATH&&(i.type=_.LINE_TO,i.x=i.relative?o-a:o,i.y=i.relative?s-n:s),i.type&_.ARC&&(0===i.rX||0===i.rY)&&(i.type=_.LINE_TO,delete i.rX,delete i.rY,delete i.xRot,delete i.lArcFlag,delete i.sweepFlag),i}))},t.NORMALIZE_ST=e,t.QT_TO_C=n,t.INFO=u,t.SANITIZE=function(t){void 0===t&&(t=0),a(t);var r=NaN,e=NaN,i=NaN,n=NaN;return u((function(a,o,s,u,h){var c=Math.abs,y=!1,p=0,m=0;if(a.type&_.SMOOTH_CURVE_TO&&(p=isNaN(r)?0:o-r,m=isNaN(e)?0:s-e),a.type&(_.CURVE_TO|_.SMOOTH_CURVE_TO)?(r=a.relative?o+a.x2:a.x2,e=a.relative?s+a.y2:a.y2):(r=NaN,e=NaN),a.type&_.SMOOTH_QUAD_TO?(i=isNaN(i)?o:2*o-i,n=isNaN(n)?s:2*s-n):a.type&_.QUAD_TO?(i=a.relative?o+a.x1:a.x1,n=a.relative?s+a.y1:a.y2):(i=NaN,n=NaN),a.type&_.LINE_COMMANDS||a.type&_.ARC&&(0===a.rX||0===a.rY||!a.lArcFlag)||a.type&_.CURVE_TO||a.type&_.SMOOTH_CURVE_TO||a.type&_.QUAD_TO||a.type&_.SMOOTH_QUAD_TO){var O=void 0===a.x?0:a.relative?a.x:a.x-o,l=void 0===a.y?0:a.relative?a.y:a.y-s;p=isNaN(i)?void 0===a.x1?p:a.relative?a.x:a.x1-o:i-o,m=isNaN(n)?void 0===a.y1?m:a.relative?a.y:a.y1-s:n-s;var T=void 0===a.x2?0:a.relative?a.x:a.x2-o,v=void 0===a.y2?0:a.relative?a.y:a.y2-s;c(O)<=t&&c(l)<=t&&c(p)<=t&&c(m)<=t&&c(T)<=t&&c(v)<=t&&(y=!0)}return a.type&_.CLOSE_PATH&&c(o-u)<=t&&c(s-h)<=t&&(y=!0),y?[]:a}))},t.MATRIX=O,t.ROTATE=function(t,r,e){void 0===r&&(r=0),void 0===e&&(e=0),a(t,r,e);var i=Math.sin(t),n=Math.cos(t);return O(n,i,-i,n,r-r*n+e*i,e-r*i-e*n)},t.TRANSLATE=function(t,r){return void 0===r&&(r=0),a(t,r),O(1,0,0,1,t,r)},t.SCALE=function(t,r){return void 0===r&&(r=t),a(t,r),O(t,0,0,r,0,0)},t.SKEW_X=function(t){return a(t),O(1,0,Math.atan(t),1,0,0)},t.SKEW_Y=function(t){return a(t),O(1,Math.atan(t),0,1,0,0)},t.X_AXIS_SYMMETRY=function(t){return void 0===t&&(t=0),a(t),O(-1,0,0,1,t,0)},t.Y_AXIS_SYMMETRY=function(t){return void 0===t&&(t=0),a(t),O(1,0,0,-1,0,t)},t.A_TO_C=function(){return u((function(t,r,e){return _.ARC===t.type?function(t,r,e){var a,n,s,u;t.cX||o(t,r,e);for(var y=Math.min(t.phi1,t.phi2),p=Math.max(t.phi1,t.phi2)-y,m=Math.ceil(p/90),O=new Array(m),l=r,T=e,v=0;v<m;v++){var f=c(t.phi1,t.phi2,v/m),N=c(t.phi1,t.phi2,(v+1)/m),x=N-f,d=4/3*Math.tan(x*h/4),E=[Math.cos(f*h)-d*Math.sin(f*h),Math.sin(f*h)+d*Math.cos(f*h)],A=E[0],C=E[1],M=[Math.cos(N*h),Math.sin(N*h)],R=M[0],g=M[1],I=[R+d*Math.sin(N*h),g-d*Math.cos(N*h)],S=I[0],L=I[1];O[v]={relative:t.relative,type:_.CURVE_TO};var H=function(r,e){var a=i([r*t.rX,e*t.rY],t.xRot),n=a[0],o=a[1];return[t.cX+n,t.cY+o]};a=H(A,C),O[v].x1=a[0],O[v].y1=a[1],n=H(S,L),O[v].x2=n[0],O[v].y2=n[1],s=H(R,g),O[v].x=s[0],O[v].y=s[1],t.relative&&(O[v].x1-=l,O[v].y1-=T,O[v].x2-=l,O[v].y2-=T,O[v].x-=l,O[v].y-=T),l=(u=[O[v].x,O[v].y])[0],T=u[1]}return O}(t,t.relative?0:r,t.relative?0:e):t}))},t.ANNOTATE_ARCS=function(){return u((function(t,r,e){return t.relative&&(r=0,e=0),_.ARC===t.type&&o(t,r,e),t}))},t.CLONE=l,t.CALCULATE_BOUNDS=function(){var t=function(t){var r={};for(var e in t)r[e]=t[e];return r},i=r(),a=n(),h=e(),c=u((function(r,e,n){var u=h(a(i(t(r))));function O(t){t>c.maxX&&(c.maxX=t),t<c.minX&&(c.minX=t)}function l(t){t>c.maxY&&(c.maxY=t),t<c.minY&&(c.minY=t)}if(u.type&_.DRAWING_COMMANDS&&(O(e),l(n)),u.type&_.HORIZ_LINE_TO&&O(u.x),u.type&_.VERT_LINE_TO&&l(u.y),u.type&_.LINE_TO&&(O(u.x),l(u.y)),u.type&_.CURVE_TO){O(u.x),l(u.y);for(var T=0,v=p(e,u.x1,u.x2,u.x);T<v.length;T++){0<(w=v[T])&&1>w&&O(m(e,u.x1,u.x2,u.x,w))}for(var f=0,N=p(n,u.y1,u.y2,u.y);f<N.length;f++){0<(w=N[f])&&1>w&&l(m(n,u.y1,u.y2,u.y,w))}}if(u.type&_.ARC){O(u.x),l(u.y),o(u,e,n);for(var x=u.xRot/180*Math.PI,d=Math.cos(x)*u.rX,E=Math.sin(x)*u.rX,A=-Math.sin(x)*u.rY,C=Math.cos(x)*u.rY,M=u.phi1<u.phi2?[u.phi1,u.phi2]:-180>u.phi2?[u.phi2+360,u.phi1+360]:[u.phi2,u.phi1],R=M[0],g=M[1],I=function(t){var r=t[0],e=t[1],i=180*Math.atan2(e,r)/Math.PI;return i<R?i+360:i},S=0,L=s(A,-d,0).map(I);S<L.length;S++){(w=L[S])>R&&w<g&&O(y(u.cX,d,A,w))}for(var H=0,U=s(C,-E,0).map(I);H<U.length;H++){var w;(w=U[H])>R&&w<g&&l(y(u.cY,E,C,w))}}return r}));return c.minX=1/0,c.maxX=-1/0,c.minY=1/0,c.maxY=-1/0,c}}(u||(u={}));var O,l=function(){function t(){}return t.prototype.round=function(t){return this.transform(u.ROUND(t))},t.prototype.toAbs=function(){return this.transform(u.TO_ABS())},t.prototype.toRel=function(){return this.transform(u.TO_REL())},t.prototype.normalizeHVZ=function(t,r,e){return this.transform(u.NORMALIZE_HVZ(t,r,e))},t.prototype.normalizeST=function(){return this.transform(u.NORMALIZE_ST())},t.prototype.qtToC=function(){return this.transform(u.QT_TO_C())},t.prototype.aToC=function(){return this.transform(u.A_TO_C())},t.prototype.sanitize=function(t){return this.transform(u.SANITIZE(t))},t.prototype.translate=function(t,r){return this.transform(u.TRANSLATE(t,r))},t.prototype.scale=function(t,r){return this.transform(u.SCALE(t,r))},t.prototype.rotate=function(t,r,e){return this.transform(u.ROTATE(t,r,e))},t.prototype.matrix=function(t,r,e,i,a,n){return this.transform(u.MATRIX(t,r,e,i,a,n))},t.prototype.skewX=function(t){return this.transform(u.SKEW_X(t))},t.prototype.skewY=function(t){return this.transform(u.SKEW_Y(t))},t.prototype.xSymmetry=function(t){return this.transform(u.X_AXIS_SYMMETRY(t))},t.prototype.ySymmetry=function(t){return this.transform(u.Y_AXIS_SYMMETRY(t))},t.prototype.annotateArcs=function(){return this.transform(u.ANNOTATE_ARCS())},t}(),T=function(t){return\" \"===t||\"\\t\"===t||\"\\r\"===t||\"\\n\"===t},v=function(t){return\"0\".charCodeAt(0)<=t.charCodeAt(0)&&t.charCodeAt(0)<=\"9\".charCodeAt(0)},f=function(t){function e(){var r=t.call(this)||this;return r.curNumber=\"\",r.curCommandType=-1,r.curCommandRelative=!1,r.canParseCommandOrComma=!0,r.curNumberHasExp=!1,r.curNumberHasExpDigits=!1,r.curNumberHasDecimal=!1,r.curArgs=[],r}return r(e,t),e.prototype.finish=function(t){if(void 0===t&&(t=[]),this.parse(\" \",t),0!==this.curArgs.length||!this.canParseCommandOrComma)throw new SyntaxError(\"Unterminated command at the path end.\");return t},e.prototype.parse=function(t,r){var e=this;void 0===r&&(r=[]);for(var i=function(t){r.push(t),e.curArgs.length=0,e.canParseCommandOrComma=!0},a=0;a<t.length;a++){var n=t[a],o=!(this.curCommandType!==_.ARC||3!==this.curArgs.length&&4!==this.curArgs.length||1!==this.curNumber.length||\"0\"!==this.curNumber&&\"1\"!==this.curNumber),s=v(n)&&(\"0\"===this.curNumber&&\"0\"===n||o);if(!v(n)||s)if(\"e\"!==n&&\"E\"!==n)if(\"-\"!==n&&\"+\"!==n||!this.curNumberHasExp||this.curNumberHasExpDigits)if(\".\"!==n||this.curNumberHasExp||this.curNumberHasDecimal||o){if(this.curNumber&&-1!==this.curCommandType){var u=Number(this.curNumber);if(isNaN(u))throw new SyntaxError(\"Invalid number ending at \"+a);if(this.curCommandType===_.ARC)if(0===this.curArgs.length||1===this.curArgs.length){if(0>u)throw new SyntaxError('Expected positive number, got \"'+u+'\" at index \"'+a+'\"')}else if((3===this.curArgs.length||4===this.curArgs.length)&&\"0\"!==this.curNumber&&\"1\"!==this.curNumber)throw new SyntaxError('Expected a flag, got \"'+this.curNumber+'\" at index \"'+a+'\"');this.curArgs.push(u),this.curArgs.length===N[this.curCommandType]&&(_.HORIZ_LINE_TO===this.curCommandType?i({type:_.HORIZ_LINE_TO,relative:this.curCommandRelative,x:u}):_.VERT_LINE_TO===this.curCommandType?i({type:_.VERT_LINE_TO,relative:this.curCommandRelative,y:u}):this.curCommandType===_.MOVE_TO||this.curCommandType===_.LINE_TO||this.curCommandType===_.SMOOTH_QUAD_TO?(i({type:this.curCommandType,relative:this.curCommandRelative,x:this.curArgs[0],y:this.curArgs[1]}),_.MOVE_TO===this.curCommandType&&(this.curCommandType=_.LINE_TO)):this.curCommandType===_.CURVE_TO?i({type:_.CURVE_TO,relative:this.curCommandRelative,x1:this.curArgs[0],y1:this.curArgs[1],x2:this.curArgs[2],y2:this.curArgs[3],x:this.curArgs[4],y:this.curArgs[5]}):this.curCommandType===_.SMOOTH_CURVE_TO?i({type:_.SMOOTH_CURVE_TO,relative:this.curCommandRelative,x2:this.curArgs[0],y2:this.curArgs[1],x:this.curArgs[2],y:this.curArgs[3]}):this.curCommandType===_.QUAD_TO?i({type:_.QUAD_TO,relative:this.curCommandRelative,x1:this.curArgs[0],y1:this.curArgs[1],x:this.curArgs[2],y:this.curArgs[3]}):this.curCommandType===_.ARC&&i({type:_.ARC,relative:this.curCommandRelative,rX:this.curArgs[0],rY:this.curArgs[1],xRot:this.curArgs[2],lArcFlag:this.curArgs[3],sweepFlag:this.curArgs[4],x:this.curArgs[5],y:this.curArgs[6]})),this.curNumber=\"\",this.curNumberHasExpDigits=!1,this.curNumberHasExp=!1,this.curNumberHasDecimal=!1,this.canParseCommandOrComma=!0}if(!T(n))if(\",\"===n&&this.canParseCommandOrComma)this.canParseCommandOrComma=!1;else if(\"+\"!==n&&\"-\"!==n&&\".\"!==n)if(s)this.curNumber=n,this.curNumberHasDecimal=!1;else{if(0!==this.curArgs.length)throw new SyntaxError(\"Unterminated command at index \"+a+\".\");if(!this.canParseCommandOrComma)throw new SyntaxError('Unexpected character \"'+n+'\" at index '+a+\". Command cannot follow comma\");if(this.canParseCommandOrComma=!1,\"z\"!==n&&\"Z\"!==n)if(\"h\"===n||\"H\"===n)this.curCommandType=_.HORIZ_LINE_TO,this.curCommandRelative=\"h\"===n;else if(\"v\"===n||\"V\"===n)this.curCommandType=_.VERT_LINE_TO,this.curCommandRelative=\"v\"===n;else if(\"m\"===n||\"M\"===n)this.curCommandType=_.MOVE_TO,this.curCommandRelative=\"m\"===n;else if(\"l\"===n||\"L\"===n)this.curCommandType=_.LINE_TO,this.curCommandRelative=\"l\"===n;else if(\"c\"===n||\"C\"===n)this.curCommandType=_.CURVE_TO,this.curCommandRelative=\"c\"===n;else if(\"s\"===n||\"S\"===n)this.curCommandType=_.SMOOTH_CURVE_TO,this.curCommandRelative=\"s\"===n;else if(\"q\"===n||\"Q\"===n)this.curCommandType=_.QUAD_TO,this.curCommandRelative=\"q\"===n;else if(\"t\"===n||\"T\"===n)this.curCommandType=_.SMOOTH_QUAD_TO,this.curCommandRelative=\"t\"===n;else{if(\"a\"!==n&&\"A\"!==n)throw new SyntaxError('Unexpected character \"'+n+'\" at index '+a+\".\");this.curCommandType=_.ARC,this.curCommandRelative=\"a\"===n}else r.push({type:_.CLOSE_PATH}),this.canParseCommandOrComma=!0,this.curCommandType=-1}else this.curNumber=n,this.curNumberHasDecimal=\".\"===n}else this.curNumber+=n,this.curNumberHasDecimal=!0;else this.curNumber+=n;else this.curNumber+=n,this.curNumberHasExp=!0;else this.curNumber+=n,this.curNumberHasExpDigits=this.curNumberHasExp}return r},e.prototype.transform=function(t){return Object.create(this,{parse:{value:function(r,e){void 0===e&&(e=[]);for(var i=0,a=Object.getPrototypeOf(this).parse.call(this,r);i<a.length;i++){var n=a[i],o=t(n);Array.isArray(o)?e.push.apply(e,o):e.push(o)}return e}}})},e}(l),_=function(t){function i(r){var e=t.call(this)||this;return e.commands=\"string\"==typeof r?i.parse(r):r,e}return r(i,t),i.prototype.encode=function(){return i.encode(this.commands)},i.prototype.getBounds=function(){var t=u.CALCULATE_BOUNDS();return this.transform(t),t},i.prototype.transform=function(t){for(var r=[],e=0,i=this.commands;e<i.length;e++){var a=t(i[e]);Array.isArray(a)?r.push.apply(r,a):r.push(a)}return this.commands=r,this},i.encode=function(t){return e(t)},i.parse=function(t){var r=new f,e=[];return r.parse(t,e),r.finish(e),e},i.CLOSE_PATH=1,i.MOVE_TO=2,i.HORIZ_LINE_TO=4,i.VERT_LINE_TO=8,i.LINE_TO=16,i.CURVE_TO=32,i.SMOOTH_CURVE_TO=64,i.QUAD_TO=128,i.SMOOTH_QUAD_TO=256,i.ARC=512,i.LINE_COMMANDS=i.LINE_TO|i.HORIZ_LINE_TO|i.VERT_LINE_TO,i.DRAWING_COMMANDS=i.HORIZ_LINE_TO|i.VERT_LINE_TO|i.LINE_TO|i.CURVE_TO|i.SMOOTH_CURVE_TO|i.QUAD_TO|i.SMOOTH_QUAD_TO|i.ARC,i}(l),N=((O={})[_.MOVE_TO]=2,O[_.LINE_TO]=2,O[_.HORIZ_LINE_TO]=1,O[_.VERT_LINE_TO]=1,O[_.CLOSE_PATH]=0,O[_.QUAD_TO]=4,O[_.SMOOTH_QUAD_TO]=2,O[_.CURVE_TO]=6,O[_.SMOOTH_CURVE_TO]=4,O[_.ARC]=7,O);\n//# sourceMappingURL=SVGPathData.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdmctcGF0aGRhdGEvbGliL1NWR1BhdGhEYXRhLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQyxhQUFhLGdDQUFnQyxjQUFjLGdCQUFnQixzRUFBc0UsUUFBUSxnQkFBZ0Isd0hBQXdILGFBQWEsbUJBQW1CLDZFQUE2RSxjQUFjLFNBQVMsMEJBQTBCLFlBQVksV0FBVyxLQUFLLFdBQVcsZ0NBQWdDLDZEQUE2RCw0REFBNEQsK0RBQStELCtEQUErRCxvR0FBb0cseUZBQXlGLGlGQUFpRixzRUFBc0UsS0FBSywwRkFBMEYscUdBQXFHLFNBQVMsZ0JBQWdCLGtCQUFrQixnRUFBZ0UsYUFBYSxpQkFBaUIsbUJBQW1CLHNCQUFzQixZQUFZLFdBQVcsZ0lBQWdJLFNBQVMsY0FBYyxrQkFBa0IsOERBQThELDhCQUE4QixrQ0FBa0MsaUhBQWlILHFEQUFxRCxzTUFBc00sb09BQW9PLGtCQUFrQixTQUFTLGtCQUFrQixnQkFBZ0IsK0NBQStDLG1CQUFtQiw0RkFBNEYsb0JBQW9CLGtCQUFrQixrQkFBa0Isb0JBQW9CLGlEQUFpRCxvQkFBb0IseURBQXlELDRDQUE0QyxxQkFBcUIsY0FBYyxpQkFBaUIscUJBQXFCLG1CQUFtQixzQkFBc0IsWUFBWSxzQkFBc0IsVUFBVSxtREFBbUQsYUFBYSxhQUFhLDBCQUEwQix1TEFBdUwsR0FBRyxhQUFhLDRCQUE0QiwwQkFBMEIsOGFBQThhLEdBQUcsYUFBYSxnQkFBZ0IsMEJBQTBCLG1KQUFtSixrREFBa0Qsa0JBQWtCLGdIQUFnSCxpQkFBaUIsU0FBUyxHQUFHLGNBQWMsd0JBQXdCLG1CQUFtQixnRkFBZ0YsbUJBQW1CLG1KQUFtSix3QkFBd0IsMkNBQTJDLDRGQUE0RixjQUFjLFdBQVcsK1hBQStYLGNBQWMsc0pBQXNKLEtBQUsscVFBQXFRLHFIQUFxSCxnRUFBZ0UsR0FBRyxhQUFhLG1CQUFtQixTQUFTLHlCQUF5QixVQUFVLG9CQUFvQixjQUFjLHlCQUF5Qiw2Q0FBNkMsb1BBQW9QLGdDQUFnQywwQkFBMEIsdUxBQXVMLEdBQUcsaUNBQWlDLHVGQUF1RixnRkFBZ0YsaVdBQWlXLEdBQUcsOERBQThELHVCQUF1Qiw0QkFBNEIsOEJBQThCLDRCQUE0Qiw2ZEFBNmQsZ0ZBQWdGLDBHQUEwRyxvRkFBb0YsNkRBQTZELGdFQUFnRSxHQUFHLHFDQUFxQyw2Q0FBNkMsZ0NBQWdDLHVDQUF1QywyQkFBMkIsK0NBQStDLHVCQUF1QiwrQ0FBK0Msc0JBQXNCLHNDQUFzQyxzQkFBc0Isc0NBQXNDLCtCQUErQiw4Q0FBOEMsK0JBQStCLDhDQUE4QyxxQkFBcUIsMEJBQTBCLHNDQUFzQyxZQUFZLGVBQWUsMkdBQTJHLElBQUksS0FBSyxvUUFBb1EsTUFBTSxxQ0FBcUMsb0JBQW9CLDhDQUE4Qyx1QkFBdUIscU5BQXFOLFNBQVMsb0NBQW9DLEdBQUcsNEJBQTRCLDBCQUEwQix3REFBd0QsR0FBRyx5Q0FBeUMsa0JBQWtCLFNBQVMseUJBQXlCLFNBQVMsd0NBQXdDLG9CQUFvQixjQUFjLDBDQUEwQyxjQUFjLDBDQUEwQyw0SkFBNEosY0FBYyxpQ0FBaUMsV0FBVyxLQUFLLHlDQUF5QyxpQ0FBaUMsV0FBVyxLQUFLLDBDQUEwQyxpQkFBaUIsdUJBQXVCLDBOQUEwTixnREFBZ0QsbUJBQW1CLHdCQUF3QixXQUFXLEtBQUssa0NBQWtDLCtCQUErQixXQUFXLEtBQUssTUFBTSxtQ0FBbUMsU0FBUyxHQUFHLHdEQUF3RCxTQUFTLEdBQUcsbUJBQW1CLGNBQWMscUNBQXFDLGtDQUFrQyw4QkFBOEIsa0NBQWtDLDhCQUE4QixrQ0FBa0MsMENBQTBDLDhDQUE4QyxvQ0FBb0Msd0NBQXdDLDhCQUE4QixtQ0FBbUMsNkJBQTZCLGtDQUFrQyxrQ0FBa0MscUNBQXFDLHFDQUFxQyx3Q0FBd0MsaUNBQWlDLG9DQUFvQyxvQ0FBb0MsdUNBQXVDLDBDQUEwQyw2Q0FBNkMsK0JBQStCLG1DQUFtQywrQkFBK0IsbUNBQW1DLG1DQUFtQyw0Q0FBNEMsbUNBQW1DLDRDQUE0QyxxQ0FBcUMseUNBQXlDLEdBQUcsaUJBQWlCLDRDQUE0QyxlQUFlLDZFQUE2RSxlQUFlLGFBQWEseUJBQXlCLHNMQUFzTCw2Q0FBNkMsNkpBQTZKLFNBQVMsaUNBQWlDLFdBQVcsbUJBQW1CLHNCQUFzQix5REFBeUQsS0FBSyxXQUFXLEtBQUssZ05BQWdOLHNLQUFzSyw2Q0FBNkMsNkJBQTZCLGlFQUFpRSxvRkFBb0YsdUZBQXVGLDJMQUEyTCw2R0FBNkcsMERBQTBELDBDQUEwQyx5REFBeUQsK0dBQStHLDhGQUE4Rix3R0FBd0csaUtBQWlLLDZDQUE2QyxrSUFBa0kscUNBQXFDLDBIQUEwSCxrQ0FBa0MsOExBQThMLHNJQUFzSSxnRkFBZ0Ysb0ZBQW9GLEtBQUsseUZBQXlGLGtJQUFrSSwySUFBMkksNEZBQTRGLHVGQUF1Rix1RkFBdUYsd0ZBQXdGLCtGQUErRix1RkFBdUYsOEZBQThGLEtBQUssMEZBQTBGLDBEQUEwRCxhQUFhLGtCQUFrQix3REFBd0QsdURBQXVELG1EQUFtRCx1QkFBdUIsK0NBQStDLHVFQUF1RSxTQUFTLG1DQUFtQywyQkFBMkIsT0FBTyxvQkFBb0IsbUJBQW1CLDZEQUE2RCxXQUFXLEtBQUssa0JBQWtCLDZDQUE2QyxXQUFXLEVBQUUsR0FBRyxrQkFBa0IsY0FBYyx5QkFBeUIsb0RBQW9ELDRDQUE0QywrQkFBK0Isa0NBQWtDLDJCQUEyQiwyQkFBMkIsbUNBQW1DLGlDQUFpQyxXQUFXLEtBQUssY0FBYyw2Q0FBNkMsNEJBQTRCLHNCQUFzQixZQUFZLHFCQUFxQixpQkFBaUIsa0NBQWtDLGlWQUFpVixZQUFZLG1MQUEwUztBQUNoempCIiwic291cmNlcyI6WyIvYXBwL25vZGVfbW9kdWxlcy9zdmctcGF0aGRhdGEvbGliL1NWR1BhdGhEYXRhLm1vZHVsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbnZhciB0PWZ1bmN0aW9uKHIsZSl7cmV0dXJuKHQ9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQscil7dC5fX3Byb3RvX189cn18fGZ1bmN0aW9uKHQscil7Zm9yKHZhciBlIGluIHIpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsZSkmJih0W2VdPXJbZV0pfSkocixlKX07ZnVuY3Rpb24gcihyLGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiK1N0cmluZyhlKStcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO2Z1bmN0aW9uIGkoKXt0aGlzLmNvbnN0cnVjdG9yPXJ9dChyLGUpLHIucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KGkucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyBpKX1mdW5jdGlvbiBlKHQpe3ZhciByPVwiXCI7QXJyYXkuaXNBcnJheSh0KXx8KHQ9W3RdKTtmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKyl7dmFyIGk9dFtlXTtpZihpLnR5cGU9PT1fLkNMT1NFX1BBVEgpcis9XCJ6XCI7ZWxzZSBpZihpLnR5cGU9PT1fLkhPUklaX0xJTkVfVE8pcis9KGkucmVsYXRpdmU/XCJoXCI6XCJIXCIpK2kueDtlbHNlIGlmKGkudHlwZT09PV8uVkVSVF9MSU5FX1RPKXIrPShpLnJlbGF0aXZlP1widlwiOlwiVlwiKStpLnk7ZWxzZSBpZihpLnR5cGU9PT1fLk1PVkVfVE8pcis9KGkucmVsYXRpdmU/XCJtXCI6XCJNXCIpK2kueCtcIiBcIitpLnk7ZWxzZSBpZihpLnR5cGU9PT1fLkxJTkVfVE8pcis9KGkucmVsYXRpdmU/XCJsXCI6XCJMXCIpK2kueCtcIiBcIitpLnk7ZWxzZSBpZihpLnR5cGU9PT1fLkNVUlZFX1RPKXIrPShpLnJlbGF0aXZlP1wiY1wiOlwiQ1wiKStpLngxK1wiIFwiK2kueTErXCIgXCIraS54MitcIiBcIitpLnkyK1wiIFwiK2kueCtcIiBcIitpLnk7ZWxzZSBpZihpLnR5cGU9PT1fLlNNT09USF9DVVJWRV9UTylyKz0oaS5yZWxhdGl2ZT9cInNcIjpcIlNcIikraS54MitcIiBcIitpLnkyK1wiIFwiK2kueCtcIiBcIitpLnk7ZWxzZSBpZihpLnR5cGU9PT1fLlFVQURfVE8pcis9KGkucmVsYXRpdmU/XCJxXCI6XCJRXCIpK2kueDErXCIgXCIraS55MStcIiBcIitpLngrXCIgXCIraS55O2Vsc2UgaWYoaS50eXBlPT09Xy5TTU9PVEhfUVVBRF9UTylyKz0oaS5yZWxhdGl2ZT9cInRcIjpcIlRcIikraS54K1wiIFwiK2kueTtlbHNle2lmKGkudHlwZSE9PV8uQVJDKXRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBjb21tYW5kIHR5cGUgXCInK2kudHlwZSsnXCIgYXQgaW5kZXggJytlK1wiLlwiKTtyKz0oaS5yZWxhdGl2ZT9cImFcIjpcIkFcIikraS5yWCtcIiBcIitpLnJZK1wiIFwiK2kueFJvdCtcIiBcIisgK2kubEFyY0ZsYWcrXCIgXCIrICtpLnN3ZWVwRmxhZytcIiBcIitpLngrXCIgXCIraS55fX1yZXR1cm4gcn1mdW5jdGlvbiBpKHQscil7dmFyIGU9dFswXSxpPXRbMV07cmV0dXJuW2UqTWF0aC5jb3MociktaSpNYXRoLnNpbihyKSxlKk1hdGguc2luKHIpK2kqTWF0aC5jb3MocildfWZ1bmN0aW9uIGEoKXtmb3IodmFyIHQ9W10scj0wO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspdFtyXT1hcmd1bWVudHNbcl07Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKyspaWYoXCJudW1iZXJcIiE9dHlwZW9mIHRbZV0pdGhyb3cgbmV3IEVycm9yKFwiYXNzZXJ0TnVtYmVycyBhcmd1bWVudHNbXCIrZStcIl0gaXMgbm90IGEgbnVtYmVyLiBcIit0eXBlb2YgdFtlXStcIiA9PSB0eXBlb2YgXCIrdFtlXSk7cmV0dXJuITB9dmFyIG49TWF0aC5QSTtmdW5jdGlvbiBvKHQscixlKXt0LmxBcmNGbGFnPTA9PT10LmxBcmNGbGFnPzA6MSx0LnN3ZWVwRmxhZz0wPT09dC5zd2VlcEZsYWc/MDoxO3ZhciBhPXQuclgsbz10LnJZLHM9dC54LHU9dC55O2E9TWF0aC5hYnModC5yWCksbz1NYXRoLmFicyh0LnJZKTt2YXIgaD1pKFsoci1zKS8yLChlLXUpLzJdLC10LnhSb3QvMTgwKm4pLGM9aFswXSx5PWhbMV0scD1NYXRoLnBvdyhjLDIpL01hdGgucG93KGEsMikrTWF0aC5wb3coeSwyKS9NYXRoLnBvdyhvLDIpOzE8cCYmKGEqPU1hdGguc3FydChwKSxvKj1NYXRoLnNxcnQocCkpLHQuclg9YSx0LnJZPW87dmFyIG09TWF0aC5wb3coYSwyKSpNYXRoLnBvdyh5LDIpK01hdGgucG93KG8sMikqTWF0aC5wb3coYywyKSxPPSh0LmxBcmNGbGFnIT09dC5zd2VlcEZsYWc/MTotMSkqTWF0aC5zcXJ0KE1hdGgubWF4KDAsKE1hdGgucG93KGEsMikqTWF0aC5wb3cobywyKS1tKS9tKSksbD1hKnkvbypPLFQ9LW8qYy9hKk8sdj1pKFtsLFRdLHQueFJvdC8xODAqbik7dC5jWD12WzBdKyhyK3MpLzIsdC5jWT12WzFdKyhlK3UpLzIsdC5waGkxPU1hdGguYXRhbjIoKHktVCkvbywoYy1sKS9hKSx0LnBoaTI9TWF0aC5hdGFuMigoLXktVCkvbywoLWMtbCkvYSksMD09PXQuc3dlZXBGbGFnJiZ0LnBoaTI+dC5waGkxJiYodC5waGkyLT0yKm4pLDE9PT10LnN3ZWVwRmxhZyYmdC5waGkyPHQucGhpMSYmKHQucGhpMis9MipuKSx0LnBoaTEqPTE4MC9uLHQucGhpMio9MTgwL259ZnVuY3Rpb24gcyh0LHIsZSl7YSh0LHIsZSk7dmFyIGk9dCp0K3Iqci1lKmU7aWYoMD5pKXJldHVybltdO2lmKDA9PT1pKXJldHVybltbdCplLyh0KnQrcipyKSxyKmUvKHQqdCtyKnIpXV07dmFyIG49TWF0aC5zcXJ0KGkpO3JldHVybltbKHQqZStyKm4pLyh0KnQrcipyKSwociplLXQqbikvKHQqdCtyKnIpXSxbKHQqZS1yKm4pLyh0KnQrcipyKSwociplK3QqbikvKHQqdCtyKnIpXV19dmFyIHUsaD1NYXRoLlBJLzE4MDtmdW5jdGlvbiBjKHQscixlKXtyZXR1cm4oMS1lKSp0K2Uqcn1mdW5jdGlvbiB5KHQscixlLGkpe3JldHVybiB0K01hdGguY29zKGkvMTgwKm4pKnIrTWF0aC5zaW4oaS8xODAqbikqZX1mdW5jdGlvbiBwKHQscixlLGkpe3ZhciBhPTFlLTYsbj1yLXQsbz1lLXIscz0zKm4rMyooaS1lKS02Km8sdT02KihvLW4pLGg9MypuO3JldHVybiBNYXRoLmFicyhzKTxhP1staC91XTpmdW5jdGlvbih0LHIsZSl7dm9pZCAwPT09ZSYmKGU9MWUtNik7dmFyIGk9dCp0LzQtcjtpZihpPC1lKXJldHVybltdO2lmKGk8PWUpcmV0dXJuWy10LzJdO3ZhciBhPU1hdGguc3FydChpKTtyZXR1cm5bLXQvMi1hLC10LzIrYV19KHUvcyxoL3MsYSl9ZnVuY3Rpb24gbSh0LHIsZSxpLGEpe3ZhciBuPTEtYTtyZXR1cm4gdCoobipuKm4pK3IqKDMqbipuKmEpK2UqKDMqbiphKmEpK2kqKGEqYSphKX0hZnVuY3Rpb24odCl7ZnVuY3Rpb24gcigpe3JldHVybiB1KChmdW5jdGlvbih0LHIsZSl7cmV0dXJuIHQucmVsYXRpdmUmJih2b2lkIDAhPT10LngxJiYodC54MSs9ciksdm9pZCAwIT09dC55MSYmKHQueTErPWUpLHZvaWQgMCE9PXQueDImJih0LngyKz1yKSx2b2lkIDAhPT10LnkyJiYodC55Mis9ZSksdm9pZCAwIT09dC54JiYodC54Kz1yKSx2b2lkIDAhPT10LnkmJih0LnkrPWUpLHQucmVsYXRpdmU9ITEpLHR9KSl9ZnVuY3Rpb24gZSgpe3ZhciB0PU5hTixyPU5hTixlPU5hTixpPU5hTjtyZXR1cm4gdSgoZnVuY3Rpb24oYSxuLG8pe3JldHVybiBhLnR5cGUmXy5TTU9PVEhfQ1VSVkVfVE8mJihhLnR5cGU9Xy5DVVJWRV9UTyx0PWlzTmFOKHQpP246dCxyPWlzTmFOKHIpP286cixhLngxPWEucmVsYXRpdmU/bi10OjIqbi10LGEueTE9YS5yZWxhdGl2ZT9vLXI6MipvLXIpLGEudHlwZSZfLkNVUlZFX1RPPyh0PWEucmVsYXRpdmU/bithLngyOmEueDIscj1hLnJlbGF0aXZlP28rYS55MjphLnkyKToodD1OYU4scj1OYU4pLGEudHlwZSZfLlNNT09USF9RVUFEX1RPJiYoYS50eXBlPV8uUVVBRF9UTyxlPWlzTmFOKGUpP246ZSxpPWlzTmFOKGkpP286aSxhLngxPWEucmVsYXRpdmU/bi1lOjIqbi1lLGEueTE9YS5yZWxhdGl2ZT9vLWk6MipvLWkpLGEudHlwZSZfLlFVQURfVE8/KGU9YS5yZWxhdGl2ZT9uK2EueDE6YS54MSxpPWEucmVsYXRpdmU/bythLnkxOmEueTEpOihlPU5hTixpPU5hTiksYX0pKX1mdW5jdGlvbiBuKCl7dmFyIHQ9TmFOLHI9TmFOO3JldHVybiB1KChmdW5jdGlvbihlLGksYSl7aWYoZS50eXBlJl8uU01PT1RIX1FVQURfVE8mJihlLnR5cGU9Xy5RVUFEX1RPLHQ9aXNOYU4odCk/aTp0LHI9aXNOYU4ocik/YTpyLGUueDE9ZS5yZWxhdGl2ZT9pLXQ6MippLXQsZS55MT1lLnJlbGF0aXZlP2EtcjoyKmEtciksZS50eXBlJl8uUVVBRF9UTyl7dD1lLnJlbGF0aXZlP2krZS54MTplLngxLHI9ZS5yZWxhdGl2ZT9hK2UueTE6ZS55MTt2YXIgbj1lLngxLG89ZS55MTtlLnR5cGU9Xy5DVVJWRV9UTyxlLngxPSgoZS5yZWxhdGl2ZT8wOmkpKzIqbikvMyxlLnkxPSgoZS5yZWxhdGl2ZT8wOmEpKzIqbykvMyxlLngyPShlLngrMipuKS8zLGUueTI9KGUueSsyKm8pLzN9ZWxzZSB0PU5hTixyPU5hTjtyZXR1cm4gZX0pKX1mdW5jdGlvbiB1KHQpe3ZhciByPTAsZT0wLGk9TmFOLGE9TmFOO3JldHVybiBmdW5jdGlvbihuKXtpZihpc05hTihpKSYmIShuLnR5cGUmXy5NT1ZFX1RPKSl0aHJvdyBuZXcgRXJyb3IoXCJwYXRoIG11c3Qgc3RhcnQgd2l0aCBtb3ZldG9cIik7dmFyIG89dChuLHIsZSxpLGEpO3JldHVybiBuLnR5cGUmXy5DTE9TRV9QQVRIJiYocj1pLGU9YSksdm9pZCAwIT09bi54JiYocj1uLnJlbGF0aXZlP3Irbi54Om4ueCksdm9pZCAwIT09bi55JiYoZT1uLnJlbGF0aXZlP2Urbi55Om4ueSksbi50eXBlJl8uTU9WRV9UTyYmKGk9cixhPWUpLG99fWZ1bmN0aW9uIE8odCxyLGUsaSxuLG8pe3JldHVybiBhKHQscixlLGksbixvKSx1KChmdW5jdGlvbihhLHMsdSxoKXt2YXIgYz1hLngxLHk9YS54MixwPWEucmVsYXRpdmUmJiFpc05hTihoKSxtPXZvaWQgMCE9PWEueD9hLng6cD8wOnMsTz12b2lkIDAhPT1hLnk/YS55OnA/MDp1O2Z1bmN0aW9uIGwodCl7cmV0dXJuIHQqdH1hLnR5cGUmXy5IT1JJWl9MSU5FX1RPJiYwIT09ciYmKGEudHlwZT1fLkxJTkVfVE8sYS55PWEucmVsYXRpdmU/MDp1KSxhLnR5cGUmXy5WRVJUX0xJTkVfVE8mJjAhPT1lJiYoYS50eXBlPV8uTElORV9UTyxhLng9YS5yZWxhdGl2ZT8wOnMpLHZvaWQgMCE9PWEueCYmKGEueD1hLngqdCtPKmUrKHA/MDpuKSksdm9pZCAwIT09YS55JiYoYS55PW0qcithLnkqaSsocD8wOm8pKSx2b2lkIDAhPT1hLngxJiYoYS54MT1hLngxKnQrYS55MSplKyhwPzA6bikpLHZvaWQgMCE9PWEueTEmJihhLnkxPWMqcithLnkxKmkrKHA/MDpvKSksdm9pZCAwIT09YS54MiYmKGEueDI9YS54Mip0K2EueTIqZSsocD8wOm4pKSx2b2lkIDAhPT1hLnkyJiYoYS55Mj15KnIrYS55MippKyhwPzA6bykpO3ZhciBUPXQqaS1yKmU7aWYodm9pZCAwIT09YS54Um90JiYoMSE9PXR8fDAhPT1yfHwwIT09ZXx8MSE9PWkpKWlmKDA9PT1UKWRlbGV0ZSBhLnJYLGRlbGV0ZSBhLnJZLGRlbGV0ZSBhLnhSb3QsZGVsZXRlIGEubEFyY0ZsYWcsZGVsZXRlIGEuc3dlZXBGbGFnLGEudHlwZT1fLkxJTkVfVE87ZWxzZXt2YXIgdj1hLnhSb3QqTWF0aC5QSS8xODAsZj1NYXRoLnNpbih2KSxOPU1hdGguY29zKHYpLHg9MS9sKGEuclgpLGQ9MS9sKGEuclkpLEU9bChOKSp4K2woZikqZCxBPTIqZipOKih4LWQpLEM9bChmKSp4K2woTikqZCxNPUUqaSppLUEqcippK0MqcipyLFI9QSoodCppK3IqZSktMiooRSplKmkrQyp0KnIpLGc9RSplKmUtQSp0KmUrQyp0KnQsST0oTWF0aC5hdGFuMihSLE0tZykrTWF0aC5QSSklTWF0aC5QSS8yLFM9TWF0aC5zaW4oSSksTD1NYXRoLmNvcyhJKTthLnJYPU1hdGguYWJzKFQpL01hdGguc3FydChNKmwoTCkrUipTKkwrZypsKFMpKSxhLnJZPU1hdGguYWJzKFQpL01hdGguc3FydChNKmwoUyktUipTKkwrZypsKEwpKSxhLnhSb3Q9MTgwKkkvTWF0aC5QSX1yZXR1cm4gdm9pZCAwIT09YS5zd2VlcEZsYWcmJjA+VCYmKGEuc3dlZXBGbGFnPSshYS5zd2VlcEZsYWcpLGF9KSl9ZnVuY3Rpb24gbCgpe3JldHVybiBmdW5jdGlvbih0KXt2YXIgcj17fTtmb3IodmFyIGUgaW4gdClyW2VdPXRbZV07cmV0dXJuIHJ9fXQuUk9VTkQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gcihyKXtyZXR1cm4gTWF0aC5yb3VuZChyKnQpL3R9cmV0dXJuIHZvaWQgMD09PXQmJih0PTFlMTMpLGEodCksZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXQueDEmJih0LngxPXIodC54MSkpLHZvaWQgMCE9PXQueTEmJih0LnkxPXIodC55MSkpLHZvaWQgMCE9PXQueDImJih0LngyPXIodC54MikpLHZvaWQgMCE9PXQueTImJih0LnkyPXIodC55MikpLHZvaWQgMCE9PXQueCYmKHQueD1yKHQueCkpLHZvaWQgMCE9PXQueSYmKHQueT1yKHQueSkpLHZvaWQgMCE9PXQuclgmJih0LnJYPXIodC5yWCkpLHZvaWQgMCE9PXQuclkmJih0LnJZPXIodC5yWSkpLHR9fSx0LlRPX0FCUz1yLHQuVE9fUkVMPWZ1bmN0aW9uKCl7cmV0dXJuIHUoKGZ1bmN0aW9uKHQscixlKXtyZXR1cm4gdC5yZWxhdGl2ZXx8KHZvaWQgMCE9PXQueDEmJih0LngxLT1yKSx2b2lkIDAhPT10LnkxJiYodC55MS09ZSksdm9pZCAwIT09dC54MiYmKHQueDItPXIpLHZvaWQgMCE9PXQueTImJih0LnkyLT1lKSx2b2lkIDAhPT10LngmJih0LngtPXIpLHZvaWQgMCE9PXQueSYmKHQueS09ZSksdC5yZWxhdGl2ZT0hMCksdH0pKX0sdC5OT1JNQUxJWkVfSFZaPWZ1bmN0aW9uKHQscixlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITApLHZvaWQgMD09PXImJihyPSEwKSx2b2lkIDA9PT1lJiYoZT0hMCksdSgoZnVuY3Rpb24oaSxhLG4sbyxzKXtpZihpc05hTihvKSYmIShpLnR5cGUmXy5NT1ZFX1RPKSl0aHJvdyBuZXcgRXJyb3IoXCJwYXRoIG11c3Qgc3RhcnQgd2l0aCBtb3ZldG9cIik7cmV0dXJuIHImJmkudHlwZSZfLkhPUklaX0xJTkVfVE8mJihpLnR5cGU9Xy5MSU5FX1RPLGkueT1pLnJlbGF0aXZlPzA6biksZSYmaS50eXBlJl8uVkVSVF9MSU5FX1RPJiYoaS50eXBlPV8uTElORV9UTyxpLng9aS5yZWxhdGl2ZT8wOmEpLHQmJmkudHlwZSZfLkNMT1NFX1BBVEgmJihpLnR5cGU9Xy5MSU5FX1RPLGkueD1pLnJlbGF0aXZlP28tYTpvLGkueT1pLnJlbGF0aXZlP3MtbjpzKSxpLnR5cGUmXy5BUkMmJigwPT09aS5yWHx8MD09PWkuclkpJiYoaS50eXBlPV8uTElORV9UTyxkZWxldGUgaS5yWCxkZWxldGUgaS5yWSxkZWxldGUgaS54Um90LGRlbGV0ZSBpLmxBcmNGbGFnLGRlbGV0ZSBpLnN3ZWVwRmxhZyksaX0pKX0sdC5OT1JNQUxJWkVfU1Q9ZSx0LlFUX1RPX0M9bix0LklORk89dSx0LlNBTklUSVpFPWZ1bmN0aW9uKHQpe3ZvaWQgMD09PXQmJih0PTApLGEodCk7dmFyIHI9TmFOLGU9TmFOLGk9TmFOLG49TmFOO3JldHVybiB1KChmdW5jdGlvbihhLG8scyx1LGgpe3ZhciBjPU1hdGguYWJzLHk9ITEscD0wLG09MDtpZihhLnR5cGUmXy5TTU9PVEhfQ1VSVkVfVE8mJihwPWlzTmFOKHIpPzA6by1yLG09aXNOYU4oZSk/MDpzLWUpLGEudHlwZSYoXy5DVVJWRV9UT3xfLlNNT09USF9DVVJWRV9UTyk/KHI9YS5yZWxhdGl2ZT9vK2EueDI6YS54MixlPWEucmVsYXRpdmU/cythLnkyOmEueTIpOihyPU5hTixlPU5hTiksYS50eXBlJl8uU01PT1RIX1FVQURfVE8/KGk9aXNOYU4oaSk/bzoyKm8taSxuPWlzTmFOKG4pP3M6MipzLW4pOmEudHlwZSZfLlFVQURfVE8/KGk9YS5yZWxhdGl2ZT9vK2EueDE6YS54MSxuPWEucmVsYXRpdmU/cythLnkxOmEueTIpOihpPU5hTixuPU5hTiksYS50eXBlJl8uTElORV9DT01NQU5EU3x8YS50eXBlJl8uQVJDJiYoMD09PWEuclh8fDA9PT1hLnJZfHwhYS5sQXJjRmxhZyl8fGEudHlwZSZfLkNVUlZFX1RPfHxhLnR5cGUmXy5TTU9PVEhfQ1VSVkVfVE98fGEudHlwZSZfLlFVQURfVE98fGEudHlwZSZfLlNNT09USF9RVUFEX1RPKXt2YXIgTz12b2lkIDA9PT1hLng/MDphLnJlbGF0aXZlP2EueDphLngtbyxsPXZvaWQgMD09PWEueT8wOmEucmVsYXRpdmU/YS55OmEueS1zO3A9aXNOYU4oaSk/dm9pZCAwPT09YS54MT9wOmEucmVsYXRpdmU/YS54OmEueDEtbzppLW8sbT1pc05hTihuKT92b2lkIDA9PT1hLnkxP206YS5yZWxhdGl2ZT9hLnk6YS55MS1zOm4tczt2YXIgVD12b2lkIDA9PT1hLngyPzA6YS5yZWxhdGl2ZT9hLng6YS54Mi1vLHY9dm9pZCAwPT09YS55Mj8wOmEucmVsYXRpdmU/YS55OmEueTItcztjKE8pPD10JiZjKGwpPD10JiZjKHApPD10JiZjKG0pPD10JiZjKFQpPD10JiZjKHYpPD10JiYoeT0hMCl9cmV0dXJuIGEudHlwZSZfLkNMT1NFX1BBVEgmJmMoby11KTw9dCYmYyhzLWgpPD10JiYoeT0hMCkseT9bXTphfSkpfSx0Lk1BVFJJWD1PLHQuUk9UQVRFPWZ1bmN0aW9uKHQscixlKXt2b2lkIDA9PT1yJiYocj0wKSx2b2lkIDA9PT1lJiYoZT0wKSxhKHQscixlKTt2YXIgaT1NYXRoLnNpbih0KSxuPU1hdGguY29zKHQpO3JldHVybiBPKG4saSwtaSxuLHItcipuK2UqaSxlLXIqaS1lKm4pfSx0LlRSQU5TTEFURT1mdW5jdGlvbih0LHIpe3JldHVybiB2b2lkIDA9PT1yJiYocj0wKSxhKHQsciksTygxLDAsMCwxLHQscil9LHQuU0NBTEU9ZnVuY3Rpb24odCxyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9dCksYSh0LHIpLE8odCwwLDAsciwwLDApfSx0LlNLRVdfWD1mdW5jdGlvbih0KXtyZXR1cm4gYSh0KSxPKDEsMCxNYXRoLmF0YW4odCksMSwwLDApfSx0LlNLRVdfWT1mdW5jdGlvbih0KXtyZXR1cm4gYSh0KSxPKDEsTWF0aC5hdGFuKHQpLDAsMSwwLDApfSx0LlhfQVhJU19TWU1NRVRSWT1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksYSh0KSxPKC0xLDAsMCwxLHQsMCl9LHQuWV9BWElTX1NZTU1FVFJZPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSxhKHQpLE8oMSwwLDAsLTEsMCx0KX0sdC5BX1RPX0M9ZnVuY3Rpb24oKXtyZXR1cm4gdSgoZnVuY3Rpb24odCxyLGUpe3JldHVybiBfLkFSQz09PXQudHlwZT9mdW5jdGlvbih0LHIsZSl7dmFyIGEsbixzLHU7dC5jWHx8byh0LHIsZSk7Zm9yKHZhciB5PU1hdGgubWluKHQucGhpMSx0LnBoaTIpLHA9TWF0aC5tYXgodC5waGkxLHQucGhpMikteSxtPU1hdGguY2VpbChwLzkwKSxPPW5ldyBBcnJheShtKSxsPXIsVD1lLHY9MDt2PG07disrKXt2YXIgZj1jKHQucGhpMSx0LnBoaTIsdi9tKSxOPWModC5waGkxLHQucGhpMiwodisxKS9tKSx4PU4tZixkPTQvMypNYXRoLnRhbih4KmgvNCksRT1bTWF0aC5jb3MoZipoKS1kKk1hdGguc2luKGYqaCksTWF0aC5zaW4oZipoKStkKk1hdGguY29zKGYqaCldLEE9RVswXSxDPUVbMV0sTT1bTWF0aC5jb3MoTipoKSxNYXRoLnNpbihOKmgpXSxSPU1bMF0sZz1NWzFdLEk9W1IrZCpNYXRoLnNpbihOKmgpLGctZCpNYXRoLmNvcyhOKmgpXSxTPUlbMF0sTD1JWzFdO09bdl09e3JlbGF0aXZlOnQucmVsYXRpdmUsdHlwZTpfLkNVUlZFX1RPfTt2YXIgSD1mdW5jdGlvbihyLGUpe3ZhciBhPWkoW3IqdC5yWCxlKnQuclldLHQueFJvdCksbj1hWzBdLG89YVsxXTtyZXR1cm5bdC5jWCtuLHQuY1krb119O2E9SChBLEMpLE9bdl0ueDE9YVswXSxPW3ZdLnkxPWFbMV0sbj1IKFMsTCksT1t2XS54Mj1uWzBdLE9bdl0ueTI9blsxXSxzPUgoUixnKSxPW3ZdLng9c1swXSxPW3ZdLnk9c1sxXSx0LnJlbGF0aXZlJiYoT1t2XS54MS09bCxPW3ZdLnkxLT1ULE9bdl0ueDItPWwsT1t2XS55Mi09VCxPW3ZdLngtPWwsT1t2XS55LT1UKSxsPSh1PVtPW3ZdLngsT1t2XS55XSlbMF0sVD11WzFdfXJldHVybiBPfSh0LHQucmVsYXRpdmU/MDpyLHQucmVsYXRpdmU/MDplKTp0fSkpfSx0LkFOTk9UQVRFX0FSQ1M9ZnVuY3Rpb24oKXtyZXR1cm4gdSgoZnVuY3Rpb24odCxyLGUpe3JldHVybiB0LnJlbGF0aXZlJiYocj0wLGU9MCksXy5BUkM9PT10LnR5cGUmJm8odCxyLGUpLHR9KSl9LHQuQ0xPTkU9bCx0LkNBTENVTEFURV9CT1VORFM9ZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbih0KXt2YXIgcj17fTtmb3IodmFyIGUgaW4gdClyW2VdPXRbZV07cmV0dXJuIHJ9LGk9cigpLGE9bigpLGg9ZSgpLGM9dSgoZnVuY3Rpb24ocixlLG4pe3ZhciB1PWgoYShpKHQocikpKSk7ZnVuY3Rpb24gTyh0KXt0PmMubWF4WCYmKGMubWF4WD10KSx0PGMubWluWCYmKGMubWluWD10KX1mdW5jdGlvbiBsKHQpe3Q+Yy5tYXhZJiYoYy5tYXhZPXQpLHQ8Yy5taW5ZJiYoYy5taW5ZPXQpfWlmKHUudHlwZSZfLkRSQVdJTkdfQ09NTUFORFMmJihPKGUpLGwobikpLHUudHlwZSZfLkhPUklaX0xJTkVfVE8mJk8odS54KSx1LnR5cGUmXy5WRVJUX0xJTkVfVE8mJmwodS55KSx1LnR5cGUmXy5MSU5FX1RPJiYoTyh1LngpLGwodS55KSksdS50eXBlJl8uQ1VSVkVfVE8pe08odS54KSxsKHUueSk7Zm9yKHZhciBUPTAsdj1wKGUsdS54MSx1LngyLHUueCk7VDx2Lmxlbmd0aDtUKyspezA8KHc9dltUXSkmJjE+dyYmTyhtKGUsdS54MSx1LngyLHUueCx3KSl9Zm9yKHZhciBmPTAsTj1wKG4sdS55MSx1LnkyLHUueSk7ZjxOLmxlbmd0aDtmKyspezA8KHc9TltmXSkmJjE+dyYmbChtKG4sdS55MSx1LnkyLHUueSx3KSl9fWlmKHUudHlwZSZfLkFSQyl7Tyh1LngpLGwodS55KSxvKHUsZSxuKTtmb3IodmFyIHg9dS54Um90LzE4MCpNYXRoLlBJLGQ9TWF0aC5jb3MoeCkqdS5yWCxFPU1hdGguc2luKHgpKnUuclgsQT0tTWF0aC5zaW4oeCkqdS5yWSxDPU1hdGguY29zKHgpKnUuclksTT11LnBoaTE8dS5waGkyP1t1LnBoaTEsdS5waGkyXTotMTgwPnUucGhpMj9bdS5waGkyKzM2MCx1LnBoaTErMzYwXTpbdS5waGkyLHUucGhpMV0sUj1NWzBdLGc9TVsxXSxJPWZ1bmN0aW9uKHQpe3ZhciByPXRbMF0sZT10WzFdLGk9MTgwKk1hdGguYXRhbjIoZSxyKS9NYXRoLlBJO3JldHVybiBpPFI/aSszNjA6aX0sUz0wLEw9cyhBLC1kLDApLm1hcChJKTtTPEwubGVuZ3RoO1MrKyl7KHc9TFtTXSk+UiYmdzxnJiZPKHkodS5jWCxkLEEsdykpfWZvcih2YXIgSD0wLFU9cyhDLC1FLDApLm1hcChJKTtIPFUubGVuZ3RoO0grKyl7dmFyIHc7KHc9VVtIXSk+UiYmdzxnJiZsKHkodS5jWSxFLEMsdykpfX1yZXR1cm4gcn0pKTtyZXR1cm4gYy5taW5YPTEvMCxjLm1heFg9LTEvMCxjLm1pblk9MS8wLGMubWF4WT0tMS8wLGN9fSh1fHwodT17fSkpO3ZhciBPLGw9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5ST1VORCh0KSl9LHQucHJvdG90eXBlLnRvQWJzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhbnNmb3JtKHUuVE9fQUJTKCkpfSx0LnByb3RvdHlwZS50b1JlbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYW5zZm9ybSh1LlRPX1JFTCgpKX0sdC5wcm90b3R5cGUubm9ybWFsaXplSFZaPWZ1bmN0aW9uKHQscixlKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5OT1JNQUxJWkVfSFZaKHQscixlKSl9LHQucHJvdG90eXBlLm5vcm1hbGl6ZVNUPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhbnNmb3JtKHUuTk9STUFMSVpFX1NUKCkpfSx0LnByb3RvdHlwZS5xdFRvQz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYW5zZm9ybSh1LlFUX1RPX0MoKSl9LHQucHJvdG90eXBlLmFUb0M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5BX1RPX0MoKSl9LHQucHJvdG90eXBlLnNhbml0aXplPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRyYW5zZm9ybSh1LlNBTklUSVpFKHQpKX0sdC5wcm90b3R5cGUudHJhbnNsYXRlPWZ1bmN0aW9uKHQscil7cmV0dXJuIHRoaXMudHJhbnNmb3JtKHUuVFJBTlNMQVRFKHQscikpfSx0LnByb3RvdHlwZS5zY2FsZT1mdW5jdGlvbih0LHIpe3JldHVybiB0aGlzLnRyYW5zZm9ybSh1LlNDQUxFKHQscikpfSx0LnByb3RvdHlwZS5yb3RhdGU9ZnVuY3Rpb24odCxyLGUpe3JldHVybiB0aGlzLnRyYW5zZm9ybSh1LlJPVEFURSh0LHIsZSkpfSx0LnByb3RvdHlwZS5tYXRyaXg9ZnVuY3Rpb24odCxyLGUsaSxhLG4pe3JldHVybiB0aGlzLnRyYW5zZm9ybSh1Lk1BVFJJWCh0LHIsZSxpLGEsbikpfSx0LnByb3RvdHlwZS5za2V3WD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5TS0VXX1godCkpfSx0LnByb3RvdHlwZS5za2V3WT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5TS0VXX1kodCkpfSx0LnByb3RvdHlwZS54U3ltbWV0cnk9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudHJhbnNmb3JtKHUuWF9BWElTX1NZTU1FVFJZKHQpKX0sdC5wcm90b3R5cGUueVN5bW1ldHJ5PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRyYW5zZm9ybSh1LllfQVhJU19TWU1NRVRSWSh0KSl9LHQucHJvdG90eXBlLmFubm90YXRlQXJjcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYW5zZm9ybSh1LkFOTk9UQVRFX0FSQ1MoKSl9LHR9KCksVD1mdW5jdGlvbih0KXtyZXR1cm5cIiBcIj09PXR8fFwiXFx0XCI9PT10fHxcIlxcclwiPT09dHx8XCJcXG5cIj09PXR9LHY9ZnVuY3Rpb24odCl7cmV0dXJuXCIwXCIuY2hhckNvZGVBdCgwKTw9dC5jaGFyQ29kZUF0KDApJiZ0LmNoYXJDb2RlQXQoMCk8PVwiOVwiLmNoYXJDb2RlQXQoMCl9LGY9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciByPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gci5jdXJOdW1iZXI9XCJcIixyLmN1ckNvbW1hbmRUeXBlPS0xLHIuY3VyQ29tbWFuZFJlbGF0aXZlPSExLHIuY2FuUGFyc2VDb21tYW5kT3JDb21tYT0hMCxyLmN1ck51bWJlckhhc0V4cD0hMSxyLmN1ck51bWJlckhhc0V4cERpZ2l0cz0hMSxyLmN1ck51bWJlckhhc0RlY2ltYWw9ITEsci5jdXJBcmdzPVtdLHJ9cmV0dXJuIHIoZSx0KSxlLnByb3RvdHlwZS5maW5pc2g9ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dCYmKHQ9W10pLHRoaXMucGFyc2UoXCIgXCIsdCksMCE9PXRoaXMuY3VyQXJncy5sZW5ndGh8fCF0aGlzLmNhblBhcnNlQ29tbWFuZE9yQ29tbWEpdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVW50ZXJtaW5hdGVkIGNvbW1hbmQgYXQgdGhlIHBhdGggZW5kLlwiKTtyZXR1cm4gdH0sZS5wcm90b3R5cGUucGFyc2U9ZnVuY3Rpb24odCxyKXt2YXIgZT10aGlzO3ZvaWQgMD09PXImJihyPVtdKTtmb3IodmFyIGk9ZnVuY3Rpb24odCl7ci5wdXNoKHQpLGUuY3VyQXJncy5sZW5ndGg9MCxlLmNhblBhcnNlQ29tbWFuZE9yQ29tbWE9ITB9LGE9MDthPHQubGVuZ3RoO2ErKyl7dmFyIG49dFthXSxvPSEodGhpcy5jdXJDb21tYW5kVHlwZSE9PV8uQVJDfHwzIT09dGhpcy5jdXJBcmdzLmxlbmd0aCYmNCE9PXRoaXMuY3VyQXJncy5sZW5ndGh8fDEhPT10aGlzLmN1ck51bWJlci5sZW5ndGh8fFwiMFwiIT09dGhpcy5jdXJOdW1iZXImJlwiMVwiIT09dGhpcy5jdXJOdW1iZXIpLHM9dihuKSYmKFwiMFwiPT09dGhpcy5jdXJOdW1iZXImJlwiMFwiPT09bnx8byk7aWYoIXYobil8fHMpaWYoXCJlXCIhPT1uJiZcIkVcIiE9PW4paWYoXCItXCIhPT1uJiZcIitcIiE9PW58fCF0aGlzLmN1ck51bWJlckhhc0V4cHx8dGhpcy5jdXJOdW1iZXJIYXNFeHBEaWdpdHMpaWYoXCIuXCIhPT1ufHx0aGlzLmN1ck51bWJlckhhc0V4cHx8dGhpcy5jdXJOdW1iZXJIYXNEZWNpbWFsfHxvKXtpZih0aGlzLmN1ck51bWJlciYmLTEhPT10aGlzLmN1ckNvbW1hbmRUeXBlKXt2YXIgdT1OdW1iZXIodGhpcy5jdXJOdW1iZXIpO2lmKGlzTmFOKHUpKXRocm93IG5ldyBTeW50YXhFcnJvcihcIkludmFsaWQgbnVtYmVyIGVuZGluZyBhdCBcIithKTtpZih0aGlzLmN1ckNvbW1hbmRUeXBlPT09Xy5BUkMpaWYoMD09PXRoaXMuY3VyQXJncy5sZW5ndGh8fDE9PT10aGlzLmN1ckFyZ3MubGVuZ3RoKXtpZigwPnUpdGhyb3cgbmV3IFN5bnRheEVycm9yKCdFeHBlY3RlZCBwb3NpdGl2ZSBudW1iZXIsIGdvdCBcIicrdSsnXCIgYXQgaW5kZXggXCInK2ErJ1wiJyl9ZWxzZSBpZigoMz09PXRoaXMuY3VyQXJncy5sZW5ndGh8fDQ9PT10aGlzLmN1ckFyZ3MubGVuZ3RoKSYmXCIwXCIhPT10aGlzLmN1ck51bWJlciYmXCIxXCIhPT10aGlzLmN1ck51bWJlcil0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0V4cGVjdGVkIGEgZmxhZywgZ290IFwiJyt0aGlzLmN1ck51bWJlcisnXCIgYXQgaW5kZXggXCInK2ErJ1wiJyk7dGhpcy5jdXJBcmdzLnB1c2godSksdGhpcy5jdXJBcmdzLmxlbmd0aD09PU5bdGhpcy5jdXJDb21tYW5kVHlwZV0mJihfLkhPUklaX0xJTkVfVE89PT10aGlzLmN1ckNvbW1hbmRUeXBlP2koe3R5cGU6Xy5IT1JJWl9MSU5FX1RPLHJlbGF0aXZlOnRoaXMuY3VyQ29tbWFuZFJlbGF0aXZlLHg6dX0pOl8uVkVSVF9MSU5FX1RPPT09dGhpcy5jdXJDb21tYW5kVHlwZT9pKHt0eXBlOl8uVkVSVF9MSU5FX1RPLHJlbGF0aXZlOnRoaXMuY3VyQ29tbWFuZFJlbGF0aXZlLHk6dX0pOnRoaXMuY3VyQ29tbWFuZFR5cGU9PT1fLk1PVkVfVE98fHRoaXMuY3VyQ29tbWFuZFR5cGU9PT1fLkxJTkVfVE98fHRoaXMuY3VyQ29tbWFuZFR5cGU9PT1fLlNNT09USF9RVUFEX1RPPyhpKHt0eXBlOnRoaXMuY3VyQ29tbWFuZFR5cGUscmVsYXRpdmU6dGhpcy5jdXJDb21tYW5kUmVsYXRpdmUseDp0aGlzLmN1ckFyZ3NbMF0seTp0aGlzLmN1ckFyZ3NbMV19KSxfLk1PVkVfVE89PT10aGlzLmN1ckNvbW1hbmRUeXBlJiYodGhpcy5jdXJDb21tYW5kVHlwZT1fLkxJTkVfVE8pKTp0aGlzLmN1ckNvbW1hbmRUeXBlPT09Xy5DVVJWRV9UTz9pKHt0eXBlOl8uQ1VSVkVfVE8scmVsYXRpdmU6dGhpcy5jdXJDb21tYW5kUmVsYXRpdmUseDE6dGhpcy5jdXJBcmdzWzBdLHkxOnRoaXMuY3VyQXJnc1sxXSx4Mjp0aGlzLmN1ckFyZ3NbMl0seTI6dGhpcy5jdXJBcmdzWzNdLHg6dGhpcy5jdXJBcmdzWzRdLHk6dGhpcy5jdXJBcmdzWzVdfSk6dGhpcy5jdXJDb21tYW5kVHlwZT09PV8uU01PT1RIX0NVUlZFX1RPP2koe3R5cGU6Xy5TTU9PVEhfQ1VSVkVfVE8scmVsYXRpdmU6dGhpcy5jdXJDb21tYW5kUmVsYXRpdmUseDI6dGhpcy5jdXJBcmdzWzBdLHkyOnRoaXMuY3VyQXJnc1sxXSx4OnRoaXMuY3VyQXJnc1syXSx5OnRoaXMuY3VyQXJnc1szXX0pOnRoaXMuY3VyQ29tbWFuZFR5cGU9PT1fLlFVQURfVE8/aSh7dHlwZTpfLlFVQURfVE8scmVsYXRpdmU6dGhpcy5jdXJDb21tYW5kUmVsYXRpdmUseDE6dGhpcy5jdXJBcmdzWzBdLHkxOnRoaXMuY3VyQXJnc1sxXSx4OnRoaXMuY3VyQXJnc1syXSx5OnRoaXMuY3VyQXJnc1szXX0pOnRoaXMuY3VyQ29tbWFuZFR5cGU9PT1fLkFSQyYmaSh7dHlwZTpfLkFSQyxyZWxhdGl2ZTp0aGlzLmN1ckNvbW1hbmRSZWxhdGl2ZSxyWDp0aGlzLmN1ckFyZ3NbMF0sclk6dGhpcy5jdXJBcmdzWzFdLHhSb3Q6dGhpcy5jdXJBcmdzWzJdLGxBcmNGbGFnOnRoaXMuY3VyQXJnc1szXSxzd2VlcEZsYWc6dGhpcy5jdXJBcmdzWzRdLHg6dGhpcy5jdXJBcmdzWzVdLHk6dGhpcy5jdXJBcmdzWzZdfSkpLHRoaXMuY3VyTnVtYmVyPVwiXCIsdGhpcy5jdXJOdW1iZXJIYXNFeHBEaWdpdHM9ITEsdGhpcy5jdXJOdW1iZXJIYXNFeHA9ITEsdGhpcy5jdXJOdW1iZXJIYXNEZWNpbWFsPSExLHRoaXMuY2FuUGFyc2VDb21tYW5kT3JDb21tYT0hMH1pZighVChuKSlpZihcIixcIj09PW4mJnRoaXMuY2FuUGFyc2VDb21tYW5kT3JDb21tYSl0aGlzLmNhblBhcnNlQ29tbWFuZE9yQ29tbWE9ITE7ZWxzZSBpZihcIitcIiE9PW4mJlwiLVwiIT09biYmXCIuXCIhPT1uKWlmKHMpdGhpcy5jdXJOdW1iZXI9bix0aGlzLmN1ck51bWJlckhhc0RlY2ltYWw9ITE7ZWxzZXtpZigwIT09dGhpcy5jdXJBcmdzLmxlbmd0aCl0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJVbnRlcm1pbmF0ZWQgY29tbWFuZCBhdCBpbmRleCBcIithK1wiLlwiKTtpZighdGhpcy5jYW5QYXJzZUNvbW1hbmRPckNvbW1hKXRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBjaGFyYWN0ZXIgXCInK24rJ1wiIGF0IGluZGV4ICcrYStcIi4gQ29tbWFuZCBjYW5ub3QgZm9sbG93IGNvbW1hXCIpO2lmKHRoaXMuY2FuUGFyc2VDb21tYW5kT3JDb21tYT0hMSxcInpcIiE9PW4mJlwiWlwiIT09bilpZihcImhcIj09PW58fFwiSFwiPT09bil0aGlzLmN1ckNvbW1hbmRUeXBlPV8uSE9SSVpfTElORV9UTyx0aGlzLmN1ckNvbW1hbmRSZWxhdGl2ZT1cImhcIj09PW47ZWxzZSBpZihcInZcIj09PW58fFwiVlwiPT09bil0aGlzLmN1ckNvbW1hbmRUeXBlPV8uVkVSVF9MSU5FX1RPLHRoaXMuY3VyQ29tbWFuZFJlbGF0aXZlPVwidlwiPT09bjtlbHNlIGlmKFwibVwiPT09bnx8XCJNXCI9PT1uKXRoaXMuY3VyQ29tbWFuZFR5cGU9Xy5NT1ZFX1RPLHRoaXMuY3VyQ29tbWFuZFJlbGF0aXZlPVwibVwiPT09bjtlbHNlIGlmKFwibFwiPT09bnx8XCJMXCI9PT1uKXRoaXMuY3VyQ29tbWFuZFR5cGU9Xy5MSU5FX1RPLHRoaXMuY3VyQ29tbWFuZFJlbGF0aXZlPVwibFwiPT09bjtlbHNlIGlmKFwiY1wiPT09bnx8XCJDXCI9PT1uKXRoaXMuY3VyQ29tbWFuZFR5cGU9Xy5DVVJWRV9UTyx0aGlzLmN1ckNvbW1hbmRSZWxhdGl2ZT1cImNcIj09PW47ZWxzZSBpZihcInNcIj09PW58fFwiU1wiPT09bil0aGlzLmN1ckNvbW1hbmRUeXBlPV8uU01PT1RIX0NVUlZFX1RPLHRoaXMuY3VyQ29tbWFuZFJlbGF0aXZlPVwic1wiPT09bjtlbHNlIGlmKFwicVwiPT09bnx8XCJRXCI9PT1uKXRoaXMuY3VyQ29tbWFuZFR5cGU9Xy5RVUFEX1RPLHRoaXMuY3VyQ29tbWFuZFJlbGF0aXZlPVwicVwiPT09bjtlbHNlIGlmKFwidFwiPT09bnx8XCJUXCI9PT1uKXRoaXMuY3VyQ29tbWFuZFR5cGU9Xy5TTU9PVEhfUVVBRF9UTyx0aGlzLmN1ckNvbW1hbmRSZWxhdGl2ZT1cInRcIj09PW47ZWxzZXtpZihcImFcIiE9PW4mJlwiQVwiIT09bil0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgY2hhcmFjdGVyIFwiJytuKydcIiBhdCBpbmRleCAnK2ErXCIuXCIpO3RoaXMuY3VyQ29tbWFuZFR5cGU9Xy5BUkMsdGhpcy5jdXJDb21tYW5kUmVsYXRpdmU9XCJhXCI9PT1ufWVsc2Ugci5wdXNoKHt0eXBlOl8uQ0xPU0VfUEFUSH0pLHRoaXMuY2FuUGFyc2VDb21tYW5kT3JDb21tYT0hMCx0aGlzLmN1ckNvbW1hbmRUeXBlPS0xfWVsc2UgdGhpcy5jdXJOdW1iZXI9bix0aGlzLmN1ck51bWJlckhhc0RlY2ltYWw9XCIuXCI9PT1ufWVsc2UgdGhpcy5jdXJOdW1iZXIrPW4sdGhpcy5jdXJOdW1iZXJIYXNEZWNpbWFsPSEwO2Vsc2UgdGhpcy5jdXJOdW1iZXIrPW47ZWxzZSB0aGlzLmN1ck51bWJlcis9bix0aGlzLmN1ck51bWJlckhhc0V4cD0hMDtlbHNlIHRoaXMuY3VyTnVtYmVyKz1uLHRoaXMuY3VyTnVtYmVySGFzRXhwRGlnaXRzPXRoaXMuY3VyTnVtYmVySGFzRXhwfXJldHVybiByfSxlLnByb3RvdHlwZS50cmFuc2Zvcm09ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyx7cGFyc2U6e3ZhbHVlOmZ1bmN0aW9uKHIsZSl7dm9pZCAwPT09ZSYmKGU9W10pO2Zvcih2YXIgaT0wLGE9T2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLnBhcnNlLmNhbGwodGhpcyxyKTtpPGEubGVuZ3RoO2krKyl7dmFyIG49YVtpXSxvPXQobik7QXJyYXkuaXNBcnJheShvKT9lLnB1c2guYXBwbHkoZSxvKTplLnB1c2gobyl9cmV0dXJuIGV9fX0pfSxlfShsKSxfPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGkocil7dmFyIGU9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBlLmNvbW1hbmRzPVwic3RyaW5nXCI9PXR5cGVvZiByP2kucGFyc2Uocik6cixlfXJldHVybiByKGksdCksaS5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZW5jb2RlKHRoaXMuY29tbWFuZHMpfSxpLnByb3RvdHlwZS5nZXRCb3VuZHM9ZnVuY3Rpb24oKXt2YXIgdD11LkNBTENVTEFURV9CT1VORFMoKTtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odCksdH0saS5wcm90b3R5cGUudHJhbnNmb3JtPWZ1bmN0aW9uKHQpe2Zvcih2YXIgcj1bXSxlPTAsaT10aGlzLmNvbW1hbmRzO2U8aS5sZW5ndGg7ZSsrKXt2YXIgYT10KGlbZV0pO0FycmF5LmlzQXJyYXkoYSk/ci5wdXNoLmFwcGx5KHIsYSk6ci5wdXNoKGEpfXJldHVybiB0aGlzLmNvbW1hbmRzPXIsdGhpc30saS5lbmNvZGU9ZnVuY3Rpb24odCl7cmV0dXJuIGUodCl9LGkucGFyc2U9ZnVuY3Rpb24odCl7dmFyIHI9bmV3IGYsZT1bXTtyZXR1cm4gci5wYXJzZSh0LGUpLHIuZmluaXNoKGUpLGV9LGkuQ0xPU0VfUEFUSD0xLGkuTU9WRV9UTz0yLGkuSE9SSVpfTElORV9UTz00LGkuVkVSVF9MSU5FX1RPPTgsaS5MSU5FX1RPPTE2LGkuQ1VSVkVfVE89MzIsaS5TTU9PVEhfQ1VSVkVfVE89NjQsaS5RVUFEX1RPPTEyOCxpLlNNT09USF9RVUFEX1RPPTI1NixpLkFSQz01MTIsaS5MSU5FX0NPTU1BTkRTPWkuTElORV9UT3xpLkhPUklaX0xJTkVfVE98aS5WRVJUX0xJTkVfVE8saS5EUkFXSU5HX0NPTU1BTkRTPWkuSE9SSVpfTElORV9UT3xpLlZFUlRfTElORV9UT3xpLkxJTkVfVE98aS5DVVJWRV9UT3xpLlNNT09USF9DVVJWRV9UT3xpLlFVQURfVE98aS5TTU9PVEhfUVVBRF9UT3xpLkFSQyxpfShsKSxOPSgoTz17fSlbXy5NT1ZFX1RPXT0yLE9bXy5MSU5FX1RPXT0yLE9bXy5IT1JJWl9MSU5FX1RPXT0xLE9bXy5WRVJUX0xJTkVfVE9dPTEsT1tfLkNMT1NFX1BBVEhdPTAsT1tfLlFVQURfVE9dPTQsT1tfLlNNT09USF9RVUFEX1RPXT0yLE9bXy5DVVJWRV9UT109NixPW18uU01PT1RIX0NVUlZFX1RPXT00LE9bXy5BUkNdPTcsTyk7ZXhwb3J0e04gYXMgQ09NTUFORF9BUkdfQ09VTlRTLF8gYXMgU1ZHUGF0aERhdGEsZiBhcyBTVkdQYXRoRGF0YVBhcnNlcix1IGFzIFNWR1BhdGhEYXRhVHJhbnNmb3JtZXIsZSBhcyBlbmNvZGVTVkdQYXRofTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNWR1BhdGhEYXRhLm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/svg-pathdata/lib/SVGPathData.module.js\n"));

/***/ })

}]);