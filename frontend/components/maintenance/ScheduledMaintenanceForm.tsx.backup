'use client';

import { useEffect, useMemo, useState } from 'react';
import { useForm, Controller } from 'react-hook-form';
import { z } from 'zod';
import { zodResolver } from '@hookform/resolvers/zod';
import { useRouter } from 'next/navigation';
import { api, getActiveBuildingId, fetchScheduledMaintenances, type ScheduledMaintenance as ApiScheduledMaintenance, createServiceReceipt } from '@/lib/api';
import { useToast } from '@/hooks/use-toast';
import { useRole } from '@/lib/auth';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { BackButton } from '@/components/ui/BackButton';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@/components/ui/dialog';
import { DistributionSelector } from '@/components/ui/DistributionSelector';
import { ConfirmDialog } from '@/components/ui/ConfirmDialog';
import { useExpenses } from '@/hooks/useExpenses';
import { PaymentConfigurationSection } from '@/components/maintenance/PaymentConfigurationSection';

const schema = z.object({
  title: z.string().trim().min(3, 'ÎŸ Ï„Î¯Ï„Î»Î¿Ï‚ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Î­Ï‡ÎµÎ¹ Ï„Î¿Ï…Î»Î¬Ï‡Î¹ÏƒÏ„Î¿Î½ 3 Ï‡Î±ÏÎ±ÎºÏ„Î®ÏÎµÏ‚').max(100, 'ÎŸ Ï„Î¯Ï„Î»Î¿Ï‚ Î´ÎµÎ½ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î¾ÎµÏ€ÎµÏÎ½Î¬ Ï„Î¿Ï…Ï‚ 100 Ï‡Î±ÏÎ±ÎºÏ„Î®ÏÎµÏ‚'),
  description: z.string().trim().max(1000, 'Î— Ï€ÎµÏÎ¹Î³ÏÎ±Ï†Î® Î´ÎµÎ½ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î¾ÎµÏ€ÎµÏÎ½Î¬ Ï„Î¿Ï…Ï‚ 1000 Ï‡Î±ÏÎ±ÎºÏ„Î®ÏÎµÏ‚').optional(),
  contractor: z.preprocess((v) => (v ? Number(v) : undefined), z.number().int().positive().optional()),
  scheduled_date: z.string().optional(),
  priority: z.enum(['low','medium','high','urgent']).default('medium'),
  template: z.string().optional(),
  is_recurring: z.boolean().optional(),
  recurrence_frequency: z.enum(['weekly','monthly','bimonthly','quarterly','semiannual','annual']).optional(),
  status_ui: z.enum(['pending','executed']).default('pending'),
  price: z.preprocess((v) => {
    if (v === undefined || v === null || v === '') return undefined;
    const n = Number(v);
    return isNaN(n) ? undefined : n;
  }, z.number().positive().optional()),
  estimated_duration: z.preprocess((v) => {
    if (v === undefined || v === null || v === '') return undefined;
    const n = Number(v);
    return isNaN(n) ? undefined : n;
  }, z.number().positive().int().optional()),
  payment_config: z.object({
    enabled: z.boolean().optional(),
    payment_type: z.enum(['lump_sum', 'advance_installments', 'periodic', 'milestone_based']).optional(),
    total_amount: z.number().optional(),
    advance_percentage: z.number().optional(),
    installment_count: z.number().optional(),
    installment_frequency: z.enum(['weekly', 'biweekly', 'monthly']).optional(),
    periodic_frequency: z.enum(['weekly', 'biweekly', 'monthly']).optional(),
    periodic_amount: z.number().optional(),
    start_date: z.string().optional(),
    notes: z.string().optional(),
    advance_amount: z.number().optional(),
    remaining_amount: z.number().optional(),
    installment_amount: z.number().optional(),
  }).optional(),
});

type FormValues = z.infer<typeof schema>;

export type ScheduledMaintenance = {
  id?: number;
  title: string;
  description?: string;
  contractor?: number | null;
  scheduled_date?: string | null;
  priority: 'low' | 'medium' | 'high' | 'urgent';
  status?: 'scheduled' | 'in_progress' | 'completed' | 'cancelled';
  estimated_duration?: number | null;
};

export default function ScheduledMaintenanceForm({
  heading = 'Î ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÎ¼ÏŒÏ‚ ÎˆÏÎ³Î¿Ï…',
  maintenanceId,
}: {
  readonly heading?: string;
  readonly maintenanceId?: number;
}) {
  const { isAdmin, isManager, isLoading } = useRole();
  const router = useRouter();
  const { toast } = useToast();
  const { createExpense, getExpenses, deleteExpense } = useExpenses();
  const [contractors, setContractors] = useState<Array<{ id: number; name: string }>>([]);
  const [loadingContractors, setLoadingContractors] = useState(false);
  const [initialData, setInitialData] = useState<ScheduledMaintenance | null>(null);
  const [existingScheduleId, setExistingScheduleId] = useState<number | null>(null);

  // Templates for common scheduled tasks
  const [templates, setTemplates] = useState<Array<{ key: string; title: string; description: string; suggestedCategory: string }>>([
    { key: 'elevator_maintenance', title: 'Î£Ï…Î½Ï„Î®ÏÎ·ÏƒÎ· Î‘Î½ÎµÎ»ÎºÏ…ÏƒÏ„Î®ÏÎ±', description: 'Î•Ï„Î®ÏƒÎ¹Î± ÏƒÏ…Î½Ï„Î®ÏÎ·ÏƒÎ· Î±Î½ÎµÎ»ÎºÏ…ÏƒÏ„Î®ÏÎ±, Î­Î»ÎµÎ³Ï‡Î¿Ï‚ Î±ÏƒÏ†Î±Î»ÎµÎ¯Î±Ï‚ ÎºÎ±Î¹ Î»Î¯Ï€Î±Î½ÏƒÎ· ÎµÎ¾Î±ÏÏ„Î·Î¼Î¬Ï„Ï‰Î½.', suggestedCategory: 'elevator_maintenance' },
    { key: 'boiler_service', title: 'Î£Ï…Î½Ï„Î®ÏÎ·ÏƒÎ· ÎšÎ±Ï…ÏƒÏ„Î®ÏÎ±', description: 'Î ÎµÏÎ¹Î¿Î´Î¹ÎºÎ® ÏƒÏ…Î½Ï„Î®ÏÎ·ÏƒÎ· ÎºÎ±Ï…ÏƒÏ„Î®ÏÎ±/Î»Î­Î²Î·Ï„Î± ÎºÎ±Î¹ ÎºÎ±Î¸Î±ÏÎ¹ÏƒÎ¼ÏŒÏ‚.', suggestedCategory: 'heating_maintenance' },
    { key: 'water_tank_cleaning', title: 'ÎšÎ±Î¸Î±ÏÎ¹ÏƒÎ¼ÏŒÏ‚ Î”ÎµÎ¾Î±Î¼ÎµÎ½Î®Ï‚ ÎÎµÏÎ¿Ï', description: 'Î ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÎ¼Î­Î½Î¿Ï‚ ÎºÎ±Î¸Î±ÏÎ¹ÏƒÎ¼ÏŒÏ‚ ÎºÎ±Î¹ Î±Ï€Î¿Î»ÏÎ¼Î±Î½ÏƒÎ· Î´ÎµÎ¾Î±Î¼ÎµÎ½Î®Ï‚ Î½ÎµÏÎ¿Ï.', suggestedCategory: 'water_tank_cleaning' },
    { key: 'fire_extinguishers', title: 'ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î Ï…ÏÎ¿ÏƒÎ²ÎµÏƒÏ„Î®ÏÏ‰Î½', description: 'Î•Ï„Î®ÏƒÎ¹Î± ÎµÏ€Î¹Î¸ÎµÏÏÎ·ÏƒÎ· ÎºÎ±Î¹ Î±Î½Î±Î³Î¿Î¼ÏÏƒÎµÎ¹Ï‚ Ï€Ï…ÏÎ¿ÏƒÎ²ÎµÏƒÏ„Î®ÏÏ‰Î½.', suggestedCategory: 'fire_extinguishers' },
    { key: 'roof_inspection', title: 'ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î£Ï„Î­Î³Î·Ï‚', description: 'Î ÎµÏÎ¹Î¿Î´Î¹ÎºÏŒÏ‚ Î­Î»ÎµÎ³Ï‡Î¿Ï‚ ÏƒÏ„Î­Î³Î·Ï‚ Î³Î¹Î± Î´Î¹Î±ÏÏÎ¿Î­Ï‚ ÎºÎ±Î¹ Ï†Î¸Î¿ÏÎ­Ï‚.', suggestedCategory: 'roof_maintenance' },
    { key: 'garden_maintenance', title: 'Î£Ï…Î½Ï„Î®ÏÎ·ÏƒÎ· ÎšÎ®Ï€Î¿Ï…', description: 'ÎšÎ»Î¬Î´ÎµÎ¼Î±, Ï€ÏŒÏ„Î¹ÏƒÎ¼Î± ÎºÎ±Î¹ ÏƒÏ…Î½Ï„Î®ÏÎ·ÏƒÎ· Ï€ÏÎ±ÏƒÎ¯Î½Î¿Ï….', suggestedCategory: 'garden_maintenance' },
    { key: 'intercom_check', title: 'Î£Ï…Î½Ï„Î®ÏÎ·ÏƒÎ· Î•Î½Î´Î¿ÎµÏ€Î¹ÎºÎ¿Î¹Î½Ï‰Î½Î¯Î±Ï‚', description: 'ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ ÎºÎ±Î¹ ÏƒÏ…Î½Ï„Î®ÏÎ·ÏƒÎ· ÏƒÏ…ÏƒÏ„Î®Î¼Î±Ï„Î¿Ï‚ Î¸Ï…ÏÎ¿Ï„Î·Î»ÎµÏŒÏÎ±ÏƒÎ·Ï‚/Î¸Ï…ÏÎ¿Ï„Î·Î»ÎµÏ†ÏÎ½Î¿Ï….', suggestedCategory: 'intercom_system' },
    { key: 'electrical_check', title: 'ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î—Î»ÎµÎºÏ„ÏÎ¹ÎºÏÎ½ ÎšÎ¿Î¹Î½Î¿Ï‡ÏÎ®ÏƒÏ„Ï‰Î½', description: 'ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Ï€Î¯Î½Î±ÎºÎ±, Ï†Ï‰Ï„Î¹ÏƒÎ¼Î¿Ï ÎºÎ±Î¹ Î±ÏƒÏ†Î±Î»ÎµÎ¹ÏÎ½ ÎºÎ¿Î¹Î½Î¿Ï‡ÏÎ®ÏƒÏ„Ï‰Î½.', suggestedCategory: 'electrical_maintenance' },
  ]);
  const [showAddTemplate, setShowAddTemplate] = useState(false);
  const [newTemplateTitle, setNewTemplateTitle] = useState('');
  const [newTemplateDescription, setNewTemplateDescription] = useState('');

  // Receipt modal state
  const [showReceiptModal, setShowReceiptModal] = useState(false);
  const [receiptTitle, setReceiptTitle] = useState('');
  const [receiptAmount, setReceiptAmount] = useState('');
  const [receiptDate, setReceiptDate] = useState(() => new Date().toISOString().slice(0,10));
  const [receiptCategory, setReceiptCategory] = useState<string>('cleaning');
  const [receiptDistribution, setReceiptDistribution] = useState<'by_participation_mills' | 'equal_share' | 'by_meters' | 'specific_apartments'>('by_participation_mills');
  const [receiptFile, setReceiptFile] = useState<File | null>(null);
  const [isCreatingExpense, setIsCreatingExpense] = useState(false);
  const [showDuplicateConfirm, setShowDuplicateConfirm] = useState(false);
  const [pendingCreateAfterConfirm, setPendingCreateAfterConfirm] = useState<null | {
    buildingId: number;
    amountNum: number;
  }>(null);
  const [showRecurringConfirm, setShowRecurringConfirm] = useState(false);

  useEffect(() => {
    const loadContractors = async () => {
      try {
        setLoadingContractors(true);
        const resp = await api.get('/maintenance/contractors/', { params: { page_size: 1000 } });
        const data = resp.data;
        const rows = Array.isArray(data) ? data : data?.results ?? [];
        setContractors(rows.map((r: any) => ({ id: r.id, name: r.name })));
      } catch {
      } finally {
        setLoadingContractors(false);
      }
    };
    loadContractors();
  }, []);

  useEffect(() => {
    const loadExisting = async () => {
      if (!maintenanceId) return;
      try {
        const { data } = await api.get(`/maintenance/scheduled/${maintenanceId}/`);
        setInitialData({
          id: data.id,
          title: data.title,
          description: data.description ?? '',
          contractor: data.contractor ?? undefined,
          scheduled_date: data.scheduled_date ?? undefined,
          priority: data.priority ?? 'medium',
          status: data.status ?? 'scheduled',
          estimated_duration: data.estimated_duration ?? 1,
        });
        // Prefill price from estimated_cost (fallback to actual_cost)
        try {
          setValue('price', (data.estimated_cost ?? data.actual_cost) as any);
        } catch {}

        // Try to load existing payment schedule and prefill payment_config
        try {
          const resp = await api.get('/maintenance/payment-schedules/', { params: { scheduled_maintenance: data.id } });
          const schedule = Array.isArray(resp.data) ? (resp.data[0] || null) : (resp.data?.results?.[0] || null);
          if (schedule) {
            console.log('Found existing payment schedule:', schedule);
            setExistingScheduleId(schedule.id);
            
            // Update the initialData to include payment config
            setInitialData(prev => ({
              ...prev,
              id: data.id,
              title: data.title,
              description: data.description ?? '',
              contractor: data.contractor ?? undefined,
              scheduled_date: data.scheduled_date ?? undefined,
              priority: data.priority ?? 'medium',
              status: data.status ?? 'scheduled',
              estimated_duration: data.estimated_duration ?? 1,
              payment_config: {
                enabled: true,
                payment_type: schedule.payment_type || 'lump_sum',
                total_amount: Number(schedule.total_amount) || 0,
                advance_percentage: schedule.advance_percentage || 30,
                installment_count: schedule.installment_count || 3,
                installment_frequency: schedule.installment_frequency || 'monthly',
                periodic_frequency: schedule.periodic_frequency || 'monthly',
                periodic_amount: schedule.periodic_amount || 0,
                start_date: schedule.start_date || '',
                notes: schedule.notes || '',
              }
            } as any));
            
            // Also set the values immediately for immediate render
            setValue('payment_config.enabled', true as any);
            setValue('payment_config.payment_type', (schedule.payment_type || 'lump_sum') as any);
            setValue('payment_config.total_amount', Number(schedule.total_amount) as any);
            setValue('payment_config.advance_percentage', schedule.advance_percentage as any);
            setValue('payment_config.installment_count', schedule.installment_count as any);
            setValue('payment_config.installment_frequency', (schedule.installment_frequency || 'monthly') as any);
            setValue('payment_config.periodic_frequency', (schedule.periodic_frequency || 'monthly') as any);
            setValue('payment_config.periodic_amount', schedule.periodic_amount as any);
            setValue('payment_config.start_date', schedule.start_date as any);
            setValue('payment_config.notes', schedule.notes as any);
          } else {
            console.log('No payment schedule found for maintenance ID:', data.id);
          }
        } catch (error) {
          console.error('Error loading payment schedule:', error);
        }
      } catch (e: any) {
        toast({ title: 'Î£Ï†Î¬Î»Î¼Î±', description: e?.message ?? 'Î‘Ï€Î¿Ï„Ï…Ï‡Î¯Î± Ï†ÏŒÏÏ„Ï‰ÏƒÎ·Ï‚ ÎµÏÎ³Î±ÏƒÎ¯Î±Ï‚' });
      }
    };
    loadExisting();
  }, [maintenanceId, toast]);

  const defaultValues: FormValues = useMemo(() => ({
    title: initialData?.title ?? '',
    description: initialData?.description ?? '',
    contractor: initialData?.contractor ?? undefined,
    scheduled_date: initialData?.scheduled_date ? formatForDateInput(initialData.scheduled_date) : undefined,
    priority: initialData?.priority ?? 'medium',
    status_ui: initialData?.status === 'completed' ? 'executed' : 'pending',
    estimated_duration: (initialData?.estimated_duration as any) ?? 1,
  }), [initialData]);

  const { control, register, handleSubmit, formState: { errors, isSubmitting }, setValue, watch, getValues, reset } = useForm<FormValues>({
    resolver: zodResolver(schema) as any,
    defaultValues,
  });

  useEffect(() => {
    // When initial data is loaded/changes, reset form once to those values
    if (initialData) {
      const resetData = {
        title: initialData.title ?? '',
        description: initialData.description ?? '',
        contractor: initialData.contractor ?? undefined,
        scheduled_date: initialData.scheduled_date ? formatForDateInput(initialData.scheduled_date) : undefined,
        priority: initialData.priority ?? 'medium',
        status_ui: initialData.status === 'completed' ? 'executed' : 'pending',
        estimated_duration: (initialData.estimated_duration as any) ?? 1,
        // Include payment config if it exists
        payment_config: (initialData as any)?.payment_config || undefined,
      };
      console.log('Resetting form with data:', resetData);
      reset(resetData);
    }
  }, [initialData, reset]);

  const watchedPrice = watch('price');
  const paymentConfigEnabled = watch('payment_config.enabled');
  const paymentConfig = watch('payment_config');

  if (isLoading) return null;
  if (!(isAdmin || isManager)) {
    if (typeof window !== 'undefined') router.push('/maintenance/scheduled');
    return null;
  }

  const createInstallmentExpenses = async ({
    buildingId,
    title,
    totalAmount,
    advancePercentage,
    installmentCount,
    startDate,
    category,
    scheduledMaintenanceId,
  }: {
    buildingId: number;
    title: string;
    totalAmount: number;
    advancePercentage: number;
    installmentCount: number;
    startDate: string;
    category: string;
    scheduledMaintenanceId: number;
  }) => {
    const advanceAmount = (totalAmount * advancePercentage) / 100;
    const remainingAmount = totalAmount - advanceAmount;
    const installmentAmount = remainingAmount / installmentCount;
    
    const createdExpenses = [];
    
    try {
      // Create advance payment expense (current month)
      const currentDate = new Date().toISOString().slice(0, 10);
      const advanceExpense = await createExpense({
        building: buildingId,
        title: `${title} - Î ÏÎ¿ÎºÎ±Ï„Î±Î²Î¿Î»Î® (${advancePercentage}%)`,
        amount: Math.round(advanceAmount * 100) / 100,
        date: currentDate,
        category: category,
        distribution_type: 'by_participation_mills',
        notes: `Î ÏÎ¿ÎºÎ±Ï„Î±Î²Î¿Î»Î® ${advancePercentage}% Î³Î¹Î± ÏƒÏ…Î½Ï„Î®ÏÎ·ÏƒÎ·. Î£Ï…Î½Î¿Î»Î¹ÎºÏŒ ÎºÏŒÏƒÏ„Î¿Ï‚: ${totalAmount}â‚¬. Î ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÎ¼Î­Î½Î¿ Î­ÏÎ³Î¿ #${scheduledMaintenanceId}`,
      } as any);
      createdExpenses.push(advanceExpense);
      
      // Create installment expenses for future months
      const baseDate = new Date(startDate);
      for (let i = 1; i <= installmentCount; i++) {
        const installmentDate = new Date(baseDate);
        installmentDate.setMonth(baseDate.getMonth() + i);
        const installmentDateStr = installmentDate.toISOString().slice(0, 10);
        
        const installmentExpense = await createExpense({
          building: buildingId,
          title: `${title} - Î”ÏŒÏƒÎ· ${i}/${installmentCount}`,
          amount: Math.round(installmentAmount * 100) / 100,
          date: installmentDateStr,
          category: category,
          distribution_type: 'by_participation_mills',
          notes: `Î”ÏŒÏƒÎ· ${i} Î±Ï€ÏŒ ${installmentCount} Î³Î¹Î± ÏƒÏ…Î½Ï„Î®ÏÎ·ÏƒÎ·. Î Î¿ÏƒÏŒ Î´ÏŒÏƒÎ·Ï‚: ${installmentAmount.toFixed(2)}â‚¬. Î ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÎ¼Î­Î½Î¿ Î­ÏÎ³Î¿ #${scheduledMaintenanceId}`,
        } as any);
        createdExpenses.push(installmentExpense);
      }
    } catch (error: any) {
      // If any expense creation fails, try to clean up the already created ones
      console.error('Error during installment expense creation:', error);
      
      // Attempt cleanup of partially created expenses
      for (const createdExpense of createdExpenses) {
        try {
          const expenseId = createdExpense?.id || createdExpense?.data?.id;
          if (expenseId) {
            await deleteExpense(expenseId);
          }
        } catch (cleanupError) {
          console.error('Error during cleanup:', cleanupError);
        }
      }
      
      throw error; // Re-throw the original error
    }
  };

  // Background processing for payment configuration (non-blocking)
  const processPaymentConfigurationBackground = async (
    savedId: number, 
    paymentConfig: any, 
    values: FormValues, 
    buildingId: number, 
    watchedPrice: any
  ) => {
    console.time('Background payment configuration processing');
    const pc = paymentConfig || {};
    
    try {
      // Create installment expenses if payment type is advance_installments
      if (pc.payment_type === 'advance_installments' && pc.total_amount && pc.installment_count) {
        // Clean up existing installment expenses for this maintenance project
        const existingExpenses = await getExpenses({ building_id: buildingId });
        const relatedExpenses = existingExpenses.filter(expense => {
          const expenseTitle = (expense.title || '').toLowerCase();
          const maintenanceTitle = values.title.toLowerCase();
          const notes = (expense.notes || '').toLowerCase();
          
          // Match expenses related to this maintenance project
          return (
            (expenseTitle.includes(maintenanceTitle) && 
             (expenseTitle.includes('Ï€ÏÎ¿ÎºÎ±Ï„Î±Î²Î¿Î»Î®') || expenseTitle.includes('Î´ÏŒÏƒÎ·') || expenseTitle.includes('installment'))) ||
            (notes.includes(`Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÎ¼Î­Î½Î¿ Î­ÏÎ³Î¿ #${savedId}`)) ||
            (notes.includes(`maintenance id: ${savedId}`)) ||
            (expenseTitle.includes(`ÏƒÏ…Î½Ï„Î®ÏÎ·ÏƒÎ·: ${values.title.toLowerCase()}`))
          );
        });

        if (relatedExpenses.length > 0) {
          console.log(`Found ${relatedExpenses.length} existing installment expenses for maintenance ${savedId}, cleaning up...`);
          
          // Delete existing related expenses in parallel (with timeout)
          const deletePromises = relatedExpenses.map(async expense => {
            try {
              await Promise.race([
                deleteExpense(expense.id),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 3000))
              ]);
              console.log('Deleted existing expense:', expense.id, expense.title);
            } catch (deleteError) {
              console.warn('Failed to delete expense:', expense.id, deleteError);
            }
          });
          
          // Wait for all deletions with overall timeout
          try {
            await Promise.race([
              Promise.allSettled(deletePromises),
              new Promise((_, reject) => setTimeout(() => reject(new Error('Cleanup timeout')), 5000))
            ]);
          } catch (timeoutError) {
            console.warn('Cleanup timed out, proceeding anyway');
          }
        }

        // Always create new installment expenses (after cleanup)
        await createInstallmentExpenses({
          buildingId: getActiveBuildingId(),
          title: values.title,
          totalAmount: pc.total_amount,
          advancePercentage: pc.advance_percentage || 30,
          installmentCount: pc.installment_count,
          startDate: pc.start_date || new Date().toISOString().slice(0, 10),
          category: 'building_maintenance',
          scheduledMaintenanceId: savedId,
        });
        
        // Show background success toast
        toast({ title: 'Î•Ï€Î¹Ï„Ï…Ï‡Î¯Î±', description: `Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î®Î¸Î·ÎºÎ±Î½ ${pc.installment_count + 1} Ï„Î¼Î·Î¼Î±Ï„Î¹ÎºÎ­Ï‚ Î´Î±Ï€Î¬Î½ÎµÏ‚ Î³Î¹Î± Ï„Î¿ Î­ÏÎ³Î¿.` });
      }

      // Then try to create/update payment schedule (optional, won't block the flow)
      const schedulePayload: any = {
        payment_type: pc.payment_type || 'lump_sum',
        total_amount: pc.total_amount ?? watchedPrice ?? 0,
        advance_percentage: pc.advance_percentage,
        installment_count: pc.installment_count,
        installment_frequency: pc.installment_frequency,
        periodic_frequency: pc.periodic_frequency,
        periodic_amount: pc.periodic_amount,
        start_date: pc.start_date || new Date().toISOString().slice(0, 10),
        notes: pc.notes,
      };
      
      // Always check for existing schedules to prevent duplicates
      let foundExistingSchedules = [];
      try {
        const existingSchedulesResp = await api.get('/maintenance/payment-schedules/', { 
          params: { scheduled_maintenance: savedId } 
        });
        foundExistingSchedules = Array.isArray(existingSchedulesResp.data) ? 
          existingSchedulesResp.data : (existingSchedulesResp.data?.results || []);
      } catch (fetchError) {
        console.warn('Failed to fetch existing payment schedules:', fetchError);
      }
      
      let scheduleResponse;
      if (existingScheduleId && foundExistingSchedules.find(s => s.id === existingScheduleId)) {
        // Update the known existing payment schedule
        scheduleResponse = await api.patch(`/maintenance/payment-schedules/${existingScheduleId}/`, schedulePayload);
      } else {
        // Clean up any existing schedules to prevent duplicates
        for (const schedule of foundExistingSchedules) {
          try {
            await api.delete(`/maintenance/payment-schedules/${schedule.id}/`);
            console.log('Deleted existing payment schedule:', schedule.id);
          } catch (deleteError) {
            console.warn('Failed to delete existing payment schedule:', schedule.id, deleteError);
          }
        }
        
        // Create new payment schedule
        scheduleResponse = await api.post(`/maintenance/scheduled/${savedId}/create_payment_schedule/`, schedulePayload);
      }
      
      console.timeEnd('Background payment configuration processing');
    } catch (error: any) {
      console.error('Background payment configuration error:', error);
      // Don't show error toast in background processing to avoid confusion
    }
  };

  const onSubmit = async (values: FormValues, options?: { skipReceipt?: boolean }) => {
    console.log('ğŸ”¥ Submit handler called with values:', values);
    const buildingId = getActiveBuildingId();
    const isEditing = Boolean(initialData?.id);
    
    try {
      // Simplified change detection for debugging
      console.log('ğŸ” Checking for changes...');
      console.log('isEditing:', isEditing, 'initialData:', initialData);
      
      if (isEditing && initialData) {
        // Basic change detection only
        const hasBasicChanges = (
          values.title !== initialData.title ||
          values.priority !== initialData.priority
        );
        
        if (!hasBasicChanges) {
          console.log('âŒ No basic changes detected');
          toast({ 
            title: 'ÎšÎ±Î¼Î¯Î± Î‘Î»Î»Î±Î³Î®', 
            description: 'Î”ÎµÎ½ ÎµÎ½Ï„Î¿Ï€Î¯ÏƒÏ„Î·ÎºÎ±Î½ Î±Î»Î»Î±Î³Î­Ï‚ Î³Î¹Î± Î±Ï€Î¿Î¸Î®ÎºÎµÏ…ÏƒÎ·.',
            variant: 'default' as any 
          });
          return;
        }
        
        console.log('âœ… Changes detected, proceeding...');
      }
    
      const payload: any = {
      title: values.title,
      priority: values.priority,
    };
    // Only set building on create; do not change building when editing
    if (!isEditing) {
      payload.building = buildingId;
    }
    // Always include description (allow clearing)
    payload.description = (values.description ?? '').trim();
    // Backend requires estimated_duration
    payload.estimated_duration = Number(values.estimated_duration ?? 1);
    // Always include contractor; allow clearing to null
    payload.contractor = (values.contractor !== undefined ? values.contractor : (initialData?.contractor ?? null));
    if (payload.contractor === undefined) payload.contractor = null;
    if (values.scheduled_date) {
      const dateOnly = values.scheduled_date.length > 10 ? values.scheduled_date.slice(0,10) : values.scheduled_date;
      payload.scheduled_date = dateOnly;
    }
    // Map UI status to backend status; only include if changed vs current
    const desiredStatus = values.status_ui === 'executed' ? 'completed' : 'scheduled';
    const currentStatusUi = initialData?.status === 'completed' ? 'executed' : 'pending';
    if (!isEditing || desiredStatus !== (initialData?.status ?? 'scheduled')) {
      payload.status = desiredStatus;
    }

    // Map price â†’ estimated_cost (and actual_cost when executed)
    if (values.price !== undefined && values.price !== null && values.price !== ('' as any)) {
      const priceNum = Number(values.price);
      if (!Number.isNaN(priceNum)) {
        payload.estimated_cost = priceNum;
        if (payload.status === 'completed') {
          payload.actual_cost = priceNum;
        }
      }
    }

    // If executed and no receipt created yet, check recurrence and then open receipt modal
    if (values.status_ui === 'executed' && !isCreatingExpense && !options?.skipReceipt) {
      // Prefill receipt fields
      setReceiptTitle(values.title);
      setReceiptAmount(values.price ? String(values.price) : '');

      try {
        const duplicateInPeriod = await hasExecutedInDefinedPeriod({
          buildingId,
          currentId: initialData?.id,
          title: values.title,
          scheduledDate: values.scheduled_date,
          referenceDate: receiptDate,
          frequency: values.recurrence_frequency ?? 'monthly',
        });
        if (duplicateInPeriod) {
          setShowRecurringConfirm(true);
          return;
        }
      } catch {
        // If check fails, fail open: proceed to modal
      }

      setShowReceiptModal(true);
      return;
    }

    try {
      console.time('Main save operation');
      let savedId: number | undefined = initialData?.id ?? undefined;
      
      if (initialData?.id) {
        console.log('Updating existing maintenance:', initialData.id);
        await api.patch(`/maintenance/scheduled/${initialData.id}/`, payload, { xToastSuppress: true } as any);
        savedId = initialData.id;
      } else {
        console.log('Creating new maintenance');
        const resp = await api.post('/maintenance/scheduled/', payload, { xToastSuppress: true } as any);
        savedId = resp?.data?.id ?? undefined;
      }
      
      console.timeEnd('Main save operation');
      console.log('Saved maintenance with ID:', savedId);
      
      // Show immediate success feedback
      if (savedId) {
        toast({ title: 'Î•Ï€Î¹Ï„Ï…Ï‡Î¯Î±', description: `Î¤Î¿ Î­ÏÎ³Î¿ ÎºÎ±Ï„Î±Ï‡Ï‰ÏÎ®Î¸Î·ÎºÎµ ÎµÏ€Î¹Ï„Ï…Ï‡ÏÏ‚ (ID: ${savedId}).` });
        router.push(`/maintenance/scheduled?highlight=${savedId}`);
      } else {
        toast({ title: 'Î•Ï€Î¹Ï„Ï…Ï‡Î¯Î±', description: 'Î¤Î¿ Î­ÏÎ³Î¿ ÎºÎ±Ï„Î±Ï‡Ï‰ÏÎ®Î¸Î·ÎºÎµ ÎµÏ€Î¹Ï„Ï…Ï‡ÏÏ‚.' });
        router.push('/maintenance/scheduled');
      }
      
      // Temporarily disable background processing for debugging
      console.log('ğŸ’¾ Save completed, payment config processing disabled for debugging');
      
      // Process payment configuration in background (non-blocking)
      // if (savedId && paymentConfigEnabled) {
      //   // Use setTimeout to move this to next tick, making UI response immediate
      //   setTimeout(() => {
      //     processPaymentConfigurationBackground(savedId, paymentConfig, values, buildingId, watchedPrice);
      //   }, 0);
      // }
    } catch (e: any) {
      const msg = extractApiErrorMessage(e) ?? 'Î‘Ï€Î¿Ï„Ï…Ï‡Î¯Î± Î±Ï€Î¿Î¸Î®ÎºÎµÏ…ÏƒÎ·Ï‚';
      toast({ title: 'Î£Ï†Î¬Î»Î¼Î±', description: msg, variant: 'destructive' as any });
    }
  };

  return (
    <>
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle>{heading}</CardTitle>
          <BackButton />
        </div>
      </CardHeader>
      <CardContent className="space-y-4">
        <form onSubmit={handleSubmit((values) => onSubmit(values))} className="space-y-4">
          <div className="text-sm text-muted-foreground">Î£Ï„Î¿Î¹Ï‡ÎµÎ¯Î± ÎˆÏÎ³Î¿Ï… â€” Î£Ï…Î¼Ï€Î»Î·ÏÏÏƒÏ„Îµ Ï„Î± Î²Î±ÏƒÎ¹ÎºÎ¬ ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î±</div>
          <div>
            <label className="block text-sm font-medium mb-1">Î¤ÏÏ€Î¿Ï‚ Î­ÏÎ³Î¿Ï…</label>
            <div className="text-xs text-muted-foreground mb-2">Î— ÎµÏ€Î¹Î»Î¿Î³Î® ÏƒÏ…Î¼Ï€Î»Î·ÏÏÎ½ÎµÎ¹ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± Ï„Î¯Ï„Î»Î¿/Ï€ÎµÏÎ¹Î³ÏÎ±Ï†Î®. ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï„Î± Î±Î»Î»Î¬Î¾ÎµÏ„Îµ.</div>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-2 items-end">
              <div className="md:col-span-2">
                <Select onValueChange={(v) => {
                  const t = templates.find(x => x.key === v);
                  if (t) {
                    setValue('template', t.key);
                    setValue('title', t.title as any);
                    setValue('description', t.description as any);
                    setReceiptCategory(t.suggestedCategory);
                  }
                }}>
                  <SelectTrigger>
                    <SelectValue placeholder="Î•Ï€Î¹Î»Î­Î¾Ï„Îµ Ï…Ï€Î·ÏÎµÏƒÎ¯Î±" />
                  </SelectTrigger>
                  <SelectContent>
                    {templates.map(t => (
                      <SelectItem key={t.key} value={t.key}>{t.title}</SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
              <div className="flex gap-2">
                <Button type="button" variant="outline" onClick={() => setShowAddTemplate(v => !v)}>
                  {showAddTemplate ? 'Î‘ÎºÏÏÏ‰ÏƒÎ·' : 'Î ÏÎ¿ÏƒÎ¸Î®ÎºÎ· Î½Î­Î±Ï‚'}
                </Button>
              </div>
            </div>
            {showAddTemplate && (
              <div className="mt-2 grid grid-cols-1 md:grid-cols-2 gap-2">
                <Input placeholder="Î¤Î¯Ï„Î»Î¿Ï‚ Î½Î­Î±Ï‚ ÎµÏÎ³Î±ÏƒÎ¯Î±Ï‚" value={newTemplateTitle} onChange={(e) => setNewTemplateTitle(e.target.value)} />
                <Input placeholder="Î ÎµÏÎ¹Î³ÏÎ±Ï†Î® (Ï€ÏÎ¿Î±Î¹ÏÎµÏ„Î¹ÎºÎ®)" value={newTemplateDescription} onChange={(e) => setNewTemplateDescription(e.target.value)} />
                <div className="md:col-span-2 flex justify-end gap-2">
                  <Button type="button" variant="secondary" onClick={() => {
                    setNewTemplateTitle('');
                    setNewTemplateDescription('');
                    setShowAddTemplate(false);
                  }}>ÎšÎ±Î¸Î±ÏÎ¹ÏƒÎ¼ÏŒÏ‚</Button>
                  <Button type="button" onClick={() => {
                    if (!newTemplateTitle.trim()) return;
                    const key = newTemplateTitle.trim().toLowerCase().replace(/\s+/g, '_').slice(0, 50);
                    const item = { key, title: newTemplateTitle.trim(), description: newTemplateDescription.trim(), suggestedCategory: 'cleaning' };
                    setTemplates(prev => [{...item}, ...prev]);
                    setValue('template', item.key);
                    setValue('title', item.title as any);
                    setValue('description', item.description as any);
                    setReceiptCategory('cleaning');
                    setShowAddTemplate(false);
                  }}>Î‘Ï€Î¿Î¸Î®ÎºÎµÏ…ÏƒÎ· Ï‰Ï‚ Ï€ÏÏŒÏ„Ï…Ï€Î¿</Button>
                </div>
              </div>
            )}
          </div>
          <div>
            <label className="block text-sm font-medium mb-1">Î¤Î¯Ï„Î»Î¿Ï‚ <span className="text-red-600">*</span></label>
            <Input {...register('title')} placeholder="Ï€.Ï‡. Î£Ï…Î½Ï„Î®ÏÎ·ÏƒÎ· Î±Î½ÎµÎ»ÎºÏ…ÏƒÏ„Î®ÏÎ±" />
            {errors.title && <p className="text-sm text-red-600">{errors.title.message}</p>}
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium mb-1">Î£Ï…Î½ÎµÏÎ³ÎµÎ¯Î¿ (Ï€ÏÎ¿Î±Î¹ÏÎµÏ„Î¹ÎºÏŒ)</label>
              <div className="flex items-center gap-2">
                <Controller
                  control={control}
                  name="contractor"
                  render={({ field }) => (
                    <Select value={field.value !== undefined && field.value !== null ? String(field.value) : ''} onValueChange={(v) => field.onChange(Number(v))}>
                      <SelectTrigger>
                        <SelectValue placeholder={loadingContractors ? 'Î¦ÏŒÏÏ„Ï‰ÏƒÎ·â€¦' : 'Î•Ï€Î¹Î»Î­Î¾Ï„Îµ ÏƒÏ…Î½ÎµÏÎ³ÎµÎ¯Î¿'} />
                      </SelectTrigger>
                      <SelectContent>
                        {(!contractors || contractors.length === 0) && (
                          <SelectItem disabled value="-1">Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎ±Î½ ÏƒÏ…Î½ÎµÏÎ³ÎµÎ¯Î±</SelectItem>
                        )}
                        {(contractors || []).map((c) => (
                          <SelectItem key={c.id} value={String(c.id)}>{c.name}</SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  )}
                />
                <Button type="button" variant="outline" onClick={() => router.push('/maintenance/contractors/new')}>ÎÎ­Î¿</Button>
              </div>
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Î—Î¼/Î½Î¯Î± Î­Î½Î±ÏÎ¾Î·Ï‚</label>
              <Input type="date" {...register('scheduled_date')} />
            </div>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium mb-1">Î ÎµÏÎ¹Î¿Î´Î¹ÎºÏŒÏ„Î·Ï„Î±</label>
              <div className="flex items-center gap-2">
                <input type="checkbox" id="is_recurring" {...register('is_recurring')} />
                <label htmlFor="is_recurring" className="text-sm">Î•Ï€Î±Î½Î±Î»Î±Î¼Î²Î±Î½ÏŒÎ¼ÎµÎ½Î¿ Î­ÏÎ³Î¿</label>
              </div>
              {watch('is_recurring') && (
                <div className="mt-2">
                  <label className="block text-sm font-medium mb-1">Î£Ï…Ï‡Î½ÏŒÏ„Î·Ï„Î±</label>
                  <Controller
                    control={control}
                    name="recurrence_frequency"
                    render={({ field }) => (
                      <Select value={field.value ?? ''} onValueChange={(v) => field.onChange(v)}>
                        <SelectTrigger><SelectValue placeholder="Î•Ï€Î¹Î»Î­Î¾Ï„Îµ ÏƒÏ…Ï‡Î½ÏŒÏ„Î·Ï„Î±" /></SelectTrigger>
                        <SelectContent>
                          <SelectItem value="weekly">Î•Î²Î´Î¿Î¼Î±Î´Î¹Î±Î¯Î±</SelectItem>
                          <SelectItem value="monthly">ÎœÎ·Î½Î¹Î±Î¯Î±</SelectItem>
                          <SelectItem value="bimonthly">Î‘Î½Î¬ 2 Î¼Î®Î½ÎµÏ‚</SelectItem>
                          <SelectItem value="quarterly">Î¤ÏÎ¹Î¼Î·Î½Î¹Î±Î¯Î±</SelectItem>
                          <SelectItem value="semiannual">Î•Î¾Î±Î¼Î·Î½Î¹Î±Î¯Î±</SelectItem>
                          <SelectItem value="annual">Î•Ï„Î®ÏƒÎ¹Î±</SelectItem>
                        </SelectContent>
                      </Select>
                    )}
                  />
                </div>
              )}
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Î ÏÎ¿Ï„ÎµÏÎ±Î¹ÏŒÏ„Î·Ï„Î±</label>
              <Controller
                control={control}
                name="priority"
                render={({ field }) => (
                  <Select value={field.value ?? ''} onValueChange={(v) => field.onChange(v)}>
                    <SelectTrigger><SelectValue placeholder="Î•Ï€Î¹Î»Î­Î¾Ï„Îµ" /></SelectTrigger>
                    <SelectContent>
                      <SelectItem value="low">Î§Î±Î¼Î·Î»Î®</SelectItem>
                      <SelectItem value="medium">ÎœÎµÏƒÎ±Î¯Î±</SelectItem>
                      <SelectItem value="high">Î¥ÏˆÎ·Î»Î®</SelectItem>
                      <SelectItem value="urgent">Î•Ï€ÎµÎ¯Î³Î¿Ï…ÏƒÎ±</SelectItem>
                    </SelectContent>
                  </Select>
                )}
              />
              <div className="mt-4">
                <label className="block text-sm font-medium mb-1">Î•ÎºÏ„Î¹Î¼ÏÎ¼ÎµÎ½Î· Î”Î¹Î¬ÏÎºÎµÎ¹Î± (ÏÏÎµÏ‚)</label>
                <Input type="number" step="1" min="1" placeholder="1" {...register('estimated_duration')} />
                {errors.estimated_duration && <p className="text-sm text-red-600">{String(errors.estimated_duration.message || 'ÎœÎ· Î­Î³ÎºÏ…ÏÎ· Î´Î¹Î¬ÏÎºÎµÎ¹Î±')}</p>}
              </div>
            </div>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium mb-1">ÎšÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ·</label>
              <Controller
                control={control}
                name="status_ui"
                render={({ field }) => (
                  <Select value={field.value ?? ''} onValueChange={(v) => field.onChange(v)}>
                    <SelectTrigger><SelectValue placeholder="Î•Ï€Î¹Î»Î­Î¾Ï„Îµ" /></SelectTrigger>
                    <SelectContent>
                      <SelectItem value="pending">Î•ÎºÎºÏÎµÎ¼ÎµÎ¯</SelectItem>
                      <SelectItem value="executed">Î•ÎºÏ„ÎµÎ»Î­ÏƒÎ¸Î·ÎºÎµ</SelectItem>
                    </SelectContent>
                  </Select>
                )}
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Î¤Î¹Î¼Î® Î¥Ï€Î·ÏÎµÏƒÎ¯Î±Ï‚ (â‚¬)</label>
              <Input type="number" step="0.01" min="0" placeholder="0.00" {...register('price')} />
            </div>
          </div>
          {/* Payment Configuration */}
          <PaymentConfigurationSection control={control} watch={watch as any} setValue={setValue as any} projectPrice={watchedPrice as any} />
          <div>
            <label className="block text-sm font-medium mb-1">Î ÎµÏÎ¹Î³ÏÎ±Ï†Î®</label>
            <Textarea rows={4} placeholder="Î£ÏÎ½Ï„Î¿Î¼Î· Ï€ÎµÏÎ¹Î³ÏÎ±Ï†Î® ÎµÏÎ³Î±ÏƒÎ¹ÏÎ½, Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ·, Ï…Î»Î¹ÎºÎ¬, ÎºÎ»Ï€." {...register('description')} />
          </div>
          <div className="flex justify-end gap-2">
            <Button type="button" variant="outline" onClick={() => router.push('/maintenance/scheduled')}>Î†ÎºÏ…ÏÎ¿</Button>
            <Button type="submit" disabled={isSubmitting}>{isSubmitting ? 'Î‘Ï€Î¿Î¸Î®ÎºÎµÏ…ÏƒÎ·â€¦' : 'Î‘Ï€Î¿Î¸Î®ÎºÎµÏ…ÏƒÎ·'}</Button>
          </div>
        </form>
      </CardContent>
    </Card>

    {/* Receipt Modal */}
    <Dialog open={showReceiptModal} onOpenChange={(open) => setShowReceiptModal(open)}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>Î£Ï„Î¿Î¹Ï‡ÎµÎ¯Î± Î‘Ï€ÏŒÎ´ÎµÎ¹Î¾Î·Ï‚</DialogTitle>
        </DialogHeader>
        <div className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium mb-1">Î¤Î¯Ï„Î»Î¿Ï‚</label>
              <Input value={receiptTitle} onChange={(e) => setReceiptTitle(e.target.value)} placeholder="Î¤Î¯Ï„Î»Î¿Ï‚ Ï€Î±ÏÎ±ÏƒÏ„Î±Ï„Î¹ÎºÎ¿Ï" />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Î Î¿ÏƒÏŒ (â‚¬)</label>
              <Input type="number" step="0.01" min="0" value={receiptAmount} onChange={(e) => setReceiptAmount(e.target.value)} placeholder="0.00" />
            </div>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium mb-1">Î—Î¼ÎµÏÎ¿Î¼Î·Î½Î¯Î±</label>
              <Input type="date" value={receiptDate} onChange={(e) => setReceiptDate(e.target.value)} />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">ÎšÎ±Ï„Î·Î³Î¿ÏÎ¯Î±</label>
              <Select value={receiptCategory} onValueChange={(v) => setReceiptCategory(v)}>
                <SelectTrigger><SelectValue placeholder="Î•Ï€Î¹Î»Î­Î¾Ï„Îµ" /></SelectTrigger>
                <SelectContent>
                  <SelectItem value="cleaning">ÎšÎ±Î¸Î±ÏÎ¹ÏƒÎ¼ÏŒÏ‚ ÎšÎ¿Î¹Î½Î¿Ï‡ÏÎ®ÏƒÏ„Ï‰Î½ Î§ÏÏÏ‰Î½</SelectItem>
                  <SelectItem value="elevator_maintenance">Î£Ï…Î½Ï„Î®ÏÎ·ÏƒÎ· Î‘Î½ÎµÎ»ÎºÏ…ÏƒÏ„Î®ÏÎ±</SelectItem>
                  <SelectItem value="heating_maintenance">Î£Ï…Î½Ï„Î®ÏÎ·ÏƒÎ· Î˜Î­ÏÎ¼Î±Î½ÏƒÎ·Ï‚</SelectItem>
                  <SelectItem value="plumbing_maintenance">Î£Ï…Î½Ï„Î®ÏÎ·ÏƒÎ· Î¥Î´ÏÎ±Ï…Î»Î¹ÎºÏÎ½</SelectItem>
                  <SelectItem value="electrical_maintenance">Î£Ï…Î½Ï„Î®ÏÎ·ÏƒÎ· Î—Î»ÎµÎºÏ„ÏÎ¹ÎºÏÎ½</SelectItem>
                  <SelectItem value="building_maintenance">Î£Ï…Î½Ï„Î®ÏÎ·ÏƒÎ· ÎšÏ„Î¹ÏÎ¯Î¿Ï…</SelectItem>
                  <SelectItem value="miscellaneous">Î›Î¿Î¹Ï€Î¬</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
          <div>
            <label className="block text-sm font-medium mb-1">Î¤ÏÏ€Î¿Ï‚ ÎšÎ±Ï„Î±Î½Î¿Î¼Î®Ï‚</label>
            <DistributionSelector value={receiptDistribution} onValueChange={(v) => setReceiptDistribution(v as any)} />
          </div>
          <div>
            <label className="block text-sm font-medium mb-1">Î•Ï€Î¹ÏƒÏÎ½Î±ÏˆÎ· (Ï€ÏÎ¿Î±Î¹ÏÎµÏ„Î¹ÎºÏŒ)</label>
            <Input type="file" accept="application/pdf,image/*" onChange={(e) => setReceiptFile(e.target.files?.[0] ?? null)} />
          </div>
        </div>
        <DialogFooter className="mt-4">
          <Button type="button" variant="outline" onClick={() => setShowReceiptModal(false)}>Î†ÎºÏ…ÏÎ¿</Button>
          <Button type="button"
            onClick={async () => {
              const buildingId = getActiveBuildingId();
              const amountNum = Number(receiptAmount);
              if (!buildingId || !receiptTitle.trim() || !amountNum || isNaN(amountNum)) {
                toast({ title: 'Î£Ï†Î¬Î»Î¼Î±', description: 'Î£Ï…Î¼Ï€Î»Î·ÏÏÏƒÏ„Îµ Ï„Î¯Ï„Î»Î¿ ÎºÎ±Î¹ Î­Î³ÎºÏ…ÏÎ¿ Ï€Î¿ÏƒÏŒ.' });
                return;
              }
              try {
                // Best-effort duplicate check: limit to same day for reliability
                try {
                  const existing = await getExpenses({
                    building_id: buildingId,
                    date_from: receiptDate,
                    date_to: receiptDate,
                  });
                  const dup = existing.find(e => (
                    (e.title || '').trim().toLowerCase() === receiptTitle.trim().toLowerCase() &&
                    Math.abs((e.amount || 0) - amountNum) < 0.005 &&
                    (e.category || '') === receiptCategory
                  ));
                  if (dup) {
                    setPendingCreateAfterConfirm({ buildingId, amountNum });
                    setShowDuplicateConfirm(true);
                    return;
                  }
                } catch (fetchErr) {
                  // If duplicate lookup fails, continue without blocking
                }
                setIsCreatingExpense(true);
                const created: any = await createExpense({
                  building: buildingId,
                  title: receiptTitle.trim(),
                  amount: Math.round(amountNum * 100) / 100,
                  date: receiptDate,
                  category: receiptCategory,
                  distribution_type: receiptDistribution,
                  attachment: receiptFile || undefined,
                } as any);
                // Link a service receipt explicitly to the expense and maintenance if possible
                try {
                  const expenseId = created?.id ?? created?.data?.id;
                  const currentValues = getValues();
                  const contractorId = currentValues.contractor ?? initialData?.contractor;
                  if (contractorId && expenseId) {
                    await createServiceReceipt({
                      contractor: Number(contractorId),
                      building: buildingId,
                      service_date: receiptDate,
                      amount: Math.round(amountNum * 100) / 100,
                      description: receiptTitle.trim(),
                      payment_status: 'pending',
                      receipt_file: receiptFile || undefined,
                      expense: expenseId,
                      scheduled_maintenance: initialData?.id,
                    });
                  }
                } catch {}
                setShowReceiptModal(false);
                const createdId = created?.id ?? created?.data?.id;
                toast({ title: 'Î•Ï€Î¹Ï„Ï…Ï‡Î¯Î±', description: createdId ? `Î— Î±Ï€ÏŒÎ´ÎµÎ¹Î¾Î· ÎºÎ±Ï„Î±Ï‡Ï‰ÏÎ®Î¸Î·ÎºÎµ (ID: ${createdId}).` : 'Î— Î±Ï€ÏŒÎ´ÎµÎ¹Î¾Î· ÎºÎ±Ï„Î±Ï‡Ï‰ÏÎ®Î¸Î·ÎºÎµ ÏƒÏ„Î¹Ï‚ Î´Î±Ï€Î¬Î½ÎµÏ‚.' });
                // After expense creation, submit/continue saving maintenance with current form values
                const currentValues = getValues();
                await onSubmit({ ...currentValues, status_ui: 'executed' }, { skipReceipt: true });
              } catch (err: any) {
                toast({ title: 'Î£Ï†Î¬Î»Î¼Î±', description: err?.message ?? 'Î‘Ï€Î¿Ï„Ï…Ï‡Î¯Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î±Ï‚ Î´Î±Ï€Î¬Î½Î·Ï‚' });
              } finally {
                setIsCreatingExpense(false);
              }
            }}
            disabled={isCreatingExpense}
          >{isCreatingExpense ? 'ÎšÎ±Ï„Î±Ï‡ÏÏÎ·ÏƒÎ·â€¦' : 'ÎšÎ±Ï„Î±Ï‡ÏÏÎ·ÏƒÎ· Î”Î±Ï€Î¬Î½Î·Ï‚'}</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>

    {/* Duplicate Confirmation */}
    <ConfirmDialog
      open={showDuplicateConfirm}
      onOpenChange={(open) => setShowDuplicateConfirm(open)}
      title="Î Î¹Î¸Î±Î½Î® Î”Î¹Ï€Î»Î¿Ï‡ÏÎ­Ï‰ÏƒÎ·"
      description="Î¥Ï€Î¬ÏÏ‡ÎµÎ¹ Î®Î´Î· Î´Î±Ï€Î¬Î½Î· Î¼Îµ Î¯Î´Î¹Î¿ Ï„Î¯Ï„Î»Î¿, ÎºÎ±Ï„Î·Î³Î¿ÏÎ¯Î± ÎºÎ±Î¹ Ï€Î¿ÏƒÏŒ Î³Î¹Î± Ï„Î·Î½ Î¯Î´Î¹Î± Î·Î¼Î­ÏÎ±. Î˜Î­Î»ÎµÏ„Îµ ÏƒÎ¯Î³Î¿Ï…ÏÎ± Î½Î± ÏƒÏ…Î½ÎµÏ‡Î¯ÏƒÎµÏ„Îµ;"
      confirmText="Î£Ï…Î½Î­Ï‡ÎµÎ¹Î±"
      cancelText="Î†ÎºÏ…ÏÎ¿"
      isConfirmLoading={isCreatingExpense}
      onConfirm={async () => {
        if (!pendingCreateAfterConfirm) { setShowDuplicateConfirm(false); return; }
        try {
          setIsCreatingExpense(true);
          const created: any = await createExpense({
            building: pendingCreateAfterConfirm.buildingId,
            title: receiptTitle.trim(),
            amount: Math.round(pendingCreateAfterConfirm.amountNum * 100) / 100,
            date: receiptDate,
            category: receiptCategory,
            distribution_type: receiptDistribution,
            attachment: receiptFile || undefined,
          } as any);
          try {
            const expenseId = created?.id ?? created?.data?.id;
            const currentValues = getValues();
            const contractorId = currentValues.contractor ?? initialData?.contractor;
            if (contractorId && expenseId) {
              await createServiceReceipt({
                contractor: Number(contractorId),
                building: pendingCreateAfterConfirm.buildingId,
                service_date: receiptDate,
                amount: Math.round(pendingCreateAfterConfirm.amountNum * 100) / 100,
                description: receiptTitle.trim(),
                payment_status: 'pending',
                receipt_file: receiptFile || undefined,
                expense: expenseId,
                scheduled_maintenance: initialData?.id,
              });
            }
          } catch {}
          setShowDuplicateConfirm(false);
          setShowReceiptModal(false);
          const createdId = created?.id ?? created?.data?.id;
          toast({ title: 'Î•Ï€Î¹Ï„Ï…Ï‡Î¯Î±', description: createdId ? `Î— Î±Ï€ÏŒÎ´ÎµÎ¹Î¾Î· ÎºÎ±Ï„Î±Ï‡Ï‰ÏÎ®Î¸Î·ÎºÎµ (ID: ${createdId}).` : 'Î— Î±Ï€ÏŒÎ´ÎµÎ¹Î¾Î· ÎºÎ±Ï„Î±Ï‡Ï‰ÏÎ®Î¸Î·ÎºÎµ ÏƒÏ„Î¹Ï‚ Î´Î±Ï€Î¬Î½ÎµÏ‚.' });
          const currentValues = getValues();
          await onSubmit({ ...currentValues, status_ui: 'executed' }, { skipReceipt: true });
        } catch (err: any) {
          toast({ title: 'Î£Ï†Î¬Î»Î¼Î±', description: err?.message ?? 'Î‘Ï€Î¿Ï„Ï…Ï‡Î¯Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î±Ï‚ Î´Î±Ï€Î¬Î½Î·Ï‚' });
        } finally {
          setIsCreatingExpense(false);
          setPendingCreateAfterConfirm(null);
        }
      }}
    />

    {/* Recurrence Confirmation */}
    <ConfirmDialog
      open={showRecurringConfirm}
      onOpenChange={(open) => setShowRecurringConfirm(open)}
      title="ÎˆÏ‡ÎµÎ¹ Î®Î´Î· ÎµÎºÏ„ÎµÎ»ÎµÏƒÏ„ÎµÎ¯ ÏƒÏ„Î·Î½ Ï€ÎµÏÎ¯Î¿Î´Î¿"
      description="Î¤Î¿ Î­ÏÎ³Î¿ Ï†Î±Î¯Î½ÎµÏ„Î±Î¹ Î½Î± Î­Ï‡ÎµÎ¹ Î¿Î»Î¿ÎºÎ»Î·ÏÏ‰Î¸ÎµÎ¯ Î®Î´Î· ÏƒÏ„Î·Î½ Î¯Î´Î¹Î± Ï€ÎµÏÎ¯Î¿Î´Î¿ Î¼Îµ Î²Î¬ÏƒÎ· Ï„Î·Î½ ÎºÎ±Î¸Î¿ÏÎ¹ÏƒÎ¼Î­Î½Î· Ï€ÎµÏÎ¹Î¿Î´Î¹ÎºÏŒÏ„Î·Ï„Î±. Î˜Î­Î»ÎµÏ„Îµ Î½Î± ÏƒÏ…Î½ÎµÏ‡Î¯ÏƒÎµÏ„Îµ;"
      confirmText="Î£Ï…Î½Î­Ï‡ÎµÎ¹Î±"
      cancelText="Î†ÎºÏ…ÏÎ¿"
      isConfirmLoading={false}
      onConfirm={() => {
        setShowRecurringConfirm(false);
        setShowReceiptModal(true);
      }}
    />
    </>
  );
}
}

function extractApiErrorMessage(error: unknown): string | null {
  try {
    const err = error as any;
    const data = err?.response?.data;
    if (!data) return err?.message ?? null;
    if (typeof data === 'string') return data;
    if (typeof data?.detail === 'string') return data.detail;
    if (Array.isArray(data?.non_field_errors) && data.non_field_errors.length > 0) {
      return String(data.non_field_errors[0]);
    }
    // DRF field errors: { field: [".."], ... }
    const parts: string[] = [];
    Object.entries(data).forEach(([field, val]) => {
      if (Array.isArray(val) && val.length > 0) {
        parts.push(`${field}: ${String(val[0])}`);
      } else if (typeof val === 'string') {
        parts.push(`${field}: ${val}`);
      }
    });
    return parts.length > 0 ? parts.join(' â€” ') : (err?.message ?? null);
  } catch {
    return null;
  }
}

async function hasExecutedInDefinedPeriod(args: {
  buildingId: number;
  currentId?: number;
  title: string;
  scheduledDate?: string;
  referenceDate?: string;
  frequency: 'weekly' | 'monthly' | 'bimonthly' | 'quarterly' | 'semiannual' | 'annual';
}): Promise<boolean> {
  const { buildingId, currentId, title, scheduledDate, referenceDate, frequency } = args;
  const list = await fetchScheduledMaintenances({ buildingId, ordering: 'scheduled_date' });
  const refISO = (referenceDate && referenceDate.length >= 10) ? referenceDate : (scheduledDate ? new Date(scheduledDate).toISOString().slice(0,10) : new Date().toISOString().slice(0,10));
  const { start, end } = getPeriodBounds(refISO, frequency);
  const lower = new Date(start).getTime();
  const upper = new Date(end).getTime();
  const normalizedTitle = title.trim().toLowerCase();

  return list.some((item: ApiScheduledMaintenance) => {
    if (!item) return false;
    if (currentId && item.id === currentId) return false;
    if ((item.status as any) !== 'completed') return false;
    const t = (item.title || '').trim().toLowerCase();
    if (t !== normalizedTitle) return false;
    const d = item.scheduled_date ? new Date(item.scheduled_date).getTime() : NaN;
    if (!Number.isFinite(d)) return false;
    return d >= lower && d <= upper;
  });
}

function getPeriodBounds(refDateISO: string, frequency: 'weekly' | 'monthly' | 'bimonthly' | 'quarterly' | 'semiannual' | 'annual') {
  const d = new Date(refDateISO + 'T00:00:00');
  const year = d.getFullYear();
  const month = d.getMonth(); // 0-based
  let start = new Date(d);
  let end = new Date(d);

  switch (frequency) {
    case 'weekly': {
      // Monday-Sunday week bounds based on ref date (adjust start to Monday)
      const day = d.getDay(); // 0: Sun, 1: Mon, ..., 6: Sat
      const diffToMonday = (day === 0 ? -6 : 1 - day); // if Sunday, go back 6 days
      start = new Date(d);
      start.setDate(d.getDate() + diffToMonday);
      start.setHours(0,0,0,0);
      end = new Date(start);
      end.setDate(start.getDate() + 6);
      end.setHours(23,59,59,999);
      break;
    }
    case 'monthly': {
      start = new Date(year, month, 1);
      end = new Date(year, month + 1, 0);
      break;
    }
    case 'bimonthly': {
      const base = month - (month % 2); // groups of 2 months
      start = new Date(year, base, 1);
      end = new Date(year, base + 2, 0);
      break;
    }
    case 'quarterly': {
      const q = Math.floor(month / 3) * 3;
      start = new Date(year, q, 1);
      end = new Date(year, q + 3, 0);
      break;
    }
    case 'semiannual': {
      const h = month < 6 ? 0 : 6;
      start = new Date(year, h, 1);
      end = new Date(year, h + 6, 0);
      break;
    }
    case 'annual':
    default: {
      start = new Date(year, 0, 1);
      end = new Date(year, 12, 0);
      break;
    }
  }
  const startISO = start.toISOString().slice(0,10);
  const endISO = end.toISOString().slice(0,10);
  return { start: startISO, end: endISO };
}

function formatForDateInput(iso: string): string {
  try {
    const d = new Date(iso);
    return d.toISOString().slice(0, 10);
  } catch {
    return '';
  }
}


