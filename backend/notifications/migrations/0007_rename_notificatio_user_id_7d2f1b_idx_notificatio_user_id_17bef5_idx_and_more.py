# Generated by Cursor on 2025-12-24
#
# IMPORTANT:
# - This migration name MUST match what was already applied on production public schema
#   (it was generated via `makemigrations` in the Railway container).
# - The original version fails on some tenant schemas because the target index already exists.
# - We make the database operation idempotent:
#   - If new index exists: drop old index (if present) and skip rename.
#   - Else if old index exists: rename old -> new.
#   - Else: do nothing.
#
# This keeps the migration graph consistent and allows `migrate_schemas` to complete.

from __future__ import annotations

from django.db import migrations


class SafeRenameOrDropIndex(migrations.RenameIndex):
    """
    Safe version of RenameIndex for PostgreSQL schemas where index state may already be partially applied.
    """

    def _get_index_names(self, schema_editor, table_name: str) -> set[str]:
        with schema_editor.connection.cursor() as cursor:
            constraints = schema_editor.connection.introspection.get_constraints(cursor, table_name)
        return set(constraints.keys())

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        model = to_state.apps.get_model(app_label, self.model_name)
        table_name = model._meta.db_table

        names = self._get_index_names(schema_editor, table_name)
        old_name = self.old_name
        new_name = self.new_name

        if new_name in names:
            # Target already exists. Drop old duplicate if present.
            if old_name in names:
                schema_editor.execute(f"DROP INDEX IF EXISTS {schema_editor.quote_name(old_name)};")
            return

        if old_name not in names:
            # Nothing to rename.
            return

        return super().database_forwards(app_label, schema_editor, from_state, to_state)

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        # Best-effort reverse:
        # If old already exists, drop new duplicate; else rename new -> old.
        model = to_state.apps.get_model(app_label, self.model_name)
        table_name = model._meta.db_table

        names = self._get_index_names(schema_editor, table_name)
        old_name = self.old_name
        new_name = self.new_name

        if old_name in names:
            if new_name in names:
                schema_editor.execute(f"DROP INDEX IF EXISTS {schema_editor.quote_name(new_name)};")
            return

        if new_name not in names:
            return

        # Reverse rename
        reverse = migrations.RenameIndex(model_name=self.model_name, old_name=new_name, new_name=old_name)
        return reverse.database_forwards(app_label, schema_editor, from_state, to_state)


class Migration(migrations.Migration):

    dependencies = [
        ("notifications", "0006_uservibersubscription_notificationpreference_and_more"),
    ]

    operations = [
        SafeRenameOrDropIndex(
            model_name="notificationpreference",
            old_name="notificatio_user_id_7d2f1b_idx",
            new_name="notificatio_user_id_17bef5_idx",
        ),
        SafeRenameOrDropIndex(
            model_name="notificationpreference",
            old_name="notificatio_user_id_0a2d0c_idx",
            new_name="notificatio_user_id_e0a7cc_idx",
        ),
        SafeRenameOrDropIndex(
            model_name="userdevicetoken",
            old_name="notificatio_user_id_2f8d14_idx",
            new_name="notificatio_user_id_c115e9_idx",
        ),
        SafeRenameOrDropIndex(
            model_name="userdevicetoken",
            old_name="notificatio_token_9f7a0a_idx",
            new_name="notificatio_token_cbe0a9_idx",
        ),
    ]


